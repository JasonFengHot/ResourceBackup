在注释中添加生效的路径
研究输入法
把培训做成视频
整理bug并归类？？？？？？？
微信小程序开发
python爬虫


FAQ 爬虫 https://online.mediatek.com/FAQ/api/ui/SW/FAQ19494/detail    需要post
Accept: application/json, text/plain, */*
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh-TW;q=0.7,zh;q=0.6
Connection: keep-alive
Content-Length: 14
Content-Type: application/x-www-form-urlencoded
Cookie: WSS_FullScreenMode=false; username=KH5ztksOLRQD+ffTecQAVhCaw5vObe954ljER26Ea2M=; usersystem=MOL; zhangzhefeng@sagereal.com.lang=zh-CN; __utmc=153516580; __utmc=246731354; __utmz=246731354.1565666097.26.10.utmcsr=search.mediatek.com|utmccn=(referral)|utmcmd=referral|utmcct=/searchresultframe.aspx; Hm_lvt_fac1ca85886ec6ae51442958d23d7be2=1565666097,1565666131,1565666179,1565666326; __utma=153516580.1425507218.1555902994.1565666069.1566450257.18; __utmz=153516580.1566450257.18.18.utmcsr=online.mediatek.com|utmccn=(referral)|utmcmd=referral|utmcct=/_layouts/15/mol/ui/ext/home.aspx; srh_shcn=%5B%22modemlog%20stopped%22%2C%22%E8%AF%AD%E8%A8%80%22%2C%22icu%22%2C%22%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%22%2C%22mtk_default_data_off%22%2C%22FAQ04794%22%2C%22%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E5%BC%80%E5%85%B3%22%2C%22%E5%A3%81%E7%BA%B8%22%2C%22%E9%94%81%E5%B1%8F%20%E6%8C%89%E9%94%AE%E7%81%AF%22%2C%22%E9%94%81%E5%B1%8F%20%E9%94%AE%E7%9B%98%E7%81%AF%22%2C%22%E9%94%81%E5%B1%8F%22%2C%22ERFIDX%22%2C%22recovery%22%2C%22FAQ13817%22%2C%22%E6%89%93%E5%BC%80root%E6%9D%83%E9%99%90%22%2C%22%E5%88%86%E5%8C%BA%E8%A1%A8%22%2C%22proguard%22%2C%22%E7%98%A6%E8%BA%AB%22%2C%22aapt%22%2C%22hal3%22%2C%22lint%22%2C%22reserve%20memory%22%2C%22mtkfusionrild%22%2C%22mblock-8-ccci%22%2C%22FAQ09296%22%2C%22AUTO_ADD_GLOBAL_DEFINE_BY_NAME%22%2C%22FAQ10474%22%2C%22FAQ10435%22%2C%22FAQ03065%22%2C%22FAQ11012%22%2C%22FAQ12292%22%2C%22FAQ14338%22%2C%22FAQ17868%22%2C%22wifi%20%E5%88%97%E8%A1%A8%20%E6%BB%91%E4%B8%8D%E5%8A%A8%22%2C%22RecyclerView%22%2C%22wifi%20%E6%BB%91%E4%B8%8D%E5%8A%A8%22%2C%22%E5%88%97%E8%A1%A8%E6%BB%91%E5%8A%A8%22%2C%22MTK_WAPI_SUPPORT%22%2C%22%E6%97%A0%203G%20%E4%BF%A1%E5%8F%B7%22%2C%22radio%20is%20locked%20by%20other%20modul%22%2C%22radioTurnedOff%22%2C%22radio%20is%20locked%22%2C%22%E6%BB%91%E5%8A%A8%E4%B8%8D%E4%BA%86%22%2C%22consyslog%22%2C%22CTS%20Customize%20Guideline.docx%22%2C%22FAQ10820%22%2C%22android.os.strictmode.LeakedClosableViolation%3A%20A%20resource%20was%20acquired%20at%20attached%20stack%20trace%20but%20never%20released%22%2C%22How_to_Write_an_Android.mk%22%2C%22Android_Build_System_for_customer_4.1.pptx%22%2C%2210820%22%2C%22%E4%B9%A6%E7%AD%BE%20%E6%96%87%E4%BB%B6%E5%A4%B9%22%2C%22partnerbookmark%22%2C%22RTC%2032K%20mode%20setting%20wrong%22%2C%22%E5%AE%89%E5%85%94%E5%85%94%22%2C%22ALPS04040853%22%2C%22mtk%20meta%20software%20version%22%2C%22lmkd%22%2C%22Fota%20system%22%2C%22USB%E5%90%8D%E7%A7%B0%E4%BF%AE%E6%94%B9%E7%B3%BB%E5%88%97%22%2C%22GENERIC_FAILURE%22%2C%22MTK_SPECIAL_FACTORY_RESET%22%2C%22omadm%22%2C%22MTK_WAPPUSH_SUPPORT%22%5D; FedAuth=77u/PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48U1A+MCMuZnxlY21tZW1iZXJzaGlwcHJvdmlkZXJ8emhhbmd6aGVmZW5nQHNhZ2VyZWFsLmNvbSwwIy5mfGVjbW1lbWJlcnNoaXBwcm92aWRlcnx6aGFuZ3poZWZlbmdAc2FnZXJlYWwuY29tLDEzMjExMzYxNjE1NTA2Njc1NixGYWxzZSx1SWtDQmtmUHZuY2MycmdRSDMrK2NrbnRIRWlINTdQemlIODk4bWtCRm5LWWEwNmRqSHJIV0xkdUNkQkprUUdFSmp6SzlrZy9FWDVacEFFak5LK0hMek9TYVFqQ0J2amZiQXM3TmF0bCtIZE1UNWlkc0dUeVlVdUVITUt3eHNlZ2pDVCt5ME5mcktPM2lHUGEzN3lMdi9yTHN6ZDNRYjVaNXZDZzVJaU9rNWNmVWYyRSt5Q2d6ekNzczZ0RkVyOFQzYTc0THYzZ2xQQWp4UGNkejh1bG1OUkpHM0loRVFocVk0NjF6QWFuaHFIa1h1anU1ZXlBNm00c3ROMEFrR0lJS1grZVA4TVdtQkxJUm5VSytIQWs3SEZUODc4bnQwYWNSZFBwK001bmNiM2h3ZTdCSVY0MWlpUVNBVVRMb0gzZ0wycWlhNWg5WklJaWpVL2ZsN3ppc2c9PSxodHRwczovL29ubGluZS5tZWRpYXRlay5jb20vX2xheW91dHMvMTUvbW9sL3BvcnRhbC9leHQvU2VhcmNoUmVzdWx0LmFzcHg/YWN0aW9uPVF1ZXJ5JmFtcDt0ZXh0PU1US19XQVBQVVNIX1NVUFBPUlQ8L1NQPg==; __utma=246731354.917593042.1555902973.1566450226.1566875581.33; __utmt=1; __utmb=246731354.2.10.1566875581; Hm_lpvt_fac1ca85886ec6ae51442958d23d7be2=1566875634
Host: online.mediatek.com
Origin: https://online.mediatek.com
Referer: https://online.mediatek.com/FAQ
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36



只要加上这个就好了
sed -i "s/src=\\\\\"/src=\\\\\"https:\/\/online.mediatek.com\//g" `grep 'src=\\\"' -rl ./`





\n      替换为 空
&#58;   替换为 =
&#160;  替换为 &nbsp;
\"      替换为 "
src="   替换为 src="https://online.mediatek.com/

sed -i "s/\\\n//g" `grep '\\\n' -rl ./`
sed -i "s/&#58;/=/g" `grep '&#58;' -rl ./`
sed -i "s/&#160;/\&nbsp;/g" `grep '&#160;' -rl ./`
sed -i "s/\\\\\"/\"/g" `grep '\\\"' -rl ./`
sed -i "s/src=\"/src=\"https:\/\/online.mediatek.com\//g" `grep 'src=\"' -rl ./`
sed -i "s/<br\/>//g" `grep '<br\/>' -rl ./`


问题1.bmp 格式的图片如何下载？？ exception:java.net.SocketException: Socket is closed

解答：
这个是因为socket被手动关闭了，所以会显示 socket is closed

问题2.version is not dcf version 1, no oma drm file

解答：
这个可能是因为手机打开了widevine导致的

问题3.在电脑上下载图片的时候会出现400错误？？

解答：
这个可能是因为url中有中文导致的，用 URLEncoder.encode


## Android学习网站

```
http://bbs.16rd.com/forum-261-1.html            一牛网mtk

https://www.androiddevtools.cn/                 Android开发工具

http://androidxref.com/                         android在线源码

https://github.com/xitu/gold-miner/blob/master/android.md       国外精品文章的翻译

https://www.jianshu.com/p/703794911751          GitHub 上优质项目整理

http://www.ituring.com.cn                       图灵社区下载电子书

https://blog.csdn.net/lmj623565791/article/details/44754023     Android 你应该知道的学习资源 进阶之路贵在坚持(国外学习网站)

https://www.wanandroid.com/article/list/0?cid=79        玩android黑科技

https://codelabs.developers.google.com/?cat=Android         google Codelabs 代码实验室

http://hukai.me/android-training-course-in-chinese/index.html?utm_source=androiddevtools&utm_medium=website         Android官方培训课程中文版

Android学习视频
https://github.com/open-android/Android
https://caster.io/
http://www.maiziedu.com/article/28121/
http://yun.itheima.com/map/21.html              黑马
https://www.youtube.com/watch?v=EOfCEhWq8sg     treehouse

https://www.wanandroid.com/blog/show/2561           各大互联网公司对外分享链接汇总

https://www.reddit.com/r/androiddev/                reddit 上的 Android 开发专区
https://plus.hencoder.com/                          hencoder

http://gityuan.com/
https://developer.android.google.cn/docs/       官方 Android 应用开发者文档
https://flutterchina.club/widgets-intro/        Flutter 中文开发者网站
https://ebookfoundation.github.io/free-programming-books/free-programming-books-zh.html#android

https://android-developers.googleblog.com/

https://pangrongxian.github.io/

http://bbs.16rd.com/forum-263-1.html
http://www.codeceo.com/article/tag/android
http://www.iteye.com/
http://www.v2ex.com/
http://www.imooc.com/
http://www.html-js.com/
https://segmentfault.com/t/android

http://gank.io/history

https://github.com/lizhangqu/CoreLink
https://github.com/GcsSloop/AndroidNote?utm_source=gold_browser_extension
https://blog.csdn.net/aqi00/article/details/50012511        Android开发笔记

http://p.codekk.com/            android开源项目集合
https://github.com/luxiaoming   代码GG的github地址

https://github.com/yechaoa/Android-Rapid-Development
https://github.com/yechaoa/Android-Develop-Tips
http://chendongmarch.github.io/

https://kymjs.com/

http://blog.zhaiyifan.cn/

https://blog.csdn.net/zhangbijun1230/article/details/79745654
https://www.cnblogs.com/aademeng/category/962043.html
https://blankj.com/
http://zmywly8866.github.io/
http://www.wxtlife.com/
http://wuxiaolong.me/
http://www.lightskystreet.com/
https://blog.csdn.net/lmj623565791/
https://blog.csdn.net/xyz_lmn
https://blog.csdn.net/lzyzsd/
https://www.trinea.cn/
http://hukai.me/
https://www.cnblogs.com/halzhang
https://www.cnblogs.com/hanyonglu
https://fookwood.com/
https://blog.csdn.net/lilu_leo
https://www.cnblogs.com/qianxudetianxia
https://blog.csdn.net/xiaominghimi
https://blog.csdn.net/hellogv
https://blog.csdn.net/yiyaaixuexi
https://blog.csdn.net/wangjinyu501
https://blog.csdn.net/asce1885
https://blog.csdn.net/qinjuning
https://blog.csdn.net/tangcheng_ok
https://blog.csdn.net/singwhatiwanna
https://over140.cnblogs.com/
https://www.cnblogs.com/daizhj
https://www.cnblogs.com/sunzn
https://jeanboy.blog.csdn.net/
http://www.apkbus.com/blog/
http://martinhan.site/
https://www.jb51.net/Special/508.htm

https://github.com/XXApple/AndroidLibs      Android开源库整理
```

## 工具网站

```
http://www.ofmonkey.com/            程序猿在线工具网站

http://gradleplease.appspot.com/#fonttype           查看gradle依赖
https://romannurik.github.io/AndroidAssetStudio/    一个可以生成各种类型图标（launcher, notification, generic, app shortcut icons）的工具集合
https://github.com/amitshekhariitbhu/Android-Debug-Database

https://www.codota.com/         写代码经常会遇到需要从github或者stackoverflow上寻找代码示例的时候，这个插件可以在无需离开IDE就能做这件事情。
https://www.hex-rays.com/products/ida/      逆向大利器


```

## 进阶学习书籍

```
https://pan.baiduwp.com/        百度云盘高速下载，需要切换UA，里面有教程

http://www.yunpangou.com/                           搜索百度网盘资源

https://yisharepdf.site/topics/android 下载网站     易分享电子资源网（专注于破解软件、游戏、电子书等资源的分享）

https://dylanbai8.github.io/ideahub/#           精品电子书

https://bbs.pediy.com/forum-128-2.htm?orderby=lastpid&digest=0      看雪

    https://github.com/fuhmmin/it-ebooks-cn

    https://github.com/a001189/dzbook

    https://github.com/roseduan/e-book

    https://github.com/zouyanjian/techbooks

        https://github.com/dengyongstefan/Ebook

        https://github.com/fancy88/iBook
    
    https://github.com/skeyboy/kBooks

        https://github.com/Walker96/-

https://github.com/jinweime/books

    《Code clean》代码整洁之道
《App研发录》
    《HeadFirst设计模式》
    《重构：改善既有代码的设计》
    《Linux内核设计与实现》
    《深入理解Linux内核》
《深入理解Android ***》系列书籍，邓凡平老师写的系列。
    《深入理解Android内核设计思想》
《Android移动性能实战》
    《Android系统源代码情景分析》
《Android源码设计模式》，结合设计模式分析源码
《Android框架揭秘》，底层架构的一本好书
    《Android开发精要-范怀宇》
    《黑客与画家》
    《深入理解Java虚拟机》
《高级Android开发强化实战》
《码农翻身》
    《剑指Offer》
《Android技术内幕：应用卷》
    《Android技术内幕：系统卷》
《高性能Android应用开发》
    《Android C++高级编程 使用NDK》
《FFmpeg从入门到精通》
《音视频开发进阶指南：基于Android与IOS平台的实践》
    《Android应用安全防护和逆向分析》
《Android系统安全和反编译实战》

    《增长黑客》
《深入探索Android热修复技术原理7.3Q》
《神策数据-Android_全埋点技术白皮书》
《Android进阶之光》
    《Android开发艺术探索》
《Android开发进阶 从小工到专家》
《Android 源码设计模式解析与实战》
    《Android内核剖析》
    《写给大忙人看的Java SE 8》

《腾讯Android自动化测试实战》
《Android 进阶揭秘》刘望舒
《Android 系统源代码情景分析》
《深入理解 Android 热修复技术原理》

《Java 并发编程的艺术》
《Java 并发编程实战》
《Java 多线程编程核心技术》
《深入理解 Java 虚拟机》
    《程序员，你伤不起》
    《鸟哥的Linux私房菜：基础学习篇 第四版》https://wizardforcel.gitbooks.io/vbird-linux-basic-4e/content/
《Android内核28讲》
《编程珠玑》
《大话设计模式》
    《算法导论》
    《数据结构与算法分析：Java语言描述》
    《啊哈 算法》
LeetCode(算法题)
https://leetcode.com/
https://leetcode-cn.com/problemset/all/
```

## 高级工程师目标

```
小明成为了梦寐以求的高级工程师，月薪达到了20k，还拿到了一丢丢股票。这个时候小明的 Android 水平已经不错了，但是小明的目标是资深工程师，小明听说资深工程师月薪可以达到30k+。
为了成为 Android 资深工程师，需要学习的东西就更多了，并且有些并不是那么具体了，如下所示：
- 继续加深理解”稍微深入的知识点“中所定义的内容
- 了解系统核心机制：
1. 了解 SystemServer 的启动过程
2. 了解主线程的消息循环模型
3. 了解AMS和PMS的工作原理
4. 能够回答问题”一个应用存在多少个Window？“
5. 了解四大组件的大概工作流程
6. …

- 基本知识点的细节
1. Activity 的 启动模式以及异常情况下不同 Activity 的表现
2. Service 的 onBind 和 onReBind 的关联
3. onServiceDisconnected(ComponentName className) 和 binderDied() 的区别
4. AsyncTask在不同版本上的表现细节
5. 线程池的细节和参数配置
6. …

- 熟悉设计模式，有架构意识
学习方法
这个时候已经没有太具体的学习方法了，无非就是看书、看源码和做项目，平时多种总结，尽量将知识融会贯通从而形成一种体系化的感觉。同时这个阶段对架构是有一定要求的，架构是抽象的，但是设计模式是具体的，所以一定要加强下设计模式的学习。关于设计模式的学习，最近一本新书推荐给大家《Android 源码设计模式解析与实战》，既可以学习设计模式，又可能体会到Android源码中的设计思想，我最近也在阅读此书。

技术要求：
- 稍微深入的知识点
- 系统核心机制
- 基本知识点的细节
- 设计模式和架构
```

## android高级学习指南

```
Android 高级学习指南
思维导图
Android 基础

相关原理
常见 IPC 方式
Binder 机制
AIDL 的使用
Handler 机制
ThreadLocal 原理
AsyncTask 原理
ListView 工作原理
阅读源码
熟悉常见优化
RecyclerView 工作原理
阅读源码
自定义 LayoutManager
Animation 工作原理
Activity 难点
setResult() 和 finish() 的顺序关系？
onSaveInstanceState() 和 onRestoreInstanceState()
onNewIntent() 和 onConfigurationChanged()
Service 难点
startService 与 bindService 的区别？
Service 中 onStartCommand 返回值的作用？
bindService后，ServiceConnection 里面的回调方法运行在哪个线程？它们的调用时机分别是什么？
Service 的 onCreate 运行在哪个线程？
ContentProvider 难点
ContentProvider 的生命周期
ContentProvider 的 onCreate 和 CRUD 运行在哪个线程？它们是线程安全的吗？
ContentProvider 的内部存储只能是 SQLite 吗？
RemoteViews
熟悉 RemoteViews 的使用，并了解其运行原理
Material Design（材料设计）
熟练使用材料设计的控件及布局
自定义 View
View 的绘制流程
onMeasure
onLayout
onDraw
invalidate() 与 postInvalidate()
事件分发机制
onDispatchTouchEvent
onInterceptTouchEvent
onTouchEvent
事件冲突处理
贝塞尔曲线、粒子效果
性能优化
布局优化：ViewStub、include、merge 的使用，它们的区别？
过度渲染的处理
ANR 的处理
监控：埋点、Crash 上报
内存优化
OOM 的处理

内存泄露的处理

内存检测

内存分析

Bitmap 的优化：超大图的加载原理

网络优化
API 优化
流量优化
弱网优化
电量优化
WakeLock 机制
JobScheduler 机制
第三方开源库
OKHttp 原理
Retrofit 原理
RxJava 原理
Glide 原理：加载原理、三级缓存、LRU 算法
Dagger2 原理
ButterKnife 原理
EventBus 原理
RxJava 原理
混合开发
WebView
React Native
Flutter
NDK 开发
熟悉调用 JNI 方法的方式，熟悉如何回调 Java 方法。

安全
熟悉各种发编译，二次打包工具，了解 smali。

动态化
阅读 VirtualAPK、Tinker 的源码，熟悉常见的热修复和插件化原理。

Gradle
Groovy 语法
Gradle 插件开发基础
设计模式与架构
熟悉 6 大基本原则

MVC、MVP、MVVM

组件化

Jetpack

其他问题
Activity、Window，View 之间的关系？
子线程访问 UI 却不报错的原因？
主线程的消息循环是一个死循环，为何不会卡死？
Binder、IBinder、IInterface 的关系？
Java 知识
String 常量池
类型转换原理
ArrayList 实现原理
HashMap 实现原理
常见锁（乐观锁、悲观锁），死锁解决方法
synchronized 关键字
volatile 关键字
常见 IO（AIO，BIO，NIO）
常见并发框架
了解类加载机制
了解垃圾回收机制
总结
以上就是 Android 高级工程师 需要掌握的知识点，高级工程师需要掌握的知识点还是比较多的。如果说初级工程师是打捞基础的过程，那么高级工程师就是一个沉淀技术进阶的过程。

高级工程师一般是指 3 - 5 年工作经验，如果学习能力比较强 3 工作经验足够进阶到高级工程师的。应聘高级工程师薪资一般在 15k - 25k 左右，这里的薪资范围一般会根据是否有亮点上下浮动。

高级工程师对 Android 的理解，不应该还停留在对 API 的使用。初级工程师可以说是对 API 熟悉的过程，高级工程师更应该注重的是 API 内部的原理，知其然而知其所以然。

这个阶段阅读源码是最好的进阶方式，当然阅读源码很容易陷入细节无法自拔。这里推荐看一下高质量的博客和一些进阶书籍，根据博客和书的思路有针对性的看源码是比较推荐的方式。

如果想让自己更加有亮点，推荐注重下面几个方面：

创建一个 GitHub 账号，多输出一些高质量的开源项目
拥有一个持续输出的技术博客
阅读源码
```

## Android 资深（专家）学习指南

```
Android 资深(专家) 思维导图

系统启动过程
这一部分是 Android 系统从按下电源键开始，然后到展示开机界面，再到展示桌面之前的一个过程。了解下面相关进程的工作流程，会对 Android 系统有一个整体的概念，是一个从 0 到 1 的过程，对深入研究 Android 系统内部机制有很大帮助。

init 进程

了解 init 进程创建与启动的流程。

Zygote 进程

了解 Zygote 进程创建的流程，以及 fork 的过程。

system_server 进程

了解 system_server 进程启动流程，工作流程。

ServiceManager

了解 ServiceManager 的启动流程，以及 ServiceManager 在系统中的作用。

内核技术
这一部分是计算机操作系统相关的原理，也是计算机相关专业的一门必修课程，推荐学习下相关知识。

CPU 调度
进程管理
文件系统
内存管理
通信方式
Binder

Binder 是 Android 系统中特有的一种 IPC 通信方式，建议阅读 Binder 相关的源码，与深入越好，理解 Binder 工作的原理，了解服务的注册、获取、死亡通知的流程。

Handler

Handler 是 Android 系统中线程间通信的方式，已经在 Android 高级工程师部分说过了。这里一定要阅读下源码了解内部的运行机制。

Socket

Socket 是系统中常见的一种 IPC 通信方式，Socket 的应用范围很广，在进程间通信、网络通信都会用到，建议深入了解下。

Pipe

Pipe（管道）是 Linux 系统中常见的一种 IPC 通信方式，建议深入了解下工作原理。

signal

signal（信号量）是系统中常见的一种 IPC 通信方式，建议深入了解下工作原理。

核心服务
Activity、Service、Broadcast、ContentProvider

了解四大组件启动流程，理解生命周期回调过程，了解工作原理。

ActivityManagerService（AMS）

理解 ActivityManagerService 工作流程，以及与 Activity 工作的流程。

WindowManagerService（WMS）

理解 WindowManagerService 工作流程，以及与 ActivityManagerService 和 Activity 工作的过程。

View、Window、Surface

理解 Activity、Window、View 之间的关系，了解 View 渲染机制。

Surface、SurfaceFlinger

理解 View 与 Surface 之间的关系，了解 SurfaceFlinger 工作流程，理解 View 渲染的过程。

PackageManagerService（PKMS）

理解 PackageManagerService 工作流程，了解 Apk 安装与卸载过程。

PowerManagerService（PMS）

理解 PackageManagerService 工作流程，了解屏幕唤醒、灭屏的过程，并理解 WeakLock 机制。

InputManagerService（IMS）

理解 InputManagerService 工作流程，理解事件的创建流程、事件分发机制，ANR 触发原理。

AudioFlinger

理解 AudioFlinger 工作流程。

AssertManager

理解 Apk 安装包中资源管理的过程。

异常处理
可以从源码的角度分析异常产生的原因，定位异常，以及处理。

Watchdog
ANR
Java Crash
Native Crash
卡顿
Java 虚拟机
内存模型

了解 JVM 内存模型，包括堆、栈、方法区、运行时常量池等。

类加载机制

了解类加载时机，类加载的过程，理解类加载器双亲委派模型。

垃圾回收机制

了解垃圾回收的原因，理解对象生命周期，了解垃圾回收算法。

动态化
Android Gradle Plugin

通过阅读 Android Gradle Plugin 源码，理解 Gradle 构建项目的过程，了解插件开发过程。

VirtualAPK、Tinker

通过阅读 VirtualAPK 源码，理解热修复、插件化的原理。

Hook 技术
设计模式与架构
熟悉六大 OOD 设计原则
熟悉常见的设计模式，可以熟练的运用在项目中
理解 MVC、MVP、MVVM 的思想以及区别
项目架构设计与重构
项目组件化设计与开发
软技能
拓展技术广度，其他领域的技术学习
团队管理和指导新人
总结
以上就是 Android 资深（专家）工程师 的基本知识点，如果在高级工程师部分基础很牢，进阶到资深（专家）是很容易的。这个级别的知识点不仅仅需要对 API 熟练应用，更重要的是对内部的运行机制的深入理解。

我们可以发现很多的知识点都是对 Android 系统源码的阅读来获取的，阅读源码是一个很痛苦的过程，也是必须经历的一个过程。

在阅读源码的时候建议多注重对整体流程的把握，而不是深入细节不能自拔。毕竟我们主要工作还是开发 App，阅读源码是为了更好的理解内部运行机制。

专家除了具有扎实的技术深度以外，还有一定的技术广度，以及不错的架构设计能力。除了技术，软技能也是很重要的部分。比如如何管理团队，带带新人，写写 PPT，吹 NB 啥的。

已经达到了资深（专家）的开发者，以后的学习路线跟自己的职业规划有很大关系。这个级别技术也不再那么重要，毕竟都是专家了，大家都很 NB，怎么还能让人手把手教呢？！

以下方面大家可以参考下：

维护一个公众号，增加业内影响力
考虑出一本书，增加业内知名度
开源一个 NB 的项目，为开源贡献一份力量
转型做产品或者管理
换一个领域继续深入研究
一般达到资深（专家）的开发者需要 3 - 5 年左右，本科毕业的学生年龄一般在 22 周岁左右，那么达到资深（专家）最快也得 25 周岁了。这里我们会遇到一个职业上的危机 —— 30 岁危机。

随着年龄的越来越大是继续做技术？还是转型做管理呢？Android 也没啥可研究的了，还是换其他领域呢？这是一个值得思考的问题，我还没有这个经历（岁数还没到）不敢妄下定论，哈哈。

这里分享下网上的一份关于各大厂 Android 级别的薪资参考图（如有侵权，请联系我删除）。

大厂薪资参考，如有侵权立删！

我看到网上很多消息都说今年互联网寒冬什么什么的，其实每年都会说寒冬。互联网总共也就发展了十几年，从 2000 年初的诺基亚到现在的智能手机时代，也就十几年的时间。谁有会预料的下一个十年之后会是什么样的呢？

由于前几年大量培训出来的开发者（这里只是说下客观事实，没有贬低的意思），整个市场涌入大量的初级、中级开发者，所以对于新人来说的确不好找工作了，因为竞争的人多了。

自己没能力就说没能力，怎么你到哪儿，哪都大环境不好，你是破坏大环境的人啊？—— 赵本山

作为开发者我们最好的准备就是知识的储备，如果我们努力学习达到了高级甚至更高，目前需求量还是很大的。目前我了解到的 Android 领域专家级别的工程师也没有多少，大家可以留意统计一下。

关于 Android 进阶的学习指南就已经完结了，欢迎大家继续关注，其他方面的技术分享，及个人感悟。
```

## 面试题

```
https://github.com/Moosphan/Android-Daily-Interview

某视频app公司面试题：

Activity启动模式。
Activity生命周期，从A页面打开B页面，两个页面的生命周期。
onStartCommand的返回值和参数的作用。
Synchronized关键字。一个线程访问某个类的Synchronized成员方法A，同时另一个线程可以去访问这个类的Synchronized成员方法B吗？
App的启动优化。
Handler，Looper，MessageQueue的关系。Handler通过sendMessageDelayed发送延时消息， 消息什么时候入队列？
主线程的Looper死循环为什么不会导致ANR?
Android 动画的实现方式。
项目中有没有用到组件化，如何实现组件化。
Hybrid开发中Android和H5的交互有哪些方式。
项目是怎样的架构，为什么这么搭建。
某物流公司的面试题;

本地广播和全局广播的区别，本地广播的实现原理。
常见第三方框架及其实现原理。
SQLite数据库操作。
Http请求中包含哪些内容，上传文件和发起请求的post请求的区别。
线程池有哪几种，如何运用。
设计实现大批量数据上传的方式。
MVC，MVP，MVVM架构的区别。
如何解决Handler导致的内存泄漏。
进程间通信的方式。
某厂电商及物流岗位的面试题：

View的绘制流程。
实现延时任务的几种方式，postDelay，AlarmManager，TimerTask的区别。
做过哪些优化性能的工作？如何考量优化的成果。
http和http2.0，以及https的不同。
Art虚拟机和Dalvik虚拟机。
三级缓存的原理。
LruCache算法的原理。
项目中用到了哪些设计模式，Android源码中用到设计模式的场景。
Java8有什么新特性。
Java类如何加载，类加载的过程。
页面卡顿如何解决，viewHolder起什么作用。
如果有大数据量网络请求，该如何优化
另某厂电商KL应用岗位面试题;

在浏览器输入网址到打开网页，中间的过程。
如何统计工程的代码量？如何去掉代码注释的影响？
模式匹配
apt ，aop
标签注解的原理
热修复的原理。
线程池的原理，如果核心线程数5，最大线程数10，新来的线程会怎样？
如何在服务器接口未准备好的情况下调试接口？
如何抓取Https传输的数据？
Android 与Js的交互，接口存在的安全隐患及修复
不同方式创建字符串，通过==和quuals比较的结果
某Y厂音乐多媒体岗位面试题:

对第三方框架的了解。EventBus可以跨进程通信吗？
Android P有什么新特性，后台限制策略是通过怎样的API来处理的？
HashMap的原理，hashCode的作用，重写equals为什么要重写hashCode方法
Synchronizd修饰静态方法也修饰了非静态方法，可以在两个线程同时被调用吗？
padding和margin的区别。给固定大小及wrap_content的textView设置padding，它的可点击区域会变化吗？
如何自定义view， Canvas的作用
onMesure()方法的参数，MeasureSpec的结构
动画有哪几种？属性动画怎么用，插值器什么作用
讲一下include，merge 和viewstub。 viewstub可以被重复加载吗？在view树里是怎样的存在？
对线程的理解，线程同步有哪几种方式
final关键字的作用，为什么匿名内部类里用到的变量必须是final类型的？
handler, Looper, MessageQueue的关系，这三个可以一对多吗？怎么保证message能被其对应的handler处理？
触摸事件传递过程。有个竖向滑动的ViewGroup里嵌套了横向滑动的view，如何处理滑动冲突？
onSaveInstanceState触发的时机。
某母婴平台部分面试题：

自定义view时如何刷新布局，invalidate会改变宽高吗
Java泛型是伪泛型吗
new Integer(1) == 1会执行拆箱吗
Looper无限循环为什么不会造成卡死
组件之间，activity如何跳转
HTTPS及其双重检验
继续补充
某高校合作研究机构的面试题：

HashSet的原理，如何保证元素不重复的
项目中登录密码是怎么加密的
如何保证HTTP通信的安全
git存储的是快照还是差异
aop 代理
了解哪些设计模式，讲解策略模式
泛型是怎么回事，类型擦除发生在什么时候
列出常用的Linux操作，如何查看内存占用
某小电商平台：

如何计算bitmap占用的内存
内存泄漏都有哪些可能的原因
数据库优化，异步操作数据库会不会导致内存泄漏，怎么解决
MVP，MVVM模式。
某炒股平台面试题：

自己实现StringBuffer类及其append方法
如何优化ListView的显示
有多个应用都能接收某个action广播，如何做到广播只被特定的应用接收到
网络下载图片并保存到SD卡，过程涉及哪些IO类
实现3秒延时后给TextView设置文字。
有哪些措施能加强应用的安全性。
apk加固的原理。
哪些情境会导致内存不一致
如何检测应用卡顿的原因
主线程要等待几个子线程处理完成后才能继续处理，该怎么实现
某人脸识别平台：

activity启动过程
BroadcastReceiver的工作原理
HandlerThread和Thread的区别，HandlerThread在Android中哪些场景用到
普通线程以及线程池里的线程，如何给线程命名，设置优先级
某个工具类的方法，传入了activity的回调，怎么解决内存泄漏
Object类的clone()是深克隆吗？怎么实现深克隆？
IntentService是怎么新建线程的？
MVP模式里，V是哪些？startService这样的操作，应该写在V里，还是P里
补充：

synchronized的实现原理，和lock的区别。
多进程操作文件，怎么解决同步？
CAS同步方法。
binder的实现。
插件化的原理。如果自己去设计插件化的框架，怎么设计？注意哪些地方？
第三方框架及其原理。在用第三方框架时有没有做比较，了解项目之外的第三方框架吗？
如何分析ANR问题？腾讯Bugly这样的框架是什么原理。
JNI开发，及原理。
Java反射的原理。
dex, odex是什么。
Android系统开机过程。
面向切面编程。
AutomicInteger的原理。
调用System.gc()会怎样，系统什么时候会触发GC。
线程的sleep和wait的区别。
Google最新动态，Android最新变化等。
队列有哪几种。
从点击桌面图标，到App启动中间发生了什么。
fragment生命周期，和activity的配合
gilde加载图片
HandlerThread
Java 集合有哪些？哪些是线程安全的
类的加载及静态变量，成员变量等的初始化顺序。
线程池里的线程是如何复用的
HTTP请求头，响应都包含哪些内容
activity的四种启动模式分别在哪些场景会用到
弱引用和软引用的区别，使用场景
线程池里的任务如果发生异常了，会怎样
手写二分查找算法
栈内有个singleTask的activity，再次启动它时，生命周期怎样
设计一个埋点功能模块，应该怎么做？
Java异常分为哪几类？RuntimeException包含哪些？
Volley框架存储请求数据时，key是什么？
请基于数组实现队列。
如何防止网络请求里的数据被抓包
fragmentTranstion有哪些操作？fragment如何回退？
多维数组的长度，及初始化
surfaceView和View的区别
线程间如何通讯
自定义view时，如何在view被销毁时保存数据
activity,window,view的关系
使用recyclerView实现三级item可伸缩的列表，如何实现
上面这些都是技术的问题，还有一些频繁被问到的体现技术能力的问题：

在工作中做过的最有难度的需求是什么，是怎么实现的。
工作中遇到的最难的Bug是怎样的，及解决过程。
工作中代码优化、性能优化等，是怎么做的，代码规范性如何保证。
在团队中担任怎样的角色，团队的开发流程是怎样的。
有开源项目吗？
平时怎么获取新知识。
另外，作为Android开发，只会Android和java的知识是不够的，虽然可以应付一般工作，但是如果想进阶的话，下面这些技能起码要掌握一二：

数据库操作。
Http，TCP/IP相关
Android源码，底层实现。
跨平台开发技术，比如ReativeNative，flutter，week等。
Android和其他方向的行业新技术，新动态
Kotlin，python，Linux等。


随着Android技术发展的成熟，Kotlin、大前端技术RN、Flutter、小程序等一下子就进入了我们的视野内，同时，Android自身的技术栈也正在不断扩展，比如前段时间Google推出的Jetpack。因此，Android开发者们越来越焦虑，越来越迷茫，每个人的时间和精力是有限的，我们到底该学什么才能有效地提高自身的竞争力呢?其实，首先我们应该优先深入学习工作中用到的技术，其次，关注这2年来Android最新的面试题所涉及的知识点，根据自身的实际情况有选择地进行针对性的学习和提升。只有这样，自身才不会被所谓的 互联网寒冬 吓倒。Awesome-Android-Interview搜集了国内一线及二线互联网公司最常出现的面试题，非常全面，笔者花费了很大的精力和时间，希望得到大家的支持。Android面试中常涉及的问题有如下几方面：

1、计算机基础：TCP/IP, HTTP/HTTPS, Socket、操作系统、数据库相关。
2、Java基础：面向对象、反射、泛型、集合类库相关。
3、Java并发：线程/线程池，volatile，悲观锁/乐观锁等等。
4、Jvm虚拟机：比如执行过程、JMM模型、Java的GC回收原理、类加载器。
5、数据结构和算法：LeetCode + 剑指Offer。
6、Android基础：启动模式、动画、自定义View。
7、Android进阶：Binder、AIDL、进程间通信、AMS/WMS/PMS、事件分发、滑动冲突、View的绘制流程、性能优化、重要的Android源码和开源库分析。
8、Android高新技术：模块化、组件化、热更新、插件化实现原理。
9、最后，如果你会其他的开发方式或语言也会加分不少。比如Kotlin、ReactNative、Flutter、Python、前后端开发。


基础
什么是面向对象（OOP）？
什么是多态？实现多态的机制是什么？
接口（Interface）与抽象类（Abstract Class）的区别？
重写（Override）与重载（Overload）的区别?
父类的静态方法能否被子类重写？
静态属性和静态方法是否可以被继承？是否可以被重写？为什么？
什么是内部类？内部类、静态内部类、局部内部类和匿名内部类的区别及作用？
== 和 equals() 和 hashCode() 的区别？
Integer 和 int 之间的区别？
String 转换成 Integer 的方式及原理？
自动装箱实现原理？类型转换实现原理？
对 String 的了解？
String 为什么要设计成不可变的？
final、finally 和 finalize 的区别？
static 关键字有什么作用？
列举 Java 的集合以及集合之间的继承关系?
List、Set、Map 的区别？
ArrayList、LinkedList 的区别？
HashMap，HashTable，ConcurrentHashMap 实现原理以及区别？
HashSet 与 HashMap 怎么判断集合元素重复？
String、StringBuffer、StringBuilder 之间的区别？
什么是序列化？怎么实现？有哪些方式？
对反射的了解？
对注解的了解？
对依赖注入的了解？
对泛型的了解？
泛型中 extends 和 super 的区别？
对 Java 的异常体系的了解？
对解析与分派的了解？
静态代理和动态代理的区别？有什么场景使用？
谈谈对 Java 状态机理解？
线程与并发
线程和进程的区别？
开启线程的三种方式
如何正确的结束一个Thread?
Thread 与 Runnable 的区别？
run() 与 start() 方法的区别？
sleep() 与 wait() 方法的区别？
wait 与 notify 关键字的区别？
synchronized 关键字的用法、作用及实现原理？
volatile 关键字的用法、作用及实现原理？
transient 关键字的用法、作用及实现原理？
ReentrantLock、synchronized、volatile 之间的区别？
什么是线程池，如何使用?
多线程断点续传的实现原理？
什么是深拷贝和浅拷贝？
Java 中对象的生命周期？
对并发编程的了解？
JVM
简述 JVM 内存模型和内存区域？
简述垃圾回收器的工作原理？
如何判断对象的生死？垃圾回收算法？新生代，老生代？
哪些情况下的对象会被垃圾回收机制处理掉？
垃圾回收机制与调用 System.gc() 的区别？
强引用、软引用、弱引用、虚引用之间的区别？
强引用设置为 null，会不会被回收？
简述 ClassLoader 类加载机制？
对双亲委派模型的了解？
String a = "a"+"b"+"c" 在内存中创建几个对象？
对 Dalvik、ART 虚拟机的了解？
对动态加载（OSGI）的了解？
常见编码方式有哪些？
utf-8 编码中的中文占几个字节？int 型占几个字节？
Android
基础
四大组件是什么？
Activity 的生命周期？
Activity 之间的通信方式？
Activity 各种情况下的生命周期？
横竖屏切换时 Activity 的生命周期
前台切换到后台，然后再回到前台时 Activity 的生命周期
弹出 Dialog 的时候按 Home 键时 Activity 的生命周期
两个 Activity 之间跳转时的生命周期
下拉状态栏时 Activity 的生命周期
Activity 与 Fragment 之间生命周期比较？
Activity 的四种 LaunchMode（启动模式）的区别？
Activity 状态保存与恢复？
Fragment 各种情况下的生命周期？
Activity 和 Fragment 之间怎么通信， Fragment 和 Fragment 怎么通信？
Service 的生命周期？
Service 的启动方式？
Service 与 IntentService 的区别?
Service 和 Activity 之间的通信方式？
对 ContentProvider 的理解？
ContentProvider、ContentResolver、ContentObserver 之间的关系？
对 BroadcastReceiver 的了解？
广播的分类？使用方式和场景？
动态广播和静态广播有什么区别？
AlertDialog、popupWindow、Activity 之间的区别？
Application 和 Activity 的 Context 之间的区别？
Android 属性动画特性？
请列举 Android 中常见的布局（Layout）类型，并简述其用法，以及排版效率。【猎豹移动】 LinearLayout、RelativeLayout、FrameLayout 的特性对比及使用场景？
对 SurfaceView 的了解？
Serializable 和 Parcelable 的区别？
Android 中数据存储方式有哪些？
屏幕适配的处理技巧都有哪些?
Android 各个版本 API 的区别？
动态权限适配方案，权限组的概念？
为什么不能在子线程更新 UI？
ListView 图片加载错乱的原理和解决方案？
对 RecycleView 的了解？
Recycleview 和 ListView 的区别？
RecycleView 实现原理？
Android Manifest 的作用与理解？
多线程在 Android 中的使用？
区别 Animation 和 Animator 的用法，概述实现原理？【猎豹移动】
高级
画出 Android 的大体架构图
低版本 SDK 如何使用高版本 API？
AsyncTask 如何使用?
AsyncTask 机制、原理及不足？
如果在 onStop() 的时候做了网络请求，onResume() 的时候怎么恢复？
Handler 机制和底层实现？
Handler、Thread、HandlerThread 区别？ Thread、Looper、MessageQueue、Handler、Message，每个类的功能是什么，这些类之间是什么关系？【猎豹移动】
ThreadLocal 原理、实现及如何保证 Local 属性？
自定义 View 的流程？如何机型适配？
自定义 View 的时怎么获取 View 的大小？
View 的绘制流程？
View 的事件传递分发机制？
requestLayout()，onLayout()，onDraw()，drawChild() 区别与联系？
invalidate() 和 postInvalidate() 的区别？
如何计算一个 View 的嵌套层级？
Android 动画框架及实现原理？
进程和 Application 的生命周期的关系？
SpareArray 的实现原理？
SharedPreferences 的实现眼里？是否进程同步？如何做到同步？
ContentProvider 是如何实现数据共享的？
ContentProvider 的权限管理？ -. Android 系统为什么会设计 ContentProvider？
Android 线程有没有上限？
怎么去除重复代码？
Android 中开启摄像头的主要流程？
对 Bitmap 对象的了解？
图片加载原理？
图片压缩原理？
图片框架实现原理？LRUCache 原理？
EventBus 实现原理？
ButterKnife 实现原理？
Volley 实现原理？
okhttp 实现原理？
服务器只提供数据接收接口，在多线程或多进程条件下，如何保证数据的有序到达？
SQLite 数据库升级，数据迁移问题？
数据库框架对比和源码分析？
CAS介绍，OAuth 授权机制？
谈谈你对安卓签名的理解
App 是如何沙箱化，为什么要这么做？
混合开发
混合开发的方式？各自优缺点和使用场景？
Hybird
React Native
Weex
Flutter
Dart
快应用
Framework
请介绍一下 NDK？
如何加载 ndk 库？如何在 jni 中注册 native 函数，有几种注册方式?【猎豹移动】
Android 进程分类？
谈谈对进程共享和线程安全的认识？
谈谈对多进程开发的理解以及多进程应用场景？
什么是协程？
逻辑地址与物理地址，为什么使用逻辑地址？
Android 为每个应用程序分配的内存大小是多少？
进程保活的方式？
系统启动流程是什么？
一个应用程序安装到手机上的过程发生了什么？
App 启动流程，从点击桌面开始（Activity 启动流程）？
什么是 AIDL？解决了什么问题？如何使用？
Binder 机制及工作原理？
App 中唤醒其他进程的实现方式？
Activity、Window、View 三者的关系与区别？
ApplicationContext 和 ActivityContext 的区别？
ActivityThread，ActivityManagerService，WindowManagerService 的工作原理？
PackageManagerService 的工作原理？
PowerManagerService 的工作原理？
权限管理系统（底层的权限是如何进行 grant 的）？
操作系统中进程和线程有什么区别？系统在什么情况下会在用户态和内核态中切换？【猎豹移动】
如果一个 App 里面有多个进程存在，请列举你所知道的全部 IPC 方法。
性能优化
如何对 Android 应用进行性能分析以及优化?
ANR 产生的原因是什么？怎么定位？
OOM 是什么？怎么解决？是否可以 try catch？
内存泄露的解决方法？
ddms 和 traceView 的使用？
性能优化如何分析 systrace？
用 IDE 如何分析内存泄漏？
Java 多线程引发的性能问题，怎么解决？
启动页白屏、黑屏、太慢怎么解决？
App 启动崩溃异常怎么捕捉？ 对于 Android App 闪退，可能有哪些原因？请针对每种情况简述分析过程。【猎豹移动】
如何保持应用的稳定性？
RecyclerView 和 ListView 的性能对比？
Bitmap 如何处理大图？如何预防 OOM？
如何缩小 Apk 的体积?
如何统计启动时长？
Gradle
Gradle 源码解析
对热修复和插件化的理解？
插件化原理分析
模块化实现（好处，原因）
项目组件化的理解
描述清点击 Android Studio 的 build 按钮后发生了什么？
Kotlin
谈谈对 Kotlin 的理解
闭包和局部内部类的区别?
网络技术
描述一次网络请求的流程?
TCP 中 3 次握手和 4 次挥手的过程?
TCP 与 UDP 的区别及应用?
HTTP 协议
HTTP 1.0 与 2.0 的区别
HTTP 报文结构
HTTP 与 HTTPS 的区别以及如何实现安全性
HTTPS 原理
谈谈你对 WebSocket 的理解
WebSocket 与 socket 的区别
视频加密传输
数据结构与算法
数据结构
简述常见的数据结构？
堆的结构？
树、B+ 树、二叉树、红黑树的了解？
二叉树的深度优先遍历和广度优先遍历？
堆和树的区别？
图的了解？
算法
排序算法有哪些？
最快的排序算法是哪个？
手写冒泡排序
手写快速排序
快速排序的过程、时间复杂度、空间复杂度
手写堆排序
常见算法问题
给阿里2万多名员工按年龄排序应该选择哪个算法？
GC算法(各种算法的优缺点以及应用场景)
蚁群算法与蒙特卡洛算法
子串包含问题(KMP 算法)写代码实现
一个无序，不重复数组，输出N个元素，使得N个元素的和相加为M，给出时间复杂度、空间复杂度。手写算法
万亿级别的两个URL文件A和B，如何求出A和B的差集C(提示：Bit映射->hash分组->多文件读写效率->磁盘寻址以及应用层面对寻址的优化)
两个不重复的数组集合中，求共同的元素。
两个不重复的数组集合中，这两个集合都是海量数据，内存中放不下，怎么求共同的元素？
一个文件中有100万个整数，由空格分开，在程序中判断用户输入的整数是否在此文件中。说出最优的方法
一张Bitmap所占内存以及内存占用的计算
2000万个整数，找出第五十大的数字？
求1000以内的水仙花数以及40亿以内的水仙花数
烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢？
5枚硬币，2正3反如何划分为两堆然后通过翻转让两堆中正面向上的硬8币和反面向上的硬币个数相同
时针走一圈，时针分针重合几次
设计模式与架构
设计模式
谈谈你对 Android 设计模式的理解
项目中常用的设计模式有哪些？
手写生产者-消费者模式？
手写观察者模式？
适配器模式、装饰者模式、外观模式的异同？
架构
MVC、MVP、MVVM 原理和区别？ 请画出 MVC、MVP 的差异？【猎豹移动】
对 RxJava 的理解，功能与原理，优缺点？
从 0 设计一款 App 整体架构，如何去做？
Fragment 如果在 Adapter 中使用应该如何解耦？
对于应用更新这块是如何做的？(解答：灰度，强制更新，分区域更新)？
实现一个 Json 解析器（可以通过正则提高速度）？
```

## 必备软件

```
Fiddler
Wireshark
vscode
```

## 常用Base类

```
BaseActivity
BaseAdapter
BaseFragment
```

## 常用工具类

```
https://github.com/Blankj/AndroidUtilCode/blob/master/utilcode/README-CN.md
https://github.com/BolexLiu/DevNote
文件操作工具类
```

## 更新jdk版本

``` bash
sudo update-alternatives --config java
sudo update-alternatives --config javac
```

## 常用jar包

```
操作excel的包
操作json的包
jsoup
爬虫的包
htmlunit
```

## TODO : 整理语言列表

## TODO : 常用缩写的意思(单开一个)

## TODO : 常用默认值的修改(单开一个)

## TODO : 常用sql语句

## TODO : 常用库(AndroidStudio)

## TODO : 常用adb命令

[awesome-adb](https://github.com/mzlogin/awesome-adb)

## TODO : 常用git命令

## TODO : 常用工具安装

```
qgit
vscode
```

## 打印当前所使用的类名、方法名、行号

``` Java
android.util.Log.e("zq8888", Thread.currentThread().getStackTrace()[2].getFileName()+" "+Thread.currentThread().getStackTrace()[2].getClassName()+"  "+Thread.currentThread().getStackTrace()[2].getMethodName()+"  "+Thread.currentThread().getStackTrace()[2].getLineNumber());
```

## android:duplicateParentState 属性详解

[android:duplicateParentState](https://blog.csdn.net/sodino/article/details/8809778)

``` Java
setDuplicateParentStateEnabled(true)
```

## [Snippet]OnClickListener

``` Java
button.setOnClickListener(new android.view.View.OnClickListener() {
    @Override
    public void onClick(android.view.View v) {
        android.util.Log.e("zq8888", "onClick(1) view:" + view);
    }
});
```

## [Snippet]OnKeyListener

``` Java
button.setOnKeyListener(new android.view.View.OnKeyListener() {
    @Override
    public boolean onKey(android.view.View v, int keyCode, android.view.KeyEvent event) {
        if (keyCode == android.view.KeyEvent.ACTION_DOWN) {
            if (event.getAction() == android.view.KeyEvent.KEYCODE_DPAD_DOWN) {
                android.util.Log.e("zq8888", "onKey(1111) event:" + event);
                return true;
            }
        }
        android.util.Log.e("zq8888", "onKey(2222) event:" + event);
        return false;
    }
});
```

## 设置窗口为半透明

```
getWindow().setFormat(PixelFormat.TRANSLUCENT);
```

## [Snippet]对话框的按键监听

``` Java
mDialog.setOnKeyListener(new android.content.DialogInterface.OnKeyListener() {
    @Override
    public boolean onKey(android.content.DialogInterface dialog, int keyCode, android.view.KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_UP) {
            if (keyCode == KeyEvent.KEYCODE_STAR) {
                keyRemappingSendFakeKeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_VOLUME_DOWN);
                keyRemappingSendFakeKeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_VOLUME_DOWN);
                return true;
            } else if (keyCode == KeyEvent.KEYCODE_POUND || keyCode == KeyEvent.KEYCODE_DEL) {
                keyRemappingSendFakeKeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_VOLUME_UP);
                keyRemappingSendFakeKeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_VOLUME_UP);
                return true;
            }
        }
        return false;
    }
});
```

## [Snippet]OnFocusChangeListener

``` Java
view.setOnFocusChangeListener(new android.view.View.OnFocusChangeListener() {
    @Override
    public void onFocusChange(android.view.View v, boolean hasFocus) {
        android.util.Log.e("zq8888", "onFocusChange(1) v:" + v + " hasFocus:" + hasFocus);
        if (hasFocus) {
        } else {
        }
    }
});
```

## [Snippet]onLongClickListener

``` Java
view.setOnLongClickListener(new android.view.View.OnLongClickListener() {
    @Override
    public boolean onLongClick(android.view.View v) {
        android.util.Log.e("zq8888", "onLongClick() v:" + v);
        return false;
    }
});
```

## [Snippet]onLayoutChangeListener 监听布局的变化

``` Java
getListView().addOnLayoutChangeListener(new android.view.View.OnLayoutChangeListener() {
    @Override
    public void onLayoutChange(android.view.View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
        android.util.Log.e("zq8888", "onLayoutChangeListener(1)" + v);
    }
});
```

## [Snippet]ListView onItemClickListener

``` Java
mListView.setOnItemClickListener(new android.widget.AdapterView.OnItemClickListener(){
    public void onItemClick(android.widget.AdapterView<?> parent, android.view.View view, int position, long id){
        android.util.Log.e("zq8888", "onItemClick(1)" + view);
    }
});
```

## [Snippet]CheckBox.setOnCheckedChangeListener

``` Java
mSwitch.setOnCheckedChangeListener(new android.widget.CompoundButton.OnCheckedChangeListener(){
    public void onCheckedChanged(android.widget.CompoundButton compoundButton, boolean isChecked) {
        android.util.Log.e("zq8888", "onCheckedChanged(0)" + isChecked);
        if (isChecked) {
        } else {
        }
    }
});
```

## [Snippet]监听全局布局的变化

``` Java
getWindow().getDecorView().addOnLayoutChangeListener(new android.view.View.OnLayoutChangeListener() {
    public void onLayoutChange(android.view.View v, int left, int top, int right, int bottom, int oldLeft, int oldTop, int oldRight, int oldBottom) {
        android.widget.TextView search_src_text = (android.widget.TextView) findViewById(getResources().getIdentifier("android:id/search_src_text", null, null));
        if (search_src_text != null) {
            search_src_text.setTextColor(0xffffffff);
            setTextCursorColor(search_src_text, 0xffffffff);
        }
    }
});
```

## 判断view是否显示???

```
isShown()
```

## ScrollView设置全屏

```
android:fillViewport=“true”
```

## 延时操作

```
SystemClock.sleep()
```

## 倒计时

```
CountDownTimer
```

## 遍历HashMap

```
public static void printMap(Map mp) {
    for (Map.Entry m : mp.entrySet()) {
        System.out.println(m.getKey() + ":" + m.getValue());
    }
}
```

## [Snippet]监听应用的安装和卸载

```
MyBroadcastReceiver myReceiver = new MyBroadcastReceiver();
IntentFilter filter = new IntentFilter(Intent.ACTION_PACKAGE_INSTALL);
filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
filter.addAction(Intent.ACTION_PACKAGE_ADDED);
filter.addAction(Intent.ACTION_PACKAGE_CHANGED);
filter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
...
filter.addDataScheme("package"); //This line is very important. Otherwise, broadcast can't be received.
registerReceiver(myReceiver, filter);
```

## [Snippet]ListView上seekbar的按键监听

``` Java
getListView().setOnKeyListener(new android.view.View.OnKeyListener() {
    public boolean onKey(android.view.View v, int keyCode , android.view.KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_UP && (keyCode == android.view.KeyEvent.KEYCODE_DPAD_LEFT || keyCode == android.view.KeyEvent.KEYCODE_DPAD_RIGHT)) {
            android.view.View selectedView = getListView().getSelectedView();
            if (selectedView != null) {
                android.widget.SeekBar seekbar = (android.widget.SeekBar)selectedView.findViewById(com.android.internal.R.id.seekbar);
                seekbar.onKeyDown(keyCode, new android.view.KeyEvent(android.view.KeyEvent.ACTION_DOWN, keyCode));
                seekbar.onKeyUp(keyCode, new android.view.KeyEvent(android.view.KeyEvent.ACTION_UP, keyCode));
                return true;
            }
        }
        return false;
    }
});
```

## [Snippet]监听音量的变化

``` Java
mAudioManager.listenRingerModeAndVolume(new AudioProfileListener() {
    public void onRingerVolumeChanged(int oldVolume, int newVolume, String extra) {
        android.util.Log.e("listenRingerModeAndVolume", "StatusBarWindowView->onRingerVolumeChanged("+oldVolume+","+newVolume+")");
        seekbar_volume.setProgress(mAudioManager.getStreamVolume(AudioManager.STREAM_RING));
    }
}, AudioProfileListener.LISTEN_RINGER_VOLUME_CHANGED);
```

## [Snippet]监听sim状态的变化

``` Java
android.telephony.TelephonyManager mTelephonyManager = (android.telephony.TelephonyManager)getSystemService(TELEPHONY_SERVICE);
mTelephonyManager.listen(mPhoneServiceListener, PhoneStateListener.LISTEN_SERVICE_STATE);
private PhoneStateListener mPhoneServiceListener = new PhoneStateListener() {
    @Override
    public void onServiceStateChanged(ServiceState serviceState) {
        mServiceState = serviceState.getState();
        Resources mRes = getResources();
        String display = mRes.getString(R.string.radioInfo_unknown);
        switch (mServiceState) {
            case ServiceState.STATE_IN_SERVICE:
                //display = mRes.getString(R.string.radioInfo_service_in);
                display = "";
                break;
            case ServiceState.STATE_OUT_OF_SERVICE:
                display = "out of service";
                display = mRes.getString(R.string.radioInfo_service_emergency);
                break;
            case ServiceState.STATE_EMERGENCY_ONLY:
                display = mRes.getString(R.string.radioInfo_service_out);
                display = mRes.getString(R.string.radioInfo_service_emergency);
                break;
            case ServiceState.STATE_POWER_OFF:
                display = mRes.getString(R.string.radioInfo_service_off);
                display = mRes.getString(R.string.radioInfo_service_emergency);
                break;
            default:
                display = mRes.getString(R.string.radioInfo_service_emergency);
                break;
        }
        btn_arrow.setText(display);
    }
};
```

## [Snippet]Handler handleMessage
``` Java
private android.os.Handler mHandler = new android.os.Handler() {
    public void handleMessage(android.os.Message msg) {
        android.util.Log.e("zq8888", "handleMessage(1)" + msg.what);
        switch (msg.what) {
            case 1:
                break;
            case 2:
                break;
        }
    }
};

//sendMessage
Message msg = mHandler.obtainMessage(1);
msg.what = 1;
msg.arg1 = 2;
msg.arg2 = 3;
msg.obj = new Object();
mHandler.sendMessage(msg);
```

## TODO : 通过handler处理长按的消息？？？？

## [Snippet]启动线程

``` Java
new Thread(new Runnable() {
    public void run() {
        try {
            Thread.sleep(1000);
            android.util.Log.e("zq8888", "new Thread(1)");
        } catch(Exception e) {
            android.util.Log.e("zq8888", "new Thread(2) exception:" + e, e);
            e.printStackTrace();
        }
    }
}).start();
```

## [Snippet]try-catch模板

``` Java
try {
    Object mObject = null;
    mObject.toString();
} catch (Exception e) {
    e.printStackTrace();
    android.util.Log.e("zq8888", "NPE:" + e, e);
}
```

## 滚动条不消失

``` xml
android:fadeScrollbars="false"
```

## Android 判断当前是否在UI线程

```
boolean isMainThread = Looper.myLooper() == Looper.getMainLooper();
```

## [shell]head | sort

```
head命令 用来显示档案的开头至标准输出中。

sort命令用于将文本文件内容加以排序。sort可针对文本文件的内容，以行为单位来排序。

# 查看前5行内容 -n  num：显示每个文件的前num 行内容
[root@localhost best]# head -n 5 besthappyday
0315 happy
0812 happy
0201 happy
0403 happy
9046 happy

# 排序一下
[root@localhost best]# head -n 5 besthappyday | sort
0201 happy
0315 happy
0403 happy
0812 happy
9046 happy
```

## [shell]zgrep | zcat

```
避免解压文件，可以使用zgrep命令查找文件内容信息、zcat查看压缩文件中的信息。
```

## awk 的用法？？？

## cheat 的用法？？？？

```
https://aflyun.blog.csdn.net/article/details/88609704
```

## hook原理

```
https://juejin.im/post/5d25f09bf265da1bb565217f

public class BaseActivity extends AppCompatActivity {
    ...
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        // TODO: 关键点1：hook（劫持）系统创建view的过程
        if (ifAllowChangeSkin) {
            mSkinFactory = new SkinFactory();
            mSkinFactory.setDelegate(getDelegate());
            LayoutInflater layoutInflater = LayoutInflater.from(this);
            layoutInflater.setFactory2(mSkinFactory);//劫持系统源码逻辑
        }
        super.onCreate(savedInstanceState);
    }
}
```

## BIO、NIO和AIO？

```
https://juejin.im/post/5d19820c6fb9a07ea42094e2

BIO （Blocking I/O）：同步阻塞I/O模式。
NIO （New I/O）：同步非阻塞模式。
AIO （Asynchronous I/O）：异步非阻塞I/O模型。
那么，同步阻塞、同步非阻塞、异步非阻塞都是怎么回事呢？关于这部分内容也可以查看《漫话：如何给女朋友解释什么是IO中的阻塞、非阻塞、同步、异步？》。

同步阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，并坐在水壶面前一直等着水烧开。
同步非阻塞模式：这种模式下，我们的工作模式是先来到厨房，开始烧水，但是我们不一直坐在水壶前面等，而是回到客厅看电视，然后每隔几分钟到厨房看一下水有没有烧开。
异步非阻塞I/O模型：这种模式下，我们的工作模式是先来到厨房，开始烧水，我们不一一直坐在水壶前面等，也不隔一段时间去看一下，而是在客厅看电视，水壶上面有个开关，水烧开之后他会通知我。

阻塞VS非阻塞：人是否坐在水壶前面一直等。

同步VS异步：水壶是不是在水烧开之后主动通知人。
```

## [APN]APN相关知识

```
apn常见type及使用场景:
default:用于普通的上网，如浏览器，qq，微信等
mms:收发彩信时建立
dun:tethering时使用
xcap:ss操作
supl:定位使用
ims:volte call,vilte call,wfc,sms over ip
bip:bip相关操作

Background
apns-conf.xml is an XML file containing APN configurations for different operators. Telephony Provider will load content of apns-conf.xml into database, and User can check and edit APN from Settings application, also Data Framework will read APN configuration and use it for data connection.

apns-conf.xml provides APN configuration for world-wide operators, as the xml file has special format, there is something you need to know for apn data check in.

L	vendor/mediatek/proprietary/frameworks/base/telephony/etc/apns-conf.xml
M/N	device/mediatek/common/apns-conf.xml
O0	device/mediatek/config/apns-conf.xml
O1  device/mediatek/config/apns-conf.xml  + wifi-apns.xml
P0	device/mediatek/config/apns-conf.xml

APN parameters
The above figure is a sample of one APN item

The apn item must be included in <apn /> mark.
The fields marked red are usually mandatory, the other fields are optional according to the APN type and decided by operator.
For specific mcc/mnc, the same apn entry with the same type should be unique, update the original data instead of adding a new item.
authtype   0: None,  1: PAP,  2: CHAP,  3: PAP or CHAP. 
If this field is not specified but user item exists, default value is 3 PAP or CHAP.
If this field is not specified and user item is not configured too, default value is 0 None.
protocol/roaming_protocol   The valid values are "IP" "IPV6" "IPV4V6". Please don't use IPV4, use IP instead. If not specified, default value is IP.
type   The valid values are "default", "mms", "supl"(used by GPS), "dun"(used by tethering, hotspot), "hipri", "fota", "ims", "cbs", "ia", "emergency", "dm", "wap", "net", "cmmail", "tethering"(phase out, don't use!), "rcse", "xcap", "rcs", "*". If not specified, it will be "*". * matches all. Normally we shouldn't use "*".
bearer_bitmask This field is used to specify under which bearers the APN can be used. E.g. to add support of WFC we need to modify it. (this field is replaced by network_type_bitmask after P0 Branch)
If configured as "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19", that means this apn can be used by mobile data and wifi both.
If configured as "18", it means this apn can only be used by wifi.
If configured as "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|19", it means all kinds of mobile data network bearer can use it except wifi.
If it's not configured, it is treated same as "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|19" described above. The only difference is that Settings App will not show the apn Bearer item if not configured.
On N1 and later, we should use "1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19" to represent all bearers  instead of 1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18. Bit 19 means LTE_CA which is a new type added since N1. The number used by bearer_bitmask is defined in ServiceState.java, from RIL_RADIO_TECHNOLOGY_GPRS to RIL_RADIO_TECHNOLOGY_LTE_CA.
On P0 and later branches please use network_type_bitmask, the same config logic and value as bearer_bitmask. Android uses this to replace bearer_bitmask, the number used by network_type_bitmask is defined in TelephonyManager.java, from NETWORK_TYPE_GPRS to NETWORK_TYPE_LTE_CA.
user_visible the value can be "true" or "false", which is supported since M1. Default is true. If configed as false, the apn will be hidden, not shown in apn list of Settings.
user_editable the value can be "true" or "false", which is supported since O1. Default is true. If configed as false, the apn will be read only, shown in grey on UI.
mvno_type the value can be "imsi", "spn", "gid", "pnn".
mvno_match_data the value defined by OP.
For MORE items, please check Telephony Provider code about how it parses the apns-conf.xml. Generally the above information is enough.
How to modify the apns-conf.xml and update DB on mobilephone
adb pull system/etc/apns-conf.xml
modify...
adb push apns-conf.xml system/etc
delete telephony.db
N/O：adb shell rm -r data/user_de/0/com.android.providers.telephony/databases/telephony.db
Before N：adb shell rm -r data/data/com.android.providers.telephony/databases/telephony.db
adb reboot
O1 specific config file wifi-apns.xml
Note: This section is specially for O1 Branch, so please skip it if your project is not based on O1.

On O1 branch we have a specific file wifi-apns.xml for WiFi configurations.

If the APN is support:

Cellular only
Do not need to add bearer_bitmask field and no entry in wifi-apns.xml
Wifi only
Need add bearer_bitmask=18 in apns-conf.xml's apn entry
Cellular(All Rat) + WiFi
Do not add bearer_bitmask in apns-conf.xml. Add apn in wifi-apns.xml
IMPORTANT NOTE: all key fields (mcc, mnc, apn, mvno_type, mvno_match_data) in wifi-apns.xml should be exactly same as those in apns-conf.xml; in wifi-apns.xml you should add seprated item for each type if the APN has several types supported in apns-conf.xml (example3)

example1:
apns-conf.xml:
<apn carrier="IMS" mcc="202" mnc="01" apn="ims" type="ims" protocol="IPV4V6" roaming_protocol="IP"/>
wifi-apns.xml:
<apn mcc="201" mnc="01" apn="ims" type="ims"/>

example2: 
apns-conf.xml:
<apn carrier="IMS" mcc="525" mnc="05" apn="ims" type="ims" protocol="IPV4V6" roaming_protocol="IP" mvno_type="gid" mvno_match_data="0A"/>
wifi-apns.xml:
<apn mcc="525" mnc="05" apn="ims" type="ims" mvno_type="gid" mvno_match_data="0A"/>

example3: 
apns-conf.xml:
<apn carrier="HOS" mcc="260" mnc="02" apn="hos" mmsc="http://mms/servlets/mms" mmsproxy="213.158.194.226" mmsport="8080" type="mms,xcap" protocol="IPV4V6" roaming_protocol="IP"/>
wifi-apns.xml:
<apn mcc="260" mnc="02" apn="hos" type="mms"/> <apn mcc="260" mnc="02" apn="hos" type="xcap"/>

Cellular(Partial Rat) + WiFi
Specify the bearer_bitmask in apns-conf.xml,  ex: bearer_bitmask=1|14|18

APN数据保存在 /data/user_de/0/com.android.providers.telephony/databases/telephony.db 中
```

## [Snippet]listenRingerModeAndVolume 监听情景模式的变化

``` Java
mAudioManager.listenRingerModeAndVolume(new AudioProfileListener(){
    public void onRingerModeChanged(int ringerMode) {
        // silent mode
        if (ringerMode == 1) {
            Vibrator vibrator = (Vibrator) mContext.getSystemService(Context.VIBRATOR_SERVICE);
            vibrator.vibrate(500);
        }
    }
}, AudioProfileListener.LISTEN_RINGERMODE_CHANGED);
```

## [Snippet]setTextSize

``` Java
setTextSize(android.util.TypedValue.COMPLEX_UNIT_DIP, 21.0f);
```

## [Snippet]调节情景模式

``` Java
AudioProfileManager mProfileManager = (AudioProfileManager) mContext.getSystemService(Context.AUDIOPROFILE_SERVICE);
if (indexToRingerMode(index) == AudioManager.RINGER_MODE_NORMAL) {
    int mSetVolume = Settings.System.getInt(mContext.getContentResolver(), "audio_profile_general_volume", 9);
    mProfileManager.setStreamVolume("mtk_audioprofile_general", AudioProfileManager.STREAM_RING, mSetVolume);
    mAudioManager.setStreamVolume(AudioManager.STREAM_RING, mSetVolume, 9);
} else if(indexToRingerMode(index) == AudioManager.RINGER_MODE_VIBRATE) {
    Settings.System.putInt(mContext.getContentResolver(), "audio_profile_general_volume", mProfileManager.getStreamVolume("mtk_audioprofile_general", AudioProfileManager.STREAM_RING));
    mProfileManager.setStreamVolume("mtk_audioprofile_general", AudioProfileManager.STREAM_RING, 0);
    mAudioManager.setStreamVolume(AudioManager.STREAM_RING, 0, 0);
}
```

## [Snippet]onKeyDown / onKeyUp

``` Java
@Override
public boolean onKeyDown(int keyCode, android.view.KeyEvent event) {
    return super.onKeyDown(keyCode, event);
}
@Override
public boolean onKeyUp(int keyCode, android.view.KeyEvent event) {
    return super.onKeyUp(keyCode, event);
}
```

## [Snippet]下拉通知栏

``` Java
((android.app.StatusBarManager)getSystemService("statusbar")).expandNotificationsPanel();
```

## [Snippet]获取View的几种方法

``` Java
//通过id的名称获取id
int id = getContext().getResources().getIdentifier("android:id/search_src_text", null, null);
View mView = findViewById(id);
```

## [Snippet]启动service

``` Java
Intent intent = new Intent("xxx");
intent.setPackage("xxx");
intent.setComponent(new ComponentName("aaa", "bbb"));
startService(intent);
```

## [Snippet]绑定service bindService

``` Java
mContext.bindService(new Intent("android.intent.action.START_MMS_SETTINGS_SERVICE_AIDL"), conn, Service.BIND_AUTO_CREATE);
```

## TODO : 用代码写LinearLayout

## [Snippet]常用View控件的xml模板

``` xml
<ImageView
    android:id="@+id/delete"
    android:layout_width="wrap_content"
    android:layout_height="match_parent"
    android:layout_gravity="center_vertical"
    android:layout_alignParentEnd="true"
    android:layout_alignTop="@id/checkbox"
    android:layout_alignBottom="@id/checkbox"
    android:paddingLeft="20dp"
    android:paddingRight="20dp"
    android:src="@drawable/ic_delete" />
```

``` xml
<TextClock
    android:id="@+id/digital_clock"
    android:format12Hour="@string/main_clock_12_hours_format"
    android:format24Hour="@string/clock_24_hours_format"
    android:layout_gravity="center"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_marginTop="4dp"
    android:layout_marginBottom="-8dp"
    android:singleLine="true"
    android:ellipsize="none"
    style="@style/big_thin"
    android:textSize="80dp"
    android:textColor="#ffffff" />
```

``` xml
<SeekBar
    android:id="@+id/seekbar_volume"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="@drawable/background_selector"
    android:paddingLeft="16dp"
    android:paddingRight="16dp"
    android:focusable="false"
    android:paddingTop="10dp"
    android:paddingBottom="10dp" />
```

## [Snippet]常用属性

``` xml
android:focusable="true"
android:focusableInTouchMode="true"
android:descendantFocusability="afterDescendants" 
android:textColorLink="@color/linkColor"
android:ellipsize="marquee" 　　　//跑马灯跑动的几个条件, selected=true focusable=true focusableInTouch=true
<item name="android:actionBarStyle">@style/ActionBarStyle</item>
<item name="android:selectableItemBackground">@*android:drawable/item_background_holo_dark</item>
<item name="android:textColorSecondary">#ffffff</item>
```

## [Snippet]修改actionbar/标题栏的颜色

``` Java
第一种方法：这种方法只能在系统app中使用，因为第三方的app无法得到 com.android.internal.R
getWindow().getDecorView().findViewById(com.android.internal.R.id.action_bar_container).setBackgroundColor(android.graphics.Color.parseColor("#ffffff"));

第二种方法：目前使用 getActionBar() 有可能会报 NPE 的问题，最新的api中使用 getSupportActionBar()代替
//getActionBar().setBackgroundDrawable(new ColorDrawable(android.graphics.Color.parseColor("#0096ff")));
getSupportActionBar().setBackgroundDrawable(new ColorDrawable(android.graphics.Color.parseColor("#0096ff")));

第三种方法：通过style去修改，这种方法只能静态设置，无法动态修改actionBar的颜色
一般可先找到该activity到底是使用了哪种主题或者style到value/theme.xml（或style.xml）文件中找到相应的主题或者style，用android:windowBackground去设置！
```

## 去掉ActionBar标题栏上的阴影效果

``` xml
frameworks/base/core/res/res/values/dimens_material.xml
<dimen name="action_bar_elevation_material">0dp</dimen>
frameworks/support/v7/appcompat/res/values/dimens_material.xml
<dimen name="abc_action_bar_elevation_material">0dp</dimen>
```

## [Snippet]发送广播

``` Java
sendBroadcast(new Intent(""));
```

## [Snippet]发送通知模板Notification

https://blog.csdn.net/lilu_leo/article/details/6608101

``` Java
NotificationManager notMgr = (NotificationManager)context.getSystemService(Context.NOTIFICATION_SERVICE);
Notification n = new Notification();
n.icon = R.drawable.ic_launcher;
n.flags |= Notification.FLAG_ONLY_ALERT_ONCE;
n.flags |= Notification.FLAG_ONGOING_EVENT;
n.defaults = Notification.DEFAULT_SOUND;
n.tickerText = title;
n.when = timeStamp;
Intent openIntent = new Intent(Constants.ACTION_INCOMING_FILE_CONFIRM);
openIntent.setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
openIntent.setDataAndNormalize(uri);
n.setLatestEventInfo(context, title, caption, PendingIntent.getBroadcast(context, 0, openIntent, 0));
Intent hideIntent = new Intent(Constants.ACTION_HIDE);
hideIntent.setClassName(Constants.THIS_PACKAGE_NAME, BluetoothOppReceiver.class.getName());
hideIntent.setDataAndNormalize(uri);
n.deleteIntent = PendingIntent.getBroadcast(context, 0, hideIntent, 0);
notMgr.notify(id, n);
```

## [Snippet]动态注册监听广播

``` Java
registerReceiver(new android.content.BroadcastReceiver() {
    public void onReceive(android.content.Context context, android.content.Intent intent){
        String action = intent.getAction();
    }
}, new android.content.IntentFilter("$1"));
```

## [Snippet]颜色解析

``` Java
textView.setTextColor(android.graphics.Color.parseColor("#0096ff"));
textView.setTextColor(0x0000ff00);
```

## 反色相关代码(color inversion)

``` Java
ACCESSIBILITY_DISPLAY_INVERSION_ENABLED

framework/base/java/com/android/internal/hardware/AmbientDisplayConfiguration.java:        return boolSettingDefaultOff(Settings.Secure.ACCESSIBILITY_DISPLAY_INVERSION_ENABLED, user);
framework/base/java/android/provider/Settings.java:        public static final String ACCESSIBILITY_DISPLAY_INVERSION_ENABLED =
framework/base/java/android/provider/Settings.java:            ACCESSIBILITY_DISPLAY_INVERSION_ENABLED,
framework/base/java/android/provider/Settings.java:            INSTANT_APP_SETTINGS.add(ACCESSIBILITY_DISPLAY_INVERSION_ENABLED);
framework/base/accessibility/java/com/android/server/accessibility/AccessibilityManagerService.java:                Settings.Secure.ACCESSIBILITY_DISPLAY_INVERSION_ENABLED);
framework/base/accessibility/java/com/android/server/accessibility/DisplayAdjustmentUtils.java:                    Secure.ACCESSIBILITY_DISPLAY_INVERSION_ENABLED, 0, userId) != 0;
framework/base/core/java/com/android/server/wm/WindowManagerService.java:                Settings.Secure.getUriFor(Settings.Secure.ACCESSIBILITY_DISPLAY_INVERSION_ENABLED);
framework/base/core/java/com/android/server/wm/WindowManagerService.java:                    Settings.Secure.ACCESSIBILITY_DISPLAY_INVERSION_ENABLED, 0, currentUserId);
```

## [Snippet]更新界面显示

``` Java
try {
    mActivityManager.updateConfiguration(null);
} catch (RemoteException e) {
}
```

## TODO : 给apk签名

## [Snippet][Android.mk]Android.mk模板(各个属性的含义)

``` Makefile
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE_TAGS := optional
# 需要修改====apk的名称
LOCAL_PACKAGE_NAME := VodafoneLauncher
LOCAL_SRC_FILES := $(call all-java-files-under, src)
# 不一定需要修改====签名
LOCAL_CERTIFICATE := platform
LOCAL_PROGUARD_FLAG_FILES := proguard-project.txt
# 如果要预置进去可卸载,需要添加以下这行
#LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS)
include $(BUILD_PACKAGE)
include $(call all-makefiles-under,$(LOCAL_PAT))
```

## TODO : 常用权限

``` xml
//T卡读写权限
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.WRITE_MEDIA_STORAGE" />

//全局对话框的权限
<uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>

精准的 (GPS) 位置|ACCESS_FINE_LOCATION
（基于网络的）粗略位置|ACCESS_COARSE_LOCATION
完全的互联网访问权限|INTERNET
修改/删除 USB 存储设备的内容修改/删除 SD 卡的内容|WRITE_EXTERNAL_STORAGE
阻止设备进入休眠状态|WAKE_LOCK
查看 Wi-Fi 状态|ACCESS_WIFI_STATE
查看网络状态|ACCESS_NETWORK_STATE
设置壁纸|SET_WALLPAPER
拍摄照片和视频|CAMERA
读取手机状态和身份|READ_PHONE_STATE
发现已知帐户|GET_ACCOUNTS
控制振动器|VIBRATE
直接拨打电话号码|CALL_PHONE
发送短信|SEND_SMS
接收短信|RECEIVE_SMS
接收彩信|RECEIVE_MMS
读取短信或彩信|READ_SMS
编辑短信或彩信|WRITE_SMS
读取联系人数据|READ_CONTACTS
写入联系人数据|WRITE_CONTACTS
更改网络连接|CHANGE_NETWORK_STATE
修改全局系统设置|WRITE_SETTINGS
停用键锁|DISABLE_KEYGUARD
检索正在运行的应用程序|GET_TASKS
开机时自动启动|RECEIVE_BOOT_COMPLETED
终止后台进程|KILL_BACKGROUND_PROCESSES
重启程序|RESTART_PACKAGES
发送置顶广播消息|BROADCAST_STICKY
安装 DRM 内容。|INSTALL_DRM
读取日历活动|READ_CALENDAR
控制闪光灯|FLASHLIGHT
使用帐户的身份验证凭据|USE_CREDENTIALS
管理帐户列表|MANAGE_ACCOUNTS
录音|RECORD_AUDIO
更改您的音频设置|MODIFY_AUDIO_SETTINGS
读取同步设置|READ_SYNC_SETTINGS
写入同步设置|WRITE_SYNC_SETTINGS
更改 Wi-Fi 状态|CHANGE_WIFI_STATE
写入订阅的供稿|SUBSCRIBED_FEEDS_WRITE
读取订阅的供稿|SUBSCRIBED_FEEDS_READ
读取同步统计信息|READ_SYNC_STATS
作为帐户身份验证程序|AUTHENTICATE_ACCOUNTS
作为 AccountManagerService|ACCOUNT_MANAGER
创建蓝牙连接|BLUETOOTH
蓝牙管理|BLUETOOTH_ADMIN
显示系统级警报|SYSTEM_ALERT_WINDOW
访问登记属性|ACCESS_CHECKIN_PROPERTIES
访问额外的位置信息提供程序命令|ACCESS_LOCATION_EXTRA_COMMANDS
用于测试的模拟位置源|ACCESS_MOCK_LOCATION
访问 SurfaceFlinger|ACCESS_SURFACE_FLINGER
修改电池统计信息|BATTERY_STATS
选择窗口小部件|BIND_APPWIDGET
与设备管理器交互|BIND_DEVICE_ADMIN
绑定至输入法|BIND_INPUT_METHOD
绑定到壁纸|BIND_WALLPAPER
永久停用手机|BRICK
发送包删除的广播|BROADCAST_PACKAGE_REMOVED
发送可通过短信接收的广播消息|BROADCAST_SMS
发送 WAP 一键接收广播消息|BROADCAST_WAP_PUSH
直接拨打任何电话号码|CALL_PRIVILEGED
启用或停用应用程序组件|CHANGE_COMPONENT_ENABLED_STATE
更改用户界面设置|CHANGE_CONFIGURATION
允许接收 Wi-Fi 多播消息|CHANGE_WIFI_MULTICAST_STATE
删除所有应用程序缓存数据|CLEAR_APP_CACHE
删除其他应用程序的数据|CLEAR_APP_USER_DATA
控制位置更新通知|CONTROL_LOCATION_UPDATES
删除其他应用程序的缓存|DELETE_CACHE_FILES
删除应用程序|DELETE_PACKAGES
设备开机或关机|DEVICE_POWER
读取/写入诊断所拥有的资源|DIAGNOSTIC
检索系统内部状态|DUMP
展开/收拢状态栏|EXPAND_STATUS_BAR
在出厂测试模式下运行|FACTORY_TEST
强制应用程序关闭|FORCE_BACK
计算应用程序存储空间|GET_PACKAGE_SIZE
全局搜索|GLOBAL_SEARCH
测试硬件|HARDWARE_TEST
按键和控制按钮|INJECT_EVENTS
允许安装位置信息提供程序|INSTALL_LOCATION_PROVIDER
直接安装应用程序|INSTALL_PACKAGES
显示未授权的窗口|INTERNAL_SYSTEM_WINDOW
管理应用程序令牌|MANAGE_APP_TOKENS
恢复出厂设置|MASTER_CLEAR
修改手机状态|MODIFY_PHONE_STATE
格式化外部存储设备|MOUNT_FORMAT_FILESYSTEMS
装载和卸载文件系统|MOUNT_UNMOUNT_FILESYSTEMS
控制近距离通信|NFC
让应用程序始终运行|PERSISTENT_ACTIVITY
拦截外拨电话|PROCESS_OUTGOING_CALLS
读取帧缓冲区|READ_FRAME_BUFFER
记录您键入的内容和执行的操作|READ_INPUT_STATE
查阅敏感日志数据|READ_LOGS
强行重新启动设备|REBOOT
接收 WAP|RECEIVE_WAP_PUSH
对正在运行的应用程序重新排序|REORDER_TASKS
监控所有应用程序的启动|SET_ACTIVITY_WATCHER
在闹钟中设置警报|SET_ALARM
关闭所有后台应用程序|SET_ALWAYS_FINISH
修改全局动画速度|SET_ANIMATION_SCALE
启用应用程序调试|SET_DEBUG_APP
更改屏幕显示方向|SET_ORIENTATION
设置首选应用程序|SET_PREFERRED_APPLICATIONS
限制运行的进程个数|SET_PROCESS_LIMIT
设置时间|SET_TIME
设置时区|SET_TIME_ZONE
设置有关壁纸大小的提示|SET_WALLPAPER_HINTS
向应用程序发送 Linux 信号|SIGNAL_PERSISTENT_PROCESSES
停用或修改状态栏|STATUS_BAR
更新设备状态|UPDATE_DEVICE_STATS
拨打/接听互联网通话|USE_SIP
编写“接入点名称”设置|WRITE_APN_SETTINGS
添加或修改日历活动以及向邀请对象发送电子邮件|WRITE_CALENDAR
修改 Google 地图|WRITE_GSERVICES
修改安全系统设置|WRITE_SECURE_SETTINGS
修改全局系统设置|WRITE_SETTINGS
发送下载通知。|SEND_DOWNLOAD_COMPLETED_INTENTS
部分关闭|SHUTDOWN
读取浏览器的历史记录和书签|READ_HISTORY_BOOKMARKS
写入浏览器的历史记录和书签|WRITE_HISTORY_BOOKMARKS
写入用户定义的词典|WRITE_USER_DICTIONARY
强行停止其他应用程序|FORCE_STOP_PACKAGES
更新组件使用情况统计信息|PACKAGE_USAGE_STATS
移动应用程序资源|MOVE_PACKAGE
访问下载管理器。|ACCESS_DOWNLOAD_MANAGER
写入用户定义的词典|READ_USER_DICTIONARY
```

## TODO : Style常用属性

## [Snippet]SharedPreference保存读取

``` Java
//保存
getSharedPreferences("prefs", Context.MODE_APPEND).edit().putBoolean("isFirst", true).apply();

//读取
boolean isFirst = getSharedPreferences("prefs", Context.MODE_APPEND).getBoolean("isFirst", false);
```

## [Snippet]ro值的读取(在某些地方可能需要用到反射)

``` Java
String type = android.os.SystemProperties.get("ro.build.type", "null");
```

## TODO : persist值的保存读取？权限问题

## [Snippet]ContentObserver监听某个数据库的值

``` Java
getContentResolver().registerContentObserver(android.provider.Settings.System.getUriFor(android.provider.Settings.System.AIRPLANE_MODE_ON), false, new android.database.ContentObserver(new android.os.Handler()) {
    @Override
    public void onChange(boolean selfChange, android.net.Uri uri) {
        super.onChange(selfChange, uri);
    }
});
```

## [Snippet]Toast

``` Java
android.widget.Toast.makeText(getContext(), "", android.widget.Toast.LEGNTH_LONG).show();

Toast高级版
private Toast mToast;
public void showToast(String msg){
    if (mToast == null) {
        mToast = Toast.makeText(mContext, msg, 2000);
    }
    if (mToast != null) {
        mToast.setText(msg);
        mToast.show();
    }
}
```

## TODO : Toast自定义版

## TODO : [Snippet]Toast开源库

## [Snippet]Dialog模板

``` Java
Dialog mDialog = new Dialog(this, R.style.dialog_theme);
View dialogView = LayoutInflater.from(Launcher.this).inflate(R.layout.dialog_first_run, null);
View btn_cling = dialogView.findViewById(R.id.btn_cling);
btn_cling.setOnClickListener(new OnClickListener(){
    public void onClick(View v){
    }
});
mDialog.setCancelable(false);
mDialog.requestWindowFeature(Window.FEATURE_NO_TITLE);
mDialog.setContentView(dialogView);
mDialog.show();
```

## [Snippet]AlertDialog模板

``` Java
android.app.AlertDialog.Builder builder = new android.app..AlertDialog.Builder(mContext);
builder.setTitle("Title");
builder.setMessage("Message");
builder.setIconAttribute(android.R.attr.alertDialogIcon)
builder.setPositiveButton("ok", new android.ontent.DialogInterface.OnClickListener() {
    @Override
    public void onClick(android.ontent.DialogInterface dialog, int which) {
        android.util.Log.e("zq8888", "AlertDialog->onClick(positive)->");
    }
});
builder.setNegativeButton("cancel", new DialogInterface.OnClickListener() {
    @Override
    public void onClick(android.ontent.DialogInterface dialog, int which) {
        android.util.Log.e("zq8888", "AlertDialog->onClick(negative)->");
    }
});
builder.create().show();
```

## [Snippet]全局对话框

``` Java
//使用 Application 作为 Dialog 的 Context 将对话框的window类型设置为 WindowManager.LayoutParams.TYPE_SYSTEM_ALERT
AlertDialog.Builder builder = new AlertDialog.Builder(mApplicationContext);
...
AlertDialog alertDialog = builder.create();
alertDialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ALERT);
alertDialog.show();
```

//在AndroidManifest.xml文件中添加如下权限

``` xml
<uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW"/>
```

## [Snippet]AlertDialog状态不变黑

``` Java
public class CustomDialog extends AlertDialog {
    public CustomDialog(@NonNull Context context) {
        super(context);
    }
    public CustomDialog(@NonNull Context context, @StyleRes int theme) {
        super(context, theme);
    }
    protected CustomDialog(@NonNull Context context, boolean cancelable, OnCancelListener cancelListener) {
        super(context, cancelable, cancelListener);
    }
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // 请使用自己的工具类获取屏幕的高度
        int screenHeight = ScreenUtils.getScreenHeight(getContext());
        // 请使用自己的工具类获取到状态栏的高度
        int statusBarHeight = ScreenUtils.getStatusHeight(getContext());
        int dialogHeight = screenHeight - statusBarHeight;
        getWindow().setLayout(ViewGroup.LayoutParams.MATCH_PARENT, dialogHeight);
    }
}
```

## [Snippet]showProgressDialog

``` Java
android.app.ProgressDialog mProgressDialog = new android.app.ProgressDialog(this);
mProgressDialog.setProgressStyle(android.app.ProgressDialog.STYLE_HORIZONTAL);
mProgressDialog.setTitle("MyTitle");
//mDialog.setIcon(R.drawable.icon);
mProgressDialog.setMessage("This is a progress example!");
mProgressDialog.setMax(100);
mProgressDialog.setProgress(0);
//mDialog.setSecondaryProgress(50);
mProgressDialog.setIndeterminate(false);
mProgressDialog.setCancelable(true);
mProgressDialog.show();
```

## [Snippet]隐藏toolbar上的 NavigationView

``` Java
Toolbar mToolbar = (Toolbar) findViewById(com.android.internal.R.id.action_bar);
if (mToolbar != null) {
    mToolbar.getNavigationView().setVisibility(View.GONE);
}
```

## [Snippet]PreferenceActivity的使用

``` Java
public class Setting extends PreferenceActivity {
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);  
        addPreferencesFromResource(R.xml.settings);  
    }
}
```

``` xml
Setting.xml:
<Preference
    android:key="setting2"
    android:title="@string/setting2"
    android:summary="@string/setting2"/>
    android:key="seting1" 
    android:title="@string/seting1" 
    android:summaryOff="@string/seting1summaryOff" 
    android:summaryOn="@stringseting1summaryOff"/>
```

## 通话录音之前播放DTMF声音通知对方

``` Java
CallCommandClient.getInstance().playDtmfTone('9', true);
CallCommandClient.getInstance().stopDtmfTone();

```

## [Snippet]按键转发

``` Java
private long mKeyRemappingSendFakeKeyDownTime;
private void keyRemappingSendFakeKeyEvent(int action, int keyCode) {
    long eventTime = android.os.SystemClock.uptimeMillis();
    if (action == android.view.KeyEvent.ACTION_DOWN) {
        mKeyRemappingSendFakeKeyDownTime = eventTime;
    }
    android.view.KeyEvent keyEvent = new android.view.KeyEvent(mKeyRemappingSendFakeKeyDownTime, eventTime, action, keyCode, 0);
    android.hardware.input.InputManager inputManager = (android.hardware.input.InputManager) getActivity().getSystemService(Context.INPUT_SERVICE);
    inputManager.injectInputEvent(keyEvent, android.hardware.input.InputManager.INJECT_INPUT_EVENT_MODE_ASYNC);
}

mEditTextFrequency.setOnKeyListener(new View.OnKeyListener() {
    @Override
    public boolean onKey(View view, int i, android.view.KeyEvent keyEvent) {
        if (keyEvent.getAction() == android.view.KeyEvent.ACTION_UP && keyEvent.getKeyCode() == android.view.KeyEvent.KEYCODE_STAR) {
            //转发
            keyRemappingSendFakeKeyEvent(android.view.KeyEvent.ACTION_DOWN, android.view.KeyEvent.KEYCODE_NUMPAD_DOT);
            keyRemappingSendFakeKeyEvent(android.view.KeyEvent.ACTION_UP, android.view.KeyEvent.KEYCODE_NUMPAD_DOT);
            return true;
        }
        return false;
    }
});


//非系统应用中无法直接使用 InputManager 的 injectInputEvent 方法，需要用到反射
private long mKeyRemappingSendFakeKeyDownTime;
private void keyRemappingSendFakeKeyEvent(int action, int keyCode) {
    long eventTime = android.os.SystemClock.uptimeMillis();
    if (action == android.view.KeyEvent.ACTION_DOWN) {
        mKeyRemappingSendFakeKeyDownTime = eventTime;
    }
    android.view.KeyEvent keyEvent = new android.view.KeyEvent(mKeyRemappingSendFakeKeyDownTime, eventTime, action, keyCode, 0);
    android.hardware.input.InputManager inputManager = (android.hardware.input.InputManager) getSystemService(Context.INPUT_SERVICE);
    try {
    	Class clazz = InputManager.class;
    	Method[] methods = clazz.getDeclaredMethods();
    	for(Method method : methods) {
    		if (method.getName().equalsIgnoreCase("injectInputEvent")) {
    			method.setAccessible(true);
    			method.invoke(inputManager, keyEvent, 0);
    		}
    	}
	} catch (Exception e) {
		e.printStackTrace();
	}
}
```

## AlarmManager 定时调用

```
registerReceiver(new BroadcastReceiver() {
	@Override
	public void onReceive(Context arg0, Intent arg1) {
		keyRemappingSendFakeKeyEvent(KeyEvent.ACTION_DOWN, 4);  //这个好像是能在自己的 apk 中模拟按键点击？？？？而且 HOME 键模拟没有效果？？？
		keyRemappingSendFakeKeyEvent(KeyEvent.ACTION_UP, 4);    //
		setRepeat();
	}
}, new IntentFilter("helloworld"));
setRepeat();

private AlarmManager alarmManager;
private PendingIntent pendingIntent;
private void setRepeat() {
	if (alarmManager == null) {
		alarmManager = (AlarmManager) getSystemService(Context.ALARM_SERVICE);
	}
	if (pendingIntent == null) {
		pendingIntent = PendingIntent.getBroadcast(this, 1, new Intent("helloworld"), PendingIntent.FLAG_UPDATE_CURRENT);
	}
	// setRepeating 好像只能1分钟调用一次？？？？？？？？？？
	//alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), 5 * 1000, pendingIntent);
	alarmManager.cancel(pendingIntent);
	alarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + 10 * 1000, pendingIntent);
}
```

## 在 Runtime 中执行命令

```
public static String execByRuntime(String cmd) {
    Process process = null;
    BufferedReader bufferedReader = null;
    InputStreamReader inputStreamReader = null;
    try {
        process = Runtime.getRuntime().exec(cmd);
        inputStreamReader = new InputStreamReader(process.getInputStream());
        bufferedReader = new BufferedReader(inputStreamReader);

        int read;
        char[] buffer = new char[4096];
        StringBuilder output = new StringBuilder();
        while ((read = bufferedReader.read(buffer)) > 0) {
            output.append(buffer, 0, read);
        }
        return output.toString();
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    } finally {
        if (null != inputStreamReader) {
            try {
                inputStreamReader.close();
            } catch (Throwable t) {
                //
            }
        }
        if (null != bufferedReader) {
            try {
                bufferedReader.close();
            } catch (Throwable t) {
                //
            }
        }
        if (null != process) {
            try {
                process.destroy();
            } catch (Throwable t) {
                //
            }
        }
    }
}
```

## 在手机中执行脚本的另外一种方法

```
1. 把脚本 test.sh push 到手机 /sdcard/ 或 /data/local/tmp (可能不存在，需要创建) 上
2. chmod 777 test.sh
3. sh test.sh &     让脚本在后台执行(否则拔了usb之后就会断开执行)
```

## [Snippet]去掉状态栏

``` Java
//注意在setContentView()之前调用，否则无效。
requestWindowFeature(Window.FEATURE_NO_TITLE);
```

## [Snippet]设置窗口格式为半透明

``` Java
getWindow().setFormat(PixelFormat.TRANSLUCENT);
```

## [Snippet]全屏

``` Java
// 注意在setContentView()之前调用，否则无效。
getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);

// 切换到全屏
getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);
getActivity().getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);

// 切换到非全屏
getWindow().clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
getWindow().addFlags(WindowManager.LayoutParams.FLAG_FORCE_NOT_FULLSCREEN);
```

## Android中在非UI线程里更新View的不同方法

``` Java
Activity.runOnUiThread( Runnable )
View.post( Runnable )
View.postDelayed( Runnable, long )
Hanlder
AsyncTask
```

## [Snippet]通话静音

``` Java
ITelephony telephonyManager = ITelephony.Stub.asInterface(ServiceManager.checkService(Context.TELEPHONY_SERVICE));
if (telephonyManager != null) {
    try {
        if (telephonyManager.isRinging()) {
            telephonyManager.silenceRinger();
            return true;
        }
    } catch(Exception e) {
        e.printStackTrace();
    }
}
```

## [Snippet]判断屏幕旋转方向

``` Java
// 判断Android当前的屏幕是横屏还是竖屏。横竖屏判断
if (this.getResources().getConfiguration().orientation == Configuration.ORIENTATION_PORTRAIT) {
    //竖屏
} else {
    //横屏
}
```

## [Snippet]通过代码动态设置屏幕方向

``` Java
setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
```

## [Snippet]通过InputFilter禁止输入特殊字符

``` Java
/** 禁止输入表情以及特殊字符 */
public static class EmojiExcludeFilter implements InputFilter {
    @Override
    public CharSequence filter(CharSequence source, int start, int end, Spanned dest, int dstart, int dend) {
        for (int i = start; i < end; i++) {
            int type = Character.getType(source.charAt(i));
            if (type == Character.SURROGATE || type == Character.OTHER_SYMBOL) {
                return "";
            }
        }
        String speChat = "[`~!@#$%^&*()+=|{}':;'\\[\\].<>/?~！@#￥%……&*（）——+|{}【】‘”“’？]";
        Pattern pattern = Pattern.compile(speChat);
        Matcher matcher = pattern.matcher(source.toString());
        if (matcher.find()) {
            return "";
        } else {
            return null;
        }
    }
}

// 调用方法如下
edtRemark.setFilters(new InputFilter[]{new UIHelper.EmojiExcludeFilter()});
```

## ViewPager无限滑动

``` Java
mViewPager.setOnPageChangeListener(new OnPageChangeListener() {
    @Override
    public void onPageSelected(int arg0) {
    }
    @Override
    public void onPageScrolled(int arg0, float arg1, int arg2) {
        if(arg0 == 0 && (arg1 <= 0.001f && arg1 >= -0.001f)){
            mVp.setCurrentItem(list.size()-2, false);
        }else if(arg0 == list.size() - 1){
            mVp.setCurrentItem(1, false);
        }
    }
    @Override
    public void onPageScrollStateChanged(int arg0) {
    }
});
```

## 判断ViewPager的滑动方向

``` Java
vp.addOnPageChangeListener(new ViewPager.OnPageChangeListener() {
    float lastPositionOffset = 0L;

    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
        if (lastPositionOffset > positionOffset && positionOffset != 0) {
            //右滑
            Log.e("direction", "right");
        } else if (lastPositionOffset < positionOffset && positionOffset != 0) {
            //左滑
            Log.e("direction", "left");
        }
        lastPositionOffset = positionOffset;
    }

    @Override
    public void onPageSelected(int position) { }

    @Override
    public void onPageScrollStateChanged(int state) {}
});
```

## 根据百分比计算颜色值

``` Java
/**
 * 根据当前的百分比 计算两个颜色之间的值
 * @param fraction 分值
 * @param startValue 开始颜色
 * @param endValue 结束颜色
 * @return 计算得出的颜色
 */
public static Integer evaluate(float fraction, Integer startValue, Integer endValue) {
    float[] startHsv = new float[3];
    float[] endHsv = new float[3];
    float[] outHsv = new float[3];

    // 把 ARGB 转换成 HSV
    Color.colorToHSV(startValue, startHsv);
    Color.colorToHSV(endValue, endHsv);

    // 根据当前的百分比（fraction）所对应的颜色值
    if (endHsv[0] - startHsv[0] > 180) {
        endHsv[0] -= 360;
    } else if (endHsv[0] - startHsv[0] < -180) {
        endHsv[0] += 360;
    }
    outHsv[0] = startHsv[0] + (endHsv[0] - startHsv[0]) * fraction;
    if (outHsv[0] > 360) {
        outHsv[0] -= 360;
    } else if (outHsv[0] < 0) {
        outHsv[0] += 360;
    }
    outHsv[1] = startHsv[1] + (endHsv[1] - startHsv[1]) * fraction;
    outHsv[2] = startHsv[2] + (endHsv[2] - startHsv[2]) * fraction;

    // 根据当前的百分比（fraction）所对应的透明度
    int alpha = startValue >> 24 + (int) ((endValue >> 24 - startValue >> 24) * fraction);

    // 把 HSV 转换回 ARGB 返回
    return Color.HSVToColor(alpha, outHsv);
}
```

## TODO ： 解析图片的几种方法？？？

``` Java
// 1. 从资源中获取Bitmap
Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), drawableId);

// 2.Bitmap ---> byte[]
public byte[] BitmapToBytes(Bitmap bitmap) {
    ByteArrayOutputStream baos = new ByteArrayOutputStream();
    bitmap.compress(Bitmap.CompressFormat.PNG, 100, baos);
    return baos.toByteArray();
}

// 3.byte[] ---->bitmap
public Bitmap BytesToBitmap(byte[] b) {
    if (b.length != 0) {
        return BitmapFactory.decodeByteArray(b, 0, b.length);
    } else {
        return null;
    }
}

// 4.Bitmap 缩放方法
public static Bitmap ZoomBitmap(Bitmap bitmap, int width, int heigh) {
    int w = bitmap.getWidth();
    int h = bitmap.getHeight();
    Matrix matrix = new Matrix();
    float scalewidth = (float) width / w;
    float scaleheigh = (float) heigh / h;
    matrix.postScale(scalewidth, scaleheigh);
    Bitmap newBmp = Bitmap.createBitmap(bitmap, 0, 0, w, h, matrix, true);
    return newBmp;
}

// 5. Drawable----> Bitmap
public static Bitmap DrawableToBitmap(Drawable drawable) {

    // 获取 drawable 长宽
    int width = drawable.getIntrinsicWidth();
    int heigh = drawable.getIntrinsicHeight();

    drawable.setBounds(0, 0, width, heigh);

    // 获取drawable的颜色格式
    Bitmap.Config config = drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888
            : Bitmap.Config.RGB_565;
    // 创建bitmap
    Bitmap bitmap = Bitmap.createBitmap(width, heigh, config);
    // 创建bitmap画布
    Canvas canvas = new Canvas(bitmap);
    // 将drawable 内容画到画布中
    drawable.draw(canvas);
    return bitmap;
}

// 6.圆角图片
public static Bitmap SetRoundCornerBitmap(Bitmap bitmap, float roundPx) {
    int width = bitmap.getWidth();
    int heigh = bitmap.getHeight();
    // 创建输出bitmap对象
    Bitmap outmap = Bitmap.createBitmap(width, heigh, Bitmap.Config.ARGB_8888);
    Canvas canvas = new Canvas(outmap);
    final int color = 0xff424242;
    final Paint paint = new Paint();
    final Rect rect = new Rect(0, 0, width, heigh);
    final RectF rectf = new RectF(rect);
    paint.setAntiAlias(true);
    canvas.drawARGB(0, 0, 0, 0);
    paint.setColor(color);
    canvas.drawRoundRect(rectf, roundPx, roundPx, paint);
    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
    canvas.drawBitmap(bitmap, rect, rect, paint);

    return outmap;
}

// 7.获取带倒影的图片
public static Bitmap CreateReflectionImageWithOrigin(Bitmap bitmap) {

    final int reflectionGap = 4;
    int w = bitmap.getWidth();
    int h = bitmap.getHeight();
    Matrix matrix = new Matrix();
    matrix.preScale(1, -1);

    Bitmap reflectionImage = Bitmap.createBitmap(bitmap, 0, h / 2, w,
            h / 2, matrix, false);

    Bitmap bitmapWithReflection = Bitmap.createBitmap(w, (h + h / 2),
            Bitmap.Config.ARGB_8888);
    Canvas canvas = new Canvas(bitmapWithReflection);
    canvas.drawBitmap(bitmap, 0, 0, null);
    Paint deafalutPaint = new Paint();
    canvas.drawRect(0, h, w, h + reflectionGap, deafalutPaint);

    canvas.drawBitmap(reflectionImage, 0, h + reflectionGap, null);

    Paint paint = new Paint();
    LinearGradient shader = new LinearGradient(0, bitmap.getHeight(), 0,
            bitmapWithReflection.getHeight() + reflectionGap, 0x70ffffff,
            0x00ffffff, Shader.TileMode.CLAMP);
    paint.setShader(shader);
    // Set the Transfer mode to be porter duff and destination in
    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));
    // Draw a rectangle using the paint with our linear gradient
    canvas.drawRect(0, h, w, bitmapWithReflection.getHeight()
            + reflectionGap, paint);
    return bitmapWithReflection;
}

// 8. bitmap ---Drawable
public static Drawable BitmapToDrawable(Bitmap bitmap, Context context) {
    BitmapDrawable drawbale = new BitmapDrawable(context.getResources(), bitmap);
    return drawbale;
}

// 9. drawable进行缩放 ---> bitmap 然后比对bitmap进行缩放
public static Drawable ZoomDrawable(Drawable drawable, int w, int h) {
    int width = drawable.getIntrinsicWidth();
    int height = drawable.getIntrinsicHeight();
    // 调用5 中 drawable转换成bitmap
    Bitmap oldbmp = DrawableToBitmap(drawable);
    // 创建操作图片用的Matrix对象
    Matrix matrix = new Matrix();
    // 计算缩放比例
    float sx = ((float) w / width);
    float sy = ((float) h / height);
    // 设置缩放比例
    matrix.postScale(sx, sy);
    // 建立新的bitmap，其内容是对原bitmap的缩放后的图
    Bitmap newbmp = Bitmap.createBitmap(oldbmp, 0, 0, width, height, matrix, true);
    return new BitmapDrawable(newbmp);
}
```

## [Snippet]HttpClient

``` Java
DefaultHttpClient httpClient = new DefaultHttpClient(); 
HttpGet method = new HttpGet("http://www.baidu.com/1.html"); 
HttpResponse resp; 
Reader reader = null; 
try { 
    HttpParams params = new BasicHttpParams(); 
    params.setIntParameter(AllClientPNames.CONNECTION_TIMEOUT, 10000); 
    httpClient.setParams(params); 
    resp = httpClient.execute(method); 
    int status = resp.getStatusLine().getStatusCode(); 
    if (status != HttpStatus.SC_OK) {
        return false; 
    }
    return true; 
} catch (ClientProtocolException e) { 
    e.printStackTrace(); 
} catch (IOException e) { 
    e.printStackTrace(); 
} finally { 
    if (reader != null) {
        try { 
            reader.close(); 
        } catch (IOException e) { 
            // TODO Auto-generated catch block 
            e.printStackTrace(); 
        } 
    }
}
```

## [Snippet]Shape的模板

``` xml
<?xml version="1.0" encoding="utf-8"?>
<!-- android:shape指定形状类型，默认为rectangle -->
<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
    <size android:width="10dp" android:height="10dp"/>
    <!-- solid指定形状的填充色，只有android:color一个属性 -->
    <solid android:color="#2F90BD" />
    <!-- padding设置内容区域离边界的间距 -->
    <padding
        android:bottom="12dp"
        android:left="12dp"
        android:right="12dp"
        android:top="12dp" />
    <!-- corners设置圆角，只适用于rectangle -->
    <corners android:radius="200dp" />
    <!-- stroke设置描边 -->
    <stroke
        android:width="2dp"
        android:color="@android:color/darker_gray"
        android:dashGap="4dp"
        android:dashWidth="4dp" />
</shape>
```

## [Snippet]Shape(圆)

``` xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval"
    android:useLevel="false">

    <solid android:color="#c6c6c6" />
    <size
        android:width="50dp"
        android:height="50dp" />
</shape>
```

## [Snippet]带圆角的矩形

``` xml
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="#b2b2b2" />
    <size
        android:width="50dp"
        android:height="30dp" />
    <corners android:radius="5dp" />
</shape>
```

## [Snippet]带圆角的矩形边框

``` xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <stroke
        android:width="1dp"
        android:color="#ff5a85" />
    <size
        android:width="50dp"
        android:height="30dp" />
    <corners android:radius="5dp" />
</shape>
```

## [Snippet]文字根据状态更改颜色的Selector模板

``` Xml
<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:color="#53c1bd" android:state_selected="true"/>
    <item android:color="#53c1bd" android:state_focused="true"/>
    <item android:color="#53c1bd" android:state_pressed="true"/>
    <item android:color="#777777"/>
</selector>

<?xml version="1.0" encoding="utf-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android" >
    <item android:state_selected="true" android:color="@color/software_textColor_selected"></item>
    <item android:state_selected="false" android:color="@color/software_textColor_unselected"></item>
</selector>


//通过代码调用颜色selector
ColorStateList mTintColor = getContext().getResources().getColorStateList(com.android.internal.R.color.item_text_color_selector);
int color = mTintColor.getColorForState(getDrawableState(), 0);
mTrackDrawable.setTintList(mTintColor);

ImageView imageView = new ImageView(mContext);
imageView.setImageTintList(mTintColor);
```

## [Snippet]背景色根据状态更改颜色的Selector模板

``` Xml
<selector xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:state_selected="true">
        <shape>
            <gradient android:angle="0" android:centerColor="#00a59f" android:endColor="#00a59f" android:startColor="#00a59f" />
        </shape>
    </item>
    <item android:state_focused="true">
        <shape>
            <gradient android:angle="0" android:centerColor="#00a59f" android:endColor="#00a59f" android:startColor="#00a59f" />
        </shape>
    </item>
    <item android:state_pressed="true">
        <shape>
            <gradient android:angle="0" android:centerColor="#00a59f" android:endColor="#00a59f" android:startColor="#00a59f" />
        </shape>
    </item>
    <item>
        <shape>
            <gradient android:angle="0" android:centerColor="#00ff00" android:endColor="00ff00" android:startColor="00ff00" />
        </shape>
    </item>
</selector>

//通过代码调用背景色selector
Drawable selector = getResources().getDrawable(com.android.internal.R.drawable.item_background_selector);
```

## [Snippet]设置Activity透明

``` Xml
<style name="TransparentActivity" parent="AppBaseTheme">
    <item name="android:windowBackground">@android:color/transparent</item>
    <item name="android:colorBackgroundCacheHint">@null</item>
    <item name="android:windowIsTranslucent">true</item>
    <item name="android:windowNoTitle">true</item>
    <item name="android:windowContentOverlay">@null</item>
</style>
```

## 切换系统中某个组件的状态,设置其enable或disable

``` Java
public void toggleComponent(View view){
    PackageManager pm = getPackageManager();
    String pkgName = "com.aa.activitytest";
    String comName = "com.aa.activitytest.SecondActivity";
    ComponentName componentName = new ComponentName(pkgName, comName);
    int state = pm.getComponentEnabledSetting(componentName);
    boolean isEnable = state == PackageManager.COMPONENT_ENABLED_STATE_ENABLED || state == PackageManager.COMPONENT_ENABLED_STATE_DEFAULT;
    if(isEnable){
        pm.setComponentEnabledSetting(componentName, PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);
    }else {
        pm.setComponentEnabledSetting(componentName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);
    }
}
```

## 调用开发者选项中显示触摸位置功能

``` Java
android.provider.Settings.System.putInt(getContentResolver(), "show_touches", 1);
```

## [Snippet]px-dp转换

``` Java
public static int dip2px(Context context, float dpValue) {
    final float scale = context.getResources().getDisplayMetrics().density;
    return (int) (dpValue * scale + 0.5f);
}

public static int px2dip(Context context, float pxValue) {
    final float scale = context.getResources().getDisplayMetrics().density;
    return (int) (pxValue / scale + 0.5f);
}
```

## [Snippet]px-sp转换

``` Java
public static int px2sp(Context context, float pxValue) {
    final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;
    return (int) (pxValue / fontScale + 0.5f);
}

public static int sp2px(Context context, float spValue) {
    final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;
    return (int) (spValue * fontScale + 0.5f);
}
```

## [Snippet]dip转px

``` Java
public static int dipToPX(final Context ctx, float dip) {
    return (int)TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, dip, ctx.getResources().getDisplayMetrics());
}
```

## 正则表达式

``` Java
//手机号码正则表达式
public static final String REG_PHONE_CHINA = "^((13[0-9])|(15[^4,\\D])|(18[0,5-9]))\\d{8}$";

//邮箱正则表达式
public static final String REG_EMAIL = "\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*";
```

## 收集设备信息

``` Java
public static Properties collectDeviceInfo(Context context) {
    Properties mDeviceCrashInfo = new Properties();
    try {
        PackageManager pm = context.getPackageManager();
        PackageInfo pi = pm.getPackageInfo(context.getPackageName(), PackageManager.GET_ACTIVITIES);
        if (pi != null) {
            mDeviceCrashInfo.put(VERSION_NAME, pi.versionName == null ? "not set" : pi.versionName);
            mDeviceCrashInfo.put(VERSION_CODE, pi.versionCode);
        }
    } catch (PackageManager.NameNotFoundException e) {
        Log.e(TAG, "Error while collect package info", e);
    }
    Field[] fields = Build.class.getDeclaredFields();
    for (Field field : fields) {
        try {
            field.setAccessible(true);
            mDeviceCrashInfo.put(field.getName(), field.get(null));
        } catch (Exception e) {
            Log.e(TAG, "Error while collect crash info", e);
        }
    }
    return mDeviceCrashInfo;
}

public static String collectDeviceInfoStr(Context context) {
    Properties prop = collectDeviceInfo(context);
    Set deviceInfos = prop.keySet();
    StringBuilder deviceInfoStr = new StringBuilder("{\n");
    for (Iterator iter = deviceInfos.iterator(); iter.hasNext();) {
        Object item = iter.next();
        deviceInfoStr.append("\t\t\t" + item + ":" + prop.get(item) + ", \n");
    }
    deviceInfoStr.append("}");
    return deviceInfoStr.toString();
}
```

## [Snippet]判断是否有SD卡

``` Java
public static boolean haveSDCard() {
    return android.os.Environment.getExternalStorageState().equals(android.os.Environment.MEDIA_MOUNTED);
}
```

## 查看是否有存储卡插入

``` Java
String status=Environment.getExternalStorageState();
if(status.equals(Enviroment.MEDIA_MOUNTED)){
}
```

## [Snippet]动态隐藏软键盘

``` Java
public static void hideSoftInput(Activity activity) {
    View view = activity.getWindow().peekDecorView();
    if (view != null) {
        InputMethodManager inputmanger = (InputMethodManager) activity.getSystemService(Context.INPUT_METHOD_SERVICE);
        inputmanger.hideSoftInputFromWindow(view.getWindowToken(), 0);
    }
}

public static void hideSoftInput(Context context, EditText edit) {
    edit.clearFocus();
    InputMethodManager inputmanger = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
    inputmanger.hideSoftInputFromWindow(edit.getWindowToken(), 0);
}
```

## [Snippet]动态显示软键盘

``` Java
public static void showSoftInput(Context context, EditText edit) {
    edit.setFocusable(true);
    edit.setFocusableInTouchMode(true);
    edit.requestFocus();
    InputMethodManager inputManager = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
    inputManager.showSoftInput(edit, 0);
}
```

## 动态显示或隐藏软键盘

``` Java
public static void toggleSoftInput(Context context, EditText edit) {
    edit.setFocusable(true);
    edit.setFocusableInTouchMode(true);
    edit.requestFocus();
    InputMethodManager inputManager = (InputMethodManager) context.getSystemService(Context.INPUT_METHOD_SERVICE);
    inputManager.toggleSoftInput(InputMethodManager.SHOW_FORCED, 0);
}
```

## [Snippet]主动回到home

``` Java
public static void goHome(Context context) {
    Intent mHomeIntent = new Intent(Intent.ACTION_MAIN);
    mHomeIntent.addCategory(Intent.CATEGORY_HOME);
    mHomeIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    context.startActivity(mHomeIntent);
}
```

## [Snippet]判断是否全屏

``` Java
public boolean isFullScreen(){
    int[] screenParams = new int[2];
    getLocationOnScreen(screenParams);
    return screenParams[0] == 0 && screenParams[1] == 0;
}
```

## [Snippet]设置状态栏的颜色

``` Java
//需要在Android.mk文件中添加v4包的支持
protected void setStatusBarColor(int statusColor) {
    android.view.Window window = getWindow();
    window.clearFlags(android.view.WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);
    window.addFlags(android.view.WindowManager.LayoutParams.FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS);
    window.getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_VISIBLE);
    window.setStatusBarColor(statusColor);
    android.view.ViewGroup mContentView = (android.view.ViewGroup) window.findViewById(android.view.Window.ID_ANDROID_CONTENT);
    View mChildView = mContentView.getChildAt(0);
    if (mChildView != null) {
        android.support.v4.view.ViewCompat.setFitsSystemWindows(mChildView, false);
        android.support.v4.view.ViewCompat.requestApplyInsets(mChildView);
    }
    // set statusbar light mode
    getWindow().getDecorView().setSystemUiVisibility(View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR);
}

//使用方法
public void onAttachedToWindow() {
    super.onAttachedToWindow();
    if("com.android.settings.Settings".equalsIgnoreCase(getClass().getName())){
        setStatusBarColor(android.graphics.Color.parseColor("#3A96FE"));
    }
}

通过style设置状态栏颜色
<item name="android:windowLightStatusBar">true</item>
```

## [Snippet]设置状态栏透明

``` Java
//方法1
setStatusBarColor(android.graphics.Color.parseColor("#00000000"));

//方法2
WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes();
LayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags);

//方法3(貌似没效果)
<item name="android:windowTranslucentStatus">true</item>
```

## 修改状态栏高度

frameworks/base/core/res/res/values/dimens.xml
``` xml
<dimen name="status_bar_height">48dp</dimen>
```

## 获取状态栏高度

``` Java
//方法1
public static int getStatusBarHeight(Activity activity) {
    Rect frame = new Rect();
    activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);
    return frame.top;
}

//方法2
public static int getStatusBarHeight(Context context){
    Class<?> c = null;
    Object obj = null;
    Field field = null;
    int x = 0, statusBarHeight = 0;
    try {
        c = Class.forName("com.android.internal.R$dimen");
        obj = c.newInstance();
        field = c.getField("status_bar_height");
        x = Integer.parseInt(field.get(obj).toString());
        statusBarHeight = context.getResources().getDimensionPixelSize(x);
    } catch (Exception e1) {
        e1.printStackTrace();
    }
    return statusBarHeight;
}
```

## 获取状态栏高度＋标题栏(ActionBar)高度

``` Java
public static int getTopBarHeight(Activity activity) {
    return activity.getWindow().findViewById(Window.ID_ANDROID_CONTENT).getTop();
}
```

## 清空手机上的cookie

``` Java
CookieSyncManager.createInstance(getApplicationContext());
CookieManager.getInstance().removeAllCookie();
```

## 建立gprs链接

``` Java
private boolean openDataConnection() {
    // Set up data connection.
    DataConnection conn = DataConnection.getInstance();
    if (connectMode == 0) {
        ret = conn.openConnection(mContext, “cmwap”, “cmwap”, “cmwap”);  
    } else {
        ret = conn.openConnection(mContext, “cmnet”, “”, “”);  
    }
}
```

## 获取MCC+MNC代码 (SIM卡运营商国家代码和运营商网络代码)

``` Java
// 仅当用户已在网络注册时有效, CDMA 可能会无效（中国移动：46000 46002, 中国联通：46001,中国电信：46003）
public static String getNetworkOperator(Context context) {
    TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    return telephonyManager.getNetworkOperator();
}
```

## 获取运营商名称

``` Java
// (例：中国联通、中国移动、中国电信) 仅当用户已在网络注册时有效, CDMA 可能会无效)
public static String getNetworkOperatorName(Context context) {
    TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    return telephonyManager.getNetworkOperatorName();
}
```

## 获取移动终端类型

``` Java
// PHONE_TYPE_NONE :0 手机制式未知
// PHONE_TYPE_GSM :1 手机制式为GSM，移动和联通
// PHONE_TYPE_CDMA :2 手机制式为CDMA，电信
// PHONE_TYPE_SIP:3
public static int getPhoneType(Context context) {
    TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    return telephonyManager.getPhoneType();
}
```

## 判断手机连接的网络类型(2G,3G,4G)

``` Java
public class Constants {
    /**
     * Unknown network class
     */
    public static final int NETWORK_CLASS_UNKNOWN = 0;

    /**
     * wifi net work
     */
    public static final int NETWORK_WIFI = 1;

    /**
     * "2G" networks
     */
    public static final int NETWORK_CLASS_2_G = 2;

    /**
     * "3G" networks
     */
    public static final int NETWORK_CLASS_3_G = 3;

    /**
     * "4G" networks
     */
    public static final int NETWORK_CLASS_4_G = 4;

}

public static int getNetWorkClass(Context context) {
    TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    switch (telephonyManager.getNetworkType()) {
        case TelephonyManager.NETWORK_TYPE_GPRS:
        case TelephonyManager.NETWORK_TYPE_EDGE:
        case TelephonyManager.NETWORK_TYPE_CDMA:
        case TelephonyManager.NETWORK_TYPE_1xRTT:
        case TelephonyManager.NETWORK_TYPE_IDEN:
            return Constants.NETWORK_CLASS_2_G;

        case TelephonyManager.NETWORK_TYPE_UMTS:
        case TelephonyManager.NETWORK_TYPE_EVDO_0:
        case TelephonyManager.NETWORK_TYPE_EVDO_A:
        case TelephonyManager.NETWORK_TYPE_HSDPA:
        case TelephonyManager.NETWORK_TYPE_HSUPA:
        case TelephonyManager.NETWORK_TYPE_HSPA:
        case TelephonyManager.NETWORK_TYPE_EVDO_B:
        case TelephonyManager.NETWORK_TYPE_EHRPD:
        case TelephonyManager.NETWORK_TYPE_HSPAP:
            return Constants.NETWORK_CLASS_3_G;

        case TelephonyManager.NETWORK_TYPE_LTE:
            return Constants.NETWORK_CLASS_4_G;

        default:
            return Constants.NETWORK_CLASS_UNKNOWN;
    }
}
```

## 获取网络类型名称

``` Java
public static String getNetworkTypeName(Context context) {
   if (context != null) {
       ConnectivityManager connectMgr = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
       if (connectMgr != null) {
           NetworkInfo info = connectMgr.getActiveNetworkInfo();
           if (info != null) {
               switch (info.getType()) {
               case ConnectivityManager.TYPE_WIFI:
                   return "WIFI";
               case ConnectivityManager.TYPE_MOBILE:
                   return getNetworkTypeName(info.getSubtype());
               }
           }
       }
   }
   return getNetworkTypeName(TelephonyManager.NETWORK_TYPE_UNKNOWN);
}

public static String getNetworkTypeName(int type) {
   switch (type) {
   case TelephonyManager.NETWORK_TYPE_GPRS:
       return "GPRS";
   case TelephonyManager.NETWORK_TYPE_EDGE:
       return "EDGE";
   case TelephonyManager.NETWORK_TYPE_UMTS:
       return "UMTS";
   case TelephonyManager.NETWORK_TYPE_HSDPA:
       return "HSDPA";
   case TelephonyManager.NETWORK_TYPE_HSUPA:
       return "HSUPA";
   case TelephonyManager.NETWORK_TYPE_HSPA:
       return "HSPA";
   case TelephonyManager.NETWORK_TYPE_CDMA:
       return "CDMA";
   case TelephonyManager.NETWORK_TYPE_EVDO_0:
       return "CDMA - EvDo rev. 0";
   case TelephonyManager.NETWORK_TYPE_EVDO_A:
       return "CDMA - EvDo rev. A";
   case TelephonyManager.NETWORK_TYPE_EVDO_B:
       return "CDMA - EvDo rev. B";
   case TelephonyManager.NETWORK_TYPE_1xRTT:
       return "CDMA - 1xRTT";
   case TelephonyManager.NETWORK_TYPE_LTE:
       return "LTE";
   case TelephonyManager.NETWORK_TYPE_EHRPD:
       return "CDMA - eHRPD";
   case TelephonyManager.NETWORK_TYPE_IDEN:
       return "iDEN";
   case TelephonyManager.NETWORK_TYPE_HSPAP:
       return "HSPA+";
   default:
       return "UNKNOWN";
   }
}
```


## 判断当前手机的网络类型(WIFI还是2,3,4G)

``` Java
public static int getNetworkStatus(Context context) {
    int netWorkType = Constants.NETWORK_CLASS_UNKNOWN;

    ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();

    if (networkInfo != null && networkInfo.isConnected()) {
        int type = networkInfo.getType();

        if (type == ConnectivityManager.TYPE_WIFI) {
            netWorkType = Constants.NETWORK_WIFI;
        } else if (type == ConnectivityManager.TYPE_MOBILE) {
            netWorkType = getNetWorkClass(context);
        }
    }
    return netWorkType;
}
```

## 启动App默认的Activity

``` Java
public static void startApkActivity(final Context ctx, String packageName) {
    PackageManager pm = ctx.getPackageManager();
    PackageInfo pi;
    try {
        pi = pm.getPackageInfo(packageName, 0);
        Intent intent = new Intent(Intent.ACTION_MAIN, null);
        intent.addCategory(Intent.CATEGORY_LAUNCHER);
        intent.setPackage(pi.packageName);
        List<ResolveInfo> apps = pm.queryIntentActivities(intent, 0);
        ResolveInfo ri = apps.iterator().next();
        if (ri != null) {
            String className = ri.activityInfo.name;
            intent.setComponent(new ComponentName(packageName, className));
            ctx.startActivity(intent);
        }
    } catch (NameNotFoundException e) {
        Log.e("startActivity", e);
    }
}

//根据包名启动应用
startActivity(getPackageManager().getLaunchIntentForPackage(data));
```

## 拨打电话

``` Java
public static void call(Context context, String phoneNumber) {
    context.startActivity(new Intent(Intent.ACTION_CALL, Uri.parse("tel:" + phoneNumber)));
}
```

## 跳转到拨号界面

``` Java
public static void callDial(Context context, String phoneNumber) {
    context.startActivity(new Intent(Intent.ACTION_DIAL, Uri.parse("tel:" + phoneNumber)));
}
```

## 发送短信

``` Java
public static void sendSms(Context context, String phoneNumber, String content) {
    Uri uri = Uri.parse("smsto:" + (TextUtils.isEmpty(phoneNumber) ? "" : phoneNumber));
    Intent intent = new Intent(Intent.ACTION_SENDTO, uri);
    intent.putExtra("sms_body", TextUtils.isEmpty(content) ? "" : content);
    context.startActivity(intent);
}
```

## 发送彩信

``` Java
StringBuilder sb = new StringBuilder();
sb.append("file://");
sb.append(fd.getAbsoluteFile());
Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.fromParts("mmsto", number,null));// Below extra datas are all optional.
intent.putExtra(Messaging.KEY_ACTION_SENDTO_MESSAGE_SUBJECT, subject);
intent.putExtra(Messaging.KEY_ACTION_SENDTO_MESSAGE_BODY, body);
intent.putExtra(Messaging.KEY_ACTION_SENDTO_CONTENT_URI, sb.toString());
intent.putExtra(Messaging.KEY_ACTION_SENDTO_COMPOSE_MODE, composeMode);
intent.putExtra(Messaging.KEY_ACTION_SENDTO_EXIT_ON_SENT, exitOnSent);
startActivity(intent);
```

## 发送email

``` Java
String mime = "img/jpg";
shareIntent.setDataAndType(Uri.fromFile(fd), mime);
shareIntent.putExtra(Intent.EXTRA_STREAM, Uri.fromFile(fd));
shareIntent.putExtra(Intent.EXTRA_SUBJECT, subject);
shareIntent.putExtra(Intent.EXTRA_TEXT, body);
```

## 打开浏览器浏览某一个网站

``` Java
Intent viewIntent = new Intent("android.intent.action.VIEW",Uri.parse("http://vaiyanzi.cnblogs.com"));
startActivity(viewIntent);
```

## 唤醒屏幕并解锁

``` Java
public static void wakeUpAndUnlock(Context context) {
    KeyguardManager km = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
    KeyguardManager.KeyguardLock kl = km.newKeyguardLock("unLock");
    // 解锁
    kl.disableKeyguard();
    // 获取电源管理器对象
    PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
    // 获取PowerManager.WakeLock对象,后面的参数|表示同时传入两个值,最后的是LogCat里用的Tag
    PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK, "bright");
    // 点亮屏幕
    wl.acquire();
    // 释放
    wl.release();
}

//需要添加权限
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.DISABLE_KEYGUARD" />
```

## 判断当前App处于前台还是后台状态

``` Java
public static boolean isApplicationBackground(final Context context) {

    ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    @ SuppressWarnings("deprecation")
    List<ActivityManager.RunningTaskInfo> tasks = am.getRunningTasks(1);
    if (!tasks.isEmpty()) {
        ComponentName topActivity = tasks.get(0).topActivity;
        if (!topActivity.getPackageName().equals(context.getPackageName())) {
            return true;
        }
    }
    return false;
}

//需要添加权限
<uses-permission android:name="android.permission.GET_TASKS" />
```

## 判断当前手机是否处于锁屏(睡眠)状态

``` Java
public static boolean isSleeping(Context context) {
    KeyguardManager kgMgr = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
    boolean isSleeping = kgMgr.inKeyguardRestrictedInputMode();
    return isSleeping;
}
```

## 判断当前是否有网络连接

``` Java
public static boolean isOnline(Context context) {
    ConnectivityManager manager = (ConnectivityManager) context.getSystemService(Activity.CONNECTIVITY_SERVICE);
    NetworkInfo info = manager.getActiveNetworkInfo();
    if (info != null && info.isConnected()) {
        return true;
    }
    return false;
}
```

## 判断当前是否是WIFI连接状态

``` Java
public static boolean isWifiConnected(Context context) {
    ConnectivityManager connectivityManager = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
    NetworkInfo wifiNetworkInfo = connectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI);
    if (wifiNetworkInfo.isConnected()) {
        return true;
    }
    return false;
}
```

## 安装APK

``` Java
public static void installApk(Context context, File file) {
    Intent intent = new Intent();
    intent.setAction("android.intent.action.VIEW");
    intent.addCategory("android.intent.category.DEFAULT");
    intent.setType("application/vnd.android.package-archive");
    intent.setDataAndType(Uri.fromFile(file), "application/vnd.android.package-archive");
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    context.startActivity(intent);
}
```

## 获取已经安装的APK路径

``` Java
PackageManager pm = getPackageManager();
for (ApplicationInfo app : pm.getInstalledApplications(0)) {
    Log.d("PackageList", "package: " + app.packageName + ", sourceDir: " + app.sourceDir);
}
```

## 判断当前设备是否为手机

``` Java
public static boolean isPhone(Context context) {
    TelephonyManager telephony = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
    if (telephony.getPhoneType() == TelephonyManager.PHONE_TYPE_NONE) {
        return false;
    } else {
        return true;
    }
}
```

## 判断设备是否是平板

``` Java
public static boolean isTablet(Context context) {
    return (context.getResources().getConfiguration().screenLayout & Configuration.SCREENLAYOUT_SIZE_MASK) >= Configuration.SCREENLAYOUT_SIZE_LARGE;
}
```

## 监听apk的安装和卸载

``` Java
MyBroadcastReceiver myReceiver = new MyBroadcastReceiver();
IntentFilter filter = new IntentFilter(Intent.ACTION_PACKAGE_INSTALL);
filter.addAction(Intent.ACTION_PACKAGE_REMOVED);
filter.addAction(Intent.ACTION_PACKAGE_ADDED);
filter.addAction(Intent.ACTION_PACKAGE_CHANGED);
filter.addAction(Intent.ACTION_PACKAGE_RESTARTED);
filter.addDataScheme("package"); //This line is very important. Otherwise, broadcast can't be received.
registerReceiver(myReceiver, filter);
```

## 获取内存大小

``` Java
ActivityManager.MemoryInfo outInfo = new ActivityManager.MemoryInfo();
activityManager.getMemoryInfo(outInfo);
//可用内存
outInfo.availMem
//是否在低内存状态
outInfo.lowMemory
```

## 取得ScrollView的实际高度

``` Java
scrollview.getHeight()
scrollview.getMeasuredHeight()
scrollview.compute()
scrollview.getLayoutParams().height
```

## 获取当前设备宽高，单位px

``` Java
public static int getDeviceWidth(Context context) {
    WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    return manager.getDefaultDisplay().getWidth();
}

@ SuppressWarnings("deprecation")
public static int getDeviceHeight(Context context) {
    WindowManager manager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    return manager.getDefaultDisplay().getHeight();
}
```

## 获取屏幕宽高

``` Java
DisplayMetrics dm = new DisplayMetrics();
//获取窗口属性
getWindowManager().getDefaultDisplay().getMetrics(dm);
int screenWidth = dm.widthPixels;//320
int screenHeight = dm.heightPixels;//480
```

## 获取当前设备的IMEI，需要与上面的isPhone()一起使用

``` Java
public static String getDeviceIMEI(Context context) {
    String deviceId;
    if (isPhone(context)) {
        TelephonyManager telephony = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
        deviceId = telephony.getDeviceId();
    } else {
        deviceId = Settings.Secure.getString(context.getContentResolver(), Settings.Secure.ANDROID_ID);

    }
    return deviceId;
}
```

## 获取SIM卡的IMSI号码

``` Java
//方法1
TelephonyManager tm = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);
String mIMSI = tm.getSubscriberIdGemini(PhoneConstants.GEMINI_SIM_1);

//方法2
import com.android.internal.telephony.Phone;
import com.android.internal.telephony.PhoneFactory;
import com.android.internal.telephony.RIL;
private static final int EVENT_GET_IMSI_DONE = 1;

Phone phone = PhoneFactory.getDefaultPhone();
phone.mCM.getIMSI(obtainMessage(EVENT_GET_IMSI_DONE));
public void handleMessage(Message msg) {
    switch (msg.what){
        case EVENT_GET_IMSI_DONE:
            isRecordLoadResponse = true;
            ar = (AsyncResult)msg.obj;
            if (ar.exception != null) {
                Log.e(LOG_TAG, "Exception querying IMSI, Exception:" + ar.exception);
                break;
            }
            imsi = (String) ar.result;
            Log.d(LOG_TAG, "IMSI: " + imsi.substring(0, 6) + "xxxxxxx");
            break;
        default:
            break;
    }
}
```

## 获取当前设备的MAC地址

``` Java
public static String getMacAddress(Context context) {
    String macAddress;
    WifiManager wifi = (WifiManager) context.getSystemService(Context.WIFI_SERVICE);
    WifiInfo info = wifi.getConnectionInfo();
    macAddress = info.getMacAddress();
    if (null == macAddress) {
        return "";
    }
    macAddress = macAddress.replace(":", "");
    return macAddress;
}
```

## 获取android设备唯一标示码

``` Java
String android_id = Secure.getString(getContext().getContentResolver(), Secure.ANDROID_ID)
```

## 获取当前程序的版本号

``` Java
public static String getAppVersion(Context context) {
    String version = "0";
    try {
        version = context.getPackageManager().getPackageInfo(context.getPackageName(), 0).versionName;
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }
    return version;
}
```

## 精确获取屏幕尺寸

``` Java
public static double getScreenPhysicalSize(Activity ctx) {
    DisplayMetrics dm = new DisplayMetrics();
    ctx.getWindowManager().getDefaultDisplay().getMetrics(dm);
    double diagonalPixels = Math.sqrt(Math.pow(dm.widthPixels, 2) + Math.pow(dm.heightPixels, 2));
    return diagonalPixels / (160 * dm.density);
}
```

## 获取应用程序下所有的activity

``` Java
public static ArrayList<String> getActivities(Context ctx) {
    ArrayList<String> result = new ArrayList<String>();
    Intent intent = new Intent(Intent.ACTION_MAIN, null);
    intent.setPackage(ctx.getPackageName());
    for (ResolveInfo info : ctx.getPackageManager().queryIntentActivities(intent, 0)) {
        result.add(info.activityInfo.name);
    }
    return result;
}
```

## 获取设备上已安装并且可启动的应用列表

``` Java
Intent intent = new Intent(Intent.ACTION_MAIN);
intent.addCategory(Intent.CATEGORY_LAUNCHER);
List<ResolveInfo> activities = getPackageManager().queryIntentActivities(intent, 0)
```

## 列出系统中所有安装的app的信息

``` Java
PackageManager pm = getPackageManager();
List<PackageInfo> packages = pm.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);
for(PackageInfo packageInfo : packages){
    //应用图标
    Drawable icon = packageInfo.applicationInfo.loadIcon(pm);
    //标题
    CharSequence lable = packageInfo.applicationInfo.loadLabel(pm);
    //包名
    String packageName = packageInfo.packageName;
}
```

## 将raw中的apk拷贝到/data/data/包名/files/中

``` Java
InputStream in = null;
OutputStream out = null;
try {
    in = getResources().openRawResource(R.raw.dex_apk);
    out = this.openFileOutput("dex_apk.apk", Context.MODE_PRIVATE);
    copyFile(in, out);
} catch (FileNotFoundException e) {
    e.printStackTrace();
} finally {
    try {
        if (in != null) {
            in.close();
        }
    } catch (IOException e) {
        e.printStackTrace();
    }

    try {
        if (out != null) {
            out.close();
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

## 文件读写相关

https://blog.csdn.net/lilu_leo/article/details/6597302
https://blog.csdn.net/lilu_leo/article/details/6589510

## TODO : 保存文件

## 拷贝文件

``` Java
private void copyFile(InputStream in, OutputStream out){
    byte[] buffer = new byte[1024];
    int len = 0;

    try {
        while((len = in.read(buffer) ) != -1){
            out.write(buffer , 0 , len);
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```

## 使用DexClassLoader加载 /data/data/包名/files/ 下的apk的classes.dex，并通过反射执行。

``` Java
String pkgDataPath = "/data/data/" + getPackageName();
String optimizedDirectory = pkgDataPath + "/files/";
String dexPath = optimizedDirectory + "dex_apk.apk";
DexClassLoader dexClassLoader = new DexClassLoader(dexPath, optimizedDirectory, null, this.getClassLoader());
try {
    Class personClazz = dexClassLoader.loadClass("com.aa.dexapk.Person");
    Object newInstance = personClazz.newInstance();
    Method method = personClazz.getMethod("doWork");
    method.invoke(newInstance);
} catch (Exception e) {
    e.printStackTrace();
}
```

## 动态加载其他已经安装的apk的dex文件， 并通过反射执行

``` Java
private void useDexClassLoader(){
    //创建一个意图，用来找到指定的apk
    Intent intent = new Intent("com.suchangli.android.plugin", null);
    //获得包管理器
    PackageManager pm = getPackageManager();
    List<ResolveInfo> resolveinfoes =  pm.queryIntentActivities(intent, 0);
    //获得指定的activity的信息
    ActivityInfo actInfo = resolveinfoes.get(0).activityInfo;
    //获得包名
    String pacageName = actInfo.packageName;
    //获得apk的目录或者jar的目录
    String apkPath = actInfo.applicationInfo.sourceDir;
    //dex解压后的目录,注意，这个用宿主程序的目录，android中只允许程序读取写自己
    //目录下的文件
    String dexOutputDir = getApplicationInfo().dataDir;
    //native代码的目录
    String libPath = actInfo.applicationInfo.nativeLibraryDir;
    //创建类加载器，把dex加载到虚拟机中
    DexClassLoader calssLoader = new DexClassLoader(apkPath, dexOutputDir, libPath,　this.getClass().getClassLoader());
    //利用反射调用插件包内的类的方法
    try {
        Class<?> clazz = calssLoader.loadClass(pacageName+".Plugin1");
        Object obj = clazz.newInstance();
        Class[] param = new Class[2];
        param[0] = Integer.TYPE;
        param[1] = Integer.TYPE;
        Method method = clazz.getMethod("function1", param);
        Integer ret = (Integer)method.invoke(obj, 1,12);
        Log.i("Host", "return result is " + ret);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (InstantiationException e) {
        e.printStackTrace();
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    } catch (IllegalArgumentException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    }
}
```

## 获取其他包中的资源

``` Java
Intent intent = new Intent("com.suchangli.android.plugin", null);
//获得包管理器
PackageManager pm = getPackageManager();
List<ResolveInfo> resolveinfoes =  pm.queryIntentActivities(intent, 0);
//获得指定的activity的信息
ActivityInfo actInfo = resolveinfoes.get(0).activityInfo;
//获得包名
String pacageName = actInfo.packageName;
try {
    Resources res = pm.getResourcesForApplication(pacageName);
    int id = 0;
    id = res.getIdentifier("ic_launcher", "drawable", pacageName);
    Log.i("", "resId is " + id);
} catch (NameNotFoundException e) {
    e.printStackTrace();
}
```

## 获取Activity的图标

``` Java
private Bitmap getIconForActivity(Context context, String packageName, String activityName){
    ComponentName activityComp = new ComponentName(packageName, activityName);
    PackageManager pm = context.getPackageManager();
    Intent intentToResolve = new Intent();
    intentToResolve.setComponent(activityComp);
    ResolveInfo resolveInfo = pm.resolveActivity(intentToResolve, 0);
    Drawable iconDrawable = resolveInfo.activityInfo.loadIcon(pm);
    return Utilities.createIconBitmap( iconDrawable, context); //其中Utilities为Launcher中的工具类
}
```

## 获取当前app的签名信息

``` Java
/**
 * get signature of current package
 * @param context
 * @return signature, null if there is no signature
 */
public static String getSignature(Context context){
    Log.i(TAG, "SignatureUtils.getSignature");
    PackageManager pm = context.getPackageManager();
    String pkgName = context.getPackageName();
    try {
        PackageInfo pi = pm.getPackageInfo(pkgName, PackageManager.GET_SIGNATURES);
        Signature[] signatures = pi.signatures;
        if(signatures != null && signatures.length > 0){
            String signature =  signatures[0].toCharsString();
            Log.i(TAG, "Signature of current package is : " + signature);

            return  signature;
        }
    } catch (PackageManager.NameNotFoundException e1) {
        e1.printStackTrace();
    }
    return null;
}
```

## 获取apk文件的签名信息

``` Java
/**
 * get signature of an apk file
 * this method will execute quit a long time, so it is suitable to call it in sub thread
 * @param context
 * @param apkFilePath
 * @return signature , null if there is no signature , or apkFilePath is wrong
 */
public static String getSignatureOfApk(Context context, String apkFilePath){
    if (TextUtils.isEmpty(apkFilePath)) {
        return null;
    }

    PackageManager pm = context.getPackageManager();
    PackageInfo pi = pm.getPackageArchiveInfo(apkFilePath, PackageManager.GET_SIGNATURES);
    Signature[] signatures = pi.signatures;

    if(signatures != null && signatures.length > 0){
        String signature =  signatures[0].toCharsString();
        Log.i(TAG, "Signature of " + apkFilePath + " is : " + signature);
        return  signature;
    }
    return null;
}
```

## 获取apk文件的权限信息

``` Java
public static List<PermissionInfo> getApkPermissions(String apkFile, PackageManager pm){
    List<PermissionInfo> permissionInfos = new ArrayList<PermissionInfo>();
    PackageInfo packageInfo =  pm.getPackageArchiveInfo(apkFile, PackageManager.GET_PERMISSIONS);
    String[] permissions = packageInfo.requestedPermissions;
    for(String permName : permissions ){
        try {
            PermissionInfo permissionInfo = pm.getPermissionInfo(permName, 0);
            permissionInfos.add(permissionInfo);
        } catch (PackageManager.NameNotFoundException e) {
            e.printStackTrace();
        }
    }
    return permissionInfos;
}
```

## 检测字符串中是否包含汉字

``` Java
public static boolean checkChinese(String sequence) {
    final String format = "[\\u4E00-\\u9FA5\\uF900-\\uFA2D]";
    boolean result = false;
    Pattern pattern = Pattern.compile(format);
    Matcher matcher = pattern.matcher(sequence);
    result = matcher.find();
    return result;
}
```

## 检测字符串中只能包含:中文、数字、下划线(_)、横线(-)

``` Java
public static boolean checkNickname(String sequence) {
    final String format = "[^\\u4E00-\\u9FA5\\uF900-\\uFA2D\\w-_]";
    Pattern pattern = Pattern.compile(format);
    Matcher matcher = pattern.matcher(sequence);
    return !matcher.find();
}
```

## 检查又没有应用程序来接受处理你发出的intent

``` Java
public static boolean isIntentAvailable(Context context, String action) {
    final PackageManager packageManager = context.getPackageManager();
    final Intent intent = new Intent(action);
    List<ResolveInfo> list = packageManager.queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);
    return list.size() > 0;
}
```

## 使用TransitionDrawable实现渐变效果

``` Java
private void setImageBitmap(ImageView imageView, Bitmap bitmap) {
    final TransitionDrawable td = new TransitionDrawable(new Drawable[] { new ColorDrawable(android.R.color.transparent), new BitmapDrawable(mContext.getResources(), bitmap) });
    imageView.setBackgroundDrawable(imageView.getDrawable());
    imageView.setImageDrawable(td);
    td.startTransition(200);
}
```

## 发送广播扫描指定文件

``` Java
sendBroadcast(new Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE, uri));
```

## 多进程Preferences数据共享

``` Java
public static void putStringProcess(Context ctx, String key, String value) {
    SharedPreferences sharedPreferences = ctx.getSharedPreferences("preference_mu", Context.MODE_MULTI_PROCESS);
    Editor editor = sharedPreferences.edit();
    editor.putString(key, value);
    editor.commit();
}

public static String getStringProcess(Context ctx, String key, String defValue) {
    SharedPreferences sharedPreferences = ctx.getSharedPreferences("preference_mu", Context.MODE_MULTI_PROCESS);
    return sharedPreferences.getString(key, defValue);
}
```

## 泛型ArrayList转数组

``` Java
public static <T> T[] toArray(Class<?> cls, ArrayList<T> items) {
    if (items == null || items.size() == 0) {
        return (T[]) Array.newInstance(cls, 0);
    }
    return items.toArray((T[]) Array.newInstance(cls, items.size()));
}
```

## 保存恢复ListView为当前位置

``` Java
private void saveCurrentPosition() {
    if (mListView != null) {
        int position = mListView.getFirstVisiblePosition();
        View v = mListView.getChildAt(0);
        int top = (v == null) ? 0 : v.getTop();
        //保存position和top
    }
}

private void restorePosition() {
    if (mFolder != null && mListView != null) {
        int position = 0;//取出保存的数据
        int top = 0;//取出保存的数据
        mListView.setSelectionFromTop(position, top);
    }
}
```

## 调用便携式热点和数据共享设置

``` Java
public static Intent getHotspotSetting() {
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_MAIN);
    ComponentName com = new ComponentName("com.android.settings", "com.android.settings.TetherSettings");
    intent.setComponent(com);
    return intent;
}
```

## 格式化输出IP地址

``` Java
public static String getIp(Context ctx) {
    return Formatter.formatIpAddress((WifiManager) ctx.getSystemService(Context.WIFI_SERVICE).getConnectionInfo().getIpAddress());
}
```

## ip地址转成8位16进制串

``` Java
/** ip转16进制 */
public static String ipToHex(String ips) {
    StringBuffer result = new StringBuffer();
    if (ips != null) {
        StringTokenizer st = new StringTokenizer(ips, ".");
        while (st.hasMoreTokens()) {
        String token = Integer.toHexString(Integer.parseInt(st.nextToken()));
        if (token.length() == 1) {
            token = "0" + token;
            result.append(token);
        }
    }
    return result.toString();
}

/** 16进制转ip */
public static String texToIp(String ips) {
    try {
        StringBuffer result = new StringBuffer();
        if (ips != null && ips.length() == 8) {
            for (int i = 0; i < 8; i += 2) {
                if (i != 0) {
                    result.append('.');
                    result.append(Integer.parseInt(ips.substring(i, i + 2), 16));
                }
            }
            return result.toString();
    } catch (NumberFormatException ex) {
        Logger.e(ex);
    }
    return "";
}
```

## 利用反射机制，获取drawable文件夹下的图片名称

``` Java
Field[] fields = R.drawable.class.getDeclaredFields();
for(Field field:fields){
    if(!"icon".equals(field.getName())){
        sb.append(field.getName() + "\t");
    }
    }
mTextView.setText(sb.toString());
```

## 文件夹排序

``` Java
public static void sortFiles(File[] files) {
    Arrays.sort(files, new Comparator<File>() {
        @Override
        public int compare(File lhs, File rhs) {
            //返回负数表示o1 小于o2，返回0 表示o1和o2相等，返回正数表示o1大于o2。 
            boolean l1 = lhs.isDirectory();
            boolean l2 = rhs.isDirectory();
            if (l1 && !l2)
                return -1;
            else if (!l1 && l2)
                return 1;
            else {
                return lhs.getName().compareTo(rhs.getName());
            }
        }
    });
}
```

## 发送不重复的通知

``` Java
public static void sendNotification(Context context, String title, String message, Bundle extras) {
    Intent mIntent = new Intent(context, FragmentTabsActivity.class);
    mIntent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    mIntent.putExtras(extras);
    int requestCode = (int) System.currentTimeMillis();
    PendingIntent mContentIntent = PendingIntent.getActivity(context, requestCode, mIntent, 0);
    Notification mNotification = new NotificationCompat.Builder(context).setContentTitle(title).setSmallIcon(R.drawable.app_icon).setContentIntent(mContentIntent).setContentText(message).build();
    mNotification.flags |= Notification.FLAG_AUTO_CANCEL;
    mNotification.defaults = Notification.DEFAULT_ALL;
    NotificationManager mNotificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
    mNotificationManager.notify(requestCode, mNotification);
}
```

## 通过代码设置TextView的样式

``` Java
new TextView(new ContextThemeWrapper(this, R.style.text_style));
```

## 通过html设置TextView中内容的样式

``` Java
tv.setText(Html.fromHtml("<font color="#ff0000">红色</font>其它颜色"));
```

## WebView保留缩放功能但隐藏缩放控件

``` Java
mWebView.getSettings().setSupportZoom(true);
mWebView.getSettings().setBuiltInZoomControls(true);
if (DeviceUtils.hasHoneycomb()){
    mWebView.getSettings().setDisplayZoomControls(false);
}
```

## 通过代码解压zip包

``` Java
/**
 * 解压一个压缩文档 到指定位置
 * @param zipFileString 压缩包的名字
 * @param outPathString 指定的路径
 */
public static void UnZipFolder(String zipFileString, String outPathString) throws Exception {
    java.util.zip.ZipInputStream inZip = new java.util.zip.ZipInputStream(new java.io.FileInputStream(zipFileString));
    java.util.zip.ZipEntry zipEntry;
    String szName = "";

    while ((zipEntry = inZip.getNextEntry()) != null) {
        szName = zipEntry.getName();
        if (zipEntry.isDirectory()) {
            // get the folder name of the widget
            szName = szName.substring(0, szName.length() - 1);
            java.io.File folder = new java.io.File(outPathString + java.io.File.separator + szName);
            folder.mkdirs();
        } else {
            java.io.File file = new java.io.File(outPathString + java.io.File.separator + szName);
            file.createNewFile();
            // get the output stream of the file
            java.io.FileOutputStream out = new java.io.FileOutputStream(file);
            int len;
            byte[] buffer = new byte[1024];
            // read (len) bytes into buffer
            while ((len = inZip.read(buffer)) != -1) {
                // write (len) byte from buffer at the position 0
                out.write(buffer, 0, len);
                out.flush();
            }
            out.close();
        }
    }
    inZip.close();
}
```

## 从assets中读取文本和图片资源

``` Java
/** 从assets 文件夹中读取文本数据 */
public static String getTextFromAssets(final Context context, String fileName) {
    String result = "";
    try {
        InputStream in = context.getResources().getAssets().open(fileName);
        // 获取文件的字节数
        int lenght = in.available();
        // 创建byte数组
        byte[] buffer = new byte[lenght];
        // 将文件中的数据读到byte数组中
        in.read(buffer);
        result = EncodingUtils.getString(buffer, "UTF-8");
        in.close();
    } catch (Exception e) {
        e.printStackTrace();
    }
    return result;
}

/** 从assets 文件夹中读取图片1 */
public static Drawable loadImageFromAsserts(final Context ctx, String fileName) {
    try {
        InputStream is = ctx.getResources().getAssets().open(fileName);
        return Drawable.createFromStream(is, null);
    } catch (IOException e) {
        if (e != null) {
            e.printStackTrace();
        }
    } catch (OutOfMemoryError e) {
        if (e != null) {
            e.printStackTrace();
        }
    } catch (Exception e) {
        if (e != null) {
            e.printStackTrace();
        }
    }
    return null;
}

/** 从assets 文件夹中读取图片2 */
bgimg0 = getImageFromAssetsFile("Cat_Blink/cat_blink0000.png");
private Bitmap getImageFromAssetsFile(String fileName) {
    Bitmap image = null;
    AssetManager am = getResources().getAssets();
    try {
        InputStream is = am.open(fileName);
        image = BitmapFactory.decodeStream(is);
        is.close();
    } catch (IOException e) {
        e.printStackTrace();
    }
    return image;
}
```

## 解析assets文件夹下的xml文件

``` Java
SAXParserFactory.newInstance().newSAXParser().parse(getResources().getAssets().open("apns-conf.xml"), apnHandler);
```

## 展开、收起状态栏

``` Java
public static final void collapseStatusBar(Context ctx) {
    Object sbservice = ctx.getSystemService("statusbar");
    try {
        Class<?> statusBarManager = Class.forName("android.app.StatusBarManager");
        Method collapse;
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
            collapse = statusBarManager.getMethod("collapsePanels");
        } else {
            collapse = statusBarManager.getMethod("collapse");
        }
        collapse.invoke(sbservice);
    } catch (Exception e) {
        e.printStackTrace();
    }
}

public static final void expandStatusBar(Context ctx) {
    Object sbservice = ctx.getSystemService("statusbar");
    try {
        Class<?> statusBarManager = Class.forName("android.app.StatusBarManager");
        Method expand;
        if (Build.VERSION.SDK_INT >= 17) {
            expand = statusBarManager.getMethod("expandNotificationsPanel");
        } else {
            expand = statusBarManager.getMethod("expand");
        }
        expand.invoke(sbservice);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

## 计算字宽

``` Java
public static float getTextWidth(String text, float Size) {
    TextPaint FontPaint = new TextPaint();
    FontPaint.setTextSize(Size);
    return FontPaint.measureText(text);
}
```

## 图片的旋转

``` Java
Bitmap bitmapOrg = BitmapFactory.decodeResource(this.getContext().getResources(), R.drawable.moon);
Matrix matrix = new Matrix();
matrix.postRotate(-90);//旋转的角度
Bitmap resizedBitmap = Bitmap.createBitmap(bitmapOrg, 0, 0, bitmapOrg.getWidth(), bitmapOrg.getHeight(), matrix, true);
BitmapDrawable bmd = new BitmapDrawable(resizedBitmap);
```

## 格式化 string.xml 中的字符串

``` xml
// in strings.xml..
<string name="my_text">Thanks for visiting %s. You age is %d!</string>
```

``` Java
// and in the java code:
String.format(getString(R.string.my_text), "oschina", 33);
```

## 查看电池使用详情

``` Java
Intent intentBatteryUsage = new Intent(Intent.ACTION_POWER_USAGE_SUMMARY);
startActivity(intentBatteryUsage);
```

## android获取存储卡路径以及使用情况

``` Java
/** 获取存储卡路径 */
File sdcardDir=Environment.getExternalStorageDirectory();
/** StatFs 看文件系统空间使用情况 */
StatFs statFs=new StatFs(sdcardDir.getPath());
/** Block 的 size*/
Long blockSize=statFs.getBlockSize();
/** 总 Block 数量 */
Long totalBlocks=statFs.getBlockCount();
/** 已使用的 Block 数量 */
Long availableBlocks=statFs.getAvailableBlocks();
```

## android中添加新的联系人

``` Java
private Uri insertContact(Context context, String name, String phone) {
    ContentValues values = new ContentValues();
    values.put(People.NAME, name);
    Uri uri = getContentResolver().insert(People.CONTENT_URI, values);
    Uri numberUri = Uri.withAppendedPath(uri, People.Phones.CONTENT_DIRECTORY);
    values.clear();

    values.put(Contacts.Phones.TYPE, People.Phones.TYPE_MOBILE);
    values.put(People.NUMBER, phone);
    getContentResolver().insert(numberUri, values);

    return uri;
}
```

## 唤醒屏幕并解锁

``` Java
public static void wakeUpAndUnlock(Context context){
    KeyguardManager km= (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
    KeyguardManager.KeyguardLock kl = km.newKeyguardLock("unLock");
    //解锁
    kl.disableKeyguard();
    //获取电源管理器对象
    PowerManager pm=(PowerManager) context.getSystemService(Context.POWER_SERVICE);
    //获取PowerManager.WakeLock对象,后面的参数|表示同时传入两个值,最后的是LogCat里用的Tag
    PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_DIM_WAKE_LOCK,"bright");
    //点亮屏幕
    wl.acquire();
    //释放
    wl.release();
}

<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.DISABLE_KEYGUARD" />
```

## 判断当前App处于前台还是后台状态

``` Java
public static boolean isApplicationBackground(final Context context) {
    ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
    @SuppressWarnings("deprecation")
    List<ActivityManager.RunningTaskInfo> tasks = am.getRunningTasks(1);
    if (!tasks.isEmpty()) {
        ComponentName topActivity = tasks.get(0).topActivity;
        if (!topActivity.getPackageName().equals(context.getPackageName())) {
            return true;
        }
    }
    return false;
}
<uses-permission android:name="android.permission.GET_TASKS" />
```

## 获取栈顶Activity

``` Java
private ComponentName getTopActivity() {
    final ActivityManager am = (ActivityManager)mContext.getSystemService(Context.ACTIVITY_SERVICE);
    ActivityInfo aInfo = null;
    List<RunningTaskInfo> list = am.getRunningTasks(1);
    if (list.size() != 0) {
        RunningTaskInfo topRunningTask = list.get(0);
        return topRunningTask.topActivity;
    } else {
        return null;
    }
}

// 判断facebook是否在栈顶
private boolean isFaceBookLiteTop(){
    ComponentName topActivity = getTopActivity();
    String packageName = "";
    String className = "";
    if (topActivity != null) {
        packageName = topActivity.getPackageName().trim();
        className = topActivity.getClassName().trim();
    }
    if ("com.facebook.lite".equalsIgnoreCase(packageName)　{
        return true;
    }
    return false;
}

// L之后的方法
public static boolean isAppRunningForeground(Context context){
    ActivityManager activityManager = (ActivityManager) context.getSystemService(Service.ACTIVITY_SERVICE);
    List<ActivityManager.RunningAppProcessInfo> runningAppProcessInfoList = activityManager.getRunningAppProcesses();
    if (runningAppProcessInfoList==null){
        return false;
    }
    for (ActivityManager.RunningAppProcessInfo processInfo : runningAppProcessInfoList) {
        if (processInfo.processName.equals(context.getPackageName())
                && processInfo.importance==ActivityManager.RunningAppProcessInfo.IMPORTANCE_FOREGROUND){
            return true;
        }
    }
    return false;
}
```

## 判断当前手机是否处于休眠状态

``` Java
public static boolean isSleeping(Context context) {
    KeyguardManager kgMgr = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);
    boolean isSleeping = kgMgr.inKeyguardRestrictedInputMode();
    return isSleeping;
}
```

## 在View Layout完成后获取控件大小

``` Java
final TextView tv = (TextView) findViewById(R.id.myTextView);
ViewTreeObserver vto = tv.getViewTreeObserver();
vto.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
    @Override
    public void onGlobalLayout() {
        Toast.makeText(MyActivity.this, tv.getWidth() + " x " + tv.getHeight(), Toast.LENGTH_LONG).show();
        tv.getViewTreeObserver().removeGlobalOnLayoutListener(this);
    }
});
```

## 关键帧插值器

``` Java
public static float calculateValue(float[] values, float time, float def) {
    float value = def;
    if (values != null && values.length > 0) {
        float segment = 1.0f / (float)(values.length - 1);
        int index = (int)(time / segment);
        if (index >= values.length - 1) {
            value = values[values.length - 1];
        } else {
            float extra = time - segment * (float)index;
            value = values[index] + (values[index + 1] - values[index]) * extra / segment;
        }
    }
    return value;
}
```

## 给图片叠加渐变

``` Java
private void addShadow(Bitmap bitmap, int color) {
    int[] colors = new int[]{
            color & 0x00FFFFFF,
            color & 0x0AFFFFFF,
            color & 0x33FFFFFF,
            color & 0x66FFFFFF,
            color & 0x99FFFFFF,
            color & 0xCCFFFFFF,
            color
    };
    GradientDrawable gradientDrawable = new GradientDrawable(GradientDrawable.Orientation.TOP_BOTTOM, colors);
    gradientDrawable.setGradientType(GradientDrawable.LINEAR_GRADIENT);
    Rect rect = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());
    gradientDrawable.setBounds(rect);
    gradientDrawable.setLevel(8);
    Canvas canvass = new Canvas(bitmap);
    gradientDrawable.draw(canvass);
}
```

## ListView 或者 GridView 去除滑动特性 (即固定高度)

``` Java
@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    heightMeasureSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE >> 2, MeasureSpec.AT_MOST);
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
}
```

## 获取系统长按时间，自定义View会用到

``` Java
getSystemLongPressTime
```

## 圆形的ImageView,CircleImageView

``` Java
import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Bitmap.Config;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.PorterDuff.Mode;
import android.graphics.PorterDuffXfermode;
import android.graphics.Rect;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.util.AttributeSet;
import android.widget.ImageView;
import android.graphics.Matrix;

/** 圆形的Imageview */
public class CircleImageView extends ImageView {
    private Paint paint = new Paint();

    public CircleImageView(Context context) {
        super(context);
    }

    public CircleImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public CircleImageView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        Drawable drawable = getDrawable();
        if (null != drawable) {
            Bitmap bitmap1 = ((BitmapDrawable) drawable).getBitmap();
            Matrix matrix = new Matrix();
            float x = (float)100/bitmap1.getWidth();
            float y = (float)100/bitmap1.getHeight();
            matrix.postScale(x, y);
            Bitmap bitmap = Bitmap.createBitmap(bitmap1, 0, 0, bitmap1.getWidth(), bitmap1.getHeight(), matrix, true);
            Bitmap b = toRoundCorner(bitmap, 14);
            final Rect rect = new Rect(0, 0, b.getWidth(),  b.getHeight());
            paint.reset();
            canvas.drawBitmap(b, rect, rect, paint);
        } else {
            super.onDraw(canvas);
        }
    }

    private Bitmap toRoundCorner(Bitmap bitmap, int pixels) {
        Bitmap output = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Config.ARGB_8888);
        Canvas canvas = new Canvas(output);
        final int color = 0xff424242;
        final Rect rect = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());
        paint.setAntiAlias(true);
        canvas.drawARGB(0, 0, 0, 0);
        paint.setColor(color);
        int x = bitmap.getWidth();
        canvas.drawCircle(x / 2, x / 2, x / 2, paint);
        paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));
        canvas.drawBitmap(bitmap, rect, rect, paint);
        return output;
    }
}
```

## 通过代码动态设置语言

``` Java
Resources resources = getResources();//获得res资源对象
Configuration config = resources.getConfiguration();//获得设置对象
DisplayMetrics dm = resources.getDisplayMetrics();//获得屏幕参数：主要是分辨率，像素等。
config.locale = Locale.SIMPLIFIED_CHINESE; //简体中文
resources.updateConfiguration(config, dm);
```

## setLanguage

```
private void setLanguage() {
    ACache aCache = ACache.get(this);//使用ACache保存配置的语言
    //如果系统当前默认的语言不等于当前ACache中保存的语言，就更改
    if (Locale.getDefault() != Utils.getLanguageLocal(aCache.getAsString(Content.currentLanguage))){
        DisplayMetrics displayMetrics = getResources().getDisplayMetrics();
        Configuration configuration = getResources().getConfiguration();
        Locale locale = Utils.getLanguageLocal(aCache.getAsString(Content.currentLanguage));//获取到ACache中保存的语言
        configuration.setLocale(locale);//设置语言
        getResources().updateConfiguration(configuration, displayMetrics);//更新系统配置文件
    }
}

setLanguage();更改语言
recreate();//刷新页面
```

## 根据控件的id名称获取控件

frameworks/base/core/java/android/app/Activity.java

``` Java
private View findViewByName(String name){
    return findViewById(getResources().getIdentifier(name, "id", getPackageName()));
}

private View findViewByName(View parent, String name){
    return parent.findViewById(getResources().getIdentifier(name, "id", getPackageName()));
}

//具体用法如下
View setting_autodownload_layout = findViewByName("setting_autodownload_layout");
```

## 获取图片信息

``` Java
import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import com.drew.imaging.jpeg.JpegMetadataReader;
import com.drew.imaging.jpeg.JpegProcessingException;
import com.drew.metadata.Directory;
import com.drew.metadata.Metadata;
import com.drew.metadata.Tag;

public class ReadPic {
    /** 导入标签，使用metadata-extractor */
    public static void main(String[] args) {
        readPic();
    }

    /** 处理 单张 图片 */
    private static void readPic() {
        File jpegFile = new File("d:\\002.jpg");
        Metadata metadata;
        try {
            metadata = JpegMetadataReader.readMetadata(jpegFile);
            Iterator<Directory> it = metadata.getDirectories().iterator();
            while (it.hasNext()) {
                Directory exif = it.next();
                Iterator<Tag> tags = exif.getTags().iterator();
                while (tags.hasNext()) {
                    Tag tag = (Tag) tags.next();
                    System.out.println(tag);
                }
            }
        } catch (JpegProcessingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 解析res/drawable下图片的另一种方式

``` Java
if (width == 540) {
    path = "/res/drawable-960x540/paillette_" + pailletteIndex + ".png";
} else if(width == 480) {
    path = "/res/drawable-800x480/paillette_" + pailletteIndex + ".png";
} else if(width == 720) {
    path = "/res/drawable-1280x720/paillette_" + pailletteIndex + ".png";
} else {
    path = "/res/drawable/paillette_" + pailletteIndex + ".png";
}
paillette_array[0] = BitmapFactory.decodeStream(getClass().getResourceAsStream(path));
```

## 通过代码动态设置view的selector

``` Java
private StateListDrawable getStateDrawable(Context context, int normalId, int focusedId, int pressedId) {
    StateListDrawable stateListDrawable = new StateListDrawable();
    Drawable normalDrawable = normalId == -1 ? null : context.getResources().getDrawable(normalId);
    Drawable focusedDrawable = focusedId == -1 ? null : context.getResources().getDrawable(focusedId);
    Drawable pressedDrawable = pressedId == -1 ? null : context.getResources().getDrawable(pressedId);
    stateListDrawable.addState(new int[] { android.R.attr.state_enabled, android.R.attr.state_focused }, focusedDrawable);
    stateListDrawable.addState(new int[] { android.R.attr.state_enabled, android.R.attr.state_pressed }, pressedDrawable);
    stateListDrawable.addState(new int[] { android.R.attr.state_focused }, focusedDrawable);
    stateListDrawable.addState(new int[] { android.R.attr.state_pressed }, pressedDrawable);
    stateListDrawable.addState(new int[] { android.R.attr.state_enabled }, normalDrawable);
    stateListDrawable.addState(new int[] {}, normalDrawable);
    return stateListDrawable;
}

//使用方法
btn_state.setBackground(getStateDrawable(mContext, R.drawable.dialog_button_normal, R.drawable.dialog_button_focused, R.drawable.dialog_button_pressed));
```

## 模拟鼠标点击？？？？

## 模拟鼠标长按？？？？

``` Java
//frameworks/base/test-runner/src/android/test/TouchUtils.java
public static void longClickView(InstrumentationTestCase test, View v) {
    int[] xy = new int[2];
    v.getLocationOnScreen(xy);
    
    final int viewWidth = v.getWidth();
    final int viewHeight = v.getHeight();
    
    final float x = xy[0] + (viewWidth / 2.0f);
    float y = xy[1] + (viewHeight / 2.0f);
    
    Instrumentation inst = test.getInstrumentation();

    long downTime = SystemClock.uptimeMillis();
    long eventTime = SystemClock.uptimeMillis();

    MotionEvent event = MotionEvent.obtain(downTime, eventTime, MotionEvent.ACTION_DOWN, x, y, 0);
    inst.sendPointerSync(event);
    inst.waitForIdleSync();

    eventTime = SystemClock.uptimeMillis();
    final int touchSlop = ViewConfiguration.get(v.getContext()).getScaledTouchSlop();
    event = MotionEvent.obtain(downTime, eventTime, MotionEvent.ACTION_MOVE, x + touchSlop / 2, y + touchSlop / 2, 0);
    inst.sendPointerSync(event);
    inst.waitForIdleSync();
    
    try {
        Thread.sleep((long)(ViewConfiguration.getLongPressTimeout() * 1.5f));
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    eventTime = SystemClock.uptimeMillis();
    event = MotionEvent.obtain(downTime, eventTime, MotionEvent.ACTION_UP, x, y, 0);
    inst.sendPointerSync(event);
    inst.waitForIdleSync();
}
```

## 模拟滑动？？？？

## 模拟按键事件？？？？

``` Java
//方法a
new EditText(context).onKeyDown(keyCode, new KeyEvent(KeyEvent.ACTION_DOWN, keyCode));    //模拟按键的点击事件,这里必须需要一个EditText才可以

//方法b, 这个也可以通过命令行发送    adb shell input keyevent 82
Process process = Runtime.getRuntime().exec("input keyevent 82");                        //模拟按键的点击事件,82相当于上面的keyCode

//方法c
Instrumentation instrumentation = new Instrumentation();
instrumentation.sendKeyDownUpSync(KeyEvent.KEYCODE_MENU);

//方法d
Instrumentation instrumentation = new Instrumentation();
instrumentation.sendKeySync(new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_MENU));
instrumentation.sendKeySync(new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_MENU));
```

## 通过反射修改全局默认字体

``` Java
private final static String CUSTOM_FONT = "fonts/custom_font.ttf";
public static void changeDefaultFont(Context ctx){
    try{
        Typeface typeface = Typeface.createFromAsset(cts.getAssets(), CUSTOM_FONT);
        Field defaultField = Typeface.class.getDeclaredField("SERIF");
        defaultField.setAccessible(true);
        defaultField.set(null, typeface);
    }catch(Exception e){
        e.printStackTrace();
    }
}
```

## 通过反射获取FeatureOption中的所有字段的值

``` Java
private String getFields() {
    StringBuilder builder = new StringBuilder();
    try {
        //通过反射可以获取 FeatureOption.java文件中定义的所有的宏还有宏的值
        Class clazz = Class.forName("com.mediatek.common.featureoption.FeatureOption");
        Field[] fields = clazz.getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            if ("boolean".equalsIgnoreCase(fields[i].getType().getName())) {
                Log.e("test", fields[i].getName() + ":" + fields[i].getBoolean(clazz));
                builder.append(fields[i].getName() + ":" + fields[i].getBoolean(clazz) + "\n");
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return builder.toString();
}
```

## 通过反射设置EditText的游标颜色

``` Java
private void setTextCursorColor(TextView et, int color){
    try {
        java.lang.reflect.Field fCursorDrawableRes = TextView.class.getDeclaredField("mCursorDrawableRes");
        fCursorDrawableRes.setAccessible(true);
        int mCursorDrawableRes = fCursorDrawableRes.getInt(et);
        java.lang.reflect.Field fEditor = TextView.class.getDeclaredField("mEditor");
        fEditor.setAccessible(true);
        Object editor = fEditor.get(et);
        Class<?> clazz = editor.getClass();
        java.lang.reflect.Field fCursorDrawable = clazz.getDeclaredField("mCursorDrawable");
        fCursorDrawable.setAccessible(true);
        android.graphics.drawable.Drawable[] drawables = new android.graphics.drawable.Drawable[1];
        drawables[0] = et.getContext().getResources().getDrawable(mCursorDrawableRes);
        drawables[0].setColorFilter(color, android.graphics.PorterDuff.Mode.SRC_IN);
        fCursorDrawable.set(editor, drawables);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

## Launcher上长按下键RecyclerView乱跳的问题

``` Java
@Override
public View onInterceptFocusSearch(View focused, int direction) {
    int currentPosition = getPosition(getFocusedChild());
    int count = getItemCount();
    int lastVisiblePosition = findLastVisibleItemPosition();
    switch (direction) {
        case View.FOCUS_RIGHT:
            currentPosition++;
            break;
        case View.FOCUS_LEFT:
            currentPosition--;
            break;
        case View.FOCUS_DOWN:
            currentPosition += 3;
            break;
        case View.FOCUS_UP:
            break;
    }
    if (currentPosition < 0 || currentPosition>count) {
        return focused;
    } else {
        if (currentPosition > lastVisiblePosition) {
            scrollToPosition(currentPosition);
        }
    }
    return super.onInterceptFocusSearch(focused, direction);
}
```

---------------------------------- 17-3-20 ----------------------------------

## SRLauncher修改图片之后，部分图片不生效

在 Android.mk 文件中看到有 LOCAL_USE_AAPT2 := true　，说明是用AAPT2来编译链接资源的，把这个去掉用aapt去编译即可
因为 AAPT2 不会重新编译生成 SRLauncher_intermediates，而 AAPT 就会重新生成

The main idea behind AAPT2, apart from new features, is that it divides the 'package' step into two: 'compile' and 'link'. It improves performance, since if only one file changes, you only need to recompile that one file and link all the intermediate files with the 'link' command.

https://fucknmb.com/2018/10/05/%E5%86%8D%E8%B0%88aapt2%E8%B5%84%E6%BA%90%E5%88%86%E5%8C%BA/

## tint 着色器的原理和使用方法

http://yifeng.studio/2017/03/30/android-tint/

``` Java
mMessageListItem.setBackgroundTintList(android.content.res.ColorStateList.valueOf(0x00000000));
```

## Android 利用 activity-alias 动态改变 App 桌面图标

http://yifeng.studio/2016/12/30/android-change-app-launcher-icon-dynamically/

## 单例模板

``` Java
private volatile static $classname$ instance;
public static $classname$ getInstance() {
    if (instance == null) {
        synchronized ($classname$.class) {
            if (instance == null) {
                instance = new $classname$();
            }
        }
    }
    return instance;
}
```

## 防止内存泄漏的Handler模板

``` Java
private static class OkHandler extends android.os.Handler {
    private java.lang.ref.WeakReference<$classname$> activityWeakReference;
    public OkHandler($classname$ activity) {
        activityWeakReference = new java.lang.ref.WeakReference<$classname$>(activity);
    }
    @Override
    public void handleMessage(android.os.Message msg) {
        $classname$ activity = activityWeakReference.get();
        if (activity != null) {

        }
    }
}
```

## PID的获取方法

``` Java
//方法1
Binder.getCallingPid()

//方法2
android.os.Process.myPid();
```

## 通过pid获取app包名

``` Java
String callerPackage = getAppNameByPID(getContext(), Binder.getCallingPid());

private String getAppName(int pID) {
    String processName = "";
    ActivityManager am = (ActivityManager)this.getSystemService(ACTIVITY_SERVICE);
    List l = am.getRunningAppProcesses();
    Iterator i = l.iterator();
    PackageManager pm = this.getPackageManager();
    while(i.hasNext()) {
        ActivityManager.RunningAppProcessInfo info = (ActivityManager.RunningAppProcessInfo)(i.next());
        try {
            if(info.pid == pID) {
                CharSequence c = pm.getApplicationLabel(pm.getApplicationInfo(info.processName, PackageManager.GET_META_DATA));
                processName = info.processName;
            }
        } catch(Exception e) {
        }
    }
    return processName;
}
```

## 获取电池电量

``` Java
android.os.BatteryManager batteryManager = (android.os.BatteryManager)getSystemService("batterymanager");
int battery = batteryManager.getIntProperty(4);//BATTERY_PROPERTY_CAPACITY = 4
```

## TAG模板

``` Java
private static final String TAG = $className$.class.getSimpleName();
```

## 文字设置高对比度 HighContrastText

``` Java
View.java
canvas.setHighContrastText(mAttachInfo.mHighContrastText);
```

## 通过代码修改字体颜色的另外一种方法

``` Java
setSpan(new ForegroundColorSpan(android.graphics.Color.parseColor("#0096ff")), before, buf.length(), Spannable.SPAN_INCLUSIVE_EXCLUSIVE);
```

## 39Ogo默认壁纸(其他的一些属性也会在 device/mediatek/common/overlay/ago/ 目录下overlay)

```
device/mediatek/common/overlay/ago/frameworks/base/core/res/res/drawable-nodpi/default_wallpaper.jpg
```

## TextView设置跑马灯效果

``` Java
1.首先控件必须是focused或selected的
2.不能设置spannable，不能是editable的
android:ellipsize="marquee"
android:singleLine="true"
android:lines="1"
android:maxLines="1"
```

## TextView设置为大字体的时候wrap_content还是不能显示完全

https://blog.csdn.net/HJF_HUANGJINFU/article/details/79813172

``` Java
TextView textView = new Text(context);
textView.setText("hello world");
textView.requestLayout();   //在setText()之后主动条用requestLayout();
```

## 修改WebView的字体大小

``` Java
webSettings.setTextZoom(textZoom);
```

## 在symbols.xml文件中添加了资源之后

需要先编译 frameworks/base/core/res
再编译 frameworks/base
再编译对应模块即可 MtkSettings

## Android WebView 禁止缩放（手势、点击）

``` Java
webSettings.setBuiltInZoomControls(false);
webSettings.setSupportZoom(false);
webSettings.setDisplayZoomControls(false);
```

## system/priv-app 和 system/app 的区别

在system/priv-app目录主要是存放手机厂商定制的系统的系统级应用，比如phone app,settings app，systemui app等，这些应用需要系统及权限，而又不能被用户卸载掉。这个目录是在Android KitKat新增加的分区。在KitKat之前版本在系统分区的所有apks都可以使用系统权限，这个更改使手机厂商能够更好的控制捆绑软件对敏感权限的访问。手机厂商在定制一些系统软件的时候软件也会需要专门给priv-app添加selinux policy。当然应用需要获取系统权限还有其他的办法，在AndroidManifest.xml文件中添加 android:sharedUserId="android.uid.sysytem",同时给该apk添加系统签名，比如小米手机就需要给apk添加小米的系统权限。

## 壁纸设置流程
https://blog.csdn.net/lj527409/article/details/79825015

## Android Button有默认padding值的元凶！！！
https://blog.csdn.net/vv_bug/article/details/71698200
把padding设置为0还是有边距的原因？theme中默认把minHeight设置为56dp
所以需要把minHeight先改为0dp


## 连续插拔usb播放音效之后不会播放
01-03 08:49:11.478   431  1506 E AudioFlinger: not enough memory for AudioTrack size=65760
01-03 08:49:11.479   431  1506 E AudioFlinger_Threads: createTrack_l() initCheck failed -12; no control block?
01-03 08:49:11.479   440  3271 E AudioTrack: AudioFlinger could not create track, status: -12
01-03 08:49:11.480   440  3271 E AudioSink: Unable to create audio track
01-03 08:49:11.480   440  3271 W NuPlayerRenderer: openAudioSink: non offloaded open failed status: -19
01-03 08:49:11.480   440  3271 W NuPlayerRenderer: onDrainAudioQueue(): audio sink is not ready
01-03 08:49:11.480   440  3272 E NuPlayerDecoder: Renderer reported 0xffffffed when changing audio output format
01-03 08:49:11.480   440  3271 W NuPlayerRenderer: onDrainAudioQueue(): audio sink is not ready
01-03 08:49:11.480   440  3268 E NuPlayer: received error(0xffffffed) from audio decoder, flushing(0), now shutting down
01-03 08:49:11.481  1131  1383 E MediaPlayerNative: error (1, -19)
01-03 08:49:11.483  1131  1131 E MediaPlayer: Error (1,-19)
01-03 08:49:11.485  1013  1118 I AudioService: setForceUse(FOR_MEDIA, FORCE_NO_BT_A2DP) due to setBluetoothA2dpOn(false) from u/pid:1000/1013

可能是播放铃声之后没有及时释放导致内存泄漏
https://github.com/google/ExoPlayer/issues/954

Ringtone ringtone;
ringtone.play();
什么时候释放比较好呢？

最终是因为对应的音频文件没有编译进去导致的

## 模拟高温报警命令

``` bash
adb shell "echo 55 > /sys/devices/platform/battery/Battery_Temperature"
```

## 高温报警代码中修改字符串不起效果

查看 alps/vendor/mediatek/proprietary/packages/apps/BatteryWarning/Android.mk 文件发现有两种编译方式，一种是把编译好的apk直接编译到系统中，另外一种是通过源码编译apk

``` Makefile
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

MY_BUILD_PORTABLE := yes        # 这里默认是 yes，所以

ifeq ($(strip $(MY_BUILD_PORTABLE)),yes)
# Module name should match apk name to be installed
LOCAL_MODULE := BatteryWarning
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE)-release-unsigned.apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_CERTIFICATE := platform

LOCAL_PROPRIETARY_MODULE := false
LOCAL_MODULE_OWNER := mtk
include $(BUILD_PREBUILT)
else
LOCAL_JAVA_LIBRARIES := bouncycastle

LOCAL_MODULE_TAGS := optional

LOCAL_SRC_FILES := $(call all-java-files-under, src)

LOCAL_PACKAGE_NAME := BatteryWarning
LOCAL_PROPRIETARY_MODULE := false
LOCAL_MODULE_OWNER := mtk
LOCAL_CERTIFICATE := platform

include $(BUILD_PACKAGE)
endif

# Use the following include to make our test apk.
include $(call all-makefiles-under,$(LOCAL_PATH))
```

这里的 MY_BUILD_PORTABLE 默认为 yes，所以会默认编译已经编译好的apk，所以怎么修改字符串都不会起作用

修改方案：
MY_BUILD_PORTABLE 修改为 no 即可

## 通过 adb 抓取 radio log

``` bash
查看包含在无线/电话相关的缓冲区消息
adb logcat -b radio | grep "zq7777"

查看事件相关的消息
adb logcat -b events

查看主缓冲区 (默认缓冲区)
adb logcat -b main

adb logcat 的用法
https://developer.android.com/studio/command-line/logcat?hl=zh-cn
```

## 修改默认浏览器搜索引擎为google

https://blog.csdn.net/wobushizhainan/article/details/79872757

修改方案:
把如下文件中的 google 移动到最上面第一条即可
M:alps/vendor/mediatek/proprietary/frameworks/base/res/res/values*/donottranslate-new-search_engines.xml
``` xml
<resources xmlns:xliff="urn:oasis:names:tc:xliff:document:1.2">
    <string-array name="new_search_engines" translatable="false">
        <item>--</item>
        <item>google--Google--google.com--search_engine_google--http://www.google.com/m?hl={language}&amp;ie={inputEncoding}&amp;source=android-browser&amp;q={searchTerms}--UTF-8--http://www.google.com/complete/search?hl={language}&amp;json=true&amp;q={searchTerms}</item>
        <item>start--Start--mt.start.fyi--search_engine_other--http://mt.start.fyi/search?ie={inputEncoding}&amp;source=browser#gsc.q={searchTerms}--UTF-8--http://www.google.com/complete/search?hl={language}&amp;json= true&amp;q={searchTerms}</item>
        <item>yahoo--Yahoo!--yahoo.com--search_engine_yahoo--https://search.yahoo.com/search?ei={inputEncoding}&amp;.tsrc=mtkandroid&amp;p={searchTerms}--UTF-8--http://sugg.search.yahoo.com/gossip/?output=fxjson&amp;command={searchTerms}</item>
        <item>bing--Bing--bing.com--search_engine_bing--http://www.bing.com/search?q={searchTerms}--UTF-8--http://api.bing.com/osjson.aspx?query={searchTerms}&amp;language={language}</item>
    </string-array>
</resources>
```

## 8.0O版本上默认打开数据连接

http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commitdiff;h=c0729839d0b3a73c3b67e58d1f4cd20f3068e446;hp=2991172ce00d8c7b979b2cf405f2a8fe417be2e2

## 操作excel的类库

POI
http://poi.apache.org/download.html

## 修改信号log的抓取

修改：
vendor/mediatek/proprietary/hardware/ril/fusion/mtk-ril/mdcomm/nw/RmcNetworkHandler.cpp
的 updateSignalStrengthProperty() 方法中有
编译：
./mk -ud DFC0270_VF292_7030_DORO_S01A mm vendor/mediatek/proprietary/hardware/ril/fusion/mtk-ril/
adb root;adb remount;
adb push out/target/product/k39tv1_bsp_512/vendor/lib/libmtk-ril.so vendor/lib/;
push之后需要重启
adb reboot;

## 信号强度
在Android手机上，通过“设置”-“关于手机”-“状态”-“信号强度”可以查看到手机的信号强度，显示出如“-87 dBm 13 asu”这样的数据。ASU与dBm之间的关系是：dBm=-113+（2*ASU）。在你手机屏幕上方显示的信号条永远不会是最好的方法来确定你手机的信号，无论你用什么手机都一样。Android也是，用很粗的条来展示很强的信号，但这些条仅仅表示最高的信号。或许你并不熟悉，信号通常是以dBm度量的。dBm是每毫瓦特的电磁波产生的功率。-60dBm的信号接近完美，-112dBm就很容易掉线，如果你在 -87dBm以上，Android会显示一个4格的满信号。android界面UI信号显示是通过RIL对通讯模块发送AT命令来实现的，如AT+CSQ，我们查看一般可以通过 logcat -b radio来获取一些RIL的实时信息，可以通过关键字“CSQ”查找radio.log，查看手机信号强度。log如：AT< +CSQ: 14,99  这里的14就是ASU值，在4.0源码中有SignalStrength.Java类，其中有ASU值转换为几格信号的方法

## 修改 TextView 的省略号

``` Java
- effectiveEllipsize = TruncateAt.END_SMALL;
+ effectiveEllipsize = TruncateAt.END;
```

## adb直接打开某个网页进行浏览

``` bash
adb shell am start -a android.intent.action.VIEW -d http://www.baidu.com
```

## ota 升级之后没有走 DatabaseHelper.java 中的 onUpgrade() 方法

o上走的是 SettingsProvider.java 中的 onUpgradeLocked() 方法

## APN相关

https://blog.csdn.net/u012686462/article/details/55213023

## framework下字体文件的修改

``` Java
1.将需要添加的ttf字体文件放在 frameworks/base/data/fonts/ 目录

A:frameworks/base/data/fonts/hiosClock_thin.ttf

2.修改 frameworks/base/data/fonts/Android.mk 文件,将字体文件编译到 system/fonts/ 目录中

M:frameworks/base/data/fonts/Android.mk
#Redmine124982 modified for clock widget font 2018/03/23:begin
font_src_files := \
    AndroidClock.ttf \
    hiosClock_thin.ttf
#Redmine124982 modified for clock widget font 2018/03/23:end

3.修改 frameworks/base/data/fonts/fonts.mk 文件

M:frameworks/base/data/fonts/fonts.mk
#Redmine124982 modified for clock widget font 2018/03/23:begin
PRODUCT_PACKAGES := \
    DroidSansMono.ttf \
    AndroidClock.ttf \
    hiosClock_thin.ttf \
    fonts.xml
#Redmine124982 modified for clock widget font 2018/03/23:end

4.在 fonts.xml 文件中定义字体对应的名称

M:frameworks/base/data/fonts/fonts.xml
<!--Redmine124982 modified for clock widget font 2018/03/23:begin-->
<family name="tecno-clock-font">
    <font weight="400" style="normal">hiosClock_thin.ttf</font>
</family>
<!--Redmine124982 modified for clock widget font 2018/03/23:end-->

5.使用新添加的字体

方法1:
TextView textView = new TextView(mContext);
textView.setTypeface(android.graphics.Typeface.createFromFile("/system/fonts/hiosClock_thin.ttf"));

方法2:
<TextView
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:fontFamily="tecno-clock-font" />

6.在项目中的具体使用实例----Bug124982 修改桌面时钟widget的字体

M:alps/frameworks/base/core/java/android/widget/RemoteViews.java
public class RemoteViews implements Parcelable, Filter {
    ...
    private class TextViewSizeAction extends Action {
        ...
        @Override
        public void apply(View root, ViewGroup rootParent, OnClickHandler handler) {
            final TextView target = root.findViewById(viewId);
            if (target == null) return;

            //通过特殊约定的参数(如77,0)来特殊设置TextView的字体
            if(units == -77 && size == 0f){
                target.setTypeface(android.graphics.Typeface.createFromFile("/system/fonts/hiosClock_thin.ttf"));
            }else{
                target.setTextSize(units, size);
            }
        }
        ...
    }
    ...
}

M:alps/vendor/mediatek/proprietary/packages/apps/DeskClock/src/com/android/alarmclock/DigitalAppWidgetProvider.java
public class DigitalAppWidgetProvider extends AppWidgetProvider {
    private static RemoteViews relayoutWidget(Context context, AppWidgetManager wm, int widgetId, Bundle options, boolean portrait) {
        final String packageName = context.getPackageName();
        final RemoteViews rv = new RemoteViews(packageName, R.layout.digital_widget);
        //通过特殊约定的参数(如77,0)来特殊设置TextView的字体,这里调用setTextViewTextSize方法就会调用RemoteViews的内部类TextViewSizeAction的apply方法
        rv.setTextViewTextSize(R.id.clock, -77, 0f);
        ...
    }
    ...
}
```

## 使用framework下隐藏的api

在 Android.mk 文件中添加 LOCAL_JAVA_LIBRARIES := framework 即可

## 监听 SharePreference 的变化

``` Java
SharedPreferences sp1 = getSharedPreferences(getPackageName() + "test", MODE_PRIVATE);
sp1.registerOnSharedPreferenceChangeListener(new SharedPreferences.OnSharedPreferenceChangeListener() { 
    @Override 
    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
    }
});
```

## 通过监听布局变化来获取view的高度和宽度

``` Java
private int mViewHeight;
private View mView;
...
//注册监听
mView.getViewTreeObserver().addOnGlobalLayoutListener(
    new OnGlobalLayoutListener() {
        @Override
        public void onGlobalLayout() {
            //获取View高度
            mViewHeight = mView.getHeight();
            //取消监听，否则该方法会不断回调
            mView.getViewTreeObserver().removeGlobalLayoutListener(this);
        }
    }
)
```

## TextView各种padding解析、长度测量

https://www.jianshu.com/p/fd9cce7a333f

## View.post()原理

https://www.jianshu.com/p/85fc4decc947

## Android KeyEvent 点击事件分发处理流程（一）

https://www.jianshu.com/p/2f28386706a0

## 查看方法的调用栈

``` Java
RuntimeException here = new RuntimeException("bolex");
here.fillInStackTrace();
Log.w("myTag", "Called: " + this, here);
```

## [FAQ06189] 插国外SIM卡，第一次开机语言没有自适应

问题描述：在有些国家进行场测时，插该国SIM卡（比如俄罗斯），首次开机语言自适应结果是英文，应该变成俄语。而使用中国SIM卡测试该功能时正常的。
问题原因：语言自适应需要通过利用SIM卡MCC信息查表来实现，而此表内容对于每个国家并不一样，有些国家没有默认语言，只有较少国家有默认语言。
解决方案：补充该表，使每个国家都有默认语言。
``` Java
frameworks\base\telephony\java\com\android\internal\telephony\MccTable.java
table = new ArrayList<MccEntry>(240);
table.add(new MccEntry(202,"gr",2,"el"));//Greece
```

## 读取图片信息

``` Java
package com.test;
import java.io.File;
import java.io.IOException;
import java.util.Iterator;
import com.drew.imaging.jpeg.JpegMetadataReader;
import com.drew.imaging.jpeg.JpegProcessingException;
import com.drew.metadata.Directory;
import com.drew.metadata.Metadata;
import com.drew.metadata.Tag;

public class ReadPic {
    /** 导入标签，使用metadata-extractor */
    public static void main(String[] args) {
        readPic();
    }
    /** 处理 单张 图片 */
    private static void readPic() {
        File jpegFile = new File("d:\\002.jpg");
        Metadata metadata;
        try {
            metadata = JpegMetadataReader.readMetadata(jpegFile);
            Iterator<Directory> it = metadata.getDirectories().iterator();
            while (it.hasNext()) {
                Directory exif = it.next();
                Iterator<Tag> tags = exif.getTags().iterator();
                while (tags.hasNext()) {
                    Tag tag = (Tag) tags.next();
                    System.out.println(tag);

                }
            }
        } catch (JpegProcessingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 如何设置MTKlogger是否开机自启动

``` Java
1. 第一次开机MTKlogger是否开启

1) 配置prop文件:   true则开启，false则关闭 
com.mediatek.log.mobile.enabled = true/false
com.mediatek.log.modem.enabled = true/false
com.mediatek.log.net.enabled = true/false
com.mediatek.log.gps.enabled = true/false

2) prop文件路径
KK版本: alps/mediatek/external/xlog/tools/mtklog-config-eng.prop或mtklog-config-user.prop
L 版本:  alps/vendor/mediatek/proprietary/external/xlog/tools/mtklog-config-eng.prop或mtklog-config-user.prop
M/N版本:  alps/device/mediatek/common/mtklog/mtklog-config-bsp-eng.prop或mtklog-config-bsp-user.prop

2. 非第一次开机是否开启的配置方法有如下两种

1) 勾选Start Automatically进行设置
MTKlogger UI——》Settings——》MobileLog/ModemLog/NetworkLog/GPSLog——》Start Automatically

2) 通过adb发送广播设置
adb shell am broadcast -a com.mediatek.mtklogger.ADB_CMD -e cmd_name set_auto_start_1/set_auto_start_0 --ei   cmd_target 23
set_auto_start_1表示开启开机自启动, set_auto_start_0表示关闭开机自启动
cmd_target is a combination or just a single of each Log type
MobileLog: 1 ModemLog: 2 NetworkLog: 4 GPSLog: 16
```

## 编译优化：去掉编译java的时候生成的javadoc

``` Java
android2.3 以前
修改如下：
build/tools/droiddoc/src/DroidDoc.java
private static boolean generateDocs = false;

android4.0 以后
修改如下：
external/doclava/src/com/google/doclava/Doclava.java
private static boolean generateDocs = false;
```

## java使用代理访问网络

``` Java
使用代码的方式：
String proxyHost = "127.0.0.1";
String proxyPort = "1080";

System.setProperty("http.proxyHost", proxyHost);
System.setProperty("http.proxyPort", proxyPort);

System.setProperty("https.proxyHost", proxyHost);
System.setProperty("https.proxyPort", proxyPort);

使用参数的方式：
-Dhttp.proxyHost=127.0.0.1 -Dhttp.proxyPort=1080 -Dhttps.proxyHost=127.0.0.1 -Dhttps.proxyPort=1080
```

## AsyncTask和Thread的使用场景

``` Java
AsyncTask 的使用场景
不需要下载大量数据的简单网络操作
I/O 密集型任务，耗时可能几个毫秒以上

Java Thread 使用场景
涉及中等或大量的网络数据操作（包括上传和下载）
需要在后台执行的 CPU 密集型任务
当你想要在 UI 线程控制 CPU 占用率时

还有一个老生常谈的问题就是，千万不要在 UI 线程（主线程）执行网络操作。你需要使用上述两种方式之一来访问网络。
```

## 性能优化

``` Java
根据 SystemServer.java 中的代码去掉一些不用的feature和service
去掉 init.rc 中启动的一些不需要的服务
媒体播放：预留给视频解码器可以去掉，操作系统看不到
界面：硬件拉伸缓存，芯片厂商SDK配置，操作系统可见
Java堆大小全局配置，堆调小。
JVM预加载jar包，可以不加载部分不用的jar包
swap分区在内存不足的情况下，擦写频繁对flash压力大
内存裁剪：不用的驱动通过menuconfig裁掉
socket缓存调小，默认256k，多个socket消耗更多内存
去掉一些不用的监听，ContentObserver
去掉一些广播和广播监听器


1、移除或修改Window默认的Background
2、移除XML布局文件中非必需的Background
3、按需显示占位背景图片
4、控制绘制区域

第一个建议：可以使用相对布局减少层级的就使用相对布局，否则使用线性布局。Android中RelativeLayout和LinearLayout性能分析，参考：www.jianshu.com/p/8a7d059da…
第二个建议：用merge标签来合并布局，这可以减少布局层次。
第三个建议：用include标签来重用布局，抽取通用的布局可以让布局的逻辑更清晰明了，但要避免include乱用。
第四个建议：避免创建不必要的布局层级。（最容易发生的！）
第五个建议：使用惰性控件ViewStub实现布局动态加载
```

## ROM优化

``` Java
开机动画换成更小的
精简 system/media/audio/ 下的铃声资源
system/tts
删除整个srec的内容，语音拨号相关的东西，从来不用
删除ttf字库文件
```

## adbkill 脚本

``` bash
adb shell kill `adb shell ps | grep $1 | awk {'print $2'} | head -n 1`;

or:
PID=`adb shell ps | grep $1 | awk '{print $2}'`
echo "adb shell kill $1 : $PID"
result=`adb shell kill $PID`
echo "$result"
```

## android 7.0 之后启动服务必须 startForegroundService()

``` bash
Prior to Android 8.0, the usual way to create a foreground service was to create a background service, then promote that service to the foreground. With Android 8.0, there is a complication; the system doesn't allow a background app to create a background service. For this reason, Android 8.0 introduces the new method startForegroundService() to start a new service in the foreground. After the system has created the service, the app has five seconds to call the service's startForeground() method to show the new service's user-visible notification. If the app does not call startForeground() within the time limit, the system stops the service and declares the app to be ANR.
```

## 签名问题:如何在L上use release key？

https://online.mediatek.com/FAQ#/SW/FAQ13817

## 查看apk签名？？

``` Java
jarsigner -verify -verbose -certs ${your_apk} > log.txt
```

## 设置 EditText 的游标颜色

``` Java
方法一、通过XML文件设置
TextView 有一个属性 android:textCursorDrawable，这个属性是用来控制光标颜色的
android:textCursorDrawable="@null"，"@null"作用是让光标颜色和text color一样

也可以自定义游标的颜色
cursor.xml
<shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape="rectangle">
    <size android:width="1dp" />
    <solid android:color="#008000" />
</shape>
android:textCursorDrawable="@drawable/cursor"

方法二、通过代码设置
遗憾的是 TextView 默认没有设置游标颜色的方法
在 TextView.java 中找到
    case com.android.internal.R.styleable.TextView_textCursorDrawable:
        mCursorDrawableRes = a.getResourceId(attr, 0);
        break;
int mCursorDrawableRes;     //这个值是不可以被直接访问的

于是就想到可以使用反射来设置游标的颜色
try {
    Field f = TextView.class.getDeclaredField("mCursorDrawableRes");
    f.setAccessible(true);
    f.set(editText, R.drawable.cursor_color);
} catch (Exception ignored) {
}

也可以使用如下封装好的方法
private void setTextCursorColor(TextView et, int color){
    try {
        java.lang.reflect.Field fCursorDrawableRes = TextView.class.getDeclaredField("mCursorDrawableRes");
        fCursorDrawableRes.setAccessible(true);
        int mCursorDrawableRes = fCursorDrawableRes.getInt(et);
        java.lang.reflect.Field fEditor = TextView.class.getDeclaredField("mEditor");
        fEditor.setAccessible(true);
        Object editor = fEditor.get(et);
        Class<?> clazz = editor.getClass();
        java.lang.reflect.Field fCursorDrawable = clazz.getDeclaredField("mCursorDrawable");
        fCursorDrawable.setAccessible(true);
        android.graphics.drawable.Drawable[] drawables = new android.graphics.drawable.Drawable[1];
        drawables[0] = et.getContext().getResources().getDrawable(mCursorDrawableRes);
        drawables[0].setColorFilter(color, android.graphics.PorterDuff.Mode.SRC_IN);
        fCursorDrawable.set(editor, drawables);
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```

## 联系人编辑界面上的号码输入框无法输入+号？

``` Java
问题分析：
可以参照拨号盘界面上的号码输入框的实现方法，通过跟踪代码发现长按0键之后会调用如下方法
packages/apps/Dialer/src/com/android/dialer/dialpad/DialpadFragment.java
public boolean onLongClick(View view) {
    ......
    case R.id.zero: {
        removePreviousDigitIfPossible();        //删除之前输入的 "0"
        keyPressed(KeyEvent.KEYCODE_PLUS);      //输入 "+"
        stopTone();
        mPressedDialpadKeys.remove(view);
        return true;
    }
    ......
}
private void removePreviousDigitIfPossible() {
    final Editable editable = mDigits.getText();
    final int currentPosition = mDigits.getSelectionStart();
    if (currentPosition > 0) {
        mDigits.setSelection(currentPosition);
        mDigits.getText().delete(currentPosition - 1, currentPosition);
    }
}
private void keyPressed(int keyCode) {
    ......
    mDigits.onKeyDown(keyCode, new KeyEvent(KeyEvent.ACTION_DOWN, keyCode));        //关键代码，重新发送 keycode 的 event 事件，模拟按键的输入
    final int length = mDigits.length();
    if (length == mDigits.getSelectionStart() && length == mDigits.getSelectionEnd()) {
        mDigits.setCursorVisible(false);
    }
    mDigits.setCursorVisible(true);
}

但是很遗憾，EditText默认没有 onKey 的长按监听事件，我们需要自己重写EditText，添加 onKey 的长按监听事件

public class DigitsEditText extends EditText {
    public DigitsEditText(Context context) {
        super(context);
        setInputType(getInputType() | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
        setShowSoftInputOnFocus(false);
    }
    public DigitsEditText(Context context, AttributeSet attrs) {
        super(context, attrs);
        setInputType(getInputType() | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
        setShowSoftInputOnFocus(false);
    }
    @Override
    public boolean dispatchKeyEvent(KeyEvent event) {
        if(event.getRepeatCount() > 0 && lockLongPressKey){
            if(KeyEvent.KEYCODE_0 <= event.getKeyCode() && event.getKeyCode() <= KeyEvent.KEYCODE_9){
                return true;
            }else if(KeyEvent.KEYCODE_STAR == event.getKeyCode()){
                return true;
            }else if(KeyEvent.KEYCODE_POUND == event.getKeyCode()){
                return true;
            }
        }
        return super.dispatchKeyEvent(event);
    }
    private boolean lockLongPressKey = false;
    private final static int MSG_LONG_CLICK = 777;
    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if(event.getRepeatCount() > 0 && !lockLongPressKey){
            event.startTracking();
            lockLongPressKey = true;
            Message msg = new Message();
            msg.what = MSG_LONG_CLICK;
            msg.arg1 = keyCode;
            handler.sendMessageDelayed(msg, 500);
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }
    private Handler handler = new Handler(){
        public void handleMessage(Message msg){
            if(msg.what == MSG_LONG_CLICK){
                if(mOnKeyLongClickListener != null){
                    mOnKeyLongClickListener.onKeyLongClick(msg.arg1);
                }
            }
        }
    };
    public interface OnKeyLongClickListener{
        public void onKeyLongClick(int keyCode);
    }
    private OnKeyLongClickListener mOnKeyLongClickListener;
    public void setOnKeyLongClickListener(OnKeyLongClickListener onKeyLongClickListener){
        mOnKeyLongClickListener = onKeyLongClickListener;
    }
    @Override
    public boolean onKeyUp(int keyCode, KeyEvent event) {
        if(lockLongPressKey){
            lockLongPressKey = false;
            handler.removeMessages(MSG_LONG_CLICK);
            return true;
        }
        return super.onKeyUp(keyCode, event);
    }
}

长按 onKey 方法的实现原理如下：
a. 在 onKeyDown() 的时候发送一个延时500ms的消息
b. 在 onKeyUp() 的时候移除这个消息，如果Handler接收到了这个消息，就处理长按事件，如果Handler没有接收到这个消息，就处理短按事件
```

## 在某些ListView界面点击按键的时候会显示搜索框？？

``` Java
listView.setTextFilterEnabled(false);
```

## 减慢按键输入速度

``` Java
public boolean onKeyDown(int keyCode, KeyEvent event) {
    if(event.getRepeatCount() % 3 != 0){    //添加了这段代码
        return true;
    }
}
```

## Launcher预置快捷方式shortcut

``` xml
launcher:uri 可以从 Launcher 数据库中获取

<shortcut
launcher:uri="#Intent;action=android.intent.action.MAIN;launchFlags=0x10200000;component=com.cleanmaster.mguard/com.cleanmaster.processcleaner.ProcessCleanerActivity;end"
launcher:icon="@drawable/ic_launcher_application"
launcher:title="@string/jinshan_title" 
launcher:screen=""
launcher:x=""
launcher:y=""/>
```

## 通过代码创建快捷方式

``` Java
private void createShortcut(String title, String url) {
    Intent intent = new Intent(INSTALL_SHORTCUT);
    intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, "Baidu");
    Intent shortcutIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));
    long urlHash = url.hashCode();
    long uniqueId = (urlHash << 32) | shortcutIntent.hashCode();
    shortcutIntent.putExtra("com.android.browser.application_id", Long.toString(uniqueId));
    intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
    intent.putExtra(Intent.EXTRA_SHORTCUT_ICON, BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher));
    sendBroadcast(intent);
}
```

## 设置 SeekBar 每一格的进度？

``` Java
mSlider.setKeyProgressIncrement(val);
```

## 隐藏AllApp中的应用图标？？

``` Java
public void reorderApps() {
    ......
    for(int i = mApps.size() - 1; i > 0 ; i--){
        AppInfo appInfo = mApps.get(i);
        if("com.google.android.gms".equalsIgnoreCase(appInfo.getPackageName())){
            mApps.remove(appInfo);
        }
    }
}
```

## 耳机模式下播放音乐再拍照，音乐会卡顿

``` Java
M:alps/frameworks/av/services/camera/libcameraservice/CameraService.cpp
//mp->setAudioStreamType(AUDIO_STREAM_ENFORCED_AUDIBLE);    //注释掉这一行就可以了

M:alps/vendor/mediatek/proprietary/packages/apps/Camera/src/com/mediatek/camera/util/CaptureSound.java
//AudioAttributes attrs = new AudioAttributes.Builder().setInternalLegacyStreamType(AudioManager.STREAM_SYSTEM_ENFORCED).build();//去掉STREAM_SYSTEM_ENFORCED
AudioAttributes attrs = new AudioAttributes.Builder().build();
case AUDIO_STREAM_ENFORCED_AUDIBLE:
    attr->flags  |= AUDIO_FLAG_AUDIBILITY_ENFORCED;
// intended fall through, attributes in common with STREAM_SYSTEM
```

## 查看手机中安装的所有apk的包名？？？

``` bash
adb shell pm -l
```

## 查看 Android 许可权限

``` bash
adb shell pm list permissions -d -g
```

## KK GMS无法通过网络定位？？

``` Java
https://onlinesso.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ11643
1.系统对提供LocationProvider的应用需要进行申明,而KK GMS将NetworkLocation应用的功能集成到了GmsCore（Google Play Service）中，所以需要添加GmsCore的packageName进去：
framework/base/core/res/res/values/config.xml
<string-array name="config_locationProviderPackageNames" translatable="false">
    <!-- The standard AOSP fused location provider -->
    <item>com.android.location.fused</item>
    <!-- MTK add for GMS -->
    <item>com.google.android.location</item>
    <item>com.google.android.gms</item>
    <!-- MTK add end -->
</string-array>

2.GMS4.4_r3（包含r3）之后版本在满足1条件下依然可能存在无法使用网络定位功能，请继续按照如下修改操作：
WifiStateMachine.java (frameworks\base\wifi\java\android\net\wifi)
private void setScanResults() {
    ...
    if (bssid != null) {
    String ssid = (wifiSsid != null) ? wifiSsid.toString() : WifiSsid.NONE;
    String key = bssid + ssid;
    tsf = SystemClock.elapsedRealtimeNanos()/1000;//add this line
    ScanResult scanResult = mScanResultCache.get(key);
    ...
}
```

## 如何判断是否支持VOLTE？？

``` Java
在如下文件中搜索 107(sfr)
ALPS-MP-N0.MP1-V1.0.2_SR6737T_65_N_modem/custom/service/nvram/custom_nvram_int_config.c
```

## android中图片的uri??

``` Java
"http://site.com/image.png" // from Web
"file:///mnt/sdcard/image.png" // from SD card
"file:///mnt/sdcard/video.mp4" // from SD card (video thumbnail)
"content://media/external/images/media/13" // from content provider
"content://media/external/video/media/13" // from content provider (video thumbnail)
"assets://image.png" // from assets
"drawable://" + R.drawable.img // from drawables (non-9patch images) //通常不用。
```

## 提高进程优先级的方法

``` Java
方法1：
找到这个进程对应的AndroidMannifest.xml文件，在其中添加属性『android:persistent="true"』， 这样可以将该进程设置为常驻内存进程，就可以降低被Kill的概率。以Acore进程为例， 在 /package/providers/ContactsProvider/AndroidMannifest.xml 文件中增加一行『android:persistent="true"』
具体修改示例如下：
android:label="@string/app_label"
android:icon="@drawable/app_icon"
android:allowBackup="false"
android:persistent="true" 

方法2： 
提高进程优先级 startForeground(1, new Notification()); 降低进程优先级 stopForeground(true); 
onStart() 方法中进行提高优先级操作，然后在onStop()方法中进行降低优先级操作
这个方法可以将对应AP的ADJ临时提高到2。
```

## [FAQ02683] 如何将一个app 设置为持久app, 不被low memory kill 关闭

```
1. 将app 的manifest.xml 中的 application 中添加属性 android:persistent="true"
2. 对这个APP 使用platform 的签名
3. 放置在system/app 下面
注: 一个app 被设置为 persistent 后，将很难被low memory kill 杀掉(oom_adj=-12)，请在设置之前仔细确认是否必须，否则将浪费掉memory。
```

## 去掉ID资源编译检查？？

``` Java
alps/vendor/mediatek/proprietary/framework/base/res/android.mk 文件中
#include #(LOCAL_PATH)/apicheck.mk
```

## 通过代码设置view的selector

``` Java
private StateListDrawable getStateDrawable(Context context, int normalId, int focusedId, int pressedId) {
    StateListDrawable stateListDrawable = new StateListDrawable();
    Drawable normalDrawable = normalId == -1 ? null : context.getResources().getDrawable(normalId);
    Drawable focusedDrawable = focusedId == -1 ? null : context.getResources().getDrawable(focusedId);
    Drawable pressedDrawable = pressedId == -1 ? null : context.getResources().getDrawable(pressedId);
    stateListDrawable.addState(new int[] { android.R.attr.state_enabled, android.R.attr.state_focused }, focusedDrawable);
    stateListDrawable.addState(new int[] { android.R.attr.state_enabled, android.R.attr.state_pressed }, pressedDrawable);
    stateListDrawable.addState(new int[] { android.R.attr.state_focused }, focusedDrawable);
    stateListDrawable.addState(new int[] { android.R.attr.state_pressed }, pressedDrawable);
    stateListDrawable.addState(new int[] { android.R.attr.state_enabled }, normalDrawable);
    stateListDrawable.addState(new int[] {}, normalDrawable);
    return stateListDrawable;
}

btn_state.setBackground(getStateDrawable(mContext, R.drawable.dialog_button_normal, R.drawable.dialog_button_focused, R.drawable.dialog_button_pressed));
```

## 通过代码删除一个字符

``` Java
mDigits.getText().delete(currentPosition - 1, currentPosition);
```

## adb 关机命令

``` bash
adb shell reboot -p
adb shell svc power shutdown
```

## adb shell input 的代码实现

``` Java
private void sendKeyCode(int paramInt1, int paramInt2) {
    long l = SystemClock.uptimeMillis();
    KeyEvent localKeyEvent = new KeyEvent(l, l, paramInt2, paramInt1, 0);
    try {
        IWindowManager.Stub.asInterface(ServiceManager.getService("window")).injectKeyEvent(localKeyEvent, true);
        return;
    } catch (RemoteException localRemoteException) {
    }
}

private void sendTouchKeyEvent(int paramInt, boolean paramBoolean1, boolean paramBoolean2) {
    if (paramBoolean2);
    try {
        this.mIWM.injectKeyEvent(new KeyEvent(this.now, SystemClock.uptimeMillis(), 1, paramInt, 0), paramBoolean1);
        return;
        //this.now = SystemClock.uptimeMillis();
        //this.mIWM.injectKeyEvent(new KeyEvent(this.now, this.now, 0, paramInt, 0), paramBoolean1);
    } catch (RemoteException localRemoteException) {
    }
}

private void sendTouchKeyEvent(int paramInt1, boolean paramBoolean1, boolean paramBoolean2, int paramInt2) {
    if (paramBoolean2);
    try {
        this.mIWM.injectKeyEvent(new KeyEvent(0L, 0L, 1, paramInt1, paramInt2), paramBoolean1);
        return;
        //this.mIWM.injectKeyEvent(new KeyEvent(this.now, 1100L + this.now, 0, paramInt1, paramInt2, 0, 0, 0, this.flag), paramBoolean1);
    } catch (RemoteException localRemoteException) {
        Log.i("input", localRemoteException.toString());
    }
}
```

## 状态栏上显示小时钟？？？

``` xml
<item
    android:id="@+id/clock"
    android:actionLayout="@layout/actionbar_layout_menu"
    android:showAsAction="always"
    android:title="时钟"/>

actionbar_layout_menu.xml
<AnalogClock xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content" >
</AnalogClock>
```

## FAQ15487 如何让Launcher3支持横屏显示？

``` Java
N/M：
Launcher默认支持横屏显示，只需要按如下操作即可开启横屏显示：
桌面空白处长按→进入OverviewMode→点击设置→打开允许旋转的开关
 
L：
1.修改AndroidManifest.xml
<activity
android:name="com.android.launcher3.Launcher"
android:launchMode="singleTask"
android:clearTaskOnLaunch="true"
android:stateNotNeeded="true"
android:theme="@style/Theme"
android:configChanges="mcc|mnc"
android:windowSoftInputMode="adjustPan"
android:screenOrientation="sensor"> <!--modify to sensor -->

2.修改Utilities.java的isRotationEnabled方法
public static boolean isRotationEnabled(Context c) {
    return true;//直接返回true
}

此时旋转手机，Launcher会横竖屏切换。但hotseat会显示在屏幕的右方。如果要让hotseat显示在屏幕底部，可以按照如下步骤操作：

3.修改res/values/config.xml
<!--hotseat --> 
<bool name="hotseat_transpose_layout_with_orientation">false</bool> <!--改为false-->

4.修改Hotseat.java的onFinishInflate方法
@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    LauncherAppState app = LauncherAppState.getInstance();
    DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
    mAllAppsButtonRank = grid.hotseatAllAppsRank;
    mContent = (CellLayout) findViewById(R.id.layout);
    if (grid.isLandscape && !grid.isLargeTablet()) {
        mContent.setGridSize((int) grid.numHotseatIcons, 1); //modify
    } else {
        mContent.setGridSize((int) grid.numHotseatIcons, 1);
    }
    mContent.setIsHotseat(true);
    Log.i(TAG, "onFinishInflate,(int) grid.numHotseatIcons: " + (int) grid.numHotseatIcons);
    resetLayout();
}
```

## 修改recovery界面的显示问题

1.修改 Makefile 中的 recovery 字体资源
M:alps/build/make/core/Makefile
-recovery_font := $(call include-path-for, recovery)/fonts/12x22.png
+recovery_font := $(call include-path-for, recovery)/fonts/8x14.png

2.添加 8*14 的资源
A:alps/bootable/recovery/fonts/8x14.png
A:alps/bootable/recovery/minui/font_8x14.h

3.添加 ldpi 分辨率的 recovery 动画资源
A:alps/bootable/recovery/res-ldpi/images/*

4.上传记录
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=97d43c37c7a211fd1e768c4ae1c93e3bf6f3ce18

## 根据霍尔器件的状态发送AT指令来控制 SAR 值功率是否回退

1.在 EngineerMode 中添加一个 ATService 来发送AT命令
``` Java
String cdmaSlotIdStr = SystemProperties.get("persist.radio.cdma_slot", "1");
int cdmaSlotId = Integer.parseInt(cdmaSlotIdStr) - 1;
Phone sarPhone = null;
if (TelephonyManager.getDefault().getPhoneCount() > 1) {
    try {
        sarPhone = PhoneFactory.getPhone(cdmaSlotId);
    } catch (Exception e) {
        return;
    }
} else {
    sarPhone = PhoneFactory.getDefaultPhone();
}
String[] sarStr = new String[2];
sarStr[0] = shutDown ? "AT+ERFIDX=1,0" : "AT+ERFIDX=1,1";    //对应的AT命令，盒盖的时候发送 AT+ERFIDX=1,0 回退功率，开盖的时候发送 AT+ERFIDX=1,1 不回退功率
sarStr[1] = "+ERFIDX";
if (sarPhone != null) {
    sarPhone.invokeOemRilRequestStrings(sarStr, mMessageHandler.obtainMessage(EVENT_AT_CMD));   //发送命令
}
```

2.在 PhoneWindowManager.java 中通过 AIDL 绑定 EngineerMode 中的 ATService

3.在 PhoneWindowManager.java 的 notifyLidSwitchChanged(long whenNanos, boolean lidOpen) 方法中的 lidOpen 就是霍尔器件的状态
``` Java
if (atService == null) {
    bindATService(mContext);
}
if (null != atService){
    try {
        atService.sendATCommand(lidOpen);
    } catch (RemoteException e) {
        e.printStackTrace();
    }
}
```

4.遇到的问题
a.为什么在 EngineerMode 中添加 ATService，而不是在别的应用中？

因为 Phone 这个类只能在 phone 进程中使用，而 EngineerMode 中有 android:sharedUserId="android.uid.phone"

b.开机第一次盒盖没有发送 AT 命令？

因为第一次绑定 ATService 的时候 phone 进程可能没有启动，绑定失败
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=518e1a0088cfb63c262926f69f537398da78a73e


c.开机第一次盒盖没有发送正确的 AT 命令

因为第一次绑定的时候需要一定的时间，绑定成功了之后实际的霍尔器件的状态已经发生了改变，通过一个局部变量 private int mLidOpenState = 0; 来保存第一次绑定时候的霍尔器件的状态
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=fb0b93a7cc02d2b4652859510ed58aefe6477a24

d.如何查看对应 AT 命令是否发送成功，是否发送正确？

adb logcat -b radio > log.txt
在 log 中搜索 ERFIDX 附近的 log, 如果有 OK 则表示已经发送成功

5.上传记录
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=54ba3a5018d97814ffe21bd9df4c5ca238baf3b9
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=c6e5472f36bdaea5230f48b3f5450ff1cdd2b64c
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=518e1a0088cfb63c262926f69f537398da78a73e
http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commit;h=fb0b93a7cc02d2b4652859510ed58aefe6477a24

## 按键无法输入#的问题

在 39go SmartFeaturePhone 平台一开始移植按键输入法的时候就没有把#键加到 alps/device/mediatek/mt6739/mtk-kpd.kcm 文件中
只是在添加了 SageRealIME 之后，这个问题被隐藏了。现在添加了 Kika 输入法之后，这个问题又被曝光了出来，修改方案如下:
M:alps/device/mediatek/mt6739/mtk-kpd.kcm
key POUND {
    label: '#'
    base: '#'
}

M:alps/frameworks/base/core/java/android/text/method/WordResource.java
this.put(KeyEvent.KEYCODE_POUND, "#");

## 在连续点击 * 键之后会卡在某些字符上一直切换大小写

因为在 MultiTapKeyListener.java 中有实现 * 键切换大小写的功能，代码如下：
``` Java
if (keyCode == KeyEvent.KEYCODE_STAR) {
    char current = content.charAt(selStart);
    if (Character.isLowerCase(current)) {
        content.replace(selStart, selEnd, String.valueOf(current).toUpperCase());   //切换为大写
        removeTimeouts(content);
        new Timeout(content); // for its side effects
        return true;
    }
    if (Character.isUpperCase(current)) {
        content.replace(selStart, selEnd, String.valueOf(current).toLowerCase());   //切换为小写
        removeTimeouts(content);
        new Timeout(content); // for its side effects
        return true;
    }
}
```

而在 WordResource.java 中有 private static String WORD_KEYCODE_STAR = "*+Δ¡¿£Φ\"¥ΓΛ¤ΩΠΨΣÇøΘΞØÄäÅåÆæàÉéèìÖöòÑñßÜüù§";
在遇到 Δ 的时候就会一直在切换大小写，无法切换后后面的字符

修改方案:
只需要去掉 MultiTapKeyListener.java 中点击 * 键切换大小写的功能即可

## 根据包名查看apk的安装路径

``` bash
adb shell pm path com.sagereal.launcher
```

## 39go无法打开 modemlog

M:sagereal/mk/VQ288_common/k39tv1_bsp_512.mk
MTK_DYNAMIC_CCB_BUFFER_GEAR_ID =

M:sagereal/mk/VQ288_common/ProjectConfig.mk
MTK_DYNAMIC_CCB_BUFFER_GEAR_ID =

## EngineerMode 中没有 batterylog

``` Java
private static final String[] KEY_REMOVE_ARRAY = {"de_sense", "display", "battery_log", //只需要去掉 battery_log 就不会消失了
```

## 通过 "Outline" tag 来控制View是否高对比度显示

``` Java
Object mViewTag = getTag();
if (mViewTag instanceof String) {
    String mViewTagStr = (String)mViewTag;
    if ("Outline".equalsIgnoreCase(mViewTagStr)) {
        canvas.setHighContrastText(true);   //设置高对比度显示
    }
}
```

## dumpsys 系统服务

``` bash
$ adb shell service list 列出所有系统服务 然后通过dumpsys media.camera 打印media.camera服务的信息
$ adb shell dumpsys meminfo 打印内存信息
$ adb shell dumpsys SurfaceFlinger 显示当前应用的包名
$ adb shell dumpsys activity
$ adb shell dumpsys cpuinfo CPU
$ adb shell dumpsys battery
$ adb shell dumpsys window（最后部分可以看到分辨率的信息） 有些service能够接收额外的参数，我们可以使用-h查看帮助信息。
$ adb shell dumpsys package -h
$ adb shell dumpsys activity -h
如adb shell dumpsys activity o 能够输出oom的值 adb shell dumpsys activity p 能够打印运行中的进程
```

## 39Go TPLink 中 FaceBook 图标显示白块

http://192.168.3.79:8084/gitweb?p=O1_MP1/alps-release-o1.mp1-default.git;a=commitdiff;h=24fd8a317d43a1c618a26a58101927139164c750
M:alps/frameworks/base/core/java/android/app/Notification.java
``` Java
private void processSmallIconColor(Icon smallIcon, RemoteViews contentView, boolean ambient) {
-            boolean colorable = !isLegacy() || getColorUtil().isGrayscaleIcon(mContext, smallIcon);
+            boolean colorable = getColorUtil().isGrayscaleIcon(mContext, smallIcon);
```

M:alps/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/ExpandableNotificationRow.java
``` Java
-        boolean colorize = !isPreL || NotificationUtils.isGrayscale(expandedIcon,
+        boolean colorize = NotificationUtils.isGrayscale(expandedIcon, NotificationColorUtil.getInstance(mContext));
```

M:alps/vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/statusbar/phone/NotificationIconAreaController.java
``` Java
-        boolean colorize = !isPreL || NotificationUtils.isGrayscale(v, mNotificationColorUtil);
+        boolean colorize = NotificationUtils.isGrayscale(v, mNotificationColorUtil);
```

## 强制修改 39Go TPLink 中安兔兔跑分中的参数

一开始的时候在 setText() 方法中作的修改，但是在最新的antutu中不管用了，反编译发现最新的antutu中不再使用 setText() 来设置字符串了，而是把字符串分割成了单个的字符再append()到TextView中，应该是发现有太多的厂商强行修改这些参数，然而这并难不倒我们，修改方法如下。
``` Java
public void append(CharSequence text, int start, int end) {
    if (!(mText instanceof Editable)) {
        setText(mText, BufferType.EDITABLE);
    }

    ((Editable) mText).append(text, start, end);

    //modified begin
    if (getContext() != null) {
        String packageName = getContext().getPackageName();
        if ("com.antutu.ABenchMark".equalsIgnoreCase(packageName)) {
            int textViewId = getContext().getResources().getIdentifier("item_hardware_text_desc", "id", "com.antutu.ABenchMark");
            if (textViewId == getId()) {
                String sizeStr = getContext().getResources().getString(getContext().getResources().getIdentifier("size_panel", "string", "com.antutu.ABenchMark"));
                if (mText.toString().contains(sizeStr)) {
                    mText = "5.45 " + sizeStr;
                    setText(mText);
                }
            }
        }
    }
    //modified end

    if (mAutoLinkMask != 0) {
        boolean linksWereAdded = Linkify.addLinks((Spannable) mText, mAutoLinkMask);
        // Do not change the movement method for text that support text selection as it
        // would prevent an arbitrary cursor displacement.
        if (linksWereAdded && mLinksClickable && !textCanBeSelected()) {
            setMovementMethod(LinkMovementMethod.getInstance());
        }
    }
}
```

## 查看文件夹占用磁盘空间大小

``` bash
du -h --max-depth=1
```

## 如何精简apk??

https://blog.csdn.net/u013176138/article/details/78894538
https://blog.csdn.net/xJ032w2j4cCjhOW8s8/article/details/80174800

1.使用proguard混淆，规则是什么样的呢？
    a. 修改该模块的Android.mk文件，添加如下内容：
    LOCAL_PROGUARD_ENABLED := custom
    LOCAL_PROGUARD_FLAG_FILES := proguard.flags

    b. 编写一个文本文件，将其命名为proguard.flags，并将该文件放到与该模块的Android.mk相同的目录下；该文件开头部分内容需要填写：
    -dontpreverify
    -dontoptimize
    -keepattributes *Annotation*
    该文件其余部分根据模块的内容填写即可，文件格式可参考Codebase中其他proguard.flags文件(Codebase中有很多proguard.flags文件)

2.优化图片资源，使用 webp 或 9.png 格式

3.去掉一些没必要的分辨率

## LCA项目，MTK_PRODUCT_LOCALES中"-sw600dp -sw720dp"的含义

LCA项目中，为给img瘦身，若MTK_PRODUCT_LOCALES中定义了"-sw600dp -sw720dp"，则在MTK_LCA_ROM_OPTIMIZE为yes，且MTK_TABLET_PLATFORM为no的前提情况下，那些为Tablet（大屏幕设备）准备的资源（含有sw600dp，sw720dp限定符的resource目录）将不会被build到apk中。
 
比如：
定义MTK_PRODUCT_LOCALES=zh_CN en_US zh_TW hdpi -sw600dp -sw720dp
假设某一app的res目录下，关于drawable，含有下面的资源目录：
drawable
drawable-hdpi
drawable-land-hdpi
drawable-land-mdpi
drawable-land-xhdpi
drawable-mdpi
drawable-nodpi
drawable-sw600dp-hdpi
drawable-sw600dp-mdpi
drawable-sw600dp-xhdpi
drawable-sw720dp-hdpi
drawable-sw720dp-mdpi
drawable-sw720dp-xhdpi
drawable-xhdpi

那么，最终编译过后，apk中将只含有下面这些目录：
drawable
drawable-hdpi
drawable-land-hdpi
drawable-nodpi

这样将大大减小img的大小，达到为project瘦身的目的。

aapt2 link 怎么使用 --preferred-density 参数？？？

device/mediatek/common/aapt_config.mk 中的参数好像不起作用？？

1. 在L0(android 5.0)及之前的AOSP版本：
在device\mediatek\$(proj_name)\full_$(proj_name).mk设置
PRODUCT_AAPT_CONFIG := hdpi xhdpi xxhdpi 
指定project支持的density.

2. 在L1和M0(android 5.1之后版本):
系统会通过屏幕height和width来算出project默认应该支持的density:
device/mediatek/common/aapt/aapt_config.mk

如果该默认值不符合您的要求，可以在device\mediatek\$(proj_name)\full_$(proj_name).mk中添加如下：
PRODUCT_AAPT_PREF_CONFIG := xhdpi
AAPT会将xhdpi的资源打包。如果此时找不到xhdpi资源, AAPT会去找其他分辨率。这种情况下，为避免资源缺失，至少会包一种类型的资源进来。所以这种case下，可能会发生系统编译进多种其他分辨率资源，导致rom变大的情况。

注意1：PRODUCT_AAPT_PREF_CONFIG只能设置一种dpi。不能设置为PRODUCT_AAPT_PREF_CONFIG := xhdpi xxhdpi 这种错误形式。
注意2: PRODUCT_AAPT_CONFIG在L1上已经失效.

## [FAQ13924] Lollipop之后的新版本上，如何使AAPT将最佳匹配资源编译打包

```
1. 在L0(android 5.0)及之前的AOSP版本：
在device\mediatek\$(proj_name)\full_$(proj_name).mk设置
PRODUCT_AAPT_CONFIG := hdpi xhdpi xxhdpi 
指定project支持的density.

2. 在L1和M0(android 5.1之后版本):
系统会通过屏幕height和width来算出project默认应该支持的density:
device/mediatek/common/aapt/aapt_config.mk

如果该默认值不符合您的要求，可以在device\mediatek\$(proj_name)\full_$(proj_name).mk中添加如下：
PRODUCT_AAPT_PREF_CONFIG := xhdpi
AAPT会将xhdpi的资源打包。如果此时找不到xhdpi资源, AAPT会去找其他分辨率。这种情况下，为避免资源缺失，至少会包一种类型的资源进来。所以这种case下，可能会发生系统编译进多种其他分辨率资源，导致rom变大的情况。

注意1：PRODUCT_AAPT_PREF_CONFIG只能设置一种dpi。不能设置为PRODUCT_AAPT_PREF_CONFIG := xhdpi  xxhdpi 这种错误形式。
注意2: PRODUCT_AAPT_CONFIG在L1上已经失效.
```

## Android.mk 中打 log

``` bash
$(warning Warning:xxxx)
eg:$(warning Warning:BUILD_FINGERPRINT=$(BUILD_FINGERPRINT))

1、输出打印信息的方法是：
$(warning xxxxx)
$(info string)
$(error string)
2、输出打印变量值的方法是：$(warning  $(XXX))
```

## makefile里面加打印：

```
［table］@echo ' zImage - Compressed kernel image' 
```

## 监测设备是否root

``` Java
public boolean isRoot() {
    boolean root = false;
    try {
        if(!("eng".equals(SystemProperties.get("ro.build.type")))){
            if ((!new File("/system/bin/su").exists()) && (!new File("/system/xbin/su").exists())) {
                root = false;
            }else {
                root = true;
            }
        }
    } catch (Exception e) {
    }
    return root;
}
```

## lint 命令行怎么使用？

```
lint [flags] <project directory>
gradlew lint

https://juejin.im/post/5d307615f265da1b6b1d0dd9
```

## Selinux权限快速编译

添加对应selinux权限到文件之后
编译：
source build/envsetup.sh
lunch {prj}
mmm system/sepolicy （O之后）
mmm external/sepolicy （O之前）
make -j24 ramdisk-nodeps
make -j24 bootimage-nodeps
重刷boot.img

## Android.mk 文件中打印log

有时候需要在Android.mk文件或者其他以 .mk结尾的文件中打印默写变量的值, 如何打印呢. 使用$(waing text ) 或者 $(error text) 语句,
其中text 可以是普通文本 加 变量. 变量打印用$(val) sample:
$(waing 111 $(TARGET_BOARD_PLATFORM_PRODUCT))
$(warning Warning:BUILD_FINGERPRINT=$(BUILD_FINGERPRINT))
$(error 111  $(TARGET_BOARD_PLATFORM_PRODUCT))
Note: 如使用error, 打印完成后,停止向下继续执行

## 添加系统应用引v7包

部分模块没有添加V7包，导致有些主题（appcompat）不能使用。
具体修改如下：
在模块的android.mk下面添加：
LOCAL_STATIC_JAVA_LIBRARIES := \
    android-support-v7-appcompat

LOCAL_RESOURCE_DIR += \
    $(LOCAL_PATH)/res \
    $(LOCAL_PATH)/../../../../prebuilts/sdk/current/support/v7/appcompat/res       //v7/路径

LOCAL_AAPT_FLAGS := \
    --auto-add-overlay \
    --extra-packages android.support.v7.appcompat

## 默认语言不会随着sim卡变化而变化

``` Java
alps/vendor/mediatek/proprietary/packages/services/Telephony/src/com/android/phone/PhoneInterfaceManager.java
-        final Locale mccLocale = MccTable.getLocaleFromMcc(mPhone.getContext(), mcc, simLanguage);
+        //final Locale mccLocale = MccTable.getLocaleFromMcc(mPhone.getContext(), mcc, simLanguage);
+        //redmine139979 panhaoda modify for language not change from sim 2018 0704 begin
+        final Locale mccLocale = null;
+        //redmine139979 panhaoda modify for language not change from sim 2018 0704 end
```

## P go 上关机对话框上会有两种 item 的颜色

```
vendor/mediatek/proprietary/packages/apps/SystemUI/src/com/android/systemui/globalactions/GlobalActionsDialog.java

MyAdapter
public View getView(int position, View convertView, ViewGroup parent) {
    Action action = getItem(position);
    View view = action.create(mContext, convertView, parent, LayoutInflater.from(mContext));
    // Everything but screenshot, the last item, gets white background.
    if (position == getCount() - 1) {
        //HardwareUiLayout.get(parent).setDivisionView(view);   //这里会把最后一项变成其他颜色，去掉这一行代码就可以
    }
    return view;
}
```

## smaps 各个字段含义

``` bash
adb shell ps | grep "systemui"

adb shell cat /proc/${pid}/smaps

ffff0000-ffff1000 r-xp 00000000 00:00 0          [vectors]
Size:                  4 kB
Rss:                   0 kB
Pss:                   0 kB
Shared_Clean:          0 kB
Shared_Dirty:          0 kB
Private_Clean:         0 kB
Private_Dirty:         0 kB
Referenced:            0 kB
Anonymous:             0 kB
AnonHugePages:         0 kB
Shared_Hugetlb:        0 kB
Private_Hugetlb:       0 kB
Swap:                  0 kB
PSwap:                 0 kB
SwapPss:               0 kB
KernelPageSize:        4 kB
MMUPageSize:           4 kB
Locked:                0 kB
VmFlags: rd ex mr me

第一行： 
08048000-080bc000 地址空间的开始地址 - 结束地址 
r-xp 属性。前三个是rwx（读、写、可执行）,如果不具有则为“-”。最后一个是p/s(私有/共享) 
00000000 偏移量。如果这段内存是从文件里映射过来的，则偏移量为这段内容在文件中的偏移量。如果不是从文件里面映射过来的则为0. 
03:02 If the region was mapped from a file, this is the major and minor device number (in hex) where the file lives. 
13130 If the region was mapped from a file, this is the file number. 
/bin/bash If the region was mapped from a file, this is the name of the file. This field is blank for anonymous mapped regions. There are also special regions with names like [heap], [stack], or [vdso]. [vdso] stands for virtual dynamic shared object. It’s used by system calls to switch to kernel mode.

Rss-Resident Set Size 实际使用物理内存（包含共享库占用的内存） 
Rss=Shared_Clean+Shared_Dirty+Private_Clean+Private_Dirty 
Pss 实际使用的物理内存（按比例包含共享库占用的内存）。比如四个进程共享同一个占内存1000MB的共享库，每个进程算进250MB在Pss。 
Shared_Clean 、 Shared_Dirty 、 Private_Clean、 Private_Dirty 
（shared/private）共享和私有 
一个页的clean字段表示没有更改此页，当发生换页时不用写回。dirty表示更改了此页，当发生换页时要写回磁盘。此处这四个值是遍历页表中各个页后得到的。 
“Referenced” indicates the amount of memory currently marked as referenced or accessed. “Anonymous” shows the amount of memory that does not belong to any file. Even a mapping associated with a file may contain anonymous pages: when MAP_PRIVATE and a page is modified, the file page is replaced by a private anonymous copy. “Swap” shows how much would-be-anonymous memory is also used, but out on swap.
```

## meminfo 各个字段含义
 
``` bash
adb shell dumpsys meminfo com.android.systemui

Applications Memory Usage (in Kilobytes):
Uptime: 560220 Realtime: 560220

** MEMINFO in pid 875 [com.android.systemui] **
                   Pss  Private  Private  SwapPss     Heap     Heap     Heap
                 Total    Dirty    Clean    Dirty     Size    Alloc     Free
                ------   ------   ------   ------   ------   ------   ------
  Native Heap     7482     7324      108     2073    12544    10061     2482
  Dalvik Heap     4124     4004       12      147     7038     3519     3519
 Dalvik Other     1522     1516        4       16                           
        Stack       44       44        0        0                           
       Ashmem        2        0        0        0                           
    Other dev       16        0       12        0                           
     .so mmap     6851      132      732       77                           
    .apk mmap     6026        0     5528        0                           
    .ttf mmap      385        0      256        0                           
    .dex mmap     5151        0      688        0                           
    .oat mmap     3584        0       64        0                           
    .art mmap     2249      784       60       32                           
   Other mmap     2587        4     1388        1                           
   EGL mtrack       62       62        0        0                           
    GL mtrack     5289     5289        0        0                           
      Unknown      652      560       92      101                           
        TOTAL    48473    19719     8944     2447    19582    13580     6001
 
 App Summary
                       Pss(KB)
                        ------
           Java Heap:     4848
         Native Heap:     7324
                Code:     7400
               Stack:       44
            Graphics:     5351
       Private Other:     3696
              System:    19810
 
               TOTAL:    48473       TOTAL SWAP PSS:     2447
 
 Objects
               Views:      376         ViewRootImpl:        3
         AppContexts:        5           Activities:        0
              Assets:        7        AssetManagers:        0
       Local Binders:      156        Proxy Binders:       55
       Parcel memory:       20         Parcel count:      110
    Death Recipients:        2      OpenSSL Sockets:        0
            WebViews:        0
 
 SQL
         MEMORY_USED:        0
  PAGECACHE_OVERFLOW:        0          MALLOC_SIZE:        0


PSS TOTAL:              内存锁实际占用的值
Dalvik Heap Alloc:      Runtime.totalMemory() - Runtime.freeMemory(), Dalvik Heap 分配的内存大小
Dalvik Heap Free:       Runtime.freeMemory()  获得，DalvikHeap 剩余的内存大小
Dalvik Heap size:       Runtime.totalMemory() 获得，DalvikHeap 总共的内存大小 = Heap Alloc + Heap Free
.so mmap                C库代码占用的内存
.jar mmap               Java文件代码占用的内存
.apk mmap               apk代码占用的内存
.ttf mmap               ttf文件代码占用的内存
.dex mmap               dex文件代码占用的内存
Other mmap              其他文件占用的内存
Cursor                  /dev/ashmem/Curxor Cursor消耗的内存(KB)
Ashmem                  /dev/ashmem，匿名共享内存用来提供共享内存通过分配一个或多个进程可以共享的带名称的内存块
Other dev               /dev/,内部driver占用的在 Other dev
```

## showmap

``` bash
adb shell showmap ${pid}
```

## procrank

``` bash
VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）
RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存）
PSS - Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存）
USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）
一般来说内存占用大小有如下规律：VSS >= RSS >= PSS >= USS

VSS：VSS表示一个进程可訪问的所有内存地址空间的大小。

这个大小包含了进程已经申请但尚未使用的内存空间。在实际中非常少用这样的方式来表示进程占用内存的情况，用它来表示单个进程的内存使用情况是不准确的。
RSS：表示一个进程在RAM中实际使用的空间地址大小。包含了所有共享库占用的内存。这样的表示进程占用内存的情况也是不准确的。
PSS：表示一个进程在RAM中实际使用的空间地址大小，它按比例包括了共享库占用的内存。假如有3个进程使用同一个共享库，那么每一个进程的PSS就包括了1/3大小的共享库内存。

这样的方式表示进程的内存使用情况较准确。但当仅仅有一个进程使用共享库时，其情况和RSS一模一样。
USS：表示一个进程本身占用的内存空间大小，不包括其他不论什么成分，这是表示进程内存大小的最好方式！

Overview

The aim of this post is to provide information that will assist in interpreting memory reports from various tools so the true memory usage for Linux processes and the system can be determined.

Android has a tool called procrank (/system/xbin/procrank), which lists out the memory usage of Linux processes in order from highest to lowest usage. The sizes reported per process are VSS, RSS, PSS, and USS.

For the sake of simplicity in this description, memory will be expressed in terms of pages, rather than bytes. Linux systems like ours manage memory in 4096 byte pages at the lowest level.

VSS (reported as VSZ from ps) is . This size also includes memory that may not be resident in RAM like mallocs that have been allocated but not written to. VSS is of very little use for determing real memory usage of a process.

RSS is the. RSS can be misleading, because it reports the total all of the shared libraries that the process uses, even though a shared library is only loaded into memory once regardless of how many processes use it. RSS is not an accurate representation of the memory usage for a single process.

PSS , i.e. if three processes all use a shared library that has 30 pages, that library will only contribute 10 pages to the PSS that is reported for each of the three processes. PSS is a very useful number because when the PSS for all processes in the system are summed together, that is a good representation for the total memory usage in the system. When a process is killed, the shared libraries that contributed to its PSS will be proportionally distributed to the PSS totals for the remaining processes still using that library. In this way PSS can be slightly misleading, because when a process is killed, PSS does not accurately represent the memory returned to the overall system.

USS is . USS is an extremely useful number because it indicates the true incremental cost of running a particular process. When a process is killed, the USS is the total memory that is actually returned to the system. USS is the best number to watch when initially suspicious of memory leaks in a process.

For systems that have Python available, there is also a nice tool called smem that will report memory statistics including all of these categories.
```

## free命令查看剩余可用空间

``` bash
free 命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。
            total        used        free      shared     buffers
Mem:        441946112   432463872     9482240     1175552     1437696
-/+ buffers/cache:      431026176    10919936
Swap:       331452416    91521024   239931392
```

## reserve memory 查看和详情

https://online.mediatek.com/FAQ#/SW/FAQ21499
```
一个固定的内存，通过proc/meminfo 发现total memory 并不是全部的内存，那剩下的的内存如何查看？
都是做了什么？
 
部分kernel代码、modem ,  tee,  framebuffer 等都会占用一部分的内存

MTK 有相关内容的记录
k71v1_64_bsp:/proc/mtk_memcfg # ls
memory_layout reserve_memory total_reserve
 
k71v1_64_bsp:/proc/mtk_memcfg # cat reserve_memory
*mblock-15-ccci: 80412672
mblock-9-dtb_kernel_addr_mb: 524288
ram_console-reserved-memory@54400000: 65536
pstore-reserved-memory@54410000: 917504
minirdump-reserved-memory@544f0000: 65536
mblock-4-atf-reserved: 262144
mblock-7-pl-bootarg: 2097152  // pl 
mblock-8-lk_addr_mb: 4194304 // lk 
reserve-memory-dram_r0_dummy_read: 4096
mblock-12-SPM-reserved: 65536
mblock-10-framebuffer: 29229056  //framebuffer
mblock-6-SSPM-reserved: 786432
mblock-3-log_store: 262144  // log 
*mblock-16-ccci: 23068672  // modem
*mblock-14-ccci: 1048576
reserve-memory-scp_share: 20971520
reserve-memory-sspm_share: 5308416
mblock-13-SCP-reserved: 6291456
consys-reserve-memory: 2097152
mblock-11-vpu_binary: 44105728
mblock-5-atf-log-reserved: 262144
mblock-1-dramc-rk0: 4096
mblock-2-dramc-rk1: 4096
kernel(text): 13340672
kernel(data): 14116716
kernel(page): 67108800
kernel(other): 12486868

k71v1_64_bsp:/proc/mtk_memcfg # cat total_reserve
321388 kB
 
321388 kB = 321388 /1024 =  313 MB
 
totoal  meminfo 
 
k71v1_64_bsp:/proc/mtk_memcfg # cat /proc/meminfo
MemTotal: 3872916 kB
MemFree: 119676 kB
MemAvailable: 2269012 kB
Buffers: 218348 kB
 
MemTotal: 3872916 kB =  3872916  / 1024  = 3782.14 MB
 
4G =4096MB - 313 MB = 3783M
 
physics RAM = Total meminfo + total_reserve
```

## Android P one 版本默认底层配的 device version为 HAL3.2，如果想改为 HAL1.0

``` C
在文件 alps/vendor/mediatek/proprietary/custom/mt6739/hal/imgsensor_metadata/common/config_static_metadata_common.h 中把
case 0:
    CONFIG_METADATA_BEGIN(MTK_HAL_VERSION)
    CONFIG_ENTRY_VALUE(MTK_HAL_VERSION_3_2, MINT32)
    CONFIG_METADATA_END()
    break;
case 1:
    CONFIG_METADATA_BEGIN(MTK_HAL_VERSION)
    CONFIG_ENTRY_VALUE(MTK_HAL_VERSION_3_2, MINT32)
    CONFIG_METADATA_END()
    break;
改为
case 0:
    CONFIG_METADATA_BEGIN(MTK_HAL_VERSION)
    CONFIG_ENTRY_VALUE(MTK_HAL_VERSION_1_0, MINT32)
    CONFIG_METADATA_END()
    break;
case 1:
    CONFIG_METADATA_BEGIN(MTK_HAL_VERSION)
    CONFIG_ENTRY_VALUE(MTK_HAL_VERSION_1_0, MINT32)
    CONFIG_METADATA_END()
    break;
```

## 根据 SIM 卡的 mccmnc 设置语言

``` Java
MccTable.java updateMccMncConfiguration() 中添加
setLocaleFromMccIfNeeded(context, mcc);     //部分平台没有这个方法，需要自行添加实现部分的代码
```

## 开机后发现Home和Menu功能不正常

``` Java
原因是开机向导过程中意外关机导致 Settings.Global.DEVICE_PROVISIONED 这个值没有写入到数据库中
M:frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java文件中的setEnabledSetting方法中   ----->redmine62528
try {
    if(packageName.equals("com.google.android.setupwizard") && !(newState == COMPONENT_ENABLED_STATE_ENABLED||newState == COMPONENT_ENABLED_STATE_DEFAULT)) {
        if (android.provider.Settings.Global.getInt(mContext.getContentResolver(),android.provider.Settings.Global.DEVICE_PROVISIONED, 0) == 0) {
            android.provider.Settings.Global.putInt(mContext.getContentResolver(), android.provider.Settings.Global.DEVICE_PROVISIONED, 1);
        }
    }
} catch (Exception e) {
}

adb shell settings put  global device_provisioned 0
adb shell settings get  global device_provisioned
```

## 在 app 中使用自定义字体

``` Java
//package/apps/calculate/里面新建assets/fonts文件夹，然后把那个.otf/.ttf文件放到里面
Typeface typeface = Typeface.createFromAsset(context.getAssets(), "fonts/HelveticaNeueLTStd-UltLt.otf");
setTypeface(typeface);
```

## SIM卡联系人数量显示的与实际不符

```
SIM卡联系人数量显示的与实际不符（SIM卡中有很多联系人，选择删除所有SIM卡联系人，删除过程中下拉状态栏，点击“联系人”正在运行，选择强制停止后返回联系人。sim卡中联系人的数量没有变，重启后才会减少。）
1、sim卡中的联系人删除原理：删除过程中首先删除的是sim卡里的数据，然后去删除数据库的数据，如果在删除过程中强制停止的话，可能就只删除了sim卡里面的数据，而还没有删除掉数据库的数据，然后再打开联系人的时候，它会根据数据库的数据进行更新，如果数据库没被 删除掉的话，联系人的数据也就不会变了，因此出现了上述的bug情况。
2、手机中联系人删除原理：删除过程中是直接删除数据库的数据，不会出现上述情况。
3、手机重启联系人会更新的原理：手机重启后，会先把数据库中关于sim卡的数据进行删除，然后再从sim卡中把那些号码导入到数据库，这样数据库的数据就会跟sim卡的数据一样，然后再从数据库读取数据显示出来就会是最新的。
4、无法修改原因：我通过调试和使用MTKlog抓取log的方法，在删除联系人的地方发现了有关它删除sim卡联系人的方法，然后进行修改，最终发现更新功能是能实现，但是删除的速度会减慢，本来是100条删除一次，现在变成每1条删除一次，这样会严重影响效率，而且该bug的操作我认为是非法操作，手机已经提醒如此操作会使数据发生错乱，综合上面种种原因，我认为该bug不用修改。
5、删除sim卡联系人数据具体方法：trunk/Packages/apps/Contacts/src/com/mediatek/contacts/list/DeleteProcessor.java中的runInternal()方法中。
```

## (情景模式)勾选触摸提示音，每次约5s后第一次触摸时触摸音较小，之后触摸声音会变大一点(主要还是要注意kernel修改以后怎么把它烧到手机里面去)

```
注意：先进入mediatek/config/所编的工程/ProjectConfig.mk,然后搜索CUSTOM_KERNEL_SOUND，看我们所使用su_android_speaker.c
1.打开mediatek/custom/common/kernel/sound/上一步搜索出来的文件夹/yusu_android_speaker.c，然后把define CONFIG_DEBUG_MSG前面的“//”去掉，接着把define SPK_WARM_UP_TIME的参数改为50，然后再Sound_Speaker_Turnon方法下面加上了两句log。
2.在终端里执行./mk sagetel82_wet_kk r kernel
3.在终端里执行./mk bootimage
4.在终端里执行./copy_sagetel82_wet_kk.sh
5.然后用Release_SW文件夹进行刷机
然后就可以了！
```

## 为什么第一次编译的时候要"./mk 工程名 new"，而第二次编的与上一次编的是同一个工程的话，我们直接"./mk new"就可以了？

```
这是因为你把工程下下来后，第一次编译的时候会编译产生makeMtk.ini文件，然后再这个文件里面会把第一次输入的"./mk 工程名 new"中的工程名记录到这个文件里面,然后下次编译再你不写工程名的时候就会默认为makeMtk.ini文件的工程名
```

## 经常会出现开机logo显示正确，而关机充电图标显示乱，

```
原因：
1、我们少修改了一个文件mediatek/custom/common/lk/include/target/cust_display.h)以tecno的UP07为例，config文件中BOOT_LOGO=fwvga_tecno_d7 
tecnoD7项目是FWVGA的分辨率，因此需要在cust_display.h的FWVGA最后添加一句
#elif defined(FWVGA) || defined(CU_FWVGA) || defined(CMCC_FWVGA) || defined(FWVGA_TECNO_D7) (这个的分辨率是fwvga 480*854，所以每个项目都要到projectConfig.mk文件中找到手机对应的分辨率)
如果你的分辨率是320*480的话，就要在该文件中的#elif defined(HVGA) || defined(CU_HVGA) || defined(CMCC_HVGA) || defined(CT_HVGA) || defined(HVGA_UP11)加了，可以直接搜索分辨率(320*480)
注：BOOT_LOGO中定义的是小写的，而cust_display.h中需要写成大写的
2、你要去看mediatek/custom/common/lk/logo中的图片的分辨率是否正确！
```

## FeatureOption.java 的位置

```
out/target/product/mq16_h451_t3_p/obj/JAVA_LIBRARIES/mediatek-common_intermediates/FeatureOption.java（看宏编译后生成的是什么就再java文件中调用什么，注意有些宏再projectConfig.mk文件中的宏名字和featrueoption产生的宏名字不一样，如果我们要使用这个宏的话以编后再featrueoption生成的为准）
```

## [默认值]usb默认联接用Media device(MTP)而不用USB Storage

```
方法：[FAQ04464] [USB]如何修改USB连接后的默认功能
/build/core/main.mk 中搜索 ADDITIONAL_DEFAULT_PROPERTIES += persist.sys.usb.config，会发现默认连接值用哪个可以用宏控制，MTK_MASS_STORAGE
```

## [默认值]短信转彩信条数

```
短信字数到达一定数字短信变成彩信（redmine 6837）
SAGEREAL_SMSTOMMS_LIMIT，这个宏要打开!
该功能修改再MmsConfig.java文件里面！

1.短信变为彩信？？？？
解决：
packages/apps/Mms/res/xml/mms_config.xml
<!-- Maximum number of SMS message segments in a long text message before converting the SMS message to an MMS message. -->
<int name="smsToMmsTextThreshold">7</int>
```

## [默认值]当用USB链接的时候，USB名称修改

```
1、打开/system/vold/Fat.cpp，然后 if(isInttrunkernalSd)下面把要修改的名字修改了！（相当于我的电脑上显示出来的名称）
2、是按照客户需求名称汇总表20131105文件修改！（这个是虚拟机上面的设备-->分配设备）
```

## [默认值]照片详情中 maker,modle 名称修改

```
1、mediatek/custom/mt6572/hal/camera/camera/camera_custom_if.cpp中修改（jb3），可以搜索CUSTOM_EXIF_STRING_MAKE
2、mediatek/custom/up09l_h401_ddm_single/hal/inc/camera_custom_exif.h（kk），可以搜索CUSTOM_EXIF_STRING_MAKE
3、mediatek/custom/common/hal/inc/camera_custom_exif.h（kk），可以搜索CUSTOM_EXIF_STRING_MAKE
4、../sagereal/mk/UP19_H353_Vodacom/full_sr6572_wet_l.mk (l),可以搜索PRODUCT_MANUFACTURER和PRODUCT_MODEL

TODO : 其他平台的也更新进来？？？
```

## launcher界面最下面排顺序（Hotseat）-->[FAQ10350] 如何修改Allapp Button的位置

```
1、/packages/apps/Launcher2/res/xml/default_workspace.xml中修改除了app button以外按钮的顺序，就是Hotseat
然后/packages/apps/Launcher2/src/com/android/launcher2/Hotseat.java中有一个Allapp Button的默认位置，是通过/packages/apps/Launcher2/res/values/config.xml中的hotseat_all_apps_index值设置的，如果你要把all button的位置也修改了，必须要把这个hotseat_all_apps_index默认值给修改了,当然那个默认值修改后你要把default_workspace.xml中的hotseat的其他图标的位置做相应的修改！
2、/packages/apps/Launcher3:
DynamicGrid.java文件
hotseatAllAppsRank = (int) (numColumns/2); //默认是列数除以2取整，可以设置为需要的值,(比如说(int) (numColumns/2)-1就是相当与把Allapp Button向左移动了一位，当然在default_workspace.xml中要把原来在Allapp Button左边的那个应用的位置给让出来！)
```

## [NTP]选择使用网络自动更新时间后，时间不准确

```
frameworks/base/services/java/com/android/server/NetworkTimeUpdateService.java
进入文件，然后把"203.160.128.59","2.android.pool.ntp.org","time-a.nist.gov"中的"203.160.128.59"注销掉，因为这个通过这个服务器获得的时间是有问题，导致了这个时间不准确！
```

## [NTP]修改自动对时服务器

```
How to change server address?
There are two ways:
1. change Android default server address. Just replace this value that in "/frameworks/base/core/res/res/values/config.xml"with your own server address.
2. Add your server in NetworkTimeUpdateService.java. use ((NtpTrustedTime) mTime).setServer(custom_server) to set custom NTP server before call mTime.forceRefresh(). Then 
NtpTrustedTime will connect to custom_server to update time.

How to verify modify?
initialization:
Make sure handset can access internet, enter settings -> Date & time, enable Automatic time from network. Disable Automatic time zone.

test:
reboot phone, check mainlog/syslog:

07-12 08:56:09.770370   943   943 D NtpTrustedTime: getServer:[time.android.com]   // this address should be custom server 
07-12 08:57:07.184321   943  1172 D NetworkTimeUpdateService: New default network 100; checking time.
07-12 08:57:07.184816   943  1172 D NetworkTimeUpdateService: onPollNetworkTime start
07-12 08:57:07.191897   943  1172 D NetworkTimeUpdateService: Stale NTP fix; forcing refresh
07-12 08:57:07.192420   943  1172 D NetworkTimeUpdateService: mTryAgainCounter = 0;mNtpServers.size() = 3;index = 0;mNtpServers = time.android.com
07-12 08:57:07.192835   943  1172 D NtpTrustedTime: setServer:[time.android.com]
07-12 08:57:07.555810   943  1172 D SntpClient: round trip: 84ms, clock offset: 200ms  // means success
```

## [6509](情景模式)勾选触摸提示音，每次约5s后第一次触摸时触摸音较小，之后触摸声音会变大一点（第二十三条有详细步骤）

```
custom/common/kernel/sound/amp_aw8145/yusu_android_speaker.c
然后把 SPK_WARM_UP_TIME 的数值修改！
```

## [6410](通话记录)通话记录详情界面进入到电话本记录后，按返回键退出的不是上一个界面

```
packages/apps/Dialer/src/com/android/dialer/CallDetailActivity.java
把 onPostExecute() 中的 mainActionIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP)注销掉！
```

## [11203] pls remove the calendar option

```
packages/apps/Mms/src/com/android/mms/util/MessageConsts.java
把calendar的项给去掉，然后进入 packages/apps/Mms/res/values/mtk_arrays.xml 把calendar的项去掉

packages/apps/Mms/src/com/mediatek/ipmsg/ui/SharePanel.java
把多余的一页去掉！
```

## [11786](相机)后置摄像头拍照的预览大小更换为全屏后，再更换为4:3，默认像素变为8M

```
描述：手机默认像素为13.1M，后置摄像头的预览大小默认为4:3，更换为全屏后，像素变为6M，再更换为4:3后，像素默认为8M
期望：更换为4:3，像素应该仍然为默认值13.1M；全屏的像素为6M，请确认是否正确
首先去找projectconfig.mk文件中的CUSTOM_HAL_MAIN_IMGSENSOR（后摄像头），然后按照这个找到/mediatek/custom/mq16_h504_c5vp/hal/imgsensor/ov8858_mipi_raw/config.ftbl.ov8858_mipi_raw.h文件
一般在java和xml文件中已经把每个比例的所有pictrue size都写进去了，只是config.ftbl.ov8858_mipi_raw.h这个文件中没有把所有的东西写进去（每个比例写了哪几个就在手机上显示哪几个尺寸）
```

## [FAQ02892] 紧急号码的管理及客制化方法

```
思想大义：framework/base/telephony/java/android/telephony/PhoneNumberUtils.java 中的 isEmergencyNumber 为 true，isSpecialEmergencyNumber 为 false
1、不插卡时：framework/base/telephony/java/android/telephony/PhoneNumberUtils.java 中的 isEmergencyNumber(String number) 方法中是有插卡和不插卡的两个方法(可以直接抓取log看，一般就能看出有卡和无卡情况下怎么修改)
isEmergencyNumber(String number)方法中当int eccNo = 9;
String[] emergencyNumList = {"112", "911", "000", "08", "110", "118", "119", "999", "123"}中把要加的号码加上去（一般再SIM4的判断后面是无sim情况的）
2、插卡时：打开 mediatek/frameworks/base/op/java/com/mediatek/op/telephony/PhoneNumberExt.java，有 isCustomizedEmergencyNumber(String number, String plusNumber, String numberPlus) 方法，然后就可以在这里加上你要定制的紧急拨号号码！（特殊情况：如果是去掉911号码要在PhoneNumberUtils中判断sim1的时候（有注释的），直接在判断方法中把911去除）
ps：编译 mediatek/frameworks/base/op/java/com/mediatek/op/telephony/PhoneNumberExt.java 该文件的时候可以编译 ./mk -t mm mediatek/frameworks/base

ps:在插入卡的时候会发现在默认112、911为紧急拨号，如果要去除的话，要在 frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SIMRecords.java 文件中handleMessage(Message msg)方法中 case EVENT_GET_SIM_ECC_DONE和case EVENT_GET_USIM_ECC_DONE下有个mEfEcc = "112,911"

[Android Version]
Android 5.0/5.1 (L)
Android 6.0 (M)
Android 7.0(N)
Android 8.0(O)

[DESCRIPTION]
L及之后的版本紧急号码Customer的部分改成了在XML文件中来配置，文件的路径：
alps/vendor/mediatek/proprietary/external/EccList

EccList文件夹中会包含ecc_list.xml，以及与运营商有关的ecc_list_OP01.xml、ecc_list_OPXX.xml等对应文件，此外还包括一个EccList.mk的Makefile。实际运行中会根据Makefile文件中的定义匹配对应的XML文件作为判断是否是紧急号码的来源。

下面是ecc_list.xml文件中的内容：

N及之后的版本ecc_list.xml 文件不变，但是有加上PLMN的配置， 也就是可以按照运营商

26    <!-- Add for China CTA -->
27    <EccEntry Ecc="110" Category="0" Condition="2" Plmn = "460 FFF" />
28    <EccEntry Ecc="119" Category="0" Condition="2" Plmn = "460 FFF" />
29    <EccEntry Ecc="120" Category="0" Condition="2" Plmn = "460 FFF" />
30    <EccEntry Ecc="122" Category="0" Condition="2" Plmn = "460 FFF" />
31
32    <!-- Add for Malaysis Digi operator -->
33    <EccEntry Ecc="999" Category="0" Condition="1" Plmn = "502 FFF" />
*说明：

一 、添加号码请注意Condition的配置，根据需求来选择对应的值。
0:表示在无卡的时候当紧急号码；
1:表示始终当紧急号码；
2:表示界面上显示成紧急拨号，但实际以普通方式拨出。
二 、Category属性的设置于语音台选择有关，只有在实际拨打紧急号码的时候会将此号码配置的Category属性发送到Modem。国内默认都是‘0’，国外根据实际情况选择。 

[FAQ21186] 特定运营商紧急号码配置（After Android O）
```

## 查看sim卡信息

```
*#*#4636#*#*
```

## 改了宏该如何编译(KK)

```
需要编译mediatek/frameworks/common(不需要push进去)，然后把使用宏的java代码重新编译一下，push到手机上就会有新的现象产生！
```

## [shell]通过终端找字符串

``` bash
find . | xargs grep -n --color "orange"
grep "字符" ./ -r(./代表当前文件夹，-r代表遍trunk历)
```

## 如何确定全屏时屏幕比例

```
再 ProjectConfig.mk 文件中搜索LCM，会找到一个宽度和一个高度，然后比一下就会出来全屏的比例！
```

## [adb]抓取kernel log

``` bash
adb shell cat /proc/kmsg > log.txt
```

## [默认值]camera闪光灯默认情况

``` bash
可以打开 package/apps/camera/res/values/string.xml,然后搜索 pref_camera_flashmode_default 就可以了！(R.styleable.ListPreference_defaultValue要去搜索defaultValue而不是去搜索ListPreference_defaultValue)
```

## [默认值]默认声音改成80%

```
可以打开/frameworks/base/media/java/android/media/AudioService.java，可以发现MAX_STREAM_VOLUME，这个数组里面有各种声音的最大值，STREAM_NOTIFICATION和STREAM_ALARM应该改成80%，然后进入/frameworks/base/media/java/android/media/AudioManager.java，搜索DEFAULT_STREAM_VOLUME，然后把STREAM_RING和STREAM_ALARM改成15x80%=12就可以了
打开mediatek/frameworks/base/media/audio/java/com/mediatek/audioprofile/AudioProfileManager.java，然后搜索DEFAULT_NOTIFICATION_VOLUME_GENERAL和DEFAULT_ALARM_VOLUME_GENERAL，把他们改成15x80%=12就可以了！
```

## 如何修改邮件帐号类型和邮件签名

``` Java
帐号类型：packages/apps/Email/res/xml/providers.xml（redmine16643）
邮件签名：（redmine30687）
M:mediatek/config/mq16_h504_c5ql/sagereal_copy/packages/apps/Email/UnifiedEmail/src/com/android/mail/compose/ComposeActivity.java  -->appendSignature方法下
if (TextUtils.isEmpty(newSignature)) {
    newSignature  = getString(R.string.email_signature_h504_c5ql);
}
M:mediatek/config/mq16_h504_c5ql/sagereal_copy/packages/apps/Email/src/com/android/email/activity/setup/AccountSettingsFragment.java  -->loadSettings()方法下
if (TextUtils.isEmpty(accountSignature)) {
    accountSignature =getString(R.string.email_signature_h504_c5ql);
} 
M:packages/apps/Email/res/values/mtk_strings.xml
M:packages/apps/Email/res/values-es/mtk_strings.xml
```

## [默认值]如何使settings/printing/cloud print默认为off

``` Java
frameworks/base/services/java/com/android/server/print/UserState.java  -->  enableSystemPrintServicesOnFirstBootLocked()
if (builder.length() <= 0) {
    return;
}后面加上if (true) return; 
相当于没有寻找到相关设备，默认就会是off 
```

## [默认值]修改 GPS 默认高精度 high accuracy

```
frameworks/base/packages/SettingsProvider/res/values/defaults.xml
把 def_location_providers_allowed 设置为 gps,network 然后清理一下 SettingsProvider 的数据或恢复出厂设置就可以了！
```

## [默认值]修改make passwords visible默认为off
打开frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java，然后查看com.android.providers.settings的数据库（一般你一点击你要修改的项，数据库的最后一项就会自动改变），你找到要修改项的名字，这个项的名字show_password，然后可以看到再loadSystemSettings中没有进行loading，所以加上loadBooleanSetting(stmt, Settings.System.TEXT_SHOW_PASSWORD, R.bool.show_password)（主要是该数据保存存在叫system的table中，所以用loadSystemSettings）;show_password到frameworks/base/packages/SettingsProvider/res/values/defaults.xml里面去加这个字符串，然后值为false

## [默认值]修改unknown sources默认为off

```
frameworks/base/packages/SettingsProvider/res/values/defaults.xml
def_install_non_market_apps
```

## [默认值]如何使vibrate默认为on

```
mediatek/frameworks/base/media/audio/java/com/mediatek/audioprofile/AudioProfileManager.java
DEFAULT_VIBRATION_GENERAL = true;
```

## [默认值]如何使dial pad touch tones默认为off

```
mediatek/frameworks/base/media/audio/java/com/mediatek/audioprofile/AudioProfileManager.java
DEFAULT_DTMFTONE_GENERAL = false;
```

## [默认值]screen lock sound默认为off (redmine36401)

```
mediatek/frameworks/base/media/audio/java/com/mediatek/audioprofile/AudioProfileManager.java
DEFAULT_LOCK_SCREEN_GENERAL = false;
```

## [默认值]默认语言

```
mediatek/config/项目名/ProjectConfig.mk
MTK_PRODUCT_LOCALES = en_GB en
```

## [默认值]默认键盘语言

```
这个是写在数据库里面的！
```

## 下载DRM的音频文件，使用google play music无法播放，原生音乐app可播放。

```
[FAQ10443] [Audio App] DRM下载的音频文件无法使用GMS play music播放。
可修改DrmMtkDef.cpp文件，把有需要打开该格式的的APK名称添加到TRUSTED_APP数组中（比如说用google play music打开该文件，就可以在这个数组里面加上apk名字.注意该apk名字eclipse中的DDMS中显示的apk名字，不是Hierarchy中显示的apk名字），
TRUSTED_APP[TRUSTED_APP_CNT]这个数组我们要把TRUSTED_APP_CNT也要加上1（可全局搜索TRUSTED_APP_CNT）
同样的，如果是视频文件，也可以使用类似的方式修改，把播放视频APK 添加到TRUSTED_VIDEO_APP中
```

## 信号跳变如何分析

```
如果是想从log里面看modem上报的信号强度，可以在radio log里面搜 : +ECSQ:，然后看第一个参数的值，如果是99为无效，其他值是越小表示信号强度越弱；
```

## 如何模拟sim卡的mcc和mnc

```
ApnSettings.java 文件中的 initSimState() 方法的最下面添加一行代码 mNumeric = "21403";就可以模拟了
现在有专门的白卡可以写mccmnc
```

## 在修改Preference上的内容之后，不会立刻刷新如何修改！

```
只要在设置好内容之后调用 notifyChanged() 就行了
```

## 获取屏幕密度

``` Java
DisplayMetrics metric = new DisplayMetrics();
getWindowManager().getDefaultDisplay().getMetrics(metric);
int density Dpi = metric.densityDpi;    //屏幕dpi
```

## 如何使桌面去掉没有app的页面

```
打开/packages/apps/Launcher3/res/values/config.xml，然后把config_workspaceMaxScreenNum改为1（相当于说再其他页都没有app的情况下，launcher最多显示一页，当然如果其他页上面也有app，当然可以多页）
config_workspaceDefaultScreen则表示默认的中间页，也就是按home键回到的那一页！
```

## [shell]linux下替换某些文件中的某些字符

``` bash
格式: sed -i "s/查找字段/替换字段/g" `grep 查找字段 -rl 路径`
sed -i "/MTK_VOLTE_SUPPORT =/s/=.*/= no/" ----->  sed -i "/查找字段/s/需要替换的字段/想要替换成的结果/
```

## 升级SettingsProvider数据库

``` Java
if (oldVersion <= 43) {
    try {
        db.execSQL("alter table " + Account.TABLE_NAME + " add column " + AccountColumns.IS_START +" integer" + ";");
        final ContentValues cv = new ContentValues(1);
        cv.put(AccountColumns.IS_START, 0);
        db.update(Account.TABLE_NAME, cv, null, null);
    } catch (final SQLException e) {
        // Shouldn't be needed unless we're debugging and interrupt the process
        LogUtils.w(TAG, "Exception upgrading EmailProvider.db from v113 to v114", e);
    }
}
```

## ToggleButton 如何设置背景

``` Java
mSundayButton.setButtonDrawable(getContext().getResources().getDrawable(R.drawable.sunday_4));sunday_4里面可以设置点击和不点击的图片(normal 和 pressed)
```
在布局文件中可以设置textOn,textOff为空 ，不然的话会在图片上出现on和off字样
android:textOff=""
android:textOn=""
drawable/sunday_4

``` xml
<?xml version="1.0" encoding="UTF-8"?>
<selector xmlns:android="http://schemas.android.com/apk/res/android" android:exitFadeDuration="@android:integer/config_mediumAnimTime">
    <item android:state_checked="true" android:drawable="@drawable/friday_pressed" />
    <item android:state_checked="false" android:drawable="@drawable/friday_normal" />
</selector>
```

## [默认值]Chrome 第三方浏览器添加书签

```
packages/providers/PartnerBookmarksProvider/res/values 里面的两个文件进行修改!
```

## [默认值]如何修改network mode的默认值

```
frameworks/base/telephony/java/com/android/internal/telephony/RILConstants.java
该文件中的 PREFERRED_NETWORK_MODE 是默认的 network mode 的值！
```

## [Bug](相机)用闪光灯拍照声音会卡（redmine 20631）

```
原因：拍照后loading的时候一个cpu不够用，可以直接强制开启两个cpu
[FAQ12541] 拍照时强制开两个CPU
```

## soft touch 左右中快捷键（menu键出现运行的文件）（具体可参考h502s_srf中的redmine 16884）-->虚拟键

```
frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java，加上keyCode == KeyEvent.KEYCODE_F12的判断
frameworks/base/core/res/res/values/config.xml，然后<integer name="config_longPressOnHomeBehavior">1</integer>改为2，<bool name="config_dreamsEnabledByDefault">true</bool>改为false（config_longPressOnHomeBehavior中的值每个都是有不同意思的，可以到这个文件中去看，那里有注释）
mediatek/custom/up16_sfr_h502s/kernel/touchpanel/GT9XX_V22/tpd_custom_gt9xx.h，把#define GTP_KEY_TAB     {KEY_BACK, KEY_HOMEPAGE, KEY_MENU}改为#define GTP_KEY_TAB     {KEY_BACK, KEY_HOMEPAGE, KEY_F12}
l路径:/alps/kernel-3.10/drivers/input/touchscreen/mediatek/GT9XX_V24，如果在projectConfig.mk中去搜索touchpanel，然后如果发现在前面路径中没有这个touchpanel的文件夹，这时候就需要我们去/sagereal/mk/WQ30_H556_WINONA/sr6735_65u_l1_defconfig文件去中找具体用了哪个touchpanel
M路径：kernel-3.18/arch/arm/boot/dts/sr6580_we_m.dts，在这个里面有个tpd-key-local= <158 172 88 0>;88为F12的值，139为MENU的值

ps：为什么我们不能直接在menu的以前的方法上直接改成另一种方法实现bug的要求呢？那是因为menu里面的方法是不能修改的，不然CTS是过不了的，所以我们直接把KEY_MENU改成了KEY_F12，然后在    PhoneWindowManager.java，加上keyCode == KeyEvent.KEYCODE_F12的判断，这样就会不走keyCode == KeyEvent.KEYCODE_MENU,会直接走keyCode == KeyEvent.KEYCODE_F12
```

## [默认值]修改相机 Anti-flicker 默认为 Auto

``` xml
关于相机中 Anti-flicker 默认要求为Auto,然后这个就是默认值的修改方法，如果相机配有自动功能，则选择auto，如果没有则选择下面一个
packages/apps/Camera/res/values/camera_arrays.xml
<string-array name="pref_camera_antibanding_default_array" translatable="false">
    <item>auto</item>
    <item>60hz</item>
    <item>off</item>
</string-array>
```

## 信号图标的显示（信号的具体的值）

```
frameworks/base/op/java/com/mediatek/op/telephony/ServiceStateExt.java
```

## [bug](相机)相机连拍，手松开后，仍会继续拍照（redmine22662）

```
分两种情况：
1、虽然声音和拍照张数不符合，但是不会一直连拍到40张：长按快门连拍，快门声音比拍出的照片数量多。因为目前长按快门连拍时，声音的循环播放是AP端来控制的，跟拍照的次数没有关系，所以会不同步。
2、松手后直接拍照到40张：
packages/apps/Camera/src/com/android/camera/actor/PhotoActor.java中 onKeyUp(int keyCode, KeyEvent event)
case KeyEvent.KEYCODE_CAMERA:最后面加上
mContinuousShotPerformed = false;
if (mCamera.getCameraState() == Camera.STATE_SNAPSHOT_IN_PROGRESS) {
    cancelContinuousShot();
}
```

## 修改 VoiceMail number

```
voicemail number设置
frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GSMPhone.java
frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/SIMRecords.java

主要是再 SIMRecords.java 中的 setVoiceMailByCountry() 方法中把
//mIsVoiceMailFixed = true;  //注释掉此语句以让用户能够修改
isSetByCountry = true; 
voiceMailNum = "*77";
voiceMailTag = "Messagerie vocale";

把 voiceMailNum 和 voiceMailTag 写死
然后把这个方法下面的mVmConfig.containsCarrier(spn)判断方法去掉，该方法是当把voicemail-conf.xml写进common.mk中才能检测到，我们使用简单方法是没有把这个文件写进去的，所以把该判断方法也是去掉的！ 
```

## [bug]0005636: ITA Vodafone italy PLMN name is wrong（把plmn中的"Voda IT"改成"VODAFONE IT"）

```
M:mediatek/frameworks/base/telephony/etc/spn-conf.xml，把这个里面的"Voda IT"都改成"VODAFONE IT"
```

## (小部件)电量控制小部件无法从最大亮点切换到自动亮度（redmine 25309）,该问题是再jb3升级到kk时候出现的，原因是jb3上面是没有disable_aal这个参数，而到了kk是有这个参数的，当这个参数为0时才能正常操作

```
packages/apps/Settings/src/com/android/settings/widget/SettingsAppWidgetProvider.java中
int secureMode = Settings.System.getInt(context.getContentResolver(),Settings.System.DISABLE_AAL);改成int secureMode = Settings.System.getInt(context.getContentResolver(),Settings.System.DISABLE_AAL，0)；
```

## 在 c++ 中引用 ProjectConfig.mk 中定义的宏

```
详细如下:
AUTO_ADD_GLOBAL_DEFINE_BY_NAME:
如果你希望定义一个宏开关（作为一个功能模块的开关），然后在源文件(*.c/h等使用到这个宏开关)，比如你定义了一个XXX_SUPPORT这个宏的值只有yes和no。那么你可以在
ProjectConfig.mk中定义：
XXX_SUPPORT = yes
但是这样定义在源文件是找不到XXX_SUPPORT的，因此需要加入AUTO_ADD_GLOBAL_DEFINE_BY_NAME，加入之后就可以在源文件使用了，比如aa.c中：
#ifdef XXX_SUPPORT
......
#endif
注意：如果添加的宏的值为no/none/false（无论大小写），那么该宏不会被添加进去。

AUTO_ADD_GLOBAL_DEFINE_BY_VALUE:
同上，但是差别在于你希望将宏的值传给源文件，比如定义了：
XXX_TP = CTP#RTP or CTP
你希望在代码中去判断当前使用了RTP还是CTP，那么可以将XXX_TP加入AUTO_ADD_GLOBAL_DEFINE_BY_VALUE
这样在源文件中就可以引用了，比如aa.c中：
#ifdef CTP
......
#elif RTP
......
#endif

AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE:
它与AUTO_ADD_GLOBAL_DEFINE_BY_NAME差别在于AUTO_ADD_GLOBAL_DEFINE_BY_NAME只有定义和没有定义之分，而AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE还可以知道它的值是多少(注意这个值是字符串)，比如：
XXX_NUM = 1#1 or 2
那么加入AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE之后：
在源文件中就可以这样用(比如aa.c):
if (!strcmp(XXX_NUM, "1")) {
} else {
}
```

## [Recovery]模式中无法恢复出厂设置，即进入恢复出厂设置没有yes选项（redmine 26513）

```
bootable/recovery/recovery.cpp，打开该文件const char* items[]中把第八项往上移（该bug我们是移到第二项），然后把chosen_item != 7改成chosen_item != 1
```

## 从jb3升级到kk，音量变成原来的一半

```
因为jb3的音量最大值是7，而kk的最大值是15，所以当jb3存的音量是7时，升上去到kk后7相当于一半的音量
```

## 语言设置为阿拉伯语，添加快捷方式至桌面或删除桌面快捷图标，待机界面会先显示一下第二页再显示主页面（redmine 26599）

```
关于redmine 26599这个问题是在由于阿拉伯语显示的时候从右往左引起的，而我们其他的语言一般都是从左到右显示的
修改方法：/ddm/packages/apps/Launcher3/AndroidManifest.xml中的com.android.launcher3.LauncherApplication上有个android:supportsRtl="true"这个支持从右往左的功能，所以把这句话去掉就可以了，阿拉伯语的launcher也会从左往右    就不会这个问题了！
```

## 日历中的事件不能通过蓝牙分享（redmine 27043）

```
打开packages/apps/Bluetooth/src/com/android/bluetooth/opp/Constants.java文件，然后 ACCEPTABLE_SHARE_INBOUND_TYPES = new String[] 中加上"text/x-vcalendar",在UNACCEPTABLE_SHARE_INBOUND_TYPES = new String[]中去掉"text/x-vcalendar",这样我们手机就可以通过蓝牙分享接收了，但是分享出去的话只能是同样这样修改的手机才可以！
```

## camera拍照的的咔嚓声音的存储位置

```
adb shell -->cd /system/media/audio/ui
frameworks/av/services/camera/libcameraservice/CameraService.cpp
```

## 1、默认输入法的配置（默认输入法和默认输入法的语言）

```
kk：进入projectConfig.mk文件，搜索DEFAULT_INPUT_METHOD=com.google.android.inputmethod.latin和DEFAULT_LATIN_IME_LANGUAGES=en_US，然后如果输入法是第三方的，必须要把客户提供的第三方软件也要编进去（把该apk放到packages/apps/中，然后在build/target/product/common.mk中也加上，让它编进去）
L、M：请在APK正确预置的前提下，再修改如下
在InputMethodManagerService的systemRunning()函数， if (!mImeSelectedOnBoot) 的分支中修改如下
if (!mImeSelectedOnBoot) {
Slog.w(TAG, "Reset the default IME as \"Resource\" is ready here.");
// String preInstalledImeName = SystemProperties.get("ro.mtk_default_ime");
String preInstalledImeName = "第三方输入法的完整包名ID";
或者直接修改build.prop中的ro.mtk_default_ime属性值，也可在system.prop中增加此属性值。只要修改完后，adb shell getprop ro.mtk_default_ime能获取到正确的预置输入法ID即可。

如何修改默认输入法 请参考FAQ04327
如果按照FAQ04327修改之后不成功，JBX版本请参考FAQ06663，KKX版本请先参考FAQ12213，如果没有FAQ12213中的内容请参考FAQ06663。
如何实现把多个第三方输入法转换为系统输入法，并且在输入法设置时候勾选框默认是勾选的，请参考FAQ08909
Latin输入法怎么默认勾选几种语言，请参考FAQ06649。
Latin输入法如何添加删除某些语言的输入法，请参考FAQ08884
如何添加一个新的Latin输入法语言，请参考FAQ09620

ps：PinyinIME是mtk默认的输入法apk，LatinImeGoogle是google的输入法，两个apk必须预置其中一个
```

## SIM ME lock

```
 一、首先是要下载对应的modem代码，通过shengjun的ppt里面的方法，把该锁的运营商给锁起来（custom/service/nvram/custom_nvram_sec.c这个文件中去锁网的时候最好用一个宏去控制下，做到一个项目一个宏，比如说加个宏__UP11_DDM_A35_EI_SINGLE_TELMA_SIM_LOCK__，然后还要去定义这个宏，那么就要进入make/文件夹中，然后按照其他项目建一个自己项目的.mak文件，再该文件中去定义前面的宏，再该.mak文件中的CUSTOM_OPTION +=后面加上宏），然后用./make.sh .mak(新加的.mak文件) new去编译这个modem，然后按照excel表格去把需要的文件拿出来放到mediatek/custom/common/modem/中
ps：如果是升级下载的话必须还要修改modem的东西，不然的话升级下载后还是没有锁网现象，修改方法
1、trunk/service/nvram/src/nvram_io.c这个文件中加上
#if !defined(__SFR_H502S_SIMUNLOCK__) && !defined(__UP11_DDM_A35_EI_SINGLE_TELMA_SIM_LOCK__)
    EXT_ASSERT(KAL_FALSE, DISPLAY_ERROR(status), NVRAM_LOC_WRITE_IMPORTANT_DATA_FAIL, ldi->LID);
    return status;
#endif
#if !defined(__H5_MTN_SIMLOCK__) && !defined(__UP11_DDM_A35_EI_SINGLE_TELMA_SIM_LOCK__)
    EXT_ASSERT(KAL_FALSE, DISPLAY_ERROR(status), NVRAM_LOC_READ_IMPORTANT_DATA_FAIL, ldi->LID);
#endif
#if !defined(__H5_MTN_SIMLOCK__) && !defined(__UP11_DDM_A35_EI_SINGLE_TELMA_SIM_LOCK__)
    EXT_ASSERT(KAL_FALSE, DISPLAY_ERROR(status), NVRAM_LOC_RESTORE_SUCCESS_READ_FAIL, ldi->LID);(这句话是在kk的版本上必须修改的，不然OTA方式升级没有问题，升级下载方式升级会出问题)
#endif
（具体可以参照kk的modem）
2、trunk/interface/service/nvram/nvram_editor_data_item.h中NVRAM_EF_SML_LID_VERNO加上1，同时用自己modem的宏控制下，
如#elif defined （__UP09L_H401_DDM_SINGLE_SIMLOCK__）
#define NVRAM_EF_SML_LID_VERNO               "008"
二、除了上述的需要修改外还要在上层代码中打开SAGEREAL_SIM_ME_LOCK_SUPPORT = yes
```

## [shell]通过命令查看每个文件夹的大小

```
du -d 1 data/
```


## chip id

```
基带芯片的唯一的chip id（CPUID）
Userdata的backup和restore是读取的chip id，此id在/proc/rid，如果不一样，就不能实现不同机器的userdata backup和restore，请知悉。
```

## [术语]基带

```
Baseband 基带。信源（信息源，也称发终端）发出的没有经过调制（进行频谱搬移和变换）的原始电信号所固有的频带（频率带宽），称为基本频带，简称基带。
```

## 开机状态下拔下电池再插上电池，会自动开机

```
该功能是kk新加的功能，短时间掉电后会自动开机，因此不用修改
```

## Sim卡中的通话记录与NVRAM中通话记录的关系

```
下面通过几个关键点来介绍：
1.Sim卡和NVRAM里面都存放有通话记录，但是Sim卡由于容量限制只存放已拨记录，并且已拨记录只包含名字和号码。
2.当我们进入通话记录菜单的时侯，显示出来的通话记录是从NVRAM里读出来的，当我们产生一个新的通话时，通话记录也是更新到NVRAM里面去。
3.Sim卡的通话记录和NVRAM里面的通话记录会进行同步,这个同步的做法是,关机的时候会把NVRAM的已拨通话记录更新到Sim卡里面去,开机的时候,会先判断Sim卡是否更换，如果更换了，则会删除手机的通话记录，然后将Sim卡的通话记录复制到NVRAM里面。
4.Sim卡通话记录与NVRAM通话记录的同步是可以改变的，在10A上可以通过宏CFG_MMI_CLOG_SIM_SYNC_SUPPORT来控制，但是在10A之前没有类似的宏，所以需要手动修改代码。关机时候的同步过程是在phb_sync_handler里面完成的，所以只需定义__PHB_NVRAM_LN_ONLY__就可以免去这个过程；开机过程的同步是在phb_startup_erase_ln完成的，只要在函数前面加上两条语句直接返回即可：phb_init_ln_confirm(PHB_ERRNO_SUCCESS, control_block);
return;
```

## 在 Launcher 上隐藏某个应用

```
一、如果有APK的源码，只需修改AndroidManifest.xml文件
<activity
    android:name=".Calculator"
    android:label="@string/app_name"
    android:windowSoftInputMode="stateAlwaysHidden">
    <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />   <!--去掉此行-->
        <category android:name="android.intent.category.APP_CALCULATOR" />
    </intent-filter>
</activity>


二、如果不能修改apk的源码，修改Launcher的代码
1. 请修改LauncherModel.java的loadAllApps()方法，如下：
    // Create the ApplicationInfos
    for (int i = 0; i < apps.size(); i++) {
        LauncherActivityInfoCompat app = apps.get(i);
        // This builds the icon bitmaps.
        mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, quietMode));
    }
    //mtk add begin
    mBgAllAppsList.removePackage("PackageName",user,true);
    mBgAllAppsList.added.removeAll(mBgAllAppsList.removed);
    mBgAllAppsList.removed.clear();
    //PackageName为要隐藏的包名
    //mtk add end
}
......
2. 请在LauncherModel.java的PackageUpdatedTask的run()方法开头，将mPackages变量中要求不显示的package name移除掉。 
```

## [shell]如何查看电脑的ip地址等信息

``` bash
ifconfig
```

## 快捷方式不能更新

```
快捷方式不能更新
72KK与82KK有一个共性问题，某些老版本的apk在安装后第一次打开会在Idle界面自动生成一个快捷方式，然后更新此apk，发现自动生成的这个快捷方式图标未更新，QQ新老版本就有这个问题存在；
纠其原因，是因为apk自己生成的那个虽然与应用程序图标相同，但却是一个shortcut，而我们手动拖出来放在桌面上的却是application，而源码中只判断了application，因此造成了这个现象的产生；
现已经在所有KK分支中上传；

该问题并不是很严重，目前只发现QQ满足以下三点：
1.新老版本图标不同
2.打开后会自动在桌面生成图标
3.生成的图标是shortcut类型的
如后续客户在他们自己使用apk的过程中发现了该问题，还请集成组同时更新以下代码：
packages/apps/Launcher3/src/com/android/launcher3/Workspace.java
packages/apps/Launcher2/src/com/android/launcher2/Workspace.java
```

## 如何修改某些plmn(plmn = mcc+mnc)的一些漫游或者显示的文件

```
/frameworks/opt/telephony/src/java/com/android/internal/telephony/gsm/GsmServiceStateTracker.java
N:frameworks/opt/telephony/src/java/com/android/internal/telephony/ServiceStateTracker.java
哪些PLMN（MCC+MNC）想不显示roaming图标就可以在customEhplmn中加上该主运营商和虚拟运营商的plmn就可以了（如果要把某个虚拟运营商去掉roaming图标，也要把主运营商的plmn加上去）
如果要去获取主运营商和虚拟运营商，可以早radio.log中去搜索plmn
MVNO(Mobile Virtaul Network Operator)虚拟网络运营商，没有自己的实体网络，通过租用MNO(Mobile Network Operator)的网络来提供网络服务
[FAQ10438][NW]如何设定忽略国内漫游 ---> SIM卡的MCC跟网络MCC相同时，默认设定不属于漫游，不需要修改。如果需要修改，按照该FAQ，每个平台修改方法不同
```

## [默认值]默认亮度

```
/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
def_screen_brightness
def_screen_brightness_automatic_mode
```

## （信息）在收到内容只有一个“=”的信息后，手机自动重启（redmine 9870）

```
原因：
01-01 03:11:31.515 501 517 E AndroidRuntime: *** FATAL EXCEPTION IN SYSTEM PROCESS: android.server.ServerThread
01-01 03:11:31.515 501 517 E AndroidRuntime: java.lang.RuntimeException: Error receiving broadcast Intent { act=android.provider.Telephony.SMS_RECEIVED flg=0x10 (has extras) } in com.android.server.location.GpsLocationProvider$6@41676700
01-01 03:11:31.515 501 517 E AndroidRuntime: at android.app.LoadedApk$ReceiverDispatcher$Args.run(LoadedApk.java:798)
01-01 03:11:31.515 501 517 E AndroidRuntime: at android.os.Handler.handleCallback(Handler.java:800)
01-01 03:11:31.515 501 517 E AndroidRuntime: at android.os.Handler.dispatchMessage(Handler.java:100)
01-01 03:11:31.515 501 517 E AndroidRuntime: at android.os.Looper.loop(Looper.java:194)
01-01 03:11:31.515 501 517 E AndroidRuntime: at com.android.server.ServerThread.run(SystemServer.java:1303)
01-01 03:11:31.515 501 517 E AndroidRuntime: Caused by: java.lang.ArrayIndexOutOfBoundsException: length=0; index=0
01-01 03:11:31.515 501 517 E AndroidRuntime: at com.android.server.location.GpsLocationProvider.gpsTestMessageParser(GpsLocationProvider.java:1902)
01-01 03:11:31.515 501 517 E AndroidRuntime: at com.android.server.location.GpsLocationProvider.access$2400(GpsLocationProvider.java:98)
01-01 03:11:31.515 501 517 E AndroidRuntime: at com.android.server.location.GpsLocationProvider$6.onReceive(GpsLocationProvider.java:1861)
01-01 03:11:31.515 501 517 E AndroidRuntime: at android.app.LoadedApk$ReceiverDispatcher$Args.run(LoadedApk.java:788)
01-01 03:11:31.515 501 517 E AndroidRuntime: ... 4 more
说明上述原因是数组越界
修改：frameworks/base/services/java/com/android/server/location/GpsLocationProvider.java中
```

## 通过反射调用 SystemProperties

```
Class clazz = Class.forName("android.os.SystemProperties");  -->通过具体类名获取到具体的类
Method method = clazz.getMethod("get", String.class);   -->通过上面拿到的类获取到get方法（String.class是参数的类型，相当于后面的"internal_sd_path"的类型）
String path = (String) method.invoke(clazz, "internal_sd_path"); -->通过上面的类和方法获取到该方法运行后的结果（其中"internal_sd_path"为get里面的参数）
等同于
String path = SystemProperties.get("internal_sd_path");
Log.e("test", path);

ps：有时候google把某些类的方法给@hide了，这就导致我们在其他apk上无法拿到这个方法，这时候就要用到反射
@hide在新的sdk版本上越来越少，因为google会对每一个@hide的方法进行多次验证，如果验证完全没问题了就会把@hide给去掉
```

## 如何获取到phone storage的路径

``` Java
String path = SystemProperties.get("internal_sd_path")，L、M上不可用
```

## 常用运营商制式

```
中国移动：band1、band8
中国联通：band1、band8
美频：band2、band4、band5
欧频：band1、band8
```

## 预置apk的库文件

```
如果apk有库文件怎么办？
如果该apk有lib库的话，也要把这个lib给内置进去，然后android.mk文件也需要修改，具体可参照其他项目的内置lib库的apk中的android.mk（预制在system区需要这个步骤，预制在data区或者vendor下的话就会开机自动去解析lib文件，不会出现找不到lib库报错问题）
库文件加的方法:
include $(CLEAR_VARS)
LOCAL_MODULE := libLCEFnativeU
LOCAL_SRC_FILES := libs/libLCEFnativeU.so
LOCAL_MODULE_SUFFIX := .so
LOCAL_MODULE_CLASS := SHARED_LIBRARIES
LOCAL_MODULE_TAGS := optional
LOCAL_MODULE_PATH := $(PRODUCT_OUT)/system/lib  -->相当于把库放到system/lib中，apk要用到的时候会直接去拿
include $(BUILD_PREBUILT)
或者是把库文件拿出来放到/vendor/mediatek/项目名/artifacts/out/target/product/项目名/system/lib -->相当于把库放到system/lib中，apk要用到的时候会直接去拿

然后把 libLCEFnativeU 添加到 common.mk 或 device.mk 文件中编译


有的时候库文件太多，一个一个解析太麻烦
File file = new File("vendor/mediatek/proprietary/packages/inputmethods/KikaIME/lib");
for (String fileName : file.list()) {
    if (fileName.endsWith(".so")) {
        System.out.println("PRODUCT_COPY_FILES += vendor/mediatek/proprietary/packages/inputmethods/KikaIME/lib/"+fileName+":system/lib/"+fileName);
    }
}
```

## 解析apk包中的文件列表

``` Java
public static void readZipFile2(File file) { 
    try { 
        ZipFile zipfile = new ZipFile(file); //创建ZipFile对象
        System.out.println(zipfile.getName()); //打印Zip文件路径
        System.out.println("ZIP条目数：" + zipfile.size()); //打印Zip文件条目数
        Enumeration<? extends ZipEntry> en = zipfile.entries(); 
        ZipEntry entry; 
        while (en.hasMoreElements()) { 
            entry = (ZipEntry) en.nextElement(); 
            System.out.println(entry.getName()); 
        } 
        zipfile.close(); 
    } catch(ZipException e) { 
        System.out.println(file.getName() + "压缩文件错误"); 
    } catch(IOException e) { 
        System.out.println(file.getName() + "读取文件时出错"); 
    } 
}
```

## 解析apk包中的lib库，并打印到终端

```
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;

public class ParseApk {
	public static void main(String[] args) {
		//System.out.println("args0:"+args[0]);
		if (args == null || args.length == 0 || args[0] == null || !args[0].endsWith(".apk")) {
			System.out.println("Please input right apk path!");
			return;
		}
		
		ArrayList<String> libNames = parseLibFiles(new File(args[0]));
		System.out.println("# add to Android.mk");
		for (String libName : libNames) {
			System.out.println("#################### " + libName + " begin ####################");
			System.out.println("include $(CLEAR_VARS)");
			System.out.println("LOCAL_MODULE := " + libName);
			System.out.println("LOCAL_SRC_FILES := lib/" + libName + ".so");
			System.out.println("LOCAL_MODULE_CLASS := SHARED_LIBRARIES");
			System.out.println("LOCAL_MODULE_TAGS := optional");
			System.out.println("LOCAL_MODULE_SUFFIX := .so");
			System.out.println("LOCAL_MODULE_PATH := $(PRODUCT_OUT)/system/lib");
			System.out.println("include $(BUILD_PREBUILT)");
			System.out.println("#################### " + libName + " end   ####################");
			System.out.println();
		}
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println();
		System.out.println("# add to common.mk");
		for(String libName:libNames){
			System.out.println("PRODUCT_PACKAGES += " + libName);
		}
	}

	public static ArrayList<String> parseLibFiles(File file) {
		ArrayList<String> libNames = new ArrayList<String>();
		try {
			ZipFile zipfile = new ZipFile(file); // 创建ZipFile对象
			// System.out.println(zipfile.getName()); // 打印Zip文件路径
			// System.out.println("ZIP条目数：" + zipfile.size()); // 打印Zip文件条目数
			Enumeration<? extends ZipEntry> en = zipfile.entries();
			ZipEntry entry;
			while (en.hasMoreElements()) {
				entry = (ZipEntry) en.nextElement();
				String entryName = entry.getName();
				if (entryName.contains("lib") && entryName.endsWith(".so")) {
					String libName = entryName.substring(entryName.lastIndexOf("/") + 1).replaceAll(".so", "");
					libNames.add(libName);
				}
			}
			zipfile.close();
		} catch (ZipException e) {
			System.out.println(file.getName() + "压缩文件错误");
		} catch (IOException e) {
			System.out.println(file.getName() + "读取文件时出错");
		}
		return libNames;
	}
}

已经编译打包成 jar 包 parselib.jar
使用方法 java -jar parlib.jar xxx.apk
```

## 修改recovery后怎么快速编译

``` bash
./makeMtk mm bootable/recovery/
./makeMtk -opt=ONE_SHOT_MAKEFILE=build/target/board/Android.mk r recoveryimage
然后把recovery.img单独down进去就行了
```

## Collections.sort() 排序

``` Java
Collections.sort排序
Collections.sort(appsPackageName, comparator);
举例：
ArrayList<String> aa = new ArrayList<String>();
aa.add("1");
aa.add("2");
Collections.sort(aa, comparator );
Comparator<? super String> comparator =  new Comparator<String>() {
    public int compare(String lhs, String rhs) {
        return Integer.valueOf(lhs)-Integer.valueOf(rhs);
    }
};
aa是什么类型的list，那么comparator的方法的参数就是什么类型的，比如说这个是string的list，那么生成的方法的参数就是String类型的，但是该方法返回的是一个int
如果你要排序某些string的数组，那么可以给每个string中做个数字的排序，
HashMap<String, String> hashMap = new HashMap<String, String>();
hashMap.put("packageName","aa");
hashMap.put("index", "1");
ArrayList<HashMap<String, String>> appsPackageName =  new ArrayList<HashMap<String,String>>();
appsPackageName.add(hashMap);
相当于把string中的东西放到hashMap上，然后同时在hashMap中加上一个标记位，然后标记位去通过Collections.sort(aa, comparator );进行比较
```

## 如何使data/nvram中的东西备份到bin区

```
打开 mediatek/custom/common/cgen/CFG_file_info.c 或 mediatek/external/nvram/libcustom_nvram/CFG_file_info.c 文件，然后找到aBackupToBinRegion[]这一个数组
把要备份到bin区写到这里，然后刷IMEI触动备份即可
```

## [FAQ08623]如何在滑动解锁界面添加“紧急拨号”按钮

```
如需在滑动解锁界面添加“紧急拨号”，请修改EmergencyButton.java文件onFinishInflate()方法，将mIsSecure = mLockPatternUtils.isSecure()改为 mIsSecure = true。
```

## 怎样延长锁屏界面显示时间？

```
屏灭状态，按power键，显示锁屏界面，然后又进入灭屏状态，现在显示锁屏界面，到又进入灭屏状态大概5s，怎样延长该时间到15s。
修改KeyguardViewMediator.java中的KEYGUARD_LOCK_AFTER_DELAY_DEFAULT的值
```

## [需求](Factory Mode)All the menus should be in English

```
MTK_FACTORY_MODE_IN_GB2312=no
```

## 通过反射获取 FeatureOption 中的值

``` Java
Class clazz = Class.forName("com.mediatek.common.featureoption.FeatureOption");
Field[] fields = clazz.getDeclaredFields();                 //获取这个类里面的所有变量
for (int i = 0; i < fields.length; i++) {
    if ("boolean".equalsIgnoreCase(fields[i].getType().getName())) {
        builder.append(fields[i].getName() + ":" + fields[i].getBoolean(clazz) + "\n");
    }
}
```

## IO流文件读写模板

``` Java
//读取文件方法1：
private String path = "/sys/devices/platform/pcbid/pcbid"
File file = new File(path);
BufferedReader bufferedReader = null;
if(file.exists()){
    try {
        bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(file)));
        bufferedReader.readLine();
        .....
    } catch (FileNotFoundException e1) {
        // TODO Auto-generated catch block
        e1.printStackTrace();
    }catch (IOException e) {
        // TODO Auto-generated catch block
        e.printStackTrace();
    }
}

读取文件方法2：
private boolean proc_read_flash_light() {
    FileInputStream fileinputstream = null;
    byte abyte0[] = new byte[3];
    try {
        File procFile = new File("/proc/torch_config");
        if (procFile.exists() && procFile.canRead()) {
            fileinputstream = new FileInputStream(procFile);
            fileinputstream.read(abyte0);
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        try {
            if (fileinputstream != null) {
                fileinputstream.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return abyte0[2] == 0x31 ? true : false;
}
    
写入文件方法1：
final File file = new File("/storage/sdcard0/jcb.txt");
try {
    FileOutputStream fileOutputStream = new FileOutputStream(file);
    fileOutputStream.write(aa.getBytes());
    fileOutputStream.close();
} catch (FileNotFoundException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
}

写入文件方法2：
private void proc_write_flash_light(boolean state) {
    FileOutputStream fileoutputstream=null;
        
    byte abyte0[] = new byte[1];
    if(state)
        abyte0[0] = 0x31;
    else
        abyte0[0] = 0x30;
        
    try {
        File procFile = new File("/proc/torch_config");
        if(procFile.exists() && procFile.canWrite()) {
            fileoutputstream = new FileOutputStream(procFile);
            fileoutputstream.write(abyte0);
            fileoutputstream.flush();
        }
    } catch (Exception e) {
        e.printStackTrace();
    } finally{
        try {
            if(fileoutputstream != null){
                fileoutputstream.close();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

ps：新建文件的方法
private String path = "/sys/devices/platform/pcbid/pcbid";
File file = new File(path);
file.createNewFile();当然当使用new FileOutputStream(file)方法的时候也是会默认新建文件到指定路径的
```

## 如何使屏幕不灭屏

``` Java
getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);-->保持屏幕不灭屏
```

## 无法抓取log时将log写入到文件中的方法

``` Java
public static void Log(String tag, String str) {
    File file = null;
    try {
        file = new File("storage/sdcard0/log.txt");
        if(!file.exists()) {
            file.createNewFile();
        }
    } catch (IOException e1) {
        e1.printStackTrace();
    }
    if (file == null) {
        return;
    }
    FileWriter fw = null;
    try {
        fw = new FileWriter(file, true);
        fw.append("\n" + System.currentTimeMillis() + "\t" + tag + ",\t" + str);
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (fw != null) {
            try {
                fw.flush();
                fw.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
            fw = null;
        }
    }
}
```

## watchDog的作用

```
Watchdog目的是监控系统几个比较主要的service，如果超过一定时间没有反应，认为系统出错，会强制重启Android.
```

## L项目文件获取写入权限：

```
[FAQ13635]Android L APP 如何获取sys file system 中节点的写权限+SELinux_Policy_Editing_Guideline这个文档
device/mediatek/common/sepolicy/system_app.te
```

## 手机安装apk的代码：/packages/apps/PackageInstaller/src/com/android/packageinstaller/

```
在PackageInstallerActivity.java这个Activity中：
1.首先检查所要安装的程序是否是正确的安装文件
2.判断安装应用是否设置未知来源应用的安装判断：isInstallingUnknownAppsAllowed()
3.当前系统中是否已安装了此应用程序，提示用户是否重复安装
4.还获取所欲安装的程序所将要用到的权限，然后将这些信息通过一个对话框提示给用户，startInstallConfirm()
然后当用户确定安装时，启动packages/apps/PackageInstaller/src/com/android/packageinstaller/InstallAppProgress.java，在这个Activity中，系统调用
pm.installPackageWithVerificationAndEncryption(mPackageUri,observer,installFlags,installerPackageName);-->该方法实现在packageManagerService.java中，即进行安装
```

## 结束当前程序的进程

``` Java
android.os.Process.killProcess(android.os.Process.myPid());
```

## 如何让 app 自行处理 power key

```
Power key 通常都是由 framework 自行的
app 无法拿到这个 key 值
如果想让某个 app 自行处理 power key
应该要怎么做呢?

L、M
修改PhoneWindowManager的interceptKeyBeforeQueueing方法：
....
case KeyEvent.KEYCODE_POWER: {
    result &= ~ACTION_PASS_TO_USER;
    isWakeKey = false; // wake-up will be handled separately
    //com.example.adc 为要处理power key的包名
    if (win != null && win.getAttrs() != null && win.getOwningPackage().equals("com.example.adc")) {
        return 1;// return 1事件就传给app处理
    }
    if (down) {
        interceptPowerKeyDown(event, interactive);
    } else {
        interceptPowerKeyUp(event, interactive, canceled);
    }
    break;
}
 
如果只想让power键让某个Activity处理，将以上的if条件改为：
if(win != null && win.getAttrs() != null&&win.getAttrs().getTitle().equals("xxx.xxx.xxx.xxxActivity")){
    return 1;// return 1 就会传给 xxx.xxx.xxx.xxxActivity处理
}
 
KK、JB
1: 修改 phoneWindowManager.java 的 interceptKeyBeforeQueueing 方法,在 reference line 后加入下面这段代码
case KeyEvent.KEYCODE_POWER: { //reference line
    result &= ~ACTION_PASS_TO_USER; //reference line
    // add begin
    ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
    try {
        if (activityManager.getRunningTasks(1).get(0).topActivity.getPackageName().equals("your_special_package_name")) { 
            //Please reset the special package name.
            result |= ACTION_PASS_TO_USER;
            Xlog.d(TAG,"detect power key in special package, pass to user!")
        }
    }catch(NullPointerException e){
        Xlog.d(TAG,"ingore a NullPointerException ..");
    }
    //add end
 
2: 同样在此分支内, 找到 else 语句段, 并找到如下位置加入
if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) { //参考行
    if(!((result & ACTION_PASS_TO_USER) == ACTION_PASS_TO_USER)){ //加入行
        result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP; //原有代码
    } //加入行
}
```

## ro值修改位置（KK）

```
ro.build.display.id -->相当于版本号，可直接修改ProjectConfig.mk文件中的CUSTOM_BUILD_VERNO，CUSTOM_BUILD_VERNO1，CUSTOM_BUILD_VERNO2
ro.product.model -->/build/target/product/up29_h403_ddm.mk中
ro.product.name -->ProjectConfig.mk文件中SAGEREAL_PRODUCT_NAME
ro.product.device -->ProjectConfig.mk文件中SAGEREAL_TARGET_DEVICE
ro.product.board -->ProjectConfig.mk文件中SAGEREAL_TARGET_DEVICE
ro.product.locale.language -->/build/core/Makefile中可搜索define default-locale-language，其中后面的$是指取出的值赋值给default-locale-language
ro.product.locale.region  -->/build/core/Makefile中可搜索define default-locale-region，其中后面的$是指取出的值赋值给default-locale-region
ro.build.product -->ProjectConfig.mk文件中SAGEREAL_TARGET_DEVICE
ro.build.fingerprint --> /build/core/Makefile中可搜索BUILD_FINGERPRINT
```

## *.mk中加宏的时候

```
ifdef MTK_WEATHER_PROVIDER_APP   -->先判定是否有宏
    ifneq ($(strip $(MTK_WEATHER_PROVIDER_APP)), no)   -->再判断宏的值
        PRODUCT_PACKAGES += MtkWeatherProvider
    endif
endif

ifneq (yes, $(strip $(BUILD_CLARO_GMS)))     --> 当BUILD_CLARO_GM不是yes的情况下，怎么样，其他情况怎么样
    $(shell rm -r $(TOPDIR)vendor/claro_gms)
else
    $(shell cp $(TOPDIR)mediatek/config/$(PROJECT)/sagereal_copy/vendor/claro_gms/apps/Android_gms.mk $(TOPDIR)vendor/claro_gms/google/apps/Android.mk)
endif
ps：BUILD_CLARO_GMS在common.mk里面如果其他项目的projectConfig.mk文件中没有定义这个宏，也不会报错，直接当成no，如果是java宏的话一定要去判断ifdef BUILD_CLARO_GMS，不然某些项目没有定义这个宏，就会报错 
```

## 如何获取可用内存

``` Java
private long getAvailMemory(Context context) {
    String path = "/proc/meminfo";
    String[] arrayOfString = null;
    File file = new File(path);
    BufferedReader bufferedReader = null;
    InputStreamReader inputStreamReader = null;
    long avail_memory = 0;
    try {
        inputStreamReader = new InputStreamReader(new FileInputStream(file));
    } catch (FileNotFoundException e2) {
        // TODO Auto-generated catch block
        android.util.Log.d("jcb", "e2 =", e2);
        e2.printStackTrace();
    }
    if (file.exists()) {
        bufferedReader = new BufferedReader(inputStreamReader);
        String readLine = null;
        try {
            for(int i = 0 ; i<2 ; i++){
                readLine = bufferedReader.readLine();
            }
            android.util.Log.d("jcb", "readLine = "+readLine);
            arrayOfString = readLine.split("\\s+");
            avail_memory = Integer.valueOf(arrayOfString[1]).intValue() * 1024;
        } catch (IOException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
            android.util.Log.d("jcb", "e1 =", e1);
        }
        android.util.Log.d("jcb", "getAvailMemory readLine = " + arrayOfString[1]);
        android.util.Log.d("jcb","getAvailMemory = "+ Formatter.formatFileSize(context,avail_memory));
    }
    return avail_memory;
}
```

## 如何获取总内存

``` Java
private long getTotalMemory(Context context) {
    // 获取android当前可用内存大小
    String path = "/proc/meminfo";
    String[] arrayOfString = null;
    File file = new File(path);
    BufferedReader bufferedReader = null;
    InputStreamReader inputStreamReader = null;
    long initial_memory = 0;
    try {
        inputStreamReader = new InputStreamReader(new FileInputStream(file));
    } catch (FileNotFoundException e2) {
        // TODO Auto-generated catch block
        android.util.Log.d("jcb", "e2 =", e2);
        e2.printStackTrace();
    }
    if (file.exists()) {
        bufferedReader = new BufferedReader(inputStreamReader);
        String readLine = null;
        try {
            readLine = bufferedReader.readLine();
            android.util.Log.d("jcb", "readLine = "+readLine);
            arrayOfString = readLine.split("\\s+");
            initial_memory = Integer.valueOf(arrayOfString[1]).intValue() * 1024;
        } catch (IOException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
            android.util.Log.d("jcb", "e1 =", e1);
        }
        android.util.Log.d("jcb", "readLine = " + arrayOfString[1]);
        android.util.Log.d("jcb","getTotalMemory = "+ Formatter.formatFileSize(context,initial_memory));
    }
    return initial_memory;
}
```

## [FAQ03065]如何开启或隐藏 Navigation Bar

```
第一步：修改系统变量。
打开目录下文件：alps/device/mediatek/工程名字/system.prop
修改变量值：qemu.hw.mainkeys=0
qemu.hw.mainkeys=1   表示隐藏Navigationbar
qemu.hw.mainkeys= 0   表示显示Navigationbar
注意： 如果工程没有定义该变量，再进行第二步。否则修改结束。因系统变量优先级比配置文件高。

第二步：修改配置文件。
frameworks/base/core/res/res/values/config.xml
device/mediatek/common/overlay/navbar/frameworks/base/core/res/res/values/config.xml
修改 config 文件中的 config_showNavigationBar 的值。

隐藏Navigationbar：

<bool name=“config_showNavigationBar”>false</bool>
将这个配置信息修改为false即可。

显示Navigationbar：
<bool name=“config_showNavigationBar”>true</bool>

将这个配置信息修改为true即可。

特别的，对于O版本还要修改如下：
O版本主要是google 设计默认有navigationbar，所以没有判断mNavigationBar 这个window 为null，还请修改如下，
如果还有其他异常报错请贵司按照这个mWindowManagerService.hasNavigationBar()办法来规避即可。
frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java
frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBar.java
public NavigationBarView getNavigationBarView() {
    // return (NavigationBarView) mNavigationBar.getView(); 修改为下面：
    boolean showNav = mWindowManagerService.hasNavigationBar();
    if(showNav) {
        mNavigationBar.onKeyguardOccludedChanged(keyguardOccluded);
    } else {
        return null; 
    }
}

public void onKeyguardOccludedChanged(boolean keyguardOccluded) {
    //mNavigationBar.onKeyguardOccludedChanged(keyguardOccluded);修改如下：
    boolean showNav = mWindowManagerService.hasNavigationBar();
    if(showNav) {
        mNavigationBar.onKeyguardOccludedChanged(keyguardOccluded);
    }
}
```

## 如何在L上预置图片且恢复出厂设置不会消失

```
先在data/media中预置图片，然后在system/vendor下面预置图片，然后在恢复出厂设置的时候去调用recovery.cpp文件，在该文件中自己写方法把system/vendor下面的图片还原到data/media下面
具体可以看/home/jiangcunbin/Desktop/sagereal资料/自己总结/他人培训/预置资源
ps:刷机进去后到开机不会进入recovery模式，也就是说不会调用recovery.cpp文件，但是在恢复出厂设置的时候是会进入recovery模式的，会调用recovery.cpp文件
提交记录：http://192.168.3.76:8007/gitweb/?p=ALPS-MP-N0.MP2-V1_SR6580_WE_N.git;a=commit;h=bb723f9be5edf6c5ccaaf04e5240d11fa6060691
```

## [shell]使用终端查看ascii码

```
在终端中输入man ascii，然后hex列代表16进制，比如说那边写的31，我们在代码中使用要写0x31;Dec列为10进制，可以直接写
```

## L项目上如何让手机能充电

```
把 alps/kernel-3.10/drivers/misc/mediatek/mach/mt6735/include/mach/upmu_sw.h 文件中关闭宏 BATTERY_CDP_WORKAROUND  就可以充电了
```

## [FAQ12075]如何让 keguard run 在 com.android.keyguard 进程

```
如何让 keguard run 在 com.android.keyguard 进程
KK 上, keyguard 默认会 run 在 com.android.systemui 进程中如果需要将 keyguard run 在 com.android.keyguard 进程中，请修改

alps/frameworks/base/packages/Keyguard/res/values/mtk_config.xml
-<string name="keyguard_process_name">com.android.systemui</string>
+<string name="keyguard_process_name">com.android.keyguard</string>

PS:L上keyguard作为SystemUI的一个lib,不再是一个独立的apk,不能运行在单独的进程。
```

## 开机进入桌面，会先出现壁纸，而后状态栏空白透明，屏幕其他地方为黑色，之后进入锁屏界面。这一概率比较大

```
期望：希望不要出现状态栏透明空白，其他地方却是黑色
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarWindowView.java
public class StatusBarWindowView extends FrameLayout {
    onAttachedToWindow(){
    ...
    //WindowManagerGlobal.getInstance().changeCanvasOpacity(windowToken, true); 注释掉这句，设置不透明.
    setWillNotDraw(false);
} else {
    ...
}
```

## [adb]通过命令启动 Service

``` bash
adb shell am startservice -n "包名类名"   ----> service
```

## 阿拉伯语下文字布局等相反，有些布局显示不正常，可采用如下方式优化：

```
1.Androidmanifest中设置android:supportsRtl="true"， 找到显示异常的布局，将其中的left，right等标签修改为start， end标签
eg: android:layout_marginStart替换android:layout_marginLeft, android:layout_alignParentStart替换android:layout_alignParentLeft

2.图片若显示异常，可尝试将图片修改正常，放置res下带有ldrtl的文件夹中，具体根据手机分辨率放置
eg：res/drawable-ldrtl-hdpi

3.重写 public void onRtlPropertiesChanged(int layoutDirection)， 根据layoutDirection判断
layoutDirection = 1， 则为rtl
layoutDirection = 0， 则为ltr

4.可根据Configuration的getLayoutDirection()方法获取是否是View.LAYOUT_DIRECTION_RTL
RTL     right-> left
LTR     left-> right
```

## 如何去看调用的是drawable_hdpi还是drawable_xdpi等？

```
alps/device/mediatek/common/aapt/aapt_config.mk
```

## preference设置后如何保存到sharedPrefence的文件中

```
在布局文件中加上android:persistent="true"，如果为false就不会保存到sharedPrefence
```

## 系统数据库对多媒体文件已经进行了归类，我们使用它就可以了。

```
String volumeName = "external";
获取音频
Uri uri = Audio.Media.getContentUri(volumeName);
获取视频
uri = Video.Media.getContentUri(volumeName);
获取图片
uri = Images.Media.getContentUri(volumeName);
获取所有文件
uri = Files.getContentUri(volumeName);
可以看出音频，视频，图片已经完全被系统归类好了，对于apk,doc, zip等文件，我们可以根据它们的后缀在uri = Files.getContentUri(volumeName);里面进行筛选，获得我们想要的数据
```

## 系统媒体数据库无法扫描到数据

```
1.插入一张SDCARD
2.push 3000左右图片到sdcard
3.重启
4.观察发现手机不能读取到图片数据 （读取方法：Images.Media.getContentUri(“external”)获取uri, 然后读取数据库）
5.push 1首歌曲
6.重启进入music,等待扫描结束,music不能显示歌曲

根本原因是：
多媒体文件所在目录下有.nomedia文件，因此，MediaProvider会把该目录的文件识别为普通文件，具体表现是在db文件中media_type的值为0； 因此在image、video 、audio等视图中通过type查询时，是查询不到信息的。 该问题的原因就在目录中有了.nomedia文件

.nomedia产生的原因：
在MediaProvider.apk中是不会自动添加该文件的； 一般.nomedia文件是由其他apk的一些设置等操作才会添加。由于缺乏信息且无法复现，无法分析是什么产生的。
```

## Webview是用来浏览网页或浏览文件使用，使用google webview会有以下两问题：

```
1.打开中文电子书乱码
2.浏览器输入 186.148.57.28/browser/httpreq，查看UAPROFILE为Unknow
```

## [UserAgent][UA]UA相关

```
UserAgent：Http协议中的一部分，属于头域的组成部分，是一种向访问网站提供你所使用的浏览器类型、操作系统及版本、CPU类型、浏览器渲染引擎、浏览器语言、浏览器插件等信息的标识。UA字符串在每次浏览器HTTP请求时发送到服务器。
ex:browser.UserAgent = Athens15_TD/V2 Linux/3.0.13 Android/4.0 Release/02.15.2012 Browser/AppleWebKit534.30 Mobile Safari/534.30 System/Android 4.0.1;
mms.UserAgent = Android-Mms/2.0
UAProfileURL是一个相当于放在某个服务器的UAProfile的网址，如http://218.249.47.94/Xianghe/MTK_Phone_KK_UAprofile.xml
UAProfile就是上面的MTK_Phone_KK_UAprofile.xml文件，该文件中有终端机的一下信息：
1、硬件信息：制造厂商、类型、屏幕大小（像素、文字等）
2、软件信息：应用软件管理版本、SK-VM版本、MIN
UAProfile文件描述了手机的功能，包括供应商、型号、分辨率、多媒体功能、支持字符集等

[FAQ13899][VS]RTSP流媒体UA/UAProfile修改方法
[FAQ04656]如何修改Android自带浏览器的User Agent

可以查看 UA 的网址
186.148.57.28/browser/httpreq   //不可用了～
www.ua.yeswap.com
www.show-ip.net/browserinfo     //不可用了～

browser.UserAgent所在位置
alps/device/sagetel/sr6572_wet_l/custom.conf中的
#browser.UserAgent = Athens15_TD/V2 Linux/3.0.13 Android/4.0 Release/02.15.2012 Browser/AppleWebKit534.30 Mobile Safari/534.30 System/Android 4.0.1;
browser.UAProfileURL = http://218.249.47.94/Xianghe/MTK_Phone_KK_UAprofile.xml
mms.UserAgent = Android-Mms/0.1
mms.UAProfileURL = http://www.google.com/oha/rdf/ua-profile-kila.xml

//通过代码获取 UA
public String getUserAgent() {
    String user_agent = ProductProperties.get(ProductProperties.USER_AGENT_KEY, null);
    return user_agent;
}
```

## 以下是根据早前的mtk分析kazam网络问题导致modem重启得到的经验，我们也可以根据以下信息对后续的丢信号问题进行分析

```
1.在radio log中查找关键字updateDataStallInfo
如果出现连续的一片只有out的情况updateDataStallInfo: OUT
则说明网络出了问题，只有发出去的数据，却没有收到回复；
正常的应该是updateDataStallInfo: IN/OUT

2.搜索关键字onDataStallAlarm
06-04 12:09:17.374: D/DCT(1189): [0]onDataStallAlarm: tag=28495 do recovery action=3
在KK中当这个recovery action为3时，会去reset radio
在L中当这个recovery action为4时，会去reset radio
当达到次数条件时，会出现如下log：
06-04 12:10:49.618: D/DCT(1189): [0]restarting radio with gsm.radioreset to true
06-04 12:10:50.621: D/DCT(1189): [0]restartRadio: ************TURN OFF RADIO**************

3.在mainlog中同步搜索socket：
06-04 12:10:20.674: I/System.out(1550): [socket][157] connection www.google.com/216.58.221.132:443;LocalPort=36353(30000)
可以看到它都是在尝试与谷歌的地址链接，确定引起问题的原因
```

## 如何在log中分析网络是否为3g

```
打开radio_log，然后搜索“networktype =”即可
```

## 如何调整横竖屏

```
1、android:screenOrientation="landscape"（"portrait"）
2、setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
3、横竖屏切换的时候先会去调用onSaveInstanceState(Bundle outState)方法，然后切换好了onRestoreInstanceState(Bundle savedInstanceState)
注意：可以通过outState的putInt，以及savedInstanceState的getint来传输数据
4、android:configChanges="orientation"，然后切换横竖屏的时候可以去重写onConfigurationChanged(Configuration newConfig)方法
```

## 发送开机广播的位置

```
frameworks/base/packages/SystemUI/src/com/android/systemui/keyguard/KeyguardViewMediator.java  -->  onBootCompleted() 方法里面进行开机广播的发送
```

## [默认值]USB连接方式，CD-ROM

```
mediatek/config/mq16_h451_t3_p/system.prop 中搜索 ro.sys.usb.storage.type，然后在后面可以加上你想加的选择项 mtp,mass_storage
usb、mtp ：真正修改的地方：device/sagetel/$base_project/system.prop中的ro.sys.usb.storage.type值设为mtp,mass_storage，现在都用宏控，即config_usbtype=mtp,mass_storage
如何选择默认选择为usb：用宏控MTK_MASS_STORAGE = yes
cd rom：真正修改的地方：device/sagetel/$base_project/system.prop中的ro.sys.usb.bicr设为yes，现在都用宏控，即ro_sys_usb_bicr=yes
```

## [默认值]如何使Settings --> Security --> Lock screen = None

```
frameworks/base/packages/SettingsProvider/res/values/defaults.xml 中的 def_lockscreen_disabled 改为 true
```

## git 终端显示颜色

```
git config --global color.ui true
```

## L项目的falsh的配置怎么看

```
ProjectConfig.mk文件--> sagereal_memory_flash = EMMC_64_8（8G+1G）、EMMC_32_4（4G+512M）、EMMC_16GB_2GB（16G+2G）
```

## [FAQ09022]如何调整锁屏界面的背景亮度

```
锁屏和launcher一样，都是透到wallpaper上的.但是同样一张wallpaper背景图片，在锁屏界面上看起来要比launcher暗一些。这是因为锁屏界面设置了一个半透明的灰色背景色0X70000000。
如果需要调整锁屏界面的背景色，可以通过调整KeyguardViewBase.java中BACKGROUND_COLOR的值。

L上的修改参考如下:
ScrimView.java()
private float mViewAlpha = 1.0f; // 将1.0f修改为0.0f.
```

## user版本和eng版本的区别, UserDebug版本呢？？？？？

```
1.user 版本为提高第一次开机速度，使用了ART 的预优化，将dex 文件分解成可直接load 运行的odex 文件；ENG 版本不会开启这项优化，每次开机都会从apk包解析出dex文件，执行的是dex文件，降低运行速度。
2.user版本更少的LOG 打印，UART 的关闭。UART，是一种异步收发传输器。
3.ART执行的区别
user：首次开机执行一次，apk->dex->odex->被ART执行  ----->直接被优化为odex后，一直不用去apk中提取dex，直接运行odex文件就可以了，这样速度就快了
eng：每次执行，apk->dex->被ART执行
4.编译路径区别
User版：64位路径：out/.../system/app/arm64/***.odex
32位路径：out/.../system/app/arm/***.odex
User版本的32位apk在64位系统环境下编译时，默认被编译解析为64位路径。当运行时找不到其32位的默认路径，报错。在Android.mk文件中加入LOCAL_MULTILIB := 32，可以编译解析为32位路径，运行不报错。
Eng版本没有32位和64位区分，运行不报错
5、如何分辨32位和64位系统
1.ProjectConfig.mk文件中，MTK_K64_SUPPORT = yes/no
2.在sagereal/mk/项目名/full_sr67**m_**gu_l.mk中，
# Inherit for devices that support 64-bit primary and 32-bit secondary zygote startup script
$(call inherit-product, $(SRC_TARGET_DIR)/product/core_64_bit.mk)
有以上这句话的是64位系统，反之没有这句话是32位系统。
3. 在alps/device/sagetel/     sr6735m_35gu_l（32位系统）     sr6735m_65u_l（64位系统）
4. 在当前手机中查看。输入adb shell---->cd system----->ls----->看到lib(lib64)，32位系统没有lib64文件夹，64位系统含有lib和lib64文件夹
```

## sharedUserID 的使用

```
Android提供了如下的一种机制，可以使两个apk打破前面讲的这种壁垒，只有相同签名和相同sharedUserID标签的两个应用程序签名才会被分配相同的用户ID。
在AndroidManifest.xml中利用sharedUserId属性给不同的package分配相同的userID，通过这样做，两个package可以被当做同一个程序，系统会分配给两个程序相同的UserID。当然，基于安全考虑，两个package需要有相同的签名，否则没有验证也就没有意义了。
如果增加了上面的属性但没有定义与之对应的LOCAL_CERTIFICATE（android.mk）的话，APK是安装不上去的。提示错误是：Package com.test.MyTest has no signatures that match those in shared user android.uid.system; ignoring!（也就是上面说的需要两个相同的签名），例如所有和media/download相关的APK都使用android.media作为sharedUserId的话，那么它们必须有相同的签名media。
关于签名： build/target/product/security目录中有四组默认签名供Android.mk在编译APK使用： 
1、testkey/releasekey：普通APK，默认情况下使用。
2、platform：该APK完成一些系统的核心功能。经过对系统中存在的文件夹的访问测试，这种方式编译出来的APK所在进程的UID为system。 
3、shared：该APK需要和home/contacts进程共享数据。 
4、media：该APK是media/download系统中的一环。 
应用程序的Android.mk中有一个LOCAL_CERTIFICATE字段，由它指定用哪个key签名，未指定的默认用testkey（但是当MTK_SIGNATURE_CUSTOMIZATION这个宏打开后，未指定的默认的会用releasekey，不懂看第五百四十六条即可）. 对于使用eclipse编译的apk，可以使用signapk.jar来手动进行签名
platform和shared对应签名文件的key都放在alps/build/target/product/security/common下，如platform.x509.pem、platform.pk8、shared.x509.pem、shared.pk8
签名工具signapk.jar位于/out/host/linux-x86/framework 下，由alps/build/tools/signapk/生成​。

ps：当打开MTK_SIGNATURE_CUSTOMIZATION这个宏时会直接使用device/mediatek/common/security/sr6580_we_n下面的key去进行签名，如果关闭MTK_SIGNATURE_CUSTOMIZATION这个宏时会直接使用MTK默认的key去签名，即build/target/product/security下面的，device/mediatek/common/security/sr6580_we_n下面的keyplatform.x509.pem、platform.pk8等这些是梁爽做出来的，同平台的应该都是一样的

使用方法：
1、以platform为例：java -jar signapk.jar platform.x509.pem platform.pk8 input.apk output.apk (platform.x509.pem platform.pk8在build/target/product/security获取)
2、以shared为例：用 shared.x509.pem和shared.pk8来签名 Contacts.apk，重新签名之后的apk名字为Contacts_2.apk 
java -jar signapk.jar shared.x509.pem shared.pk8 Contacts.apk Contacts_2.apk 

ps：如果在AndroidManifest.xml和android.mk中都进行了修改，可以把该apk预置到手机中，这样在编译整个项目的时候会去编译这个apk，这样就会按照android.mk中的LOCAL_CERTIFICATE进行平台签名，如果不内置直接对apk进行签名，这时候就要用signapk.jar来手动进行签名，步骤在上面。

LOCAL_CERTIFICATE := PRESIGNED 表示 这个apk已经签过名了，系统不需要再次签名；

关于apk的签名
1、第三方的apk用eclipse生成后可以直接install到手机中，我们如果不再eclipse里面特地的生成签名，那就默认会使用debug的签名；当然可以直接在生成apk的时候生成有自己个人信息的正式签名
2、第三方的apk用客户提供的keystore签名，会出现两种情况，如果该apk中没有使用shareduserid，那就可以直接install到手机上；如果该apk中使用了shareduserid（system）,这时候需要在keystore的基础上再进行平台签名，才能install到手机中
3、第三方的apk直接用平台签名可以直接install到手机中
```

## 如何实现每台手机的序列号唯一？

```
KK：alps/mediatek/platform/mt65**/ kernel/core/mt_devs.c中定义CONFIG_MTK_USB_UNIQUE_SERIAL
L ：alps/bootable/bootloader/lk/app/mt_boot/mt_boot.c中定义CONFIG_MTK_USB_UNIQUE_SERIAL
M ：alps/vendor/mediatek/proprietary/bootable/bootloader/lk/app/mt_boot/mt_boot.c 中定义CONFIG_MTK_USB_UNIQUE_SERIAL

PS：在c文件中定义该CONFIG_MTK_USB_UNIQUE_SERIAL，即为#define CONFIG_MTK_USB_UNIQUE_SERIAL

FAQ10923[USB serial number客制化][系列2]：如何实现每台手机的序列号唯一？10924[USB serial number客制化][系列3]：如何修改手机序列号为Barcode ？
FAQ10925[USB serial number客制化][系列4]：如何修改手机序列号为手机型号？
FAQ10926[USB serial number客制化][系列5]：如何实现可以通过pc工具来修改serial number？
FAQ10927[USB serial number客制化][系列6]：能否实现adb devices的序列号，usb serial number, cts device ID，SN一致？
```

## [术语]UUID

```
UUID是一个128位长的数字,用16进制表示，然后是电脑随机生成的一个值，是结合机器的网卡、当地时间、一个随机数生成的，能保证3240年不重复，相当于一个永不重复的随机数
```

## 文件监听

```
当删除文件管理器上的音乐文件的时候，数据库会发生改变，可监听 Uri.parse("content://media/external/file") 这个uri的数据库
```

## permission和uses-permission的区别

```
两者之间的不同之一就是，作用域不同，在 manifest.xml文件中，<uses-permission>是和<application>同级的节点，一般<uses-permission >是在</application>后面的。但<permission>就不同了，是定义在<application>和</application>之间，和Activity、Service同级别的，同时使用 group的权限组可以大幅减少你同类型相似权限的声明。
其二可能就是<uses-permission>是官方定义的权限，<permission>是自己定义的权限。
ps：uses-permission这个是给整个apk用的权限，permission是给自己activity或者service使用的权限
```

## 如何预置wifi热点  （redmine55627）

```
kk：/mediatek/external/mtk_wifi/config/mtk-wpa_supplicant.conf
l：请在alps/hardware/mediatek/wlan/config/mtk-wpa_supplicant.conf
m:alps/vendor/mediatek/proprietary/hardware/connectivity/wlan/config/mtk-wpa_supplicant.conf
文件中增加network={} 即可。
network={
 	ssid="aaaa"
 	scan_ssid=1
 	key_mgmt=NONE
}
ps：Wifi的预置说明也可以查看/alps/hardware/mediatek/wlan/wpa_suppli_8/wpa_supplicant/wpa_supplicant.conf

ps:ps:ps:在增加这个wifi热点的时候，一定要加上节省功耗的操作，文件路径：
kk：external/wpa_supplicant_8/wpa_supplicant/wpa_supplicant.c，在ssid_len == os_strlen("CMCC")判断之后，加上如下代码
if(ssid_len == os_strlen("MEO-WiFi.x")){
   if(os_strncasecmp(cmcc_conf->ssid,"MEO-WiFi.x",ssid_len) == 0){
       tmp = cmcc_conf->next;
       removed = 1;
       wpa_config_remove_network(wpa_s->conf, cmcc_conf->id);
       if(wpa_s->conf->update_config){
           if(wpa_config_write(wpa_s->confname, wpa_s->conf)){
               wpa_printf(MSG_DEBUG,"CTRL_IFACE:SAVE_CONFIG - Failed to update configuration");
           }else{
               wpa_printf(MSG_DEBUG,"CTRL_IFACE:SAVE_CONFIG -Configuration updated");
           }
       }
   }
}
[ALPS02441559] 预制WIFI热点造成功耗过大问题
[ALPS02399488] 预制WIFI热点造成功耗过大问题
M:external/wpa_supplicant_8/wpa_supplicant/wpa_supplicant.c,在wpa_supplicant_init_iface
Redmine 63933[bug]wifi有时不能自动连接上
```

## 识别SIM卡的位置

```
SIM卡识别位置寻找与开机类似，我们知道SIM卡状态变化时会有 android.intent.action.SIM_STATE_CHANGED，这样我们就可以找发出此广播的地方：
alps/frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/IccCardProxy.java 其中有一个方法为 broadcastIccStateChangedIntent()
```

## 开机顺序

```
开机顺序：
IccCardProxy（在亮屏之前会有消息，在手机运行过程中sim卡状态改变也会有消息）---主要用来读取数据，也需要启动动画
doKeyguardLocked（在亮屏之前）
finishBooting（在亮屏之后一小段时间）---启动动画
```

## 如何自定义google launcher的桌面

```
自己写一个apk（比如说packages/apps/SageRealApp/GoogleHomeCustomization/），这个apk的里面是一个广播接收器，action为com.android.launcher3.action.PARTNER_CUSTOMIZATION
```

## Handler.post(runnable)和 new Thread(runnable)的区别

```
mHandler.post(mMeoRunnable);这个是没有启动新的线程，还是在原来线程中，用这个的好处主要是可以在非ui线程中修改ui
new Thread(runnable)，这个是直接启动新的线程
```

## 防止用户在最近应用程序列表中看到

```
在 activity 中请加入 android:excludeFromRecents="true" 属性
```

## M项目上关于settingsProvider是在哪里？

```
adb shell --> data/system/user/0
android N后某些数据库位置：
Google Now Launcher数据库存放位置  ---->  /data/data/com.google.android.googlequicksearchbox/databases/launcher.db
ContactsProvider ----->  contacts.db和callog.db都位于data/user/0/com.android.providers.contacts/databases
TelephonyProvider -----> data/user_de/0/com.android.providers.telephony/databases
MediaProvider -----> data/user/userid/com.android.providers.media/databases
```

## 如何设置fm、music的耳机声音提示等级

```
frameworks/base/core/res/res/values/config.xml 中的 config_safe_media_volume_index 值
```

## 手机加密默认开关方法：

```
/device/sagetel/sr6735m_35gu_l/fstab.mt6735，encryptable=/dev/block/platform/mtk-msdc.0/by-name/metadata表示默认关闭，而替换成forceencrypt表示默认开启
该文件可能位于project、platform、common下，优先级从前到后，以优先级最高的属性为准
手动开启加密方法：
1.电量在80%以上
2.连接usb或者充电器
3.设置锁定屏幕 PIN 或密码
点击加密菜单进行加密，刚刚刷的软件一般加密需要几分钟时间，加密成功后会自动重启手机，再进入菜单会显示“已加密”，菜单点击无效

此功能可以用来加密手机上的所有数据，包括 Google 帐户、应用数据、音乐和其他媒体信息、已下载的信息等。如果执行了加密操作，您每次开机时都必须输入数字 PIN 或密码。
请注意，上述 PIN 或密码与您在未加密状态下解锁手机时所用的相同，无法单独设置。
警告：加密操作无法撤消。要将手机恢复为未加密状态，唯一的方法是恢复出厂设置，但这会清除您的所有数据

三百四十四、客户希望在通话过程中我方开始录音时，对方能够收到提示音；
我们发现在通话过程中点击拨号盘会有声音发出，且对方能够听到，于是我们在通话录音开启的时候使用拨号盘的发声方式去解决此问题；
方法很简单：
alps/packages/apps/InCallUI/src/com/android/incallui/CallButtonFragment.java
在onVoiceRecordClick方法中添加如下：

Call mRecordCall=CallList.getInstance().getActiveCall();
TelecomAdapter.getInstance().playDtmfTone(mRecordCall.getId(), '0');
TelecomAdapter.getInstance().stopDtmfTone(mRecordCall.getId());
TelecomAdapter.getInstance().playDtmfTone(mRecordCall.getId(), '9');
TelecomAdapter.getInstance().stopDtmfTone(mRecordCall.getId());
TelecomAdapter.getInstance().playDtmfTone(mRecordCall.getId(), '0');
TelecomAdapter.getInstance().stopDtmfTone(mRecordCall.getId());
代码连续播放了三个键的tone，用来区分录音和普通按键音
```

## Google app安全检查

```
该项的修改在/alps/frameworks/base/packages/SettingsProvider/res/values/defaults.xml中的def_package_verifier_enable，该项需要设置为true；该项设置为true后会有一个问题，当在有数据连接或wifi的情况下安装app，大多数情况下会出现一个弹出框，详见redmine46265。而客户的sfr应用会在有网络的情况下自动下载app，因此会弹出这个框，客户要求将此框去掉，只要将该值设定为false即可，在KK上是这么做的；但是最新google认证中，需要有这个弹出框，因此将其设置为true，google认证软件以google认证优先
```

## 在 init.rc 文件里面添加回调

```
//监听 sys.camera_standby 的值，如果设置为0则把 0100 00 写入到 /proc/driver/camsensor 文件中
on property:sys.camera_standby=0
    write /proc/driver/camsensor "0100 00"

on property:sys.camera_standby=1
    write /proc/driver/camsensor "0100 01"
```

## 如何隐藏settings-->apps里面的一些apk

``` Java
packages/apps/Settings/src/com/android/settings/applications/ApplicationsState.java，在该文件中的handleRebuildList()方法中的 filteredApps.add(entry);下面加上
for(int j=0;j<HIDE_APPS.length;j++){
    if(HIDE_APPS[j].equals(info.packageName)){
        filteredApps.remove(entry);
    }
}

而
public final static String[] HIDE_APPS=new String[] {
	"com.mediatek.mtklogger",
	"com.example.factorydevelop",
	"com.example.factorydevelopx",
	"com.mediatek.ygps",
	"com.mediatek",
	"com.android.simmelock",
	"com.android.location.fused",
	"com.mediatek.engineermode",
	"com.mediatek.weather",
	"com.mediatek.appwidget.weather",
	"com.android.keyguard",
	"com.mediatek.thermalmanager",
	"com.android.printspooler",
	"com.mediatek.apst.target",
	"org.simalliance.openmobileapi.service",
};
```

## [FAQ12880]锁屏界面如何延长亮屏到灭屏的等待时间

```
默认锁屏界面无操作情况下到灭屏的等待时间是10S.如想延长锁屏界面到灭屏的等待时间, 可参考如下solution.
可以修改KeyguardViewMediator.java文件中常量AWAKE_INTERVAL_DEFAULT_MS的值:protected static final int AWAKE_INTERVAL_DEFAULT_MS = 10000;
可自行修改，但需注意:
(1)锁屏界面亮屏到灭屏的等待时间不会大于系统设置中休眠时间的值, 例如系统设置->显示->休眠中 设置为一分钟, 而AWAKE_INTERVAL_DEFAULT_MS的值为修改两分钟，则锁屏界面亮屏到灭屏的等待时间为一分钟。
(2)如果AWAKE_INTERVAL_DEFAULT_MS的值设置为小于10S, 则锁屏到灭屏的等待时间为10S.
```

## settings-->more-->Mobile networks-->Access Point Names里面的默认值

```
这些默认值都是在mediatek/frameworks/base/telephony/etc/apns-conf.xml里面设置的，具体哪项用哪句话去写（比如说要apns protocol默认为IPV4/IPV6，那就要在apns-conf.xml文件中加上protocol="IPV4V6"，至于为什么用protocol,因为这些默认值都是写在com.android.providers.telephony中的，默认的值是直接解析apns-conf.xml文件的，所以到底为什么用protocol，我们可以进入packages/providers/TelephonyProvider/src/com/android/providers/telephony/TelephonyProvider.java中getRow(XmlPullParser parser)方法去看，里面都有解析的方法）
ps：如果默认为ipv4的话，protocol="IP"；如果默认为ipv6，protocol="IPV6"；如果默认为ipv4、ipv6的话，protocol="IPV4V6"
```

## 如何抓取操作数据库的log的方法（因为操作数据库的log较大且多，所以mtklogger一般不会把这块的代码放入到mobilelog里面，要进行以下操作）

```
新建一个 local.prop 文件，里面填入
log.tag.SQLiteStatements=VERBOSE
log.tag.SQLiteTime=VERBOSE
log.tag.SQLiteLog=VERBOSE
log.tag.SQLiteQueryBuilder=VERBOSE
log.tag.SQLiteDatabase=VERBOSE
log.tag.SQLiteConnection=VERBOSE
log.tag.ContactsProvider=VERBOSE
log.tag.ContactAggregator=VERBOSE
log.tag.ContentService=VERBOSE
然后
adb remount
adb push ./local.prop ./data/
adb shell chmod 750 ./data/local.prop
adb reboot
添加以上log后，帮忙复现问题，抓取mobilelog来分析，并且给出复现问题时手机显示的时间。
复现后请不要再继续操作

[FAQ17460] 如何开启database的详细log
```

## 如何看陀螺仪是否支持

```
进入projectConfig.mk文件后，搜索CUSTOM_KERNEL_GYROSCOPE即可，如何后面没有写东西，就是不支持，反之，亦然
```

## 关于modem mak文件的命名长度问题--不要超过38个字符，否则手机链接cat抓取log会出现log挂掉的情况

## IMEISV的修改   [FAQ02072]关于IMEI、IMEISV、SVN

```
IMEI(International Mobile Equipment Identity)是国际移动设备身份码的缩写，固化于手机中，每个手机的IMEI应该是唯一、不变的。
IMEI码由GSM（全球移动通信协会）统一分配，授权BABT（英国通信认证管理委员会）审受。
2004年以前的标准中，IMEI共15位（取值必须是0~9的数字），依次分别是6位TAC、2位FAC、6位SNR、1位CD校验位。
2004年以后的标准中删去了最后的1位CD校验位，新加入了2位SVN(software version number)，故称IMEISV，共16位（取值仍必须是0~9的数字）。
SVN的取值也必须是0~9的数字，而且99这个值是被保留的。
网络检查的时候会指明检查IMEI还是IMEISV，如果是检查IMEI，则手机许上报前14位IMEI（1位CD校验位不上报），如果是检查IMEISV，则手机上报16位IMEISV
1、IMEI SV 的修改，可以通过AT COMMAND ：AT+EGMR=1,9,”00”;
2、在modem端修改，custom/service/nvram/nvram_data_items.c文件中的
SYS_CACHE_ENTRY(NVRAM_SYS_SVN,
            NVRAM_APP_RESERVED,
            KAL_FALSE,
            "NVRAM_SYS_SVN",
            0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00),
```

## ro.product.device以及ro.product.name里面不可以有非法字符（如"."）,会导致google的play store连接不上

## [FAQ13432][Dialer]如何使拨号盘搜索支持葡萄牙文？     http://unicode-table.com/cn/#control-character

```
packages/providers/ContactsProvider/src/com/android/providers/contacts/HanziToPinyin.java中添加的
static {
    sMuiSupportMap.put('\u00c0', '2'); //   -->'\u00c0'这个unicode对应的字符可以用2搜索出来
    sMuiSupportMap.put('\u00c0', 'a'); //   -->'\u00c0'这个unicode对应的字符可以用a搜索出来

    sMuiSupportMap.put('\u00e3', 'a'); //ã
    sMuiSupportMap.put('\u00e2', 'a'); //â
    sMuiSupportMap.put('\u00e1', 'A'); //Á
    sMuiSupportMap.put('\u00c3', 'A'); //Ã
    sMuiSupportMap.put('\u00c0', 'A'); //À
    sMuiSupportMap.put('\u00c2', 'A'); //Â

    sMuiSupportMap.put('\u00e9', 'e'); //é 
    sMuiSupportMap.put('\u00ea', 'e'); //ê
    sMuiSupportMap.put('\u00e8', 'e'); //è
    sMuiSupportMap.put('\u00eb', 'e'); //ë

    sMuiSupportMap.put('\u00ed', 'i'); // í
    sMuiSupportMap.put('\u00ec', 'i'); // ì
    sMuiSupportMap.put('\u00ee', 'i'); // î
    sMuiSupportMap.put('\u00ef', 'i'); // ï

    sMuiSupportMap.put('\u00f5', 'o'); // õ
    sMuiSupportMap.put('\u00f4', 'o'); //ô
    sMuiSupportMap.put('\u00f3', 'o'); //ó
    sMuiSupportMap.put('\u00f2', 'o'); //ò

    sMuiSupportMap.put('\u00e7', 'c'); // ç

    sMuiSupportMap.put('\u00fa', 'u'); //ú
    sMuiSupportMap.put('\u00f9', 'u'); //ù
    sMuiSupportMap.put('\u00fb', 'u'); //û
    sMuiSupportMap.put('\u00fc', 'u'); //ü

    sMuiSupportMap.put('\u00ff', 'y'); //ÿ
}
具体所有的特殊字符的对应unicode值，可以看/home/jiangcunbin/Desktop/sagereal资料/自己总结/特殊字符unicode值 该文件
```

## 预置联系人的名字修改在

```
packages/apps/Contacts/src/com/mediatek/contacts/simservice/PresetContactsImportProcessor.java中的INSERT_PRESET_NAME[]
问题点：如果在恢复出厂设置后预置联系人去写入数据库时断电，就会出现预置联系人只写入一部分，这时候去重启的时候，代码端检测到预置联系人数据库已经有值（不会去管你是否完全写入），这就导致预置联系人一直丢失一部分，这时候就需要一些保护措施。
修改方法：packages/apps/Contacts/src/com/mediatek/contacts/simservice/PresetContactsImportProcessor.java文件中contactCursor != null && contactCursor.getCount() > 0下面的return修改为continue；packages/apps/Contacts/src/com/mediatek/contacts/simservice/PresetContactsImportProcessorOrange.java文件中contactCursor != null && contactCursor.getCount() > 0下面的return修改为continue；
```

## 如何关闭小区广播（Cell Broadcast）

```
在modem端修改，custom/service/nvram/nvram_cust_pack.c文件中COMMON_NVRAM_EF_SMSAL_COMMON_PARAM_DEFAULT[]项中
#if defined (__CB_SETTING_OFF__)  //redmine 36063 CB setting modify by shiyujiao 2015-07-23 begin
    0x00, 0x01,              -->关闭小区广播
#else
    0x01, 0x01,              -->打开小区广播
#endif
ps:有时候在modem端关闭小区广播后，发现插卡后刚进去是关闭的，过段时间进去就出现又打开的状态，这是去看下MTK_ETWS_SUPPORT是否关闭
```

## 当使用startActivityForResult()时，去启动一个acitivity的时候，前面千万不能有Intent.FLAG_ACTIVITY_NEW_TASK和Intent.FLAG_ACTIVITY_SINGLE_TOP，且被启动的apk

```
在androidManifest.xml文件中不可以有android:launchMode="singleInstance"，只能是默认的（也就是launchMode是standard模式），不然的话，会出现startActivityForResult()运行后，还没等到被调用的 Activity 返回，onActivityResult() 就被执行了，且返回的RESULT_CANCELED
还有一种情况：startActivityForResult(intent, 0);是第二个参数的问题，该参数必须大于0才能在返回值，并激活onActivityResult方法。
ps：也就是onActivityResult要这个有用被启动的activity只能是standard模式
```

## 短信编码方式(bit是位，byte是字节，1byte = 8bit)，短信最多输入140个字节（byte）

```
1、GSM编码 --> 7bit -->1个字节-->主要用来发送ASCII字符 --> 有abc、ABC、123、@主要是这四种类型的可以通过GSM编码发送
2、UCS2编码 --> 16bit -->2个字节-->主要用来发送Unicode字符 -->除了ASCII字符，还加上了很多国家的语言，比如汉字，所以短信发汉字用的是2个字节
1.GSM alphabet  表示用户编辑的短信内容都用7bit进行编码
如果输入的都为ASCII字符，则最多可以输入的字符数为140x8(每个字节为8位)/7(该编码方式为7位)=160，但是如果输入中存在Unicode字符，则按照Unicode的编码方式进行编码，则最多可以输入的字符数为140x8(每个字节为8位)/16(Unicode编码方式为16位)=70
2.Unicode    表示用户编辑的短信内容都用ucs2进行编码
不管输入的是ASCII字符还是Unicode字符，都是按照16位的进行计算，则最多可以输入的字符数为140x8(每个字节为8位)/16(Unicode编码方式为16位)=70
3.Automatic  先用7bit进行编码，如果有些字符无法用7bit编码（有些字符并没有在编码表里面定义），则用ucs2进行编码
如果输入的都为ASCII字符，则最多可以输入的字符数为140x8(没个字节为8位)/7(该编码方式为7位)=160，但是如果输入中存在Unicode字符，则按照Unicode的编码方式进行编码，则最多可以输入的字符数为140x8(没个字节为8位)/16(Unicode编码方式为16位)=70     （同GSM alphabet的编码方式）
由于默认的GSM alphabet和Automatic的编码方式相同，所以很多客户要求我们在选择GSM alphabet编码方式时，直接[FAQ10993]SMS内容强制用7bit编码[Orange operator]，当你输入Unicode字符时，发送出去的时候直接用“？”代替，而“？”就是ASCII字符，所以此时选择该编码方式，最多可以输入的字符数为140x8(没个字节为8位)/7(该编码方式为7位)=160
```

## 如何实现短信编码方式（M平台上）

```
[FAQ10993]SMS内容强制用7bit编码[Orange operator]
[FAQ09191]信息设置里增加让用户选择短信编码方式的菜单    ----> 里面有修改默认值的方法
vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/transaction/SmsSingleRecipientSender.java文件中sendMessage方法加上
SharedPreferences pref = mContext.getSharedPreferences("com.android.mms_preferences", Context.MODE_WORLD_READABLE);
String inputString = pref.getString("pref_key_sms_input_mode", "GSM alphabet");

if ("GSM alphabet".equals(inputString)) {
    mMessageText=mMessageText.replaceAll("ą","a");
    mMessageText=mMessageText.replaceAll("ā","a");
    mMessageText=mMessageText.replaceAll("á","a");
    mMessageText=mMessageText.replaceAll("â","a");
    mMessageText=mMessageText.replaceAll("ã","a");

    mMessageText=mMessageText.replaceAll("Ą","A");
    mMessageText=mMessageText.replaceAll("Ā","A");
    mMessageText=mMessageText.replaceAll("Á","A");
    mMessageText=mMessageText.replaceAll("À","A");
    mMessageText=mMessageText.replaceAll("Â","A");
    mMessageText=mMessageText.replaceAll("Ã","A");

    mMessageText=mMessageText.replaceAll("č","c");
    mMessageText=mMessageText.replaceAll("ç","c");
    mMessageText=mMessageText.replaceAll("ć","c");

    mMessageText=mMessageText.replaceAll("Č","C");	
    mMessageText=mMessageText.replaceAll("Ć","C");

    mMessageText=mMessageText.replaceAll("ê","e");
    mMessageText=mMessageText.replaceAll("ë","e");
    mMessageText=mMessageText.replaceAll("ė","e");
    mMessageText=mMessageText.replaceAll("ę","e");
    mMessageText=mMessageText.replaceAll("ē","e");

    mMessageText=mMessageText.replaceAll("È","E");
    mMessageText=mMessageText.replaceAll("Ê","E");
    mMessageText=mMessageText.replaceAll("Ë","E");
    mMessageText=mMessageText.replaceAll("Ė","E");
    mMessageText=mMessageText.replaceAll("Ę","E");	
    mMessageText=mMessageText.replaceAll("Ē","E");

    mMessageText=mMessageText.replaceAll("î","i");
    mMessageText=mMessageText.replaceAll("ï","i");
    mMessageText=mMessageText.replaceAll("ī","i");
    mMessageText=mMessageText.replaceAll("į","i");
    mMessageText=mMessageText.replaceAll("í","i");

    mMessageText=mMessageText.replaceAll("Ï","I");
    mMessageText=mMessageText.replaceAll("Î","I");
    mMessageText=mMessageText.replaceAll("Ī","I");
    mMessageText=mMessageText.replaceAll("Į","I");
    mMessageText=mMessageText.replaceAll("Ì","I");
    mMessageText=mMessageText.replaceAll("Í","I");

    mMessageText=mMessageText.replaceAll("ô","o");
    mMessageText=mMessageText.replaceAll("õ","o");
    mMessageText=mMessageText.replaceAll("ó","o");
    mMessageText=mMessageText.replaceAll("ō","o");

    mMessageText=mMessageText.replaceAll("Ô","O");
    mMessageText=mMessageText.replaceAll("Õ","O");
    mMessageText=mMessageText.replaceAll("Ò","O");
    mMessageText=mMessageText.replaceAll("Ó","O");
    mMessageText=mMessageText.replaceAll("Ō","O");

    mMessageText=mMessageText.replaceAll("û","u");
    mMessageText=mMessageText.replaceAll("ū","u");
    mMessageText=mMessageText.replaceAll("ú","u");

    mMessageText=mMessageText.replaceAll("Û","U");
    mMessageText=mMessageText.replaceAll("Ù","U");
    mMessageText=mMessageText.replaceAll("Ū","U");
    mMessageText=mMessageText.replaceAll("Ú","U");

    mMessageText=mMessageText.replaceAll("Ń","N");
    mMessageText=mMessageText.replaceAll("ń","n");

    mMessageText=mMessageText.replaceAll("Ÿ","Y");
    mMessageText=mMessageText.replaceAll("ÿ","y");

    mMessageText=mMessageText.replaceAll("Œ","OE");

    mMessageText=mMessageText.replaceAll("œ","oe");

    mMessageText=mMessageText.replaceAll("ž","z");
    mMessageText=mMessageText.replaceAll("ż","z");
    mMessageText=mMessageText.replaceAll("ź","z");
    mMessageText=mMessageText.replaceAll("Ž","Z");
    mMessageText=mMessageText.replaceAll("Ż","Z");
    mMessageText=mMessageText.replaceAll("Ź","Z");

    mMessageText=mMessageText.replaceAll("š","s");
    mMessageText=mMessageText.replaceAll("ś","s");
    mMessageText=mMessageText.replaceAll("Š","S");
    mMessageText=mMessageText.replaceAll("Ś","S");

    mMessageText=mMessageText.replaceAll("Ł","L");
    mMessageText=mMessageText.replaceAll("ł","l");
}
int codingType;
if ("GSM alphabet".equals(inputString)) {
    codingType = SmsMessage.ENCODING_7BIT;
}else{
    codingType = SmsMessage.ENCODING_UNKNOWN;
}
```

## 64位系统环境下，在eng版本中预置32位apk可以运行，在user版本中预置的32位apk运行报错？

```
原因：
1、User版本的32位apk在64位系统环境下编译时，默认被编译解析为64位路径。当运行时找不到其32位的默认路径，报错。在Android.mk文件中加入LOCAL_MULTILIB := 32，可以编译解析为32位路径，运行不报错。
2、Eng版本没有32位和64位区分，运行不报错
```

## [默认值]默认时间修改

```
72L：
alps/vendor/mediatek/proprietary/frameworks/base/res/res/values/config.xml  修改default_restore_year值

alps/frameworks/base/services/core/java/com/android/server/NetworkTimeUpdateService.java
//today.set(1, 8, mDefaultYear);
修改日月，第一位是日，从1开始，第二位是月，从0开始，即1，8代表9月1日，1月1日需要使用//today.set(1, 0, mDefaultYear);

alps/kernel-3.10/arch/arm/mach-mt6572/sr6572_wet_l/rtc/rtc-mt.h
alps/bootable/bootloader/lk/target/sr6572_wet_l/include/target/cust_rtc.h
alps/bootable/bootloader/preloader/custom/sr6572_wet_l/inc/cust_rtc.h
修改年月日，都是从1开始计数

其他平台稍微有点变化，目前设定为2016-01-01会出现夏令时变为2015-12-31的情况；
但是有些客户就是希望2016-01-01，因此出现夏令时情况的再单独与客户launcher沟通修改成其他时间；

53L:alps/vendor/mediatek/proprietary/frameworks/base/res/res/values/config.xml  修改default_restore_year值
alps/frameworks/base/services/core/java/com/android/server/NetworkTimeUpdateService.java
//today.set(1, 8, mDefaultYear);
修改日月，第一位是日，从1开始，第二位是月，从0开始，即1，8代表9月1日，1月1日需要使用//today.set(1, 0, mDefaultYear);

/kernel-3.10/drivers/misc/mediatek/mach/mt6735/sr6735_65c_l1/rtc/rtc-mt.h 
/bootable/bootloader/preloader/custom/sr6735_65c_l1/inc/cust_rtc.h

kk：
alps/vendor/mediatek/proprietary/frameworks/base/res/res/values/config.xml  修改default_restore_year值

alps/frameworks/base/services/core/java/com/android/server/NetworkTimeUpdateService.java
//today.set(1, 8, mDefaultYear);
修改日月，第一位是日，从1开始，第二位是月，从0开始，即1，8代表9月1日，1月1日需要使用//today.set(1, 0, mDefaultYear);
M:mediatek/custom/up40_h405f_sfr/kernel/rtc/rtc/rtc-mt.h
M:mediatek/custom/up40_h405f_sfr/kernel/rtc/rtc/rtc-mt6575.h
M:mediatek/custom/up40_h405f_sfr/preloader/inc/cust_rtc.h
在以上三个文件中修改即可
```

## [shell]aapt解析apk文件

```
拷贝一个alps/out/host/linux-x86/bin/aapt文件到apk同目录下
进入apk同目录打开终端，
1、chmod 777 aapt
2、./aaptdump badging DeskClock.apk  > log.txt，然后就可以在log.txt文件中看到很多该apk的数据，只是看部分apk信息建议用这个方法
./aapt l -a DeskClockGoogle.apk > log.txt  ，解析了所有的apk信息
./aapt dump resources DeskClockGoogle.apk > log_res.txt，解析了该apk的资源文件信息

aapt d permissions example.apk //显示这个apk所添加的权限
aapt d xmltree example.apk AndroidManifest.xml //查看apk压缩文件中AndroidManifest.xml内容
```

## 新建联系人时，把某些特殊的字母写入作为联系人的名字，保存后名字会变成保存的号码，即名字不会保存（redmine 62148）

```
[FAQ08018]系统语言为英语时，Contacts联系人名字含有特殊前缀后缀(Dr. Mr. Lt等)时的相关问题处理
```

## SIM卡相关问题

```
1、[FAQ02891][SIM]什么情况下显示Invalid SIM     Invalid SIM 表示注册网络，被网络reject.
2、[FAQ17655]SIM卡联系人无法收藏
3、[FAQ18208][SAT]如何不显示开机SIM卡欢迎语
4、[FAQ14489]Android L SIM卡更新语言问题
```

## 修改分区

```
如何在L、M、GO/O项目中修改分区
L、M：先进入projectConfig.mk文件中搜索sagereal_fat_config，如果后面有值就修改../sagereal/custom/fatconfig/SYSTEM2000M（sagereal_fat_config对应值命名）/partition_table_MT6580.xls；如果没有值就修改/device/mediatek/build/build/tools/ptgen/MT6580/partition_table_MT6580.xls

GO/O：alps/device/mediatekprojects/$project/BoardConfig.mk中设定：
BOARD_MTK_SYSTEM_SIZE_KB := 1024000
BOARD_MTK_VENDOR_SIZE_KB := 307200
BOARD_MTK_CACHE_SIZE_KB := 114688
```

## Tethering IPV4/IPV6相关

```
[FAQ08793]"Hotspot & tethering settings"的预设值IPv4,如何将它的預設值改為"IPv4 & IPv6"
[FAQ08603][Dialup]测试IPv6拨号失败
[FAQ15542]IPv6 tethering feature项介绍及通用配置
[FAQ13289][PAN][KK]网络共享与便携式热点设置”设为“IPv4&IPv6”，无法共享网络
[FAQ11563]请问平台是否支持IPv6？请帮忙确认IPv6相关需求是否支持?
[FAQ15292]IPv4 or IPv6 Prefer       如果同时拥有IPv4和IPv6的地址，是会默认优先上报IPv6的地址，若需要修改为IPv4 prefer，可以按如下方式修改
```

## [FAQ11564]长按Home键唤起Google Now

```
1. 修改 frameworks/base/core/res/res/values/config.xml
<integer name="config_longPressOnHomeBehavior">2</integer>
注：这里的值可以设置三个
1代表唤起recent app界面；
2代表唤起搜索界面（Google Now)；
3代表Nothing
```

## 通过fota升级一些nvram，必须修改lid的值

```
1、锁网的lid是在modem端的interface/service/nvram/nvram_editor_data_item.h文件中的NVRAM_EF_SML_LID_VERNO
2、音频参数的lid是在mediatek/custom/up16_h502s_meo/cgen/inc/Custom_NvRam_LID.h文件中的AP_CFG_RDCL_FILE_AUDIO_LID_VERNO值(kk)
vendor/mediatek/proprietary/custom/sr6580_weg_l/cgen/inc/Custom_NvRam_LID.h文件中的AP_CFG_RDCL_FILE_AUDIO_LID_VERNO值(L)
PS:[FAQ14500][Audio Common] OTA升级音频参数后如果不恢复工厂设置也能生效
3、小区广播的lid是在interface/service/nvram/nvram_editor_data_item.h文件中的NVRAM_EF_CB_CH_INFO_LID_VERNO
4、IMEISV的lid是在interface/service/nvram/nvram_editor_data_item.h文件中的NVRAM_EF_IMEI_IMEISV_LID_VERNO
```

## 通过IMEI算解锁码

``` Java
String imeiCode = "354648020000251";
for (int i = 0;i<8;i++) {
    int sum = 0;
    for (int k = 0 ; k < 8; k++) {
	    sum+=Integer.parseInt(imeiCode.charAt(i+k)+"");
    }
    System.out.print(sum%10);
}
```

## 开机向导引起灭屏时间问题

```
文档位置/home/jiangcunbin/Desktop/sagereal资料/自己总结/GMS认证/GMS包引起问题分析_new/开机向导引起灭屏时间问题.txt
开机向导正常整个过程就是 60000->121000->60000，在开机向导界面拔掉电池，这个行为是第二次时把121000->60000这个过程破坏了。导致开机向导没能把这个值修改回来。
而我们的修改方式就是把60000->121000这个过程就不让走。这样自然就不会把这个时间给修改了。修改文件在frameworks/base/packages/settingsprovider/src/com/android/providers/settings/SettingsProvider.java文件中的isRedundantSetValue方法中加上
if (name.equals("screen_off_timeout")&&value.equals("121000")) {
    return true;
}
```

## [adb]更新数据库命令

```
update secure set value = 1 where name="device_provisioned";
```

## 如何让user的也默认打开mtklog

```
L：alps/vendor/mediatek/proprietary/external/xlog/tools/mtklog-config-user.prop
M/N：alps/device/mediatek/common/mtklog/mtklog-config-bsp-user.prop
把这两个文件中的值都改为true
```

## 开机向导wifi skip置灰

```
sagereal资料/自己总结/GMS认证/GMS包引起问题分析_new/FAQ18056.pdf
5.1_r3版本,按钮置灰一段时间后可以恢复,点击即可跳过  -->  主要因为GmsCore的3个dex文件做dex2oat时间太长导致,由于手机防盗功能,开机向导在wifi设置界面需要判断FRP的状态来决定是否一定需要网络来登录Google账户验证,FRP状态需要通过GmsCore的FrpService获取,而FrpService需要等待GmsCore的3个插件dex文件做dex2oat完成后才能启动.如果在开机向导的wifi设置界面,FrpService还没有启动起来,那么这个时候skip按钮就是置灰的;需要一直等待FrpService启动后获取到正确的FRP状态后skip按钮才可以点击
6.0_r2版本,按钮置灰不能恢复,则此次开机一直不能跳过  -->   M版本GmsCore第一次运行时并不需要再做dex2oat,可是SetupWizard的机制有所变化,即:SetupWizard通过asyncTask调用GmsCore获取FRP Status,如果10s未返回结果则cancel掉此asyncTask(通过中断线程执行直接cancel,同时抛出InterruptedException异常),且设置必须要网络连接才可以进行下一步
对于性能不够好的机器,10s有可能线程未能及时finished,则会导致开机向导状态错误

ps：当打开数据流量的时候，不会按照上面描述的去走，会去连接google的服务器；当没有打开数据流量的时候，会通过上面的描述去走
```

## Play Store 无法连接 log 分析

```
10-08 14:00:04.374197: E/CheckinTask(1063): Checkin failed: https://android.clients.google.com/checkin (request #0): java.io.IOException: Rejected response from server: invalid hardware identifier: "Andy5.5EI" is not a valid device
从log中可以明确的知道Andy5.5EI这个名字是不被play store认可的，所以ro.product.device以及ro.product.name两个值是不能带有空格或“.”这样的字符
```

## 手机可以发送flac格式的音频文件，但不能接收（redmine57636）

```
packages/apps/Bluetooth/src/com/android/bluetooth/opp/Constants.java 文件中 ACCEPTABLE_SHARE_INBOUND_TYPES 中加上 application/x-flac
```

## 如何把window里面的txt文件转换为linux系统下的文件（不转换会显示乱码）

``` bash
iconv -f gb18030 -t utf8 file1 -o file2
```

## [默认值][bug](名称)WIFI直连名称显示错误

```
kk：frameworks/base/wifi/java/android/net/wifi/p2p/WifiP2pService.java 文件中的 getPersistedDeviceName() 方法
L：frameworks/opt/net/wifi/service/java/com/android/server/wifi/p2p/WifiP2pServiceImpl.java文件中的
```

## [默认值][FAQ04794]如何修改默认数据连接开关(前提是数据库的默认值loadSetting(stmt, Settings.Global.MOBILE_DATA要修改好)

```
L(单卡)：frameworks/opt/telephony/src/java/com/mediatek/internal/telephony/dataconnection/DataSubSelector.java文件subSelectorForOm(Intent intent)方法中
turnOffNewSimData(intent);  -->运行后关闭，不运行就是打开

L(双卡)：把上面的修改后在修改后面的
frameworks/opt/telephony/src/java/com/android/internal/telephony/dataconnection/DcTrackerBase.java文件handleMobileDataSettingNotFound()方法中
Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA + phoneSubId, 0);-->关闭
Settings.Global.putInt(mResolver, Settings.Global.MOBILE_DATA + phoneSubId, 1);-->打开
```

## [默认值][Bluetooth]修改蓝牙显示名称

```
KK:
mediatek/config/up39_h455_coppel/custom.conf 文件中 bluetooth.HostName 中

L之后:
/home/zq/projects/Project_common/alps/device/mediatek/common/custom.conf 目前都在 ProjectConfig.mk 中用宏 bluetooth_hostname 控制
```

## 如何让每个apk里面的menu通过三个点的菜单按钮显示出来

```
frameworks/base/core/res/res/values/config.xml 文件中的 <integer name="config_overrideHasPermanentMenuKey">0</integer> 值改为2

frameworks/base/core/java/com/android/internal/view/ActionBarPolicy.java
public boolean showsOverflowMenuButton() {
    return !ViewConfiguration.get(mContext).hasPermanentMenuKey();  //通过 config_overrideHasPermanentMenuKey 来控制三个点的菜单按钮是否显示
}
```

## [FAQ04312][默认值]如何修改默认字体大小 Settings-->Display-->Font size

```
L:frameworks/base/core/java/android/content/res/Configuration.java 中的 setToDefaults() 方法中的 fontScale 值，1.0f 为 normal，0.9f 是 small
Android系统中在Settings->Display->Font Size设置系统字体大小，默认的系统字体大小为普通(Normal)，如果修改默认值，可以在下面这个文件中进行修改：
在alps/frameworks/base/core/java/android/content/res/Configuration.java文件中如下
public void setToDefaults() 这个方法中进行修改，
如:把默认字体要改为超大，把fontScale值改为1.15f，然后重新build framework.jar这个模块即可；
public void setToDefaults() {
fontScale = 1.15f;  //normal value is 1
mcc = mnc = 0;

注意：Settings中系统的字体大小，在/packages/apps/Settings/res/values/arrays.xml文件中的”entryvalues_font_size”这个tag中定义
Small:0.9
Normal:1.0
Large:1.1
Extra Large:1.15

fontScale值必须是上述中的一个。

N版本上默认字体大小修改如下：
（1）将/frameworks/base/core/java/android/provider/Settings.java文件中的DEFAULT_FONT_SCALE修改为所需要设置的值。
（2）将/frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/SettingsHelper.java文件中如下位置的1.0f，修改为所需要的值。
case Settings.System.FONT_SCALE:
return Settings.System.getFloat(mContext.getContentResolver(), name, 1.0f) != 1.0f;

字体大小值 entryvalues_font_size 的定义，在N版本上 packages/apps/Settings/res/values/arrays.xml 文件中定义如下：
<string-array name="entryvalues_font_size" translatable="false">
    <item>0.85</item>
    <item>1.0</item>
    <item>1.15</item>
    <item>1.30</item>
</string-array>

在设置所需的字体大小时请参考 entryvalues_font_size 的定义。

通过 adb 命令设置字体的大小 adb shell settings put system font_scale 1.0
```

## [FAQ12292]浏览器下载文件无法打开

```
浏览器下载文件时，有时会遇到下载后文件无法打开，比如ogg，3gp等格式，或者下载的apk无法安装等问题。这类问题一般是sever返回的mimetype有问题，导致打开时，发往其他app的Intent不能被正常处理。例如无法安装apk文件，一般通过搜索关键字"DownloadManager",会搜到类似如下的log:

06-27 14:20:15.364   919   919 W DownloadManager: Failed to start Intent { act=android.intent.action.VIEW dat=content://downloads/all_downloads/9 typ=application/octet-stream flg=0x3 }: android.content.ActivityNotFoundException: No Activity found to handle Intent { act=android.intent.action.VIEW dat=content://downloads/all_downloads/9 typ=application/octet-stream flg=0x3 }

从log信息可以看出：mime typ=application/octet-stream 不能被处理。
主要原因是：下载apk时，server返回application/octet-stream,不是标准的mimetype: application/vnd.android.package-archive,
导致htmlviewer无法打开该inent. 这类一般是server issue，若server返回的是标准的：application/vnd.android.package-archive就不会有
这样的问题.

[SOLUTION]
先确认无法打开文件的正确mime type，然后在DownloadHandler.java中的DownloadStartNoStream()作特殊处理。将sever返回错误的mime强
制修正成正确的mime type即可。下面给出以无法打开apk为例的修改方案，同理，其他格式的文件也是类似的。
修改文件：\packages\apps\Browser\src\com\android\browser\DownloadHandler.java
修改方法：onDownloadStartNoStream()

具体修改：
public static void onDownloadStartNoStream(Activity activity, String url, String userAgent, String contentDisposition, String mimetype, String referer, boolean privateBrowsing, long contentLength) {
    String filename = URLUtil.guessFileName(url, contentDisposition, mimetype); 
    Xlog.d(XLOGTAG, "Guess file name is: " + filename + " mimetype is: " + mimetype);

    // modify start:   change Mime for apk
    if (filename.endsWith(".apk") && mimetype.equal("application/octet-stream")) {
        mimetype = "application/vnd.android.package-archive";
    }
    // modify end
}
```

## M或者L项目的init.rc文件路径

```
alps/device/mediatek/mt6580/init.mt6580.rc
```

## 如果开机向导结束后到launcher起来之间有黑屏出现该怎么办？

```
去除Provision这个apk，sagereal_remove_apps=Provision
```

## 3G/2G preferred 和 3G/2G auto 的区别

```
3g/2g preferred这个模式是指3g优先，就是说只要有3g的网络，哪怕3g的信号很差，手机也会挂载到3g的，如非3g的信号一点都没有了，才会跳转到2g的；3g/2g auto这个模式是指当3g的网络信号差的时候，会自动的切换到2g去
```

## [adb]显示所有apk的包名等信息的adb命令

``` bash
adb shell pm list packages -f  ---> 显示所有apk的包名
adb shell pm list packages laun ---->显示包含“laun”的包名
-f：查看关联文件，即应用apk的位置跟对应的包名（如：package:/system/app /MusicPlayer.apk=com.sec.android.app.music）
-d：查看disabled packages
-e：查看enable package
-s：查看系统package
-3：查看第三方package
-i：查看package的对应安装者（如：1、 package:com.tencent.qqmusic installer=null 2、package:com.tencent.qqpim installer=com.android.vending）
-u：查看曾被卸载过的package。（卸载后又重新安装依然会被列 入）
```

## 如何把apk预置到system/priv-app?
 
```
Android.mk 中把 LOCAL_PRIVILEGED_MODULE := true，不写即为false，默认会预置到system/app下面
```

## [ICU][翻译]ICU相关

```
很多字符串翻译的都在icu资源中，在external/icu/icu4c
[FAQ04011]如何编译ICU资源，按照编译出来后，可以直接进入adb shell --> cd system/usr/icu中，用external/icu/icu4c/source/data/out/tmp/icudt55l.dat把替换掉
```

## 有些项目工厂测试中imei和imsi都为null

```
把TelephonyManagerEx tm = TelephonyManagerEx.getDefault();修改为 TelephonyManager tm1 = (TelephonyManager) getSystemService(TELEPHONY_SERVICE);
```

## [FAQ05658]手机解锁后，如果用户未处理未读信息/未接电话等notification，如何使指示灯继续闪烁。

```
当M平台上时，除了要注释掉文档里面的那句话以外，如果要求亮屏的时候也会闪烁的话，要在frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java文件中的updateLightsLocked()方法中注释掉mScreenOn的判断
```

## [FAQ07381][Aduio Common]APP层如何控制loopback开启或关闭

```
AudioManager audiomanager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
audiomanager.setParameters("SET_LOOPBACK_TYPE=1,3");
其中中传入的两个参数意义如下：
第一个参数表示input device，1，2，3分别代码main mic，耳机mic，sub mic(dual mic项目才有效)
第二个参数表示output device，1，2，3分别表示听筒，耳机，喇叭
根据需要进行组合即可
closeMic = "SET_LOOPBACK_TYPE=0"  --> 代表关闭对应的通路
```

## 如何让紧急拨号后显示在call history(通话记录)里面

```
M：packages/services/Telecomm/res/values/config.xml文件中修改allow_emergency_numbers_in_call_log即可
N：frameworks/base/telephony/java/android/telephony/CarrierConfigManager.java文件中把sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, false)修改为sDefaults.putBoolean(KEY_ALLOW_EMERGENCY_NUMBERS_IN_CALL_LOG_BOOL, true)。
```

## 如何修改开机过程中的黑屏问题

```
eservice：ALPS02795990
[FAQ18016]L/M版本开机黑屏问题区分

1、L版本开机时，kernel logo与开机动画之间闪一帧黑屏，这个现在在kernel logo与开机动画相同并且开机动画是静态的时候表现的尤其明显,目前主要体现在455 digicel和5012 digicel项目上！-------> [FAQ14488]kernel logo到开机动画之间闪现黑屏（L）----> 这个现象是因为，在BootAnimation开始绘图之前，会先做一次clear screen的动作，避免出现前面的图干扰到BootAnimation的显示。这是Google default design，虽然不可避免，但是可以优化。
ps：在该FAQ上有很多修改的点，但是 目前我们基本上是使用的bool BootAnimation::movie()函数，之后如需修改可修改在bool BootAnimation::movie()中。

2、N项目上，（1）开机动画结束后，概率性闪现灰屏  （2）刷机后开机到语言界面时，有灰屏出现，这些在N上的项目是正常的，原因如下：   redmine86991
Google在N上新增了Direct boot（file base encryption）feature，为了配合这个feature，定义了开机过程中的一个状态：user_unlocked, 指用户设置了锁屏，重启/开机第一次解锁（即使没有设置锁屏，也会经过user_unlocked的状态）。在user unlocked之前，只有定义了 encryption-aware=true的组件能被叫起，Launcher没有定义这个flag，所以无法被PMS查询到，AMS无法先启动Launcher；Fallbackhome有定义这个flag，即使优先级是-1000，但是PMS只能找到这个activity响应HOME intent，所以会先启动Fallbackhome。
Google设计Fallbackhome的主要原因就是在user unlocked之前，必须至少要有个activity响应HOME intent，比如Launcher没有定义encryption aware，那么就需要Fallbackhome先起来。目前平台还没有找到比较根本的解决办法，google在MR1上也有增加一个patch来改善，但是也是治标不治本，用一个processing的dialog来缓解黑屏的体验，但是仍然会有黑屏。
```

## [VOLTE]如何配置VOLTE

```
首先要向mtk申请相应的patch，然后要对其进行配置，那么如何配置呢？
1、进入online，然后 MediaTek On-Line> Quick Start> IMS功能专区(VoLTE/VoWifi/ViLTE)，在该功能专区可知，（1）如果你只要弄一个运营商的话，可以看里面的IMS Configuration,对应的可以SBP ID在可在[FAQ17597]各运营商IMS feature参数配置查看；（2）如果你要配置多个运营商能自由切换的话，可以看Dynamic SBP(D-SBP),在该项最下面有如何配置的分析
How to Enable DSBP

Under device/mediatek path
[Project_Name]/ProjectConfig.mk, e.g. k55v1_64_om_lwg_volte_ss/ProjectConfig.mk
Set MTK_IMS_SUPPORT = yes             --->37M上默认打开
Set MTK_VOLTE_SUPPORT = yes           --->37M上默认打开
Set MTK_DYNAMIC_SBP_SUPPORT = yes
Set MTK_MD_SBP_CUSTOM_VALUE = 0
Set OPTR_SPEC_SEG_DEF = NONE       -----> 同时要检查persist.operator.optr也要为空

Under kernel-3.xx/arch/arm64/configs path
[Project_Name]_defconfig, e.g. k55v1_64_om_lwg_volte_ss_defconfig
Set CONFIG_MTK_MD_SBP_CUSTOM_VALUE = "0"

[Project_Name]_debug_defconfig, e.g. k55v1_64_om_lwg_volte_ss_debug _defconfig
Set CONFIG_MTK_MD_SBP_CUSTOM_VALUE = "0"

ps:SBP ID在M平台上用16进制，在N平台上要转化为10进制

VOWIFI 如何配置
1、 MTK_MD_SBP_CUSTOM_VALUE = 0	
2、MTK_MULTIPLE_IMS_SUPPORT = 2（双卡配置为2,单卡配置为1）
3、MTK_WFC_SUPPORT = yes

注意点：
doro 智能机项目 客户反馈，在插卡情况下，拨打紧急号码，并快速挂断，多次后会出现挂不断现象，MTK 回复是由于打开了跟volte相关的两个宏：
MTK_VOLTE_SUPPORT=YES
MTK_IMS_SUPPORT=YES
MTK原始代码对volte是没有配置的的，但是却开着这两个宏，如果当地网络支持IMS功能，手机就会出现挂不断现象。
为了防止再次出现这个问题，请各位以后带项目的时候，检查一下这两个宏，如果项目没有配置volte，请将
MTK_VOLTE_SUPPORT =no，
MTK_IMS_SUPPORT=no

问题：客户场测发现，插入当地卡，无法显示VOLTE
原因：OPTR_SPEC_SEG_DEF = NONE，但是persist.operator.optr设置成CUST，才出现这个问题！只要persist.operator.optr变为空就行
```

## [小区广播]SAE（紧急小区广播）

```
具体可看redmine39255
文件在 alps/vendor/mediatek/proprietary/packages/apps/CMASReceiver
```

## [小区广播]国内使用8960模拟小区广播功能

```
因为中国大陆地区的运营商不支持小区广播，所以只能通过使用仪器的方式模拟测试小区广播。以下文档说明如何使用Agilent 8960仪器测试GSM 小区广播

测试需要用到以下设备材料，请提前准备好：
1，一台支持小区信令测试的射频综测仪：Agilent 8960/R&S CMW500等（下面的SOP以Agilent  8960为例）
2，测试仪器对应的白卡（一张和仪器配套的SIM卡），以及用于连接手机和仪器的射频线
3，一台支持小区广播功能的测试手机

Step-by-step guide
1，手机插入白卡，然后开机，确保小区广播开关处于开启状态
2，按开关按钮启动8960仪器
3，仪器启动完成之后点击仪器面板上的System Config按钮进入系统配置界面
4，在配置界面查看当前运行的Application，确认当前运行的是“GSM/GPRS Lab App”,如果不是该应用请通过UI上的“Application Switch”切换到该应用（切换应用会自动重启仪器）。
5，按操作面板上的“Call SETUP”按钮，进入Call Setup Screen，然后按“Active Cell”按钮，选择Operation Mode为"Active Cell(GSM)"
6, 完整以上配置之后，再将手机和仪器通过射频线连接（注意当前测试的是GSM，请连接到手机上的GSM的射频口）
7，等待手机注册到仪器，注册上之后在手机的状态栏可以看到信号图标。
     如果长时间没有注册上网络，可以在手机上通过开启飞行模式再关闭的方式触发手机端的驻网流程
8，确认注册上网络之后在Call Setup 界面按“1 of 4” 按钮翻到下一页，选中“Short Message Service”
9，进入"Short Message Service"界面，选中“CellBroadcast”
10，进入“Cell Broadcast”界面，可以通过Message Setup设定CB信息的“Geographical Scope”/"Message Code"/"Message Identifier"/DCS/content等信息.
11, 按“Start Cell Broadcast”按钮仪器就会下发设定的CB Message给手机。
```

## [FAQ18280] 如何搭建小区广播环境

```
有些厂商需要搭建小广播环境，使用RACAL 6104
1.仪器设定
Step1. 点选Parameters
Step2. 选CCH/TCM设定
Step3.设定Channel Level/TCH Level（数值设越大，强度越大）
Step4.设定Message ID
    Coding Scheme(1:文字/ 17:乱码 87：空白)
    Repetition Interval/Initial Delay/Transmit Message
Step5. 如果手机已经camp上网路，仪器上的status会显示相关资讯

2.手机设定
Step1. 插入白卡
Step2. Camp on network
Step3. Go to message->settings->Trun on Cell Broadcast
```

## [adb]如何切换selinux的模式

```
adb shell setenforce 0(宽容模式，permissive);
adb shell getenforce可以获取当前的selinux的模式
```

## 如何设置省电模式/[Bug](显示)更换电池，原先低电量保护显示机制不会消失(redmine76107)

```
后面的这个问题是由于没有默认设置低电量level值的原因（数据库已经存在，只是没有默认值），frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java中加入loadIntegerSetting(stmt, Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL,
R.integer.def_low_battery_level);即可
其次，设置最低电量等级的是Settings.Global.LOW_POWER_MODE_TRIGGER_LEVEL这个数据库，直接去设置数据库即可

如何在settings-->battery-->menu-->battery saver中低电量level的值，首先在packages/apps/Settings/res/values/arrays.xml中battery_saver_trigger_values值，可以去新加或者去修改，然后在packages/apps/Settings/src/com/android/settings/fuelgauge/BatterySaverSettings.java文件中onActivityCreated(Bundle savedInstanceState)方法中的new SettingPref中的默认值参数（这个去设置的时候必须是battery_saver_trigger_values中的其中一个才有效，因为他会去遍历这个battery_saver_trigger_values数组），也就是说哪怕没有设置默认值，当进入这个文件也会去设置上面数据库的值，所以我们在刚刷机后去进行默认值的设置的时候最好跟你settings中去重新设置的是一样的，这样就可以保持一致性。
```

## git 清空环境

``` bash
git reset --hard HEAD && git clean -xdf && git pull && git status
```

## 如何在静音模式下也有截图以及拍照声音

```
1、frameworks/base/core/res/res/values-mcc404/config.xml中的config_camera_sound_forced 的值设置为true，强制使用拍照声音
如果设为false的话，会跟着情景模式走，当静音模式的时候就不会出现截图和拍照声音，如果是户外模式的时候就会出现截图和拍照声音
2、也可以audioservice.java里的 readCameraSoundForced()， 返回结果强制返回一个false。
```

## OMACP

```
Omacp是一个功能，相当于是运营商给你发一个ota指令或者一条短信，你点击短信后会自动去更新运营商要求你更新的apn
1、现有的状态：接收到Omacp后作为新的APN直接添加到数据库中，如有你要直接接收到Omacp设置APN信息后,用新的APN替换原有的APN，请参考[FAQ18292]Omacp Apn信息替换原有APN
2、[FAQ09453]Omacp协议版本及可以支持的配置内容
3、如果要有该功能的话，要打开MTK_OMACP_SUPPORT、MTK_OMADRM_SUPPORT、MTK_OMA_DOWNLOAD_SUPPORT的宏
4、在某些国家Email参数SMTP不同，导致在收到Omacp message中含有Email参数的时候，配置无法安装。Omacp出错log如下：
ActivityManager: Broadcast: Intent { act=com.mediatek.omacp.settings.result (has extras) } ordered=false callerApp=ProcessRecord{40b3cbd8 6138:com.android.email/10014}
Omacp/OmacpMessageSettingsDetail: OmacpMessageSettingsDetail result received, appId is : 25 result is : false
可参考[FAQ11680]由于Email参数SMTP_APPID不同，导致Omacp配置email失败的修改方法
5、要接收到omacp的短信，一般都要有自己源生的短信apk，如果用google短信是不行的，如果只有google短信，修改OmacpMessageNotification.java的updateNotification函数,将
otherAppContext = context.createPackageContext("com.android.mms",Context.CONTEXT_IGNORE_SECURITY);修改成otherAppContext = context.createPackageContext	("com.google.android.apps.messaging",Context.CONTEXT_IGNORE_SECURITY);
```

## 如何使<32M,手机内存就不能push或者复制进去东西

```
FAQ14938 关于文件系统空间预留的说明  --->可以修改第一点以及data区那个点即可实现，即kernel-3.18/fs/ext4/super.c文件中把resv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096)改为resv_clusters = min_t(ext4_fsblk_t, resv_clusters, 8192)，同时device/mediatek/mt6735/init.mt6735.rc文件中把exec /system/bin/tune2fs -O has_journal -u 10010 -r 4096 /dev/block/platform/mtk-msdc.0/11230000.msdc0/by-name/userdata修改为exec /system/bin/tune2fs -O has_journal -u 10010 -r 0 /dev/block/platform/mtk-msdc.0/11230000.msdc0/by-name/userdata
```

## 如何关闭多用户功能

```
设置为如下：
MTK_2SDCARD_SWAP = yes(这个可能可有可无)
MTK_OWNER_SDCARD_ONLY_SUPPORT=no
sagereal_add_multiuser = no
config_enableMultiUserUI = false
config_multiuserMaximumUsers = 1

[FAQ13688]【Multi-user】如何在L版本上打开Multi-user？
[FAQ18300]如何确认M版本上Multi-user的配置是否ok？
[FAQ13578]Multi-user模式下，user A设置的闹钟，在user B有铃声无画面，无法关闭
[FAQ14403]【multi-user】android 5.1 如何打开 android.software.managed_users 功能
```

## 通话 log 抓取

```
当通话时出现问题，该抓取什么log（一般抓取vm log即可）
通常Speech测试，提供一般通话log即可，如果有通话无声问题在确认为非网络原因导致，则需要按照通话无声重新提供log。
VM log抓取：按*#*#3646633#*#*进入工模/Hardware Testing/Audio/speech logger,勾选上Enable speech log+EPL(Enhanced PCM Log),打开vmlog后每打一通电话便会在mtklog/audio_dump中生成一个*.vm文件，其以通话开始时间命名。
```

## 蓝牙 log 抓取

```
当关于蓝牙的时候的bug，应该抓取什么log ---->hci log
HCI(Host Controller Interface，主机控制接口) HCI,属于蓝牙协议栈的一部分。
蓝牙规范包含了一个符合标准的接口定义(主机控制器接口),它适用于蓝牙通讯模块的硬件部分。此定义描述了位于HCI驱动程序(主机的一部分,也即蓝牙通讯模块的使用者)和主机控制器固件(蓝牙通讯模块本身的一部分)之间的接口
settings->developer options->enable bluetooth snoop hci log->勾选

路径位置：不同平台位置有所不同：
M平台：/sdcard/mtklog/btlog/
L平台：adb命令：/data/@btmtk/
```

## [gps][FAQ05622]GPS问题所需要录制的log及方法

```
对于通常遇到的GPS问题，需要录制什么log，以及如何录制。

[SOLUTION]
对于GPS问题，请提供mobile log和GPS debug log。
log 抓取办法如下：
1. 进到工程模式，打开YGPS。
2. 点击“NMEA Log->Enable dbg2file [Need Restart]”按钮和“NMEA Log->Enable dbg2ddms [Need Restart]”按钮。
3. 退出YGPS，间隔至少3s后，再进入GPS应用程序（如导航软件，YGPS）开始测试，这样才能确保操作生效。
4. log最后会存放在手机的/data/misc/gpsdebug.log.xxx，测试完后请将log提供给我们分析。
5. 附上log的同时也请告知复现问题的操作步骤以及复现问题的时间点，如hh:mm:ss出现什么现象。
note:
1.测试时请选择GPS信号良好的空地（视野范围内无建筑物遮挡）进行测试，以排除环境因素导致无法定位，定位慢，定位漂移等问题。
2.测试前请确保测试机有root 权限，可以访问/data/misc/路径，可以将gps debug log用adb拉出来。
3.测试完成后请注意以下事项
a.请进入YGPS，点击“NMEA Log->disable dbg2file [Need Restart]”按钮，然后退出YGPS，这样才能确保操作生效。否则，只要打开GPS，就会录制debug log，这样会占用更多的存储空间，导致不可预测的问题发生。
b.将/data/misc/gpsdebug.log.xxx删除，因为即使disable dbg2file以后，这笔log仍然会在/data/misc/。
【Mobile log抓取方法】
1. 进入工程模式，找到system logger进行相应设置,打开mobile log、net log、modem log。
2. 测试完成后，请将SD卡中mtklog文件夹中的所有log提供给我们。
```

## 如何快速抓取systrace （Systrace的功能用来debug performance问题）

```
前提条件：下载好android SDK，安装Python
1，终端下，cd切换到SDK目录
2，切换到systrace目录：……../platform-tools/systrace
3,执行命令.
python systrace.py --time=10 -o performanceTrace.html sched gfx view wm
--time=10表示抓取10s的信息
–o performanceTrace.html表示输出文件名
sched gfx view wm 是TAG（python systrace.py -l 可以查看全部标签）
4,在当前路径生成的performanceTrace.html即是报告文件。右键用google浏览器打开，即可查看。
```

## spn系统获取的优先级

```
在frameworks/opt/telephony/src/java/com/android/internal/telephony/uicc/SpnOverride.java文件lookupOperatorName方法中去获取那几个在system/etc下的spn文件，但是在显示过程中会先去判断，如下：
if ((numeric.equals("46000")) || (numeric.equals("46002")) || (numeric.equals("46007")) || (numeric.equals("46008"))) {
        operName = context.getText(com.mediatek.R.string.oper_long_46000).toString();
    } else if ((numeric.equals("46001")) || (numeric.equals("46009"))) {
        operName = context.getText(com.mediatek.R.string.oper_long_46001).toString();
    } else if ((numeric.equals("46003")) || (numeric.equals("46011")) || getFromResource) {
        operName = context.getText(com.mediatek.R.string.oper_long_46003).toString();
    } else if (numeric.equals("46601")) {
        operName = context.getText(com.mediatek.R.string.oper_long_46601).toString();
    } else if (numeric.equals("46692")) {
        operName = context.getText(com.mediatek.R.string.oper_long_46692).toString();
    } else if (numeric.equals("46697")) {
        operName = context.getText(com.mediatek.R.string.oper_long_46697).toString();
    } else if (numeric.equals("99998")) {
        operName = context.getText(com.mediatek.R.string.oper_long_99998).toString();
    } else if (numeric.equals("99999")) {
        operName = context.getText(com.mediatek.R.string.oper_long_99999).toString();
    } else {
        // If can't found corresspoding operator in string resource, lookup from spn_conf.xml
        if (containsCarrier(numeric)) {
            operName = getSpn(numeric);
        } else {
            Rlog.w(LOG_TAG, "Can't find long operator name for " + numeric);
        }
所以，有些比如说显示的CMCC、CU都是在这里判断显示的，并不是在spn文件中去写的
ps：在这个方法中可以看到，获取显示名字的优先级为getSpnByEfSpn(etc/virtual-spn-conf-by-efspn.xml) 》 getSpnByImsi(etc/virtual-spn-conf-by-imsi.xml) 》 getSpnByEfPnn(etc/virtual-spn-conf-by-efpnn.xml) 》 getSpnByEfGid(etc/virtual-spn-conf-by-efgid1.xml) 》  etc/spn-conf.xml

virtual-spn-conf-by-efspn.xml文件中的efspn一般是在log中去抓取的，其实就是写在sim卡中的，所以优先级相当于sim卡最高，至于为什么要出现这几个xml文件，就是为了区别网络运营商和运营商，因为这两个的mnc和mcc是一样的，所以就用网络运营商中的efspn等值来区别开来
```

## google包对应名称

```
Velvet ---> google search
Phonesky ----> Google Play Store
```

## tac code是imei的前8位 （早期是6位） ？？？

```
TAC code 是什么鬼？？
```

## 单双卡配置，修改该宏的值：

```
MTK_MULTI_SIM_SUPPORT
path:ALPS-MP-N0.MP2-V1_SR6580_WE_N/sagereal/mk/project**/ProjectConfig.mk
1.ss -单卡
2.dsds/dsda -双卡 （区别：dsds双卡双待，dsda双卡双通，我们公司基本都是dsds)
3.tsts -三卡
4.qsqs -四卡
比如双卡配置：MTK_MULTI_SIM_SUPPORT = dsds
```

## 开机向导中一直会出现Permissions denied: You can change them in Settings > Apps的提醒

```
这是因为有两个日历（calendar）引起的，如果只有一个日历就不会出现这个问题
如果客户一定要两个日历都存在，需要去把mtk日历的权限去默认打开；如果只存在其中一个日历，不会出现该问题
```

## 连上wifi后经常断开再连上

```
1、当碰到这种事情的时候，先去楼下环境（各种wifi或者热点比较少的环境下，可能会相互影响）去测试下，看是否ok
2、如果还是NOK，就需要我们在main_log或者kenerl_log中去搜一下“reason”，一般是能搜到断开wifi的reason的
3、再不行就要提MTK了，问问有没有patch  ALPS02358954
```

## [FAQ11754]KitKat版本如何将camera service修改为强占式

```
实现强占式camera service，当某些应用（如手电筒）在后台打开camera后，当camera app open camera时可以强占被后台应用占有的camera.
```

## [FAQ02941]ro.operator.optr属性问题

```
ro.operator.optr属性是代表工程中运营商的偏好行为，会在ProjectConfig.mk中由OPTR_SPEC_SEG_DEF的值来指定。目前这个属性只有八个值：OP01、OP02、OP03、OP06、OP07、OP08、OP09、OP10。
OP01表示中国移动（CMCC）
OP02表示中国联通（CU）
OP03表示Orange
OP06表示Vodafone
OP07表示AT&T
OP08表示TMO-US
OP09表示中国电信（CT）
OP10表示Tier-2 operator
且这个属性值目前无法增加其他的值。
```

## 如何让camera在拍录像的同时能拍照

```
在camera的配置文件中，搜索KEY_VIDEO_SNAPSHOT_SUPPORTED，
#if 1
//  Video Snapshot
FTABLE_CONFIG_AS_TYPE_OF_USER(
KEY_AS_(MtkCameraParameters::KEY_VIDEO_SNAPSHOT_SUPPORTED), 
    SCENE_AS_DEFAULT_SCENE(
        ITEM_AS_DEFAULT_(MtkCameraParameters::TRUE),             ---->TRUE为支持，FALSE为不支持
    ), 
)
#endif
```

## 如何跳转到某个apk的detail界面，即加权限界面

``` Java
Intent in = new Intent().setAction(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS)
    .setData(Uri.fromParts("package", "com.android.mms", null))
    .addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
mContext.startActivity(in);

如何通过 adb 的方式？？？
```

## *res/raw和assets的相同点和不同点

```
*res/raw和assets的相同点：
1.两者目录下的文件在打包后会原封不动的保存在apk包中，不会被编译成二进制。

*res/raw和assets的不同点：
1.res/raw中的文件会被映射到R.java文件中，访问的时候直接使用资源ID即R.id.filename；assets文件夹下的文件不会被映射到R.java中，访问的时候需要AssetManager类。
2.res/raw不可以有目录结构，而assets则可以有目录结构，也就是assets目录下可以再建立文件夹
*读取文件资源：
InputStream is =getResources().openRawResource(R.id.filename);
2.读取assets下的文件资源，通过以下方式获取输入流来进行写操作
AssetManager am = null;
am = getAssets();
InputStream is = am.open("filename"); 
注意1：Google的Android系统处理Assert有个bug，在AssertManager中不能处理单个超过1MB的文件，不然会报异常，raw没这个限制可以放个4MB的Mp3文件没问题。
注意2：assets 文件夹是存放不进行编译加工的原生文件，即该文件夹里面的文件不会像 xml， java 文件被预编译，可以存放一些图片，html，js, css 等文件。
```

```

## 如果在非launcher界面，短信会以toast的形式显示出来  （一般都是直接在状态栏提醒下）

```
可以搜索enqueueToast，然后发现如下log，可以发现pkg是什么，也就是是因为哪个apk才出现该toast
./mobilelog/APLog_2017_0306_212156/sys_log:03-06 21:22:21.511677   788  9291 I NotificationService: enqueueToast pkg=com.beyond.cineplanet callback=android.app.ITransientNotification$Stub$Proxy@83465a6 duration=0
```

## SeLinux相关

```
如何加selinux权限
log：
01-01 09:05:45.210000  8349  8349 W Thread-235: type=1400 audit(0.0:124): avc: denied { write } for name="brightness" dev="sysfs" ino=10091 scontext=u:r:system_app:s0 tcontext=u:object_r:sysfs:s0 tclass=file permissive=0
01-01 09:05:45.220918  1630  8346 D NuPlayerRenderer: renderer set speed = 1
01-01 09:05:45.221295  1630  8346 E NuPlayer: onScanSources
01-01 09:05:45.221736  1630  8346 D Utils   : kKeyEndian in utils is 2
01-01 09:05:45.221830  3024  8349 W System.err: java.io.FileNotFoundException: /sys/class/leds/green/brightness: open failed: EACCES (Permission denied)

内置到system/priv-app/下的第三方apk，因selinux 权限问题，无法点亮LED

解析：
audit2allow -i 111.txt

#============= system_app ==============
allow system_app sysfs:file write;

如果直接加在system_app.te中，会与externel下文件冲突，导致编译报错，可以重新定义类型：

添加：
------＞file.te
#liangshuang add for green led 2016-12-28
type sys_green_brightness_file, fs_type,sysfs_type;

file_contexts
#liangshuang add for green led 2016-12-28
/sys/class/leds/green/brightness u:object_r:sys_green_brightness_file:s0

system_app.te
#liangshuang add for green led 2016-12-28
allow system_app sys_green_brightness_file:file write;

system_server.te
#liangshuang add for green led 2016-12-28
allow system_server sys_green_brightness_file:file write;

快速编译验证
mmm external/sepolicy
make -j24 ramdisk-nodeps
make -j24 bootimage-nodeps
然后再重新刷bootimage 测试.

ps：[FAQ13324] SELinux 常见问题汇总
[FAQ13820] Android L APP 如何获取proc file system 中节点的写权限
[FAQ13635] Android L APP 如何获取sys file system 中节点的写权限
[FAQ11486] [SELinux Policy] 如何设置SELinux 策略规则 ? 在Kernel Log 中出现"avc: denied" 要如何处理？

新加冲突的selinux权限方法：
(1)、先在file.te/property.te/device.te等文件中定义
(2)、在file_contexts/gen_contexts等对应文件中绑定第(1)步定义的label
(3)、在对应的.te文件中申请权限，即allow system_server sys_green_brightness_file:file write;样式，如果用audit2allow跑出来的.te文件不存在，则可以重新新建一个
```

## sr6750_35g_n软件包中每个代表的信息

```
下图是6755 N的make文件，前4个数字代表平台（说明6750 & 6755都是用这套代码）；
第5个数字，是3或6，3代表32位系统，6代表64位系统。64位系统的CTS测试case要比32位多很多
第6个数字，是5或者6，5代表5模，6代表6模
g代表GMO版本，GMO的特点是MTK裁剪了某些feature，用于节省ram，以便512M内存也可以用
n代表android版本为N
```

## 有些4+512的项目安装大型第三方apk会出现安装时间长，在安装过程中去操作系统会出现卡顿的现象  ----->5012_LP的项目（M）

```
在L、M版本上：art/dex2oat/dex2oat.cc文件中最上面定义如下代码：
#define IS_APP(appname) ((!oat_filename_.empty() && (oat_filename_.find(appname) != std::string::npos)) ||  \
    (!zip_location_.empty() && (zip_location_.find(appname) != std::string::npos)) ||  \
    (!oat_location_.empty() && (oat_location_.find(appname) != std::string::npos)))
然后在compiler_options_.reset(new CompilerOptions这句话前面加上如下代码：
if( IS_APP("facebook") || IS_APP("youtube") || IS_APP("skype") || IS_APP("twitter") ) {
    compiler_filter = CompilerOptions::kInterpretOnly;
    LOG(INFO) <<" This apk is in whitelist, so set interpret-only ";
}
```

## [FAQ06165][NVRAM][SIM_ME_LOCK]protect_f和protect_s分区的作用是什么？

```
[Description]
protect_f和protect_s分区的作用是什么？

[Solution]
在没有Protect_s和Protect_f分区之前，SIM ME LOCK数据存在USER DATA分区内，详细路径为/data/nvram/md/NVRAM/IMPORTANT。
当恢复出厂设置时，会将/data/nvram/md/下的文件全部清除，其后开机时会将NVRAM BIN Region中备份的数据recovery到/data/nvram/md/下。

如NVRAM BIN REGION中数据为空，则会按照默认值生成SIM ME LOCK数据。
如NVRAM BIN REGION中数据不为空，则会将SIM ME LOCK数据恢复为NVRAM BIN REGION保存的状态。

针对case 2，由于NVRAM BIN REGION中保存的状态并不总是同恢复出厂之前/data/nvram/md/NVRAM/IMPORTANT下的SIM ME LOCK数据状态一致，因此可能无法满足SML 的更新一致性要求。

为了对SML数据进行持久化保存以及更新一致性的目的，我们将SML数据移入Protect_s和Protect_f分区。

Protect_s和Protect_f分区的特点有：
Download的时候若要format USERDATA分区时，不会format Protect_s和Protect_f。
恢复出厂设置时，也不会清除 Protect_s和Protect_f。但若此时BIN Region中无内容，开机时会判断出USERDATA分区中/data/nvram/md不存在且BIN Region中无内容，进而断定是第一次开机从而根据默认值生成SIM ME LOCK。

[FAQ04454][NVRAM]modem内的哪些NVRAM会被备份到BIN Region?
Protect_s和Protect_f分区数据是不会被备份到bin区的。
把数据放入到product_info就能实现该数据在回恢复出厂设置的时候不丢失
```

## gps默认关闭

```
当把gps默认关闭后，开机向导会把gps去打开（此时打开的是network，即battery saving），此时要关闭的话，必须在开机向导结束后去修改数据库
1.首先需要将def_location_providers_allowed置为空，即系统认为的默认关闭  2.默认关闭后仍然开启，则抓取第一次开机log，搜索gps字段的关键字location_providers_allowed
3.在sys log中搜索到call_put(secure:location_providers_allowed=+network) for 0   4.同样定位到SettingsProvider.java的call方法，我们也可以在这里做处理
继续查看redmine对应提交记录，我们最终是在Settings.java的putStringForUser方法中修改的，我们可以看到putStringForUser中，最后调用了cp.call(cr.getPackageName(), mCallSetCommand, name, arg);
这句代码最终调用的就是SettingsProvider.java里面的call方法
在Settings.java的putStringForUser方法中加上如下代码
if (Secure.getInt(cr,Secure.USER_SETUP_COMPLETE,0) == 0 && name.equals(Secure.LOCATION_PROVIDERS_ALLOWED)) {
    if(!android.util.FeatureOption.SAGEREAL_GPS_WORKON_WIZARD){
        return true;
    }
}
具体可参考如下文档：/home/jiangcunbin/Desktop/sagereal资料/自己总结/GMS认证/GMS包引起问题分析_new/GMS包引起问题分析.ppt
```

## 多用户相关

```
FAQ13688 【Multi-user】如何在L版本上打开Multi-user？
FAQ14403 【multi-user】android 5.1 如何打开 android.software.managed_users 功能
1. 在sagereal/mk/Project_name/ProjectConfig.mk文件中开以下宏
config_enableMultiUserUI = true
config_multiuserMaximumUsers = 8  //此宏值不小于2,
/*
以上两个宏也可以在alps/frameworks/base/core/res/resalues/config.xml文件中直接设置默认值
<bool name="config_enableMultiUserUI">true</bool>
<integer name="config_multiuserMaximumUsers">8</integer>
*/
MTK_2SDCARD_SWAP = no
MTK_OWNER_SDCARD_ONLY_SUPPORT = yes
MTK_SHARED_SDCARD = yes
2. 在alps/devicegetel/sr6572_wet_l/system.prop文件中ro值
ro.config.low_ram=false
若上面文件中没有该值，可以去alps/devicegetel/sr6572_wet_l/device.mk文件中找到ro.config.low_ram，并设置为false
3. 在alps/frameworks/native/data/etc/handheld_core_hardware.xml文件中打开手机多功能系统服务
<feature name="android.software.managed_users" />
<feature name="android.software.device_admin" />
4. AndroidForWork.apk is mandatory to preload on all GMS devices.  //Google App中必须包含该APK
注意：若要添加多用户功能，必须配置好以上4点，否则CTS测试会有15项测试不通过。

1，Check managered_users configuration:
adb shell pm list features
看是否有android.software.managed_users
2，check multi-user number
adb shell pm  get-max-users
获取到的个数应该大于1
3，check multi-user UI
adb shell getprop fw.show_multiuserui
这个值应该是true。
```

## [术语]VOLTE、VILTE、VOWIFI、VOIP、SDN、FDN

```
VOLTE 基于LTE的语音通话(VO = voice)，用流量打电话，用LTE承载，但是用分钟数收钱，优点是用数据流量传输数据，音质更好，电话接通更快
VILTE 基于LTE的视频通话（VI = video）
VOWIFI 基于wifi的语音通话(VO = voice) ，用wifi打电话，用wifi承载，这三个都是基于运营商的功能
VOIP 是互联网通话，跟运营商应该没啥关系，需要第三方的apk去实现
SDN 预制默认联系人
FDN 固定联系人
```

## 如何添加widevine 

```
http://172.16.78.132:8002/gitweb/?p=repositories/ALPS-MP-N0.MP2-V1_SR6580_WE_N.git;a=commitdiff;h=b942425cc932e1cdfb716cda72a37183ed87c995;hp=a9460b27dce8bb4163bf92522aae534af9ade5bf
修改方法：
(1)、alps/device/mediatek/common/device.mk
ifeq (yes, $(strip $(SAGEREAL_WIDEVINE_SUPPORT)))
$(shell cp $(TOPDIR)device/mediatek/common/widevine_on/SECRO_GMP.ini  $(TOPDIR)vendor/mediatek/proprietary/custom/common/secro/SECRO_GMP.ini)
else
$(shell cp $(TOPDIR)device/mediatek/common/widevine_off/SECRO_GMP.ini  $(TOPDIR)vendor/mediatek/proprietary/custom/common/secro/SECRO_GMP.ini)
endif	
(2)、alps/device/mediatek/common/widevine_off/SECRO_GMP.ini 	新建的文件
(3)、alps/device/mediatek/common/widevine_on/SECRO_GMP.ini 	新建的文件
(4)、sagereal/mk/VP40_H4007/ProjectConfig.mk   ---->  SAGEREAL_WIDEVINE_SUPPORT = yes
(5)、sagereal/script/makesagerealAction.sh
把make -j8 sign-image 2>&1 | tee sign-image_build.log修改为make -j8 sign-image-nodeps 2>&1 | tee sign-image_build.log
```

## [默认值][FAQ20101]增加National data roaming 菜单定制

```
这里的漫游，是指手机使用一个运营商的SIM卡，注册上另一个运营商的网络。
International Roaming: Operator A的sim卡注册到了和Operator A不同国家的其他Operator的plmn上；
National Roaming: Operator A的sim卡注册到了和Operator A相同国家的其他Operator的plmn上；
ps:[FAQ09599]如何默认勾选DATA ROAMING
```

## 如何修改默认camera插值

```
默认的插值都是默认插值为最后一个，有时候客户需要默认插值为某个值，可以按照下面这个FAQ进行修改。
[FAQ14380]L版本上如何修改默认picture size
```

## Android 手机上的 USB MIDI 是做什么用的?怎么用? 

```
goole 从 M 平台开始就有这一功能，这个功能是USB可以插入MIDI 键盘，手机就会成为音源，弹奏键盘，手机就能发出声音
```

## DuraSpeed（快霸）功能   ----> [FAQ19932]快霸(DuraSpeed)功能介绍

```
DuraSpeed 是 MTK 开发的进程管理软件, 目的是“缓解手机长时间使用后的性能下降”.
DuraSpeed 在 APP 启动时开始执行, 在后台限制“被保护之外”的进程. 从而为前台进程提供更多的系统资源.
DuraSpeed 有一套进程保护规则, 并提供 APP List 允许使用者编辑应用保护列表.
快霸透过抑制后台应用的活动来加速前台应用的速度，但可能导致部分通知无法正常接收
ps：这是一个apk，无源码，路径在alps/vendor/mediatek/proprietary/packages/apps/RunningBooster
```

## widevive和secureboot

```
数字版权管理 Digital Rights Management----简称DRM，这个google的默认都有，而且打开了，但是怎么保护这个DRM，这时候就需要使用widevine技术了。
DRM 是一系列访问控制技术的集合，它不仅用来控制对作品或设备的拷贝。而且也控制使用、查看、打印及修改等内容。最简单的话说对那些音乐，视频，电子书，游戏等很容易被复制的内容进行控制，防止盗版。MTK平台，实现DRM保护使用的就是widevine技术。
因此widevine与secure boot的关系是：其实两者是两个不同的东西。widevine只是一家提供了相应DRM解决方案的公司，我们提到widevine，是指该公司提供的解决方案，它实现了Android平台的版权保护，它针对数字媒体提供了与格式无关的加密解密方式来保护版权。而secure boot是mtk的在刷机，启动，升级等过程中的安全机制，只是两者绑定了。我们要想启用widevine，必须enable serure boot。

ps：widevine的机制本身就存在，但是必须打开serure boot才能启用。

当终端产品enable了该功能，相关的安全机制如下。
1）：Secure Download Check:编译时期，image会被客户的key签名。而Flashtool在下载时，会检查签名。
2）：Secure Boot Check：终端在启动时，image也会被检查key签名。如果检查失败， 那终端启动会失败。
3）：Secure Version Check：image会配置security version number和custom name，下载的时候，会被检查。（可以高，不能低）。
```

## [术语]CSFB

```
电路回落 Call Service Fall Back
```

## 如何加默认权限

```
frameworks/base/services/core/java/com/android/server/pm/DefaultPermissionGrantPolicy.java文件，如果要加某个package的权限，可以使用PackageParser.Package coppelPackage = getPackageLPr("com.esoft.movil.coppel")方法，“com.esoft.movil.coppel”为包名
```

## [adb]查看cpu信息

``` bash
adb shell cat /proc/cpuinfo
```

## [术语][RDS]FM中的RDS功能  ----> 目前MTK的chip都是支持RDS功能的。

```
一、支持RDS功能的FM收音机就是指具有“无线数据广播系统”功能的收音机。
二、所谓RDS是英国BBC广播公司开发的一种特殊无线电广播。即“无线数据广播系统”（Radio Data System). 它是在调频广播发射信号中利用副载波把电台名称，节目类型，节目内容及其它信息以数字形式发送出去。通过具有RDS功能的调谐器就可以识别这些数字信号，并做响应处理，RDS广播精髓在于其AF和TA功能，AF既自动频率调整，当信号低于某个水平时，AF功能会自动搜索当前电台的其他发射频率串。
三、RDS收音系统还独有“交流信息”功能（TA功能，也称交通公告），若有紧急事件，电台就会发送特殊信号，令收音机强行播放，另外，还有时间基准发射，自动调准收音机时间等功能，RDS在汽车，手机等移动设备上使用很方便。
四、目前国内支持RDS的电台已知的有：
上海 FM91.4 中央人民广播电台经济之声
北京 FM88.7 中国国际广播电台 HIT FM
上海 FM87.9 中国国际广播电台 HIT FM
广州 FM88.5 中国国际广播电台 HIT FM
```

## 如何把四个cpu同时打开，提高速度

```
echo 0 > /proc/hps/enabled
echo 1 > /sys/devices/system/cpu/cpu0/online
echo 1 > /sys/devices/system/cpu/cpu1/online
echo 1 > /sys/devices/system/cpu/cpu2/online
echo 1 > /sys/devices/system/cpu/cpu3/online
```

## 省晶体软件 （GPS）  ----> gps需要校准

```
1、Coclock是会节省一颗TCXO物料。
2、通过check log中CO、C1的值是否为0，为0表示校准失败 ，否则校准成功。
mnl_linux: linux_gps_init: init_cfg.C0 = 0
mnl_linux: linux_gps_init: init_cfg.C1 = 0
3、关于GPS校准，针对的是采用coclock 方案的项目:
1.涉及到的宏及路径：
MTK_GPS_CO_CLOCK_DATA_IN_MD
 
M版本在project.mak中
 
N版本在
/vendor/mediatek/proprietary/hardware/connectivity/gps/mtk_mnld/Android.mak
 
2.开关宏的标准：
看平台是否support LTE，若平台support LTE，則C0/C1是從MD NVRAM讀取，则
要打开这个宏控；若平台not support LTE，則C0/C1是從AP NVRAM讀取(如6580)，则
要关闭这个宏控。
4、备份GPS参数具体有哪些？
[GPS COClock Coefficients]
C0=0
C1=-0.224999994039536
initU=0
lastU=0
如果C0/C1是從MD NVRAM讀取，则可以直接用用meta工具（modem版本）去备份出这些参数。如果C0/C1是從AP NVRAM讀取(如6580)，则需要用张迪最新开发的apk
```

## RTC 有其自己的供电系统,所以在手机处于关机状态时,RTC仍然可以正常工作，关机闹钟的时候就是通过RTC的自己的供电系统去检测

## calendar日历中有个pop-up notification

```
M/N：该功能实现就是出悬挂式的notification，悬挂式Notification是android5.0新增加的方式，和前两种显示方式不同的是，前两种需要下拉通知栏才能看到通知，而 悬挂式Notification不需要下拉通知栏就直接显示出来悬挂在屏幕上方并且焦点不变仍在用户操作的界面因此不会打断用户的操作，过几秒就会自动消失。
和前两种Notification不同的是，他需要调用setFullScreenIntent来将Notification变为悬挂式Notification
notificationBuilder.setFullScreenIntent(pendingIntent1, false);// 横幅，悬挂式
```

## PAI

```
如果一个apk是在system区的，另一个apk是在data区的，当两个apk的包名都相同且版本号不一样的时候，在data区的apk也算是在system区且会直接覆盖system区里面的apk
ps：详细见PAI原理
```

## TEE

```
关于tee
如何查看tee.bin的版本？
	---> 在终端中执行如下密令：strings tee.bin | grep "gp" （其中tee.bin就是客户提供的tee.bin文件）,出来的结果就是tee的版本
如何查看preloader是否升级上去?
	---> 可以抓取升级前后的串口log，在log中搜索[TZ_INIT] TEE start entry即可，看看起始地址是否相同
```

## 如何将默认滑动解锁改为 pin/password 解锁

```
[DESCRIPTION]
目前 google 采用默认滑动解锁的方式
如果想改成默认其它的解锁方式, 必设定一个初始密码
请参考如下 solution:

[SOLUTION]
在 KeyguardViewMediator.java 的 onSystemReady 方法中的开始位置
判断是否为首次开机, 如果是就加入下面这段 code 去设置密码

public void onSystemReady(){
       ...
+       if(mUpdateMonitor.isDeviceProvisioned()){//判断是否首次开机
+             mLockPatternUtils.saveLockPassword("password",DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC);    //设置password为默认解锁类型
+       }
       doKeyguardLocked(null);
       ...
}

如要修改成PIN, 用如下部分替换上述红色代码
mLockPatternUtils.saveLockPassword("1234",DevicePolicyManager.PASSWORD_QUALITY_NUMERIC);

请自行修改上述参数达到设置不同解锁方式及密码的效果
```

## 当长时间播放视频或者播放音乐出现无声音现象

```
可以搜下no more track availble这块log，然后是否有如下类似的log
Dear customer,
06-07 12:55:30.413251 299 6231 E AudioFlinger_Threads: no more track availble
06-07 12:55:30.413311 299 6231 E AudioFlinger_Threads: track name: 4104, ID 10097
06-07 12:55:30.413362 299 6231 E AudioFlinger_Threads: track name: 4101, ID 10097
06-07 12:55:30.413411 299 6231 E AudioFlinger_Threads: track name: 4117, ID 10097
06-07 12:55:30.413459 299 6231 E AudioFlinger_Threads: track name: 4120, ID 10097
06-07 12:55:30.413507 299 6231 E AudioFlinger_Threads: track name: 4123, ID 10097
06-07 12:55:30.413558 299 6231 E AudioFlinger_Threads: track name: 4106, ID 10097
06-07 12:55:30.413610 299 6231 E AudioFlinger_Threads: track name: 4108, ID 10097
06-07 12:55:30.413658 299 6231 E AudioFlinger_Threads: track name: 4111, ID 10097
06-07 12:55:30.413710 299 6231 E AudioFlinger_Threads: track name: 4114, ID 10097
06-07 12:55:30.413764 299 6231 E AudioFlinger_Threads: track name: 4126, ID 10097
06-07 12:55:30.413812 299 6231 E AudioFlinger_Threads: track name: 4113, ID 10097
06-07 12:55:30.413895 299 6231 E AudioFlinger_Threads: track name: 4110, ID 10097
06-07 12:55:30.413950 299 6231 E AudioFlinger_Threads: track name: 4103, ID 10097
06-07 12:55:30.414009 299 6231 E AudioFlinger_Threads: track name: 4119, ID 10097
06-07 12:55:30.414062 299 6231 E AudioFlinger_Threads: track name: 4107, ID 10097
06-07 12:55:30.414113 299 6231 E AudioFlinger_Threads: track name: 4100, ID 10097
06-07 12:55:30.414165 299 6231 E AudioFlinger_Threads: track name: 4098, ID 10097
06-07 12:55:30.414214 299 6231 E AudioFlinger_Threads: track name: 4099, ID 10097
06-07 12:55:30.414282 299 6231 E AudioFlinger_Threads: track name: 4102, ID 10097
06-07 12:55:30.414363 299 6231 E AudioFlinger_Threads: track name: 4105, ID 10097
06-07 12:55:30.414412 299 6231 E AudioFlinger_Threads: track name: 4109, ID 10097
06-07 12:55:30.414465 299 6231 E AudioFlinger_Threads: track name: 4112, ID 10097
06-07 12:55:30.414518 299 6231 E AudioFlinger_Threads: track name: 4115, ID 10097
06-07 12:55:30.414572 299 6231 E AudioFlinger_Threads: track name: 4118, ID 10097

根据google设计，track最多只能有32个。
出现audiotrack报错，是因为track被占满了，如上LOG。
在events log可以看到10097是水果忍者进程：
06-07 12:48:56.314997 940 3309 I am_proc_start: [0,4207,10097,com.halfbrick.fruitninjahd,activity,com.halfbrick.fruitninjahd/com.halfbrick.fruitninja.FruitNinjaActivity]
通话没有问题是因为通话不需要audio track，数据不经AP，直接走MODEM。
综上，这个应该是属于水果忍者第三方APK的问题，使用了以后没有释放track导致的。
请知，谢谢！
```

## Android O以后版本内置第三方APK可卸载可恢复的方法变更

```
由于Android O以后使用了vendor分区在编译时会生成 vendor.img，使用之前内置第三方APK可卸载可恢复的方法时在编译时会报错无法生成 vendor.img。
O版以后内置可卸载可恢复的第三方APK时可将该语句

LOCAL_MODULE_PATH := $(TARGET_OUT)/vendor/operator/app

修改为：

LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/operator/app

P平台预置可卸载可恢复APK
1.预置方式和O平台一样：
预置路径：LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/operator/app
2.有些APK（eg:facebook）中会包含动态、或者静态库文件，预置后点击会因找不到库报错，一般是缺少SELinux权限，可以抓取LOG，生成权限后加入即可。
（一般需要该权限：allow untrusted_app_27 system_data_file:file {open execute r_file_perms};）
3，对于可卸载可恢复的APK注意：
P版本的vendor/operator/app将不再直接具有uninstall的功能，需要在可删除系统的list文件中加入对应的package name才可以。
alps/vendor/mediatek/proprieta
```

## 如何编译userdebug版本

```
/home/jiangcunbin/project/80M/WM05_GMO/ALPS-MP-M0.MP1-V2.34_SR6580_WE_M/sagereal/script/makesagerealAction.sh文件中把
if [ $1 == "yes" ]; then
	lunch full_${sagereal_target_project}-user
else
	lunch full_${sagereal_target_project}-eng
fi
把对应的修改为lunch full_${sagereal_target_project}-userdebug即可

或

source build/envsetup.sh
lunch full_${sagereal_target_project}-userdebug
```

## [mtklog]关于抓取mtklog

```
1、eng版本在抓取log的时候，可以把mtklog中的taglog关闭，taglog的作用：当系统有exception(如NE，ANR)发生时会弹出这个Tag Log的框，作用是把当前exception的log保存到SD card的，做记录Log之用，当ANR等情况下会把log压缩至mtklog/taglog/文件下；如果关闭该功能的话，按照正常的log抓取，具体可参考[FAQ03748] TagLog功能简述
2、userdebug版本有时候会出现无法抓取到aee_exp文件的情况，这是因为Android M/N, 因受security 限制, aee 如果mode 开到3, 权限太大, 会导致安全问题， 后续user/userdebug build 默认设置成了mode 4 , 并且mobile log 无法  直接切成mode 3. 导致开了mtklogger 后也只能抓到fatal db （见下表），而不能抓到普通exception db;具体修改
如果需要在user load 中打开mobilelogd 后，能够切换到aee mode3 抓到普通exception db ，可以参考以下修改：关闭强制性约束.
/vendor/mediatek/proprietary/external/aee/config_external/init.aee.customer.rc 文件中添加
on init
setprop ro.aee.enforcing no
（在出货版本中，切记把此行 注释掉）
具体可以参考[FAQ20159] Android M/N user load，在打了aee security enhance patch 后，如何抓到普通aee db？
```

## [adb]adb相关命令

```
adb shell ls -aal dev/pm ---> 会把dev/pm文件的权限路径等显示出来
adb shell find system -name "*app*" ----> 会把system下名字中有app的都显示出来，需要会使用*
adb logcat | egrep -i "nfc|nxp|AEE_AEDV|ERR"   ---> 抓取log时可以查找多个关键字
依次执行如下两个指令打开mobilelog及taglog
adb shell am broadcast -a com.mediatek.mtklogger.ADB_CMD -e cmd_name switch_taglog --ei cmd_target 1
adb shell am broadcast -a com.mediatek.mtklogger.ADB_CMD -e cmd_name start --ei cmd_target 1
```

## [recovery][ota]升级modem

```
FAQ18188 [Recovery][Common]Android M 版本如何升级logo等rawdata分区方法？  ---> 比如说modem端的MD1IMG等分区的升级
同时要参考FAQ17441 [Recovery] [Common] Android M 版本如何升级lk 、preloader
```

## 如何让apk只能当签了某个特定的key后才能安装？

```
http://192.168.3.76:8007/gitweb/?p=MT6572_JB3_LCA_MP3.git;a=commitdiff;h=8c9ab90ee555e59a1f518dfb938c7851bc073cd3;hp=2a633d6df3a3f83d41826376e31fdd9db1321f36
原理：在 PackageInstallerActivity.java 文件中去获取安装的apk的签名信息（2进制），然后和某个特定的key去对比是否相同，如果相同的话，就直接正常安装（安装apk的方法一直存在），如果不同的话，就是跳出一个对话框而已，不去走安装的方法，原理上platform还是正常的平台签名，key只是某个客户提供的普通key而已，不能认为把platform改成了某个key了，只是当你只签平台签名的时候，不可安装而已，但是当你只安装特定key的时候，该apk不会有平台签名的权限！
```

## [术语]subid和slotid区别

```
slotid或者phoneid是指卡槽，双卡机器卡槽一值为0，卡槽2为1，依次类推，不过国内也就双卡和单卡机器了，三卡机器只听说在遥远的印度有。

subid用过数据库的同学比较好理解，subid就是主键递增项，值从1开始，机器每插入一个新卡（iccid是没有见的，值就会加1，iccid每个sim卡是唯一的）。插入双卡后数据库中就会有subid值为1和2的两个数据条目，拔卡插卡交换卡槽数据库并不会增加新项，只有插入一张新的sim卡才会增加一条id为3的数据条目

subid是跟卡走的，slotid是跟卡槽走的。一般来说slotid比较好理解，subid不好理解。

Android5.0之后google终于加入了多sim卡的代码，5.0之前的多卡（一般也就是双卡）机制是各写各的，mtk和高通的代码各有千秋，但是基本上用slotid较多，subid只有mtk在用也很少。Google一统千秋后subid反而用的比slotid多了，

三方app获取slot和subId
这个小节是针对文章下面的评论加的。

frameworks/base/telephony/java/android/telephony/SubscriptionManager.java

public int getDefaultDataPhoneId() 　默认数据slotId
public static int getDefaultDataSubscriptionId()　默认数据subId

public int getDefaultSmsPhoneId() 　默认短信slotId 

public static int getDefaultSmsSubscriptionId() 默认短信subId

public static int getDefaultVoicePhoneId() 　默认通话slotId
public static int getDefaultVoiceSubscriptionId() 默认通话subId

public static int getDefaultSubscriptionId()　获取默认subId，上述三个都返回-1的话使用这个
双卡设置中短信和通话的设置只是设置SettingsProvider中的一个字段，而设置数据业务卡槽除了设置数据库字段外还会导致modem的重启、网络类型切换（数据业务卡能上4G，而另一张卡只能用2G）等一系列操作。所以手机开发厂商一般说主卡就是数据业务卡。
```

## 手机重启数次进入recovery模式，log分析

```
您好！从贵司的log中有看到大量JE如下：
01-04 03:15:30.424174  1994  2030 E AndroidRuntime: FATAL EXCEPTION: pool-3-thread-1
01-04 03:15:30.424174  1994  2030 E AndroidRuntime: Process: ru.appspress.android.eguarantee.bq, PID: 1994
01-04 03:15:30.424174  1994  2030 E AndroidRuntime: java.lang.IllegalStateException: Apps may not schedule more than 100 distinct jobs
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at android.os.Parcel.readException(Parcel.java:2013)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at android.os.Parcel.readException(Parcel.java:1951)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at android.app.job.IJobScheduler$Stub$Proxy.schedule(IJobScheduler.java:180)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at android.app.JobSchedulerImpl.schedule(JobSchedulerImpl.java:44)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at androidx.work.impl.background.systemjob.SystemJobScheduler.scheduleInternal(SystemJobScheduler.java:85)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at androidx.work.impl.background.systemjob.SystemJobScheduler.schedule(SystemJobScheduler.java:64)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at androidx.work.impl.Schedulers.scheduleInternal(Schedulers.java:98)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at androidx.work.impl.Schedulers.schedule(Schedulers.java:69)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at androidx.work.impl.WorkManagerImpl.rescheduleEligibleWork(WorkManagerImpl.java:398)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at androidx.work.impl.utils.ForceStopRunnable.run(ForceStopRunnable.java:66)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1162)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:636)
01-04 03:15:30.424174  1994  2030 E AndroidRuntime:     at java.lang.Thread.run(Thread.java:764)

java.lang.IllegalStateException: Apps may not schedule more than 100 distinct jobs
看起来是某些app使用job过多，属于APK issue。
贵司可以pull出data/system/job/jobs.xml ，查看到底是哪个APP使用job过多。

目前 job service 这边没有保护机制，之前的类似issue只是将jobs.xml 删除掉之后，暂时解决问题。 

如果某些app 恶意使用大量 job，目前看起来没好的方式避免。 
```

## 如何打开zsd

```
go:vendor/mediatek/proprietary/custom/mt6580/hal/sendepfeature/gc2385_mipi_raw/config.ftbl.gc2385_mipi_raw.h
#if 1
//  Zsd
FTABLE_CONFIG_AS_TYPE_OF_DEFAULT_VALUES(
    KEY_AS_(MtkCameraParameters::KEY_ZSD_MODE),
    SCENE_AS_DEFAULT_SCENE(
        ITEM_AS_DEFAULT_(MtkCameraParameters::ON),    ----> 这一条是是否打开ZSD
        ITEM_AS_VALUES_(
            MtkCameraParameters::OFF,
            MtkCameraParameters::ON
        )
    ),
)

MtkCameraParameters::OFF,
MtkCameraParameters::ON同时存在的时候，camera的界面中会出现这个选项，如果只有一个的话，camera的界面中不会出现这个问题
```

## 如何确认生成的某个so文件从哪里代码拷贝过去的？

```
1、source build/envsetup.sh    --> 导入环境
2、godir fingerprint.default.so   --> 搜索这个文件的具体代码路径
3、md5sum fingerprint.default.so   --> 获取唯一值
5656a7e732354b53d1e3b1b67b12a67a  fingerprint.default.so
因为步骤2会搜索出好几个结果，那么如何确认是哪个路径拷贝的呢？首先先在out中找到对应的文件，然后用md5sum fingerprint.default.so 获取出唯一值，然后在把步骤2搜索出来的路径每个都用md5sum的命令去获取唯一值，然后相同的就是对应的文件路径
```

## 拍照速度慢、美颜状态下拍照速度慢

```
1、美颜拍照的原图可以从capbufMgr中取图，即参考zsd的方法（不使用normalshot的取图），这样可以直接从内存取图，缩小取图的时间。
2、开启postview功能，并在app中是用postview做小图的显示，这样显示小图的时间可以加快约800ms（即美颜算法处理时间）。
3、调整美颜算法所在线程的优先级，减少算法处理时间。
4、打开ZSD功能
```

## 如何修改wqhl导致的usb连接模式在重启后会不停变化

``` Java
frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java 文件中 
trySetEnabledFunctions(String functions, boolean forceRestart) 方法内增加如下方法
if (functions.equals("adb")){
    functions = "mtp,adb";
}
```

## android 无法休眠查看，查看哪個wakelock擋到系統進入suspend的步驟

```
1：检查userspace wakelock状态
dumpsys power
cat /sys/power/wake_lock

2：检查kernel wakelock状态
cat /sys/kernel/debug/wakeup_sources
查看actvie_since列，大于0的会导致无法suspend

cat /proc/wakelocks

#查看哪個wakelock擋到系統進入suspend的步驟

當測試者認為現在系統可以進入suspend(如暗屏+無接usb/ac充電)，系統卻還一直打印uart log。
su (讓uart console變成root權限)
每一秒執行cat /sys/kernel/debug/wakeup_sources一次，共5次左右，若有某個wakelock的active_since值一直在增加(如下表)，就是此wakelock擋到系統進入suspend。
若碰到是PowerManagerService.WakeLocks的active_since值一直在增加，則需要更進一步執行"dumpsys power"，查看是哪個PARTIAL_WAKE_LOCK擋到系統進入suspend。

#查看系統內有多少個wakelock - 範例

Command: cat /sys/kernel/debug/wakeup_sources

name active_count event_count wakeup_count expire_count active_since total_time max_time last_change prevent_suspend_time
PowerManagerService.Broadcasts	3	3	0	0	0	12408	10881	282326	0
PowerManagerService.WakeLocks	91	91	7	0	57415	177029	70793	269483	0
 
#查看PowerManagerService.WakeLocks裡哪個PARTIAL_WAKE_LOCK在使用，因此擋到系統進入suspend - 範例

Command: dumpsys power

Wake Locks: size=6 (PowerManagerService.WakeLocks裡有6個PARTIAL_WAKE_LOCK在使用，所以PowerManagerService.WakeLocks不能釋放，進而擋到系統進入suspend)
PARTIAL_WAKE_LOCK 'GnssLocationProvider' (uid=1000, pid=1100, ws=null)
PARTIAL_WAKE_LOCK 'CMWakeLock' (uid=10012, pid=1926, ws=WorkSource{10012 com.google.android.gms})
PARTIAL_WAKE_LOCK 'Checkin Service' (uid=10012, pid=2311, ws=WorkSource{10012 com.google.android.gms})
PARTIAL_WAKE_LOCK '*net_scheduler*' (uid=10012, pid=1926, ws=WorkSource{10083 com.google.android.youtube})
PARTIAL_WAKE_LOCK 'NetworkTimeUpdateService' (uid=1000, pid=1100, ws=null)
PARTIAL_WAKE_LOCK '*net_scheduler*' (uid=10012, pid=1926, ws=WorkSource{10012 com.google.android.gms})
```

## [FAQ20290]modem NvRAM 四个分区的基本知识

```
nvdata：手机运行过程中，使用(读写)的NVRAM(除了存在protect_f和protect_s中的NVRAM)都是该分区的nvram文件。存储着普通NVRAM数据、 IMEI、barcode、Calibration数据等。对应的modem path是Z:\NVRAM。NVRAM目录下有CALIBRAT、NVD_DATA、NVD_CORE和NVD_IMEI四个目录，后续第三点会对这四个目录进行介绍。

protect_1、protect_2 ：一般我们也称为protect_f和protect_s分区，protect_s是对protect_f中部分NVRAM的复制。
主要存储着SIM Lock数据。具有NVRAM_CATEGORY_IMPORTANT_L4属性的NVRAM LID会存在protect_f分区(这个叫A file)，如果还具有NVRAM_ATTR_MULTIPLE属性(锁卡LID都有MULTIPLE属性)，会存一个B文件到protect_s中。正常情况下protect_f中的A文件和protect_s中的B文件是相同的，因为写的时候都会去写两只nvram文件。（同时这两个分区的两只文件是互为备份的[即如果A file损坏,可以使用B file的来还原、 B file损坏,使用A file来还原;但如果两只文件都被被异常破坏或者删除, nvram将让modem assert）.

nvram：一般我们也称为binregion分区，是一个备份分区，备份具有NVRAM_CATEGORY_IMPORTANT和NVRAM_CATEGORY_CALIBRAT属性的NVRAM LID，备份的也就是CALIBRAT和NVD_IMEI两个目录，具体有IMEI、 barcode、Calibration数据和4G RF driver参数这些NVRAM。备份可以由META Tool触发 ，ATE校准完会自动触发备份，SN Writer tool写完号后也会自动触发备份。
```

## 升级方式对各个NVRAM分区的影响

```
Format All+Download
会擦除所有分区，所有NVRAM LID都会用code中的默认值重新生成。全擦后只有触发备份过，binregion中才会有备份内容，否则binregion是空的(Flash默认的全0 or 全f)。

Firmware Upgrade 、Factory Reset(恢复出厂设置)
只会擦除nvdata分区，开机时AP会将binregion中备份的CALIBRAT和NVD_IMEI两个目录还原到nvdata分区。具体NVRAM LID是IMEI、 barcode、Calibration数据和4G RF driver参数。
protect_f和protect_s分区不会被擦除，所以SIM Lock保持不变。
其他NVRAM LID恢复为code中的默认值。
如果binregion是空的，那么IMEI、 barcode、Calibration数据和4G RF driver参数也会用code中的默认值重新生成。

Download Only、OTA、SD upgrade 、Push modem
不会擦除任何分区。这种升级方式下，如果有修改code中的default值，那么需要将相应NVRAM LID的VERNO+1，才会生效，即将会利用code中的默认值重新生成新文件。

注意：这里所说的所有分区和任何分区均指Modem NVRAM的四个分区：nvdata分区、 protect_f分区、protect_s分区和binregion分区。
```

## 如何设置MTKlogger是否开机自启动

```
1. 第一次开机MTKlogger是否开启
1) 配置prop文件:   true则开启，false则关闭 
com.mediatek.log.mobile.enabled = true/false
com.mediatek.log.modem.enabled = true/false
com.mediatek.log.net.enabled = true/false
com.mediatek.log.gps.enabled = true/false

2) prop文件路径
KK版本: alps/mediatek/external/xlog/tools/mtklog-config-eng.prop或mtklog-config-user.prop
L 版本:  alps/vendor/mediatek/proprietary/external/xlog/tools/mtklog-config-eng.prop或mtklog-config-user.prop
M/N/O/P版本:  alps/device/mediatek/common/mtklog/mtklog-config-bsp-eng.prop或mtklog-config-bsp-user.prop

2. 非第一次开机是否开启的配置方法有如下两种
1) 勾选Start Automatically进行设置
MTKlogger UI——》Settings——》MobileLog/ModemLog/NetworkLog/GPSLog——》Start Automatically

2) 通过adb发送广播设置
adb shell am broadcast -a com.mediatek.mtklogger.ADB_CMD -e cmd_name set_auto_start_1/set_auto_start_0 --ei   cmd_target 23
set_auto_start_1表示开启开机自启动, set_auto_start_0表示关闭开机自启动
cmd_target is a combination or just a single of each Log type
MobileLog: 1 ModemLog: 2 NetworkLog: 4 GPSLog: 16
```

## [mtklog]mlog

```
mlog 为内存debug机制，会不停的记录系统内存使用情况，可以用来查看系统运行过程各类型各进程内存变化等
JE , swt , NE , 等exception db 解开后可以从 SYS_MEMORY_LOG得到mlog讯息
（SYS_MEMORY_LOG   是从  /d/dmlog  抓取而来） 
 
由于/d/dmlog 为ring buffer ， 有固定的buffer size , 
发生exception 后打包db时间如果间隔过久有可能把前面mlog讯息冲掉而获取不到问题时间点的mlog讯息
此时可以加大mlog buffer size 
修改方式如下
/kernel-xx/drivers/misc/mediatek/mlog/mlog_logger.c
#define CONFIG_MLOG_BUF_SHIFT   16  /* 64KB for 32bit, 128kB for 64bit */
修改成
#define CONFIG_MLOG_BUF_SHIFT   17
即为buffer size    128KB -> 256KB  for 64bit   ， 也可以更大， 不过由于会占用固定系统内存， 建议适量修改

修改后adb pull /d/dmlog 可以明显看到文件变大

抓取mlog的几种方法
adb shell cat /sys/kernel/debug/mlog > mlog
adb shell cat /d/mlog        (持续每秒记录mlog讯息)
adb shell cat /d/dmlog       (一次性打印 mlog buffer 所有讯息)

使用 adb shell cat /sys/kernel/debug/mlog 的方式查看内存的Log，可以查看当时状态的整体状况，同时包含当前程序内存使用情况
该信息是每1秒钟打印1条，从而可以看到连续的内存状况。

/sys/module/mlog/parameters/timer_intval
mlog记录默认为每秒更新，通过修改此参数可以减小(或加大)记录时间间隔

swfree  空间逐渐变为0 , 代表那个时间需要大量的使用内存，同时这个时间点数据压到内存比较积极

FAQ21497 mlog 信息查看及其初步的分析
FAQ21888 mlog 信息抓取时间间隔以及其它有用的调整参数
FAQ21889 mlog (SYS_MEMORY_LOG) 的 buffer size 如何修改
```

## 抓取开机trace

```
1). Enables tracing during boot-up

     Android O: In frameworks/native/atrace/atrace.rc, change:
        write /sys/kernel/debug/tracing/tracing_on 0
        To:
        #write /sys/kernel/debug/tracing/tracing_on 0
        This enables tracing (which is disabled by default).

     Android P0: In frameworks/native/cmds/atrace/atrace.rc
        # Tracing disabled by default
        write /sys/kernel/debug/tracing/tracing_on 0
        To:
        # write /sys/kernel/debug/tracing/tracing_on 0


2). Set systrace tags
     In the device/mediatek/mt67××/device.mk file, add the following line:
        PRODUCT_PROPERTY_OVERRIDES += debug.atrace.tags.enableflags=0x1fe9fe
     For enableflags's bit, please refer to "system/core/include/cutils/trace.h"


3). Add ftrace tags which you wanted
     In the project's BoardConfig.mk file, add the following:
        BOARD_KERNEL_CMDLINE := ... trace_buf_size=64M trace_event=sched_wakeup,sched_switch,sched_blocked_reason,sched_wakeup_new,sched_waking,cpu_frequency,cpufreq_interactive,cpu_frequency_limits,cpu_idle
     For detailed I/O analysis, also add "block android_fs ext4..." trace tags
     If you want catch more trace log, you can increase trace_buf_size. But if the phone memory size is less then 1GB, you need reduce trace_buf_size, such as "trace_buf_size=32M" for 512MB devices.

4). Disable tracing after boot-up completed
     In the device-specific init.mt67**.rc file, make the following changes, such as:
        on property:sys.boot_completed=1 (this stops tracing on boot complete)
        write /sys/kernel/debug/tracing/tracing_on 0
        write /sys/kernel/debug/tracing/events/ext4/enable 0
        write /sys/kernel/debug/tracing/events/block/enable 0
        write /sys/kernel/debug/tracing/events/android_fs/enable 0

5). After boot up, fetch trace
     adb root && adb shell "cat /d/tracing/trace" > boot_trace 

6). Open trace
     Use chrome://tracing can open boot_trace
```

## 从 Q0 开始 mtklog 改名了

```
用户手册 http://dms.mediatek.inc/Explorer/index/238136/2
```

## [FAQ21836]Skia软件绘制基础知识介绍

```
Android apk 里面的画图分为2D和3D两种：
2D是由Skia 来实现的，也就是我们在框架图上看到的SGL，SGL也会调用部分opengl 的内容来实现简单的3D效果；
3D部分是由OpenGL|ES实现的，OpenGL|ES是Opengl的嵌入式版本。具体请参考blog:https://blog.csdn.net/yili_xie/article/details/4803565
Skia绘制分三种，分别是：
skia软件绘制、skia硬件绘制和PDF绘制；
1)skia软件绘制执行的是SkbitmapDevice
2)Skia硬件绘制执行的是SkGpuDevice，SkiaGpuDevice实际上就是之前的openGL/HWUI绘制，从Android P开始，Android 取消OpenGL，改为Skia GL，走如下框图中的SkGpuDevice，SkGpuDevice下面同以前的OpenGL，不是今天的重点
3)PDF绘制执行的是SkPDFDevice，目前只遇到一个APK使用这种绘制方式
```

## 通过OTA升级 SVNumber

```
通过OTA升级时，data分区的NVRAM文件并不会被清除，因此升级后SVN和data分区下的其他nvram数据前后都没有变化。
如果需要确保OTA升级后SVN值或某一nvram file更新为新版本默认值，那么有如下方法：

1. 对于非IMPORTANT data(IMEI\SIM ME LOCK属于IMPORTANT data), 可以通过更新NVRAM LID VERNO，确保前后版本的NVRAM LID VERNO不一样即可。
例如更新SVN值， SVN默认保存在NVRAM_EF_SYS_CACHE_OCTET_LID，因此需要做如下修改：
File: Nvram_editor_data_item.h(mcu\interface\service\nvram)
#define NVRAM_EF_SYS_CACHE_OCTET_LID_VERNO "004"
修订为:
#define NVRAM_EF_SYS_CACHE_OCTET_LID_VERNO "005"

2. 由于SVN值保存在NVRAM_EF_SYS_CACHE_OCTET_LID，该NVRAM LID中保存了其他system information（FLIGHTMODE_STATE，SIM_PLUS_SETTING，SVN，USB_BOOT_MODE，USB_TETHERING_MODE等），那么升级后这些值也会更新为新版本的默认值。
因此做到OTA升级后只更新SVN值，那么我们需要采取另外一种方法来实现。

在nvram init完成后进行客制化来写入新版本的SVN值，例如下：
FILE: custom_nvram_int_config.c(mcu\custom\service\nvram\) 
Function:custom_nvram_config(void) 

在custom_nvram_config接口内部添加写入SVN操作，demo code可以参考如下： 
kal_uint8 data[] = {0x87, 0x00, 0x00,0x00, 0x00, 0x00, 0x00, 0x00}; 
nvram_external_write_data (NVRAM_EF_SYS_CACHE_OCTET_LID, NVRAM_SYS_SVN, data, NVRAM_EF_SYS_CACHE_OCTET_SIZE); 

其中配置的0x87就是SVN，从nvram读取出来为'78',需要参考BCD编码方式来配置。
举例说明： 如果写入NV中的值为0x17,那么读取出来值为'71';如果写入NV中的值为0x35，那么读取出来的值为'53'.


也可以通过发送AT命令的方式更新
发送AT命令： AT+EGMR=1,9,"78"   //78即为需要设置的SVN
```

## [FAQ21709]Camera HAL3 内存优化

```
内存用量大头（Graphics部分）分解：adb shell cat /sys/kernel/debug/ion/ion_mm_heap > ion_1
查看优化效果，对比优化前后meminfo中的total即可.
那么会有哪些省内存办法呢？请看下文.

1.拍照后buffer立即释放
优点：拍照过程中产生的buffer使用完毕后即释放，不影响拍照后的内存用量；
缺点：内存存量不高的情况下，拍照速度会受影响;
优化量：与拍照实际feature有关，拍照feature越多占用内存越大，优化量越大;

/vendor/mediatek/proprietary/hardware/mtkcam3/feature/core/featurePipe/capture/buffer/CaptureBufferPool.cpp

mpTuningBufferPool->setAutoFree(0); //拍照后release tuning buffer
pImagePool->setAutoFree(0);//拍照后release image buffer

【重要提醒】如果使用此优化，务必保证YUVNode.cpp中有如下修改，如无，请申请patch ALPS04338041.
mtkcam3\feature\core\featurePipe\capture\nodes\YUVNode.cpp

1090:     pPlgRequest->mIBufferFull  = (iBufferFullHandle == NULL) ? PluginHelper::CreateBuffer(pNodeReq, TID_MAN_FULL_YUV, INPUT) : std::move(iBufferFullHandle);

1091:     pPlgRequest->mIBufferClean = PluginHelper::CreateBuffer(pNodeReq, TID_MAN_FULL_PURE_YUV, INPUT);

1092:     pPlgRequest->mIBufferDepth = PluginHelper::CreateBuffer(pNodeReq, TID_MAN_DEPTH, INPUT);

1093:     pPlgRequest->mOBufferFull  = (oBufferFullHandle == NULL) ? PluginHelper::CreateBuffer(pNodeReq, TID_MAN_FULL_YUV, OUTPUT) : std::move(oBufferFullHandle);
 
2.减少ZSL buffer number
优点：优化整个camera使用期间的内存用量
缺点：如果设定值过小，重载时会影响preview帧率.
优化量：实际减少的buffer数据有关，也与sensor大小有关.

/vendor/mediatek/proprietary/hardware/mtkcam3/pipeline/model/zsl/hbc/HistoryBufferContainerImp.cpp

mMaxBufNum = (pInfo->getMaxBufNum()>mMaxBufNum)? pInfo->getMaxBufNum() : mMaxBufNum;//此值即是
基于MAX_HISTORY_DEPTH 和app设定的streaminfo信息

3.修改P1Node buffer格式（需满足条件）
使用条件：Raw格式在一次configure后不会发生改变. 举例，4-cell功能以及Raw HDR功能均会在使用期间切换Raw格式.则不可使用此优化;
优点：P1Node输出buffer格式由BloB改为Bayer10;
缺点:无法实时做格式转换;
优化量：与sensor实际大小有关.

/vendor/mediatek/proprietary/hardware/mtkcam3/pipeline/policy/config/P1HwSettingPolicy.cpp

bool isLowMem = ::property_get_bool("ro.config.low_ram", false); //强制将isLowMem置为True.

如果平台支持UFO，也可使用UFO格式，P1输出可以有多种格式，格式选择的逻辑判断均在P1HwSettingPolicy.cpp中，而各值的对应列表可查阅：
/vendor/mediatek/proprietary/hardware/mtkcam/include/mtkcam/def/ImageFormat.h

4.提高MFNR的门限，尽量避免使用MFNR，减少mfnr张数
优点：极大的改善内存以及cpu 资源的消耗，提升拍照速度，提升系统流畅度；
缺点：高光感下的图像噪点略高，影响图片质量，有些可以通过tuning 其他nr参数弥补回来;

/vendor/mediatek/proprietary/custom/mtXXXX/hal/inc/camera_custom_nvram.h

MUINT16 mfll_iso_th // tunning 参数 各家不同 ，默认800;
MUINT8 capture_frame_number; //mfnr张数，最低3张，默认4张;

对应的参数tunning的同事会较清楚，或者在/vendor/mediatek/proprietary/custom/mtxxxx/hal/imgsensor/ver1/sensorname 下全搜mfll_iso_th即可.
 
5.关闭ZSL
优点：拍照的buffer不再受preview处理效率的影响，同时节省buffer;
缺点：与Hal1上关闭zsd不同的是，关闭zsl仅拍照瞬间画面略有停顿.而Hal1上关闭zsd是整个拍照未完成期间均停顿.
优化量：节省zsl buffer pool的大小，一般会达到100M以上.

Control.capture.default.zsl.mode 设为off
Control.capture.zsl.mode configure和request时，均需设定为off，否则会出现re-configuresesion的问题，影响启动时间;
 
6.拍照相关限制
原理：限制同时在hal层处理的capture 数目，变相的优化内存峰峰值.
缺点：对内存存量要求高，则容易影响shot2shot的实际效果.

Shot2shot：

/vendor/mediatek/proprietary/hardware/mtkcam3/pipeline/model/capture/

#define MIN_FREE_MEM (300000000) // 300M，只有内存可用量大于300M时，才会告知app可以拍下一张.

最大request size：

maxAppJpegStreamNum //变相限制max request size
 
以上是通用法则.还有些可能会用得上的优化点：

8.streaming场景的优化

a)确认P1Node输出的size，等于preview size值. 如若不是，请查看P1Node输出的size来源.逻辑判断来源
/vendor/mediatek/proprietary/hardware/mtkcam3/pipeline/policy/config/P1HwSettingPolicy.cpp

需要注意的是：P1Node输出size大于preview size有助于减轻锯齿问题，客户需自行斟酌是否优化此项;

b )确认streaming的三方算法要求的size<=preview size. 三方算法所需size可通过下述API设定：

if( mUseSize ) sel.mIBufferMain1.setSpecifiedSize(mSize)

此修改，除了可优化内存外，同样可提升三方算法处理效率，但是需要看三方是否都支持；

总的来说，内存相关的优化，与手机状态强相关，所有的参数均需实验后方可得出，即使同一个hw，但不同的OS系统，不同的feature，都无法使用同一套优化参数，以上仅仅是提供优化思路与相关参数，具体的数值，请大家多多实验，在性能与内存之前找到项目的平衡点，做到最优.
 
Good Luck！
```

## Android 5.0及以上版本如何编译user+root版本？

```
source build/envsetup.sh && lunch full_k82v12-user && source ./mbldenv.sh && make MTK_BUILD_ROOT=yes -j24 2>&1 | tee build.log
备注：
1.&& source ./mbldenv.sh  这个是MTK内部员工才需要带的build option，客户不需要带这个options
2.红色字体的k82v12是指project name，build之前请务必改为自己的project name
3.-j24后面的24是指编译系统核心数，请根据自己的编译环境进行设置
```

## [Browser]如何客制化Android内置浏览器，使用其它应用打开某些特定的URL?

``` 
请修改DefaultBrowserUrlExt.java或OpxxBrowserUrlExt.java(仅对对应的运营商生效)的
public boolean redirectCustomerUrl(SharedPreference mPrefs)，
在这个函数中添加对特定URL特征的判断和处理并返回true，浏览器将不再处理该URL；
如果不是特定的URL则返回false，由浏览器处理。
```

## [Browser]webview的相关问题

```
1.Mtk Webview的作用:
敝司内部load都是双webview配置。其中mtk webview主要是给mtk browser使用。里面主要是对browser一些必须功能的
支持，此外还有一些webview的bug fix

2.设置webview:
可以从settings选择默认使用的webview，通常设置为Android/Google webview。即其他APP使用webview时，会使
用默认配置

3.Mtk webview与chrome差别：
首先，chromium版本不同。Mtk webview基于chromium 58。
另外，chrome为google app，内部没有source，无法得知google的相关修改

4.双webview的使用:
双webview并不会引起其他问题，APP使用时会去拿默认配置，敝司并没有针对双webview的专门测项。
对于webview功能，可采用单webview的测试即可。
简单来说，内部采用双webview架构主要是支持Mtk browser的一些特殊测试需求。
对于mtk browser而言，无需设置mtk webview为默认项，启动时会优先使用mtk webview。
而其他APP只会使用默认配置的webview。即使手机中有两个webview，也不会造成其他APP同时加载两个
webview或者引起其他相关问题。

5.cts测试时webview的选择:
CTS应该没有对webview做要求。但是建议使用Google webview做CTS测试。
Google webview会不断升级，CTS case也可能会做针对性调整。
而MTK webview版本比较老，且无法同步升级。 CTS测试时，可以有两个webview。
会使用settings中设置的默认值,除mtk webview。

6.卸载mtk webview:
若有使用mtk browser,建议不要卸载mtk webview,MtkBrowser.apk搭配MtkWebView.apk，有些feature的改动会同
时涉及2个module
卸载方法:删除掉/vendor/mediatek/proprietary/apps/MtkWebView/Android.mk 及之前build出的apk再
full build,避免把之前的apk烧进去 
```

## [Dialer]如何客制化长按"*","#"显示"P"，"W"

```
M及之后的版本 DialpadFragment.java

1 在DialpadFragment.java的onLongClick()中添加如下代码：

case R.id.star: {
    removePreviousDigitIfPossible();
    keyPressed(KeyEvent.KEYCODE_P);
    mPressedDialpadKeys.remove(view);
    return true;
}

case R.id.pound: {
    removePreviousDigitIfPossible();
    keyPressed(KeyEvent.KEYCODE_W);
    stopTone();
    mPressedDialpadKeys.remove(view);
    return true;
}

2 (frameworks\base\telephon\java\android\telephony\PhoneNumberUtils.java)修改如下函数：

public static String convertKeypadLettersToDigits(String input) {
    if (input == null) {
        return input;
    }
    int len = input.length();
    if (len == 0) {
        return input;
    }
    char[] out = input.toCharArray();
    for (int i = 0; i < len; i++) {
        char c = out[i];
        // If this char isn't in KEYPAD_MAP at all, just leave it alone.
        if(c=="P"||c=="W"||c==("p"||c=="w") {
            out[i] = c;
        } else {
            out[i] = (char) KEYPAD_MAP.get(c, c);
        }
    }
    return new String(out);
}
3.
public static String normalizeNumber(String phoneNumber) {
    if (phoneNumber == null) {
        return null;
    }
    StringBuilder sb = new StringBuilder();
    int len = phoneNumber.length();
    for (int i = 0; i < len; i++) {
        char c = phoneNumber.charAt(i);
        // Character.digit() supports ASCII and Unicode digits (fullwidth, Arabic-Indic, etc.)
        int digit = Character.digit(c, 10);
        if (digit != -1) {
            sb.append(digit);
        } else if (i == 0 && c == '+') {
           sb.append(c);
        } else if (c == 'p' || c == 'w' || c == 'P' || c == 'W') {
            Rlog.d(LOG_TAG,"normalizeNumber() remove letter (p w P W)");
        } else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
            return normalizeNumber(PhoneNumberUtils.convertKeypadLettersToDigits(phoneNumber));
        }
    }
}
```

## android P UserDebug 软件 adb remount 失败的原因和解决方案

```
在android P版本上如果按照“FAQ18076 android 6.0 M userdebug版本执行adb remount失败”的做法在userdebug版本上执行adb remount会提示以下错误：
remount of the / superblock failed: Permission denied
remount failed
原因是android P版本后google启用avb(Android Verified Boot)2.0，verified boot and DM-verity默认启用策略发生了变化。详情如下：
DM-Verity behavior changes from vboot1.0 to avb2.0.
On vboot1.0, dm-verity is turned off on eng build and is enabled on userdebug/user build.
DM-verity could be disabled with adb (not fastboot) on userdebug build without unlocking device first.
DM-Verity could not be disabled on user build.
On avb2.0, dm-verity behavior are the same on all build variants.
It's turned on by default and could only be disabled after device is unlocked.
dm-verity disable flag is moved from system image dm-verity metadata(vboot1.0) to vbmeta image(avb2.0), and you have two ways to disable it: adb and fastboot.

[SOLUTION]
* Android P + kernel-4.4 or kernel-3.18
- download preloader with verified boot disabled which location is the same as scatter file //preloader_<PROJECT>_SBOOT_DIS.bin
- adb root
- adb disable-verity
- adb reboot
- adb root
- adb remount

* Android P + kernel-4.9 or after 
- download preloader with verified boot disabled which location is the same as scatter file. //preloader_<PROJECT>_SBOOT_DIS.bin
- boot to Home Screen
- go to setting -> system -> Developer options -> OEM unlocking
- adb reboot bootloader
- fastboot flashing unlock
- press volume up key
- fastboot reboot
- adb root
- adb disable-verity
- adb reboot
- adb root
- adb remount
 
After Android P, preloader_<PROJECT>_SBOOT_DIS.bin will be generated automatically after building preloader.
 
* 请注意下载最新的adb/fastboot tool
Windows
https://dl.google.com/android/repository/platform-tools-latest-windows.zip
Mac
https://dl.google.com/android/repository/platform-tools-latest-darwin.zip
Linux
https://dl.google.com/android/repository/platform-tools-latest-linux.zip
```

## [FAQ20989] How to make built-in APK compile filter with speed mode 开启应用加速

```
./target/product/core.mk

# The set of packages we want to force 'speed' compilation on.
- PRODUCT_DEXPREOPT_SPEED_APPS += \
+ PRODUCT_DEXPREOPT_SPEED_APPS += MtkTeleService

查看是否生效
adb shell "dumpsys package com.**.** | grep compila -A1"

Dexopt state:[com.android.camera]
path: /system/priv-app/Camera/Camera.apk
status: /system/priv-app/Camera/oat/arm64/Camera.odex [compilation_filter=speed, status=kOatUpToDate]   //compilation_filter=speed 表示已加速
```

## 应用加固厂商

```
1、加固厂商：加固宝360、娜迦nagapt、梆梆bangcle、爱加密ijm、阿里、百度，盛大，腾讯，网秦通付盾
2、加固厂商对应的特征：
娜迦libchaosvmp.so,libddog.so,libfdog.co
爱加密libexec.so，libexemain.so
梆梆libsecexe.so,libsecmain.so,libDexHelper.so,libSecShell.so 
360libprotectClass.so,libjiagu.so
通付盾libegis.so
网秦libnqshield.so
百度libbaiduprotect.so
```

## [adb]adb 无法连接问题排查

```
 确认usb debugging有开启;

确认PC adb driver有安装;
可能出现VID/PID未添加导致PC不识别： 
文件： android_winusb.inf：
可能用到如下的写法：
%CompositeAdbInterface% = USB_Install, USB\VID_0E8D&PID_201D
上面这种可能出现driver无法正常安装的情况，必须把最后的MI_XXX也加上(MI_00从设备管理器硬件ID确认)：
%CompositeAdbInterface% = USB_Install, USB\VID_0E8D&PID_201D&MI_00

adb kill-server/start-server重启PC adb server.

排除第三方软件干扰adb server: 比如豌豆荚等.
因为豌豆荚会强占某端口，比如5037端口，导致包括GAT和adb client都没法正常连接到adb server. 可以尝试卸载豌豆荚.

确认adb version是新版本：
如果版本较旧，请更新GAT或者单独下载adb包，并加入adb.exe所在路径到环境变量中(建议加到最开始避免其他位置的adb.exe被混用).

交叉测试： Device1 + PC1 ,  Device1 + PC2,   PC1 + Device1, PC1 + Device2  确认可能是PC还是Device的问题.

确认adb版本没被混用：
不同的三方软件或者包括GAT等都会单独包含一份adb.exe(及相关dll)， 所以很可能出现这个进程用的xxxx1/adb.exe, 另外进程使用的是xxxx2/adb.exe, 造成不预期的问题.
可能出现系统路径  XXX:\Windows\System32 存在adb.exe,  恰好在此路径下执行adb, 会优先执行此路径的adb.exe, 而不会执行上面环境变量adb.exe第一个所在路径.
windows系统通过PATH寻找可执行文件的方式与类unix系统不同，比如linux完全从环境变量PATH中找，而windows会优先从当前目录找, 所以需要注意.
windows系统可执行文件一般有扩展名，即环境变量：PATHEXT. 
一般会是.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC.
所以如果存在adb.com, 会优先于adb.exe执行.  如果根本没有跑adb.exe, 尝试从这个方向去查.
如果想确认adb.exe进程对应的可执行文件的准确路径，可通过任务管理器查看: 映像路径名称/命令行.

更换USB线测试.
usb cable质量偏差和连接不良.


PC主机前面的USB Port可能出现供电问题，后面的USB Port供电更稳定：
如出现某个Port始终无法识别，可能是因为之前使用的设备抽电过多导致PC disable此端口，此时建议切换到主机后面的另外一个USB Port.


如果是fastboot模式不能识别:
请尝试用最新google fastboot 工具包;
已有实例确认旧版本fastboot只能识别某些特定的VID/PID, 新版本已修正. 在linux系统可以更新新版本的fastboot.
设备管理器VID/PID如果是0BBD/0C01, 请尝试在android_winusb.inf中增加再更新driver.


排除PC端安装不同来源/不同版本的usb driver导致问题.
请使用干净的PC环境安装MTK SP Driver确认是否可以识别到.


某些usb组合模式，如rndis,adb出现问题:
已查明rndis PC端驱动版本过旧可能导致识别问题：

请卸载rndis驱动，重新更新最新驱动.
重新安装MTK SP Driver.
重启PC.
```

## [FAQ21073] [Android 7.0]切换阿拉伯语，QuickSetting界面图标左右翻转。

```
切换手机语言为阿拉伯语，下拉状态栏到Quicksetting界面，快捷图标左右翻转。

如果不想要这个左右翻转效果，修改方法如下：

frameworks/base/packages/SystemUI/src/com/android/systemui/qs/QSTile.java
-public boolean autoMirrorDrawable = true;
+public boolean autoMirrorDrawable = false;
```

## 无法同步正常的时区

```
TimeUtils.getTimeZone() 返回NULL,导致无法得到正确的时区，导致调整时区失败。
vendor/mediatek/proprietary/frameworks/opt/telephony/src/java/com/mediatek/internal/telephony/MtkServiceStateTracker.java
中传给getTimeZone的参数中，
 zOffset=7200000 是以毫秒为单位传进去的参数，但是TimeUtils.java里面调用lookupTimeZoneByCountryAndOffset
时，需要以秒为单位来算时区的offset，这样就会导致返回NULL的TIMEZONE, 可以按下面的修改解决该问题
xref: /frameworks/base/core/java/android/util/TimeUtils.java
修改
private static android.icu.util.TimeZone getIcuTimeZone(int offset, boolean dst, long when, String country) {
    if (country == null) {
        return null;
    }
    android.icu.util.TimeZone bias = android.icu.util.TimeZone.getDefault();
    // 修改一下，这里需要传的单位是秒，而以前版本传给getIcuTimeZone是 offset都是以毫秒为单位的，而google 这里没有除1000,故返回NULL
    return TimeZoneFinder.getInstance().lookupTimeZoneByCountryAndOffset(country, offset/1000, dst, when, bias);
}
```

## [FAQ15121]Ubuntu 下 QT Flashtool 不能使用

```
1, ubuntu shell cmd:  sudo apt-get purge modemmanager
2, Double confirm if the ModemManager is under the root directory /bin, if yes, remove it or rename the software.
3, Using configuration in udev to avoid USB device to be recognized as modem device.
    -- add the file "99-ttyacms.rules" in the path "/etc/udev/rules.d"
    -- add the following content in the file "99-ttyacms.rules"
    ATTRS{idVendor}=="0e8d", ENV{ID_MM_DEVICE_IGNORE}="1"

Note: If after that the QT flashtool still can not flash, there are some notics need to be checked also while download under ubuntu OS,
the detail please refer to [FAQ09734] [FlashTool]Qt FlashTool在Linux下不能下载，提示S_COM_PROT_OPEN_FAIL
```

## [FAQ11483]修改SeLinux policy之后快速验证

```
在Android KK 4.4 版本后，Google 有正式有限制的启用SELinux, 来增强android 的安全保护。
KK 版本: 在MTK Solution 中，我们将SELinux Policy 文件存放在三个目录中。
1). Google 原生目录 alps/external/sepolicy
2). MTK 配置目录 alps/mediatek/custom/common/sepolicy
3). 客户配置目录 alps/mediatek/custom/{Project}/sepolicy (默认没有配置)
在编译时，系统会以文件为单位整合替换，优先级: 客户配置目录 》MTK 配置目录 》 Google 原生目录.

L/M版本: 将SELinux Policy 文件存放在下面目录。
1). Google 原生目录 alps/external/sepolicy
2). MTK 配置目录 alps/device/mediatek/common/sepolicy
3). MTK 配置目录 alps/device/mediatek/{platform}/sepolicy (M版本后才添加使用，主要是针对平台客制化)
在编译时, 系统会以合并的方式(union), 将MTK 配置目录下的policy 附加到Google 原生的policy 上，而非替换.
如果在alps/device/mediatek/common/sepolicy 下面新增SELinux Policy file, 在L 版本需要更新alps/device/mediatek/common/BoardConfig.mk 中的BROAD_SEPOLICY_UNION 增加对应的xxxx.te, M 版本已经取消了这个宏，无需再操作.

N 版本: 将SELinux Policy 文件存放在下面目录
1). Google 原生目录 alps/system/sepolicy
2). MTK 配置目录 alps/device/mediatek/common/sepolicy/  注意的是里面有basic, bsp, full 目录. 其中basic 目录所有的版本都会吃到; bsp 目录则是bsp 版本 + Turnkey 版本都会吃到;  full 目录则是只有Turnkey 版本会吃到。

O 版本: 将SELinux Policy 文件存放在下面目录
1). Google 原生目录 alps/system/sepolicy
2).  MTK 配置目录 alps/device/mediatek/sepolicy 这个的设定已经大改, 需要大家参考MOL 上的 sepolicy O 版本更新.

1). 确认问题是否与SELinux 相关，可以参考FAQ: [SELinux] 如何设置确认selinux 模式?

2). 快速编译验证

在已经编译过的版本上,  首先编译出新的selinux policy, 然后打包boot image.
KK:  ./mk project_name mm external/sepolicy
./mk project_name bootimage

L/M:
mmm external/sepolicy
make -j24 ramdisk-nodeps
make -j24 bootimage-nodeps

N:
mmm system/sepolicy
make -j24 ramdisk-nodeps
make -j24 bootimage-nodeps

然后再重新刷bootimage 测试.

O:
mmm system/sepolicy
然后再根据对应的sepolicy 是存放在system image, 还是 vendor image 对 system, vendor image 分别打包.


[相关FAQ]
[FAQ11414] android KK 4.4 版本后，user 版本su 权限严重被限制问题说明
[FAQ11486] 在Kernel Log 中出现"avc: denied" 要如何处理？
[FAQ11485] 权限(Permission denied)问题如何确认是Selinux 约束引起
[FAQ11484] 如何设置确认selinux 模式
```

## [FAQ20658] [Shutdown]如何初步定位异常关机问题

## [FAQ18208] [SAT]如何不显示开机SIM卡欢迎语

## [FAQ20994] Android O版本发送广播受限问题

## [FAQ20745] Launcher无Notification Dots feature

```
/vendor/mediatek/proprietary/packages/apps/Launcher3/src/com/android/launcher3/badge/BadgeRenderer.java
private static final boolean DOTS_ONLY = true;
修改为：
private static final boolean DOTS_ONLY = false;
```

## [FAQ20215] 如何动态关闭fast starting window？？？？？？fast starting window是什么东西？？？

```
关闭方法如下,ENG版本有效
adb shell setprop debug.disable_fast_start_win 1
adb shell stop
adb shell start
```

## [FAQ20862] 介绍framework-res__auto_generated_rro.apk

```
在Android O上面 Google增加了一个enforced RRO的方法，可以把之前的build time overlay强制转换成runtime resource overlay.
如果overlay的是framework-res的资源包，那么会自动生成一个file在/vendor/overlay/framework-res__auto_generated_rro.apk. 里面会包含overlay的资源.
这个framework-res__auto_generated_rro.apk.不要删除，请保留。
```

## [FAQ19034] 数据库权限问题分析

```
应用报数据库相关错误，强制关闭
以01-01 08:05:07.572 E/SQLiteLog( 2276): (14) os_unix.c:30090: (13) open(/data/user/0/com.android.providers.calendar/databases/calendar.db)为例；

首先根据[FAQ11485][SELinux Debug]权限(Permission denied)问题如何确认是Selinux 约束引起？
如是selinux引起，则请使用QAAT工具进行扫描log获取分析结果和解决方案；

如果不是selinux引起，则对比正常机器和异常机器的如下信息，看下差异点，
如有差异，则把正常机器修改为异常机器的内容；如果复现，则找到问题点； 

adb shell ls -aZl /data > 1.txt
adb shell ls -aZl /data/user > 2.txt
adb shell ls -aZl /data/user/0 > 3.txt
adb shell ls -aZl /data/user/0/com.android.providers.contacts > 4.txt
adb shell ls -aZl /data/user/0/com.android.providers.contacts/databases > 5.txt
adb shell ls -aZl /data/data > 6.txt
adb shell ls -aZl /data/data/com.android.providers.contacts > 7.txt
adb shell ls -aZl /data/data/com.android.providers.contacts/databases > 8.txt
adb shell mount > 9.txt
adb shell ps > 10.txt

对于问题点，如果没有复现问题的完整log，通常较难分析根本原因；
不过可以尝试recovery下的root-check，看下手机是否有被root或者image被破坏的可能；

对于案例的原因为：data下面的user文件夹权限被修改为：drwx------ root root （正常是：drwx--x--x system system），即访问A/B/C.txt，需要拥有A、B、C.txt三个权限。

对应的workaround为：
/system/core/rootdir/init.rc

on post-fs-data

mkdir /data/system/heapdump 0700 system system

mkdir /data/user 0711 system system //添加此行

对于其他DB的分析方法类似。。。
```

## [FAQ20741] [FM APP]如何做到可以在客户端卸载内置的FM

```
如何做到可以在客户端卸载内置的FM？ 

1.  O版本之前，需要 patch，可提eService 申请。
2.  patch之后(O后不需要)，需要按如下修改：

/vendor/mediatek/proprietary/frameworks/base/data/etc/pms_sysapp_removable_vendor_list.txt
添加： com.android.fmradio

/system/core/rootdir/etc/public.libraries.android.txt
添加 libfmjni.so

Add in /device/mediatek//device.mk
PRODUCT_PROPERTY_OVERRIDES += persist.sys.pms_sys_removable=1
```

## [FAQ20491] [Android O] AEE 在android o上的变化 以及 提交log需要注意的问题

```
在android o 中， systemimg 和vendorimg 中的daemon 不能直接通信，aee 为此在android O 上做出了一些变化；
导致在提case时，不能在第一时间提供全面的log信息；
 
一， AEE 的变化：
1. 架构的改变。
Before：
AEE只存在与system/bin/下，daemon的名字叫debuggerd(debuggerd64)
After:
AEE在system/bin和vendor/bin下各有一套，daemon名字改为：aee_aed(aee_aed64)---system/bin下；aee_aedv(aee_aedv64)---vendor/bin/下

2. 不同异常类型DB存放路径
Before：
/data/aee_exp;
/sdcard/mtklog/aee_exp;
After:
JE/ANR/SWT                           db存放在data/aee_exp
KE/HWT/HW_REBOOT/EE/NE   db存放在data/vendor/mtklog/aee_exp

3. 注意 注意：不能手动删除/data/aee_exp, /data/vendor/mtklog/aee_exp 目录：
aee db 存放路径 /data/aee_exp, /data/vendor/mtklog/aee_exp 的selinux标签如下， 这个标签是在init 创建目录的时候打下去的：
/data/aee_exp(/.*)? u:object_r:aee_exp_data_file:s0
/data/vendor/mtklog/aee_exp(/.*)? u:object_r:aee_exp_data_file:s0
如果删除aee db 的存放目录， 再创建的时候会沿用父目录的selinux 标签（ system_data_file），导致aee 没有selinux 权限不能正确产生db（重新开机后，init不会强制更新标签，还是会使用 system_data_file 的签名）；
solution：有root权限的手机有可能误删，会影响抓DB。解决办法，执行restorecon -R xxx/aee_exp命令即可

4. Android user load，如何抓到所有异常的aee db？
FAQ20159   Android user/userdebug load，如何抓到所有异常的aee db？

5. aee 对三方app exception handle的过滤
public void handle(String type, String info, String pid) {
    Log.w(TAG, "Exception Log handling...");
    if (type.startsWith("data_app") && !info.contains("com.android.development") && (SystemProperties.getInt("persist.mtk.aee.filter", 1) == 1)) {
        Log.w(TAG, "Skipped - do not care third party apk");
        return;
    }
aee 有对上层三方app 进行过滤， 如需抓三方app 的exception， 可以设置属性：setprop persist.mtk.aee.filter  0

6. user load ：三方app 默认不做ANR dump
1608    /**
1609     * Reduce the 3rd party's anr dump info in user load for performance
1610     */
1611    private boolean needReduceAnrDump(ApplicationInfo appInfo) {
1612        return IS_USER_LOAD && !isBuiltinApp(appInfo) && !(SystemProperties.getInt(
1613                "persist.anr.dumpthr",NORMAL_ANR_FLOW) == ENABLE_ANR_DUMP_FOR_3RD_APP);
1614    }
如需抓三方app 的ANR exception， 可以设置属性：setprop persist.anr.dumpthr  1

二， 提交log需要注意的问题
Android O ,mtklog 和db 不在同一个目录，提交log 时需要同时导出来：
1, adb pull /sdcard/mtklog
2, adb pull /data/aee_exp
3, adb pull /data/vendor/mtklog/aee_exp
```

## [FAQ20659] How to kill a native process and remake it re-launch

```
user load开启android malloc debug机制，在设置property之后，需要将该进程kill并且重新re-launch

[SOLUTION]

请在user load设置property之后，按以下步骤进行：

1.kill -9 pid(该进程的pid)
2.ps | grep processname(该进程的name)
如果该进程存在，则该进程在kill 掉之后自动re-launch了
3.如果该进程不存在，则setprop ctl.start processname(该进程的name)
4.ps | grep processname(该进程的name)
如果该进程存在，则重新re-launch了
```

## [FAQ20594] 如何定位分析不开机及开机时间长问题

```
1、客退机问题：请先参考DCC文档《RMA_SOP.pptx》进行初步定位，厘清软件问题还是硬件问题。
2、非客退机问题：
a、不能正常开机并且会自动重启：
请在eService的title和description中标注“重启”的信息，保留问题复现版本codebase及问题现场，提交eService处理；
b、开机卡住，不能进入HomeScreen，不发生重启：
请下载DCC文档《[SOP]Bootup_Issue_Checking_SOP_V1.0.rar》进行初步分析定位，如仍未解决还请填写文档中相关信息后提交eService处理（同步上传文档）；
c、开机时间长：
请下载DCC文档《[SOP]Bootup_Issue_Checking_SOP_V1.0.rar》进行初步分析定位，如仍未解决还请填写文档中相关信息后提交eService处理（同步上传文档）；
```

## [VPN][FAQ19293] [Framework-VPN]使用VPN 之前为何要设定lock screen PIN or password

```
第一次使用vpn，在添加profile 的时候，系统会提示“You need to set a lock screen PIN or password before you can use credential storage”,有什么作用？可否去掉？
 
vpn 的信息都是需要加密的，在目前的设计里面，这个密码是用来加密要保存的账号信息的。如果去掉，账号信息很容易泄露，不建议去掉。

Android Default就只支持IPSec，这个可以通过Settings中的VPN查看，不支持 TLS 和 SSHv2。

Android VPN支持以下几种协议：
PPTP
L2TP/IPSec PSK
L2TP/IPSec RSA
IPSec Xauth PSK
IPSec Xauth RSA
IPSec Hybrid PSK
```

## [mtklog]MTKlog 常见问题汇总

```
1) Quick Start
1 .深入了解Logging Tools
http://online.mediatek.com/_layouts/15/mol/topic/ext/Topic.aspx?mappingId=844fde79-3e58-4f1f-bba7-cf0be27cee45

2 .深入了解MTKLogger
http://online.mediatek.com/_layouts/15/mol/topic/ext/Topic.aspx?MappingId=4116ea3e-1d44-4f6c-a150-19c57118bd11

2) FAQ 系列
NEW- 1 FAQ19560 user版本开启mtklog
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ19560

NEW- 2 FAQ20491 [Android O] AEE 在android o上的变化 以及 提交log需要注意的问题
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ19560

3 .FAQ19362 如何设置mobilelog modemlog networklog size大小
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ19362

4 .FAQ15308 FactoryMode下用SD卡抓取mobilelog及modemlog
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ15308

5 .FAQ14184 Factory Mode下USB抓取modem log的方法
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ14184

6 .FAQ14339 MTK各boot up mode下 log的抓取方法
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ14339

7 .FAQ06944 Meta mode以及其他模式如何抓取mobilelog 
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ06944

8 .FAQ20071 KERN_DEBUG 等级log打印 & MTK Logd Filter Mechanism
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ20071

9 .FAQ15320 不同模式下如何保持uart log一直打开
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ15320

10.FAQ03891如何在User版本开启串口(Uart),抓取上层Log,开启输入控制台
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ03891

11 FAQ19689 kernel_log.boot从时间0s开始抓取(加大kernel log buffer)的修改方法
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ19689

12 FAQ20108 How to enable kernel dynamic debug log?
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ20108

13 FAQ20241 第一次开机加解密，开机解密过程中log 抓不到/丢失问题
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ20241

14 FAQ18335 Modem Exception提交eservice要提供哪些文件
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ18335

15 FAQ17814 如何设置MTKlogger是否开机自启动
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ17814

16 FAQ06939 如何用adb控制MTKLogger
http://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ06939
```

## [FAQ20599] 单机高概率问题处理方法

```
这里针对的是死机重启类问题
单机------是指出现问题的机器只有一两台
高概率-------是指这一两台问题机很容易出现死机重启
 
一旦机器符合"单机高概率" 这个特征都可以判定为硬件问题！
原因是：如果是软件问题，如此高的概率必然会导致其他机器大规模复现！！因为机器的软硬件环境都是一样的
 
对于单机高概率问题的处理流程：
1、回读pl lk bootimg systemimg与下载前的对比，看是否OK，如果不一样要么说明被用户刷机，要么说明emmc有问题------此时客户可以重刷来验证emmc是否损坏
 
2、如果步骤1 ok,请接下来做flash tool 的DDR test ,此步骤的目的是验证DDR是不是有明显的损坏
 
3、如果上面2个步骤都OK，其他器件的排查请贵司硬件先排查，然后在求助弊司硬件
```

## [FAQ20589] 修改Camera拍照音效

```
frameworks/av/services/camera/libcameraservice/CameraService.cpp

2096void CameraService::loadSoundImp() {
2097    LOG1("[CameraService::loadSoundImp] E");
2098    mSoundPlayer[SOUND_SHUTTER] = newMediaPlayer("/system/media/audio/ui/camera_click.ogg");
2099    mSoundPlayer[SOUND_RECORDING_START] = newMediaPlayer("/system/media/audio/ui/VideoRecord.ogg");
2100    mSoundPlayer[SOUND_RECORDING_STOP] = newMediaPlayer("/system/media/audio/ui/VideoStop.ogg");
2101    LOG1("[CameraService::loadSoundImp] X");
2102}
```

## [FAQ02918] [AT]如何在java层直接下发at cmd

```
目前AP端在PhoneBase.java中有方法invokeOemRilRequestStrings可以向modem透传AT，如果您想在modem 客制化自己的AT在ap端使用，可以用此方法；
Tips: 必须是run在phone进程中的代码才可以如此，第三方apk是不可以的。如果允许第3方apk调telephony中的接口向modem下AT命令的话，对于手机，这个安全隐患太大！

需要注意的地方：
（1）modem端的客制化需要最后return OK，否则RILD收到response后不会handle
（2）ap侧使用时需要定义长度为2的string数组；
<1>第一个成员存放需要下的AT string
<2>第二个成员存放这个AT的名字，用来处理modem上报response时区分的tag；他不会被下到modem侧
例如需要读IMEI，那么可以定义如下：

String imeiString = new String[2]; //第一个string是你要下的AT command的完整string
imeiString[0] = "AT+EGMR=0,7";
imeiString[1] = “+EGMR”;  //第二个string必须有，且名字是此AT名字，主要给rild用，不会下给modem；否则不会通过此channel返回上来

////////////详细的例子如下//////////////////////////////////////////////////////////////////////////////////////////
GPRS.java
onClick
String imeiString = new String[2]; //第一个string是你要下的AT command的完整string
if(FeatureOption.MTK_GEMINI_SUPPORT){
    int simId = phone.getMySimId();
    if(simId == Phone.GEMINI_SIM_1){
        imeiString[0] = "AT+EGMR=0,7";
    }else if(simId == Phone.GEMINI_SIM_2){
        imeiString[0] = "AT+EGMR=0,10";
    }
}else{
    imeiString[0] = "AT+EGMR=0,7";
}
imeiString[1] = “+EGMR”;  //第二个string必须有，且名字是此AT名字，主要给rild用，不会下给modem；否则不会通过此channel返回上来
Log.v(LOG_TAG, "IMEI String:" + imeiString[0]+imeiString[1]);
phone.invokeOemRilRequestStrings(imeiString, mResponseHander.obtainMessage(EVENT_READ_IMEI));

以上是common的处理，上述的phone对象如果获取的是卡1的GSMPhone对象，那么这个命令是发送给SIM1，同理，如果是卡2的GSMPhone对象，那么这个命令是发送给SIM2。

【KK版本及以前】
如果获取的是GeminiPhone对象，那么可以通过GeminiPhone中invokeOemRilRequestStringsGemini方法来发送，即public void invokeOemRilRequestStringsGemini(String[] strings, Message response, int simid)。
卡1为PhoneConstants.GEMINI_SIM_1，卡2为PhoneConstants.GEMINI_SIM_2。

【L版本】
L版的C2K双卡项目上
1'当主卡为C2K卡时
要下AT至C2K Modem，可通过PhoneFactory.getDefaultPhone().getNLtePhone().invokeOemRilRequestStrings(,);方法实现；(其中getDefaultPhone()也可用getPhone(phoneId)来替换，下同)
要下AT至GSM Modem 4/3/2G protocol，可通过PhoneFactory.getDefaultPhone().getLtePhone().invokeOemRilRequestStrings(,);方法实现；
要下AT至GSM Modem 2G protocol，可通过
PhoneFactory.getPhone(phoneId).getLtePhone().invokeOemRilRequestStrings(,);方法实现；
2'当主卡为GSM卡时
要下AT至GSM Modem 4/3/2G protocol，可通过PhoneFactory.getDefaultPhone().getLtePhone().invokeOemRilRequestStrings(,);方法实现；
要下AT至C2K Modem，可通过PhoneFactory.getPhone(phoneId).getNLtePhone().invokeOemRilRequestStrings(,);方法实现；
要下AT至GSM Modem 2G protocol，可通过
PhoneFactory.getPhone(phoneId).getLtePhone().invokeOemRilRequestStrings(,);方法实现；
L版的非C2K的其他项目上，直接通过PhoneFactory.getPhone(phoneId).invokeOemRilRequestStrings(,);方法下AT命令至相应卡槽对应的Modem。

【M版本】
M0.MP1仍保持L版本的写法，其他M版本如下：
在之前的版本上，
ap侧使用时需要定义长度为2的string数组；
<1>第一个成员存放需要下的AT string
<2>第二个成员存放这个AT的名字，用来处理modem上报
在M上，因架构有所调整，如果要将AT命令发往C2K modem需在此添加第三个成员变量
<3>第三个成员存放这个AT希望发向哪个modem，DESTRILD:C2K指定发向C2K MD，DESTRILD:GSM指定发向GSM MD。
（第三个成员不设定的话，默认发向GSM MD）

【N版本】
参数<1> 和<2>处理与M上相同。
参数<3> 在 N1.MP16(MT6763) 版本 和 N1.MP18(MT6739) 版本 由于C2K和GSM在同一个modem，所以不用添加。其他版本与M上相同。

【O版本】
参数<1> 和<2>处理与M上相同。
参数<3> 在 搭配MT6763平台 和 MT6739平台的版本，由于C2K和GSM在同一个modem，所以不用添加。
```

## [FAQ19648] 如何发送AT命令

```
本FAQ说明三种情况下如何发送AT命令：
1. 在Phone进程发送AT命令
2. 在其他Java进程发送AT命令
3. 在Native进程发送AT命令

[SOLUTION]

1.在Phone进程发送AT命令
参考 FAQ02918 [AT]如何在java层直接下发at cmd

2.其他Java进程发送AT命令
> AT命令只需要发送给卡1：
调用TelephonyManager.invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp);

> AT命令需要发送给卡1/卡2：
Step 1:
/vendor/mediatek/proprietary/frameworks/base/telephony/java/com/mediatek/telephony/TelephonyManagerEx.java

//添加函数：add-start
public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp, int slotId){
    try {
        ITelephonyEx telephony = getITelephonyEx();
        if (telephony != null) {
            return telephony.invokeOemRilRequestRaw(oemReq, oemResp, slotId);
        }
    } catch (RemoteException ex) {
    } catch (NullPointerException ex) {
    }
    return -1;
}//add-end

Step 2:
frameworks/base/telephony/java/com/mediatek/internal/telephony/ITelephonyEx.aidl
添加接口：  int invokeOemRilRequestRaw(in byte[] oemReq, out byte[] oemResp, int slotId);

Step 3:
在/packages/services/Telephony/src/com/mediatek/phone/PhoneInterfaceManagerEx.java
//增加常量定义 add-start
private static final int CMD_INVOKE_OEM_RIL_REQUEST_RAW = **;
private static final int EVENT_INVOKE_OEM_RIL_REQUEST_RAW_DONE = **;
//add-end
//增加函数 add-start
public int invokeOemRilRequestRaw(byte[] oemReq, byte[] oemResp, int slotId) {
    enforceModifyPermission();
    int returnValue = 0;
        try {
            Phone phone=PhoneFactory.getPhone(slotId);
            AsyncResult result = (AsyncResult)sendRequest(CMD_INVOKE_OEM_RIL_REQUEST_RAW, phone, oemReq);
            if(result.exception == null) {
                if (result.result != null) {
                    byte[] responseData = (byte[])(result.result);
                    if(responseData.length > oemResp.length) {
                        Log.w(LOG_TAG, "Buffer to copy response too small: Response length is " +
                                responseData.length +  "bytes. Buffer Size is " +
                                oemResp.length + "bytes.");
                    }
                    System.arraycopy(responseData, 0, oemResp, 0, responseData.length);
                    returnValue = responseData.length;
                }
            } else {
                CommandException ex = (CommandException) result.exception;
                returnValue = ex.getCommandError().ordinal();
                if(returnValue > 0) returnValue *= -1;
            }
        } catch (RuntimeException e) {
            Log.w(LOG_TAG, "sendOemRilRequestRaw: Runtime Exception");
            returnValue = (CommandException.Error.GENERIC_FAILURE.ordinal());
            if(returnValue > 0) returnValue *= -1;
        }
        return returnValue;
    } //add-end

在MainThreadHandler.handleMessage()中添加：
// add-start
    case CMD_INVOKE_OEM_RIL_REQUEST_RAW:
        request = (MainThreadRequest)msg.obj;
        onCompleted = obtainMessage(EVENT_INVOKE_OEM_RIL_REQUEST_RAW_DONE, request);
        final Phone phone = (Phone) request.argument;
        phone.invokeOemRilRequestRaw((byte[])request.argument2, onCompleted);
        break;
    case EVENT_INVOKE_OEM_RIL_REQUEST_RAW_DONE:
        ar = (AsyncResult)msg.obj;
        request = (MainThreadRequest)ar.userObj;
        request.result = ar;
        synchronized (request) {
            request.notifyAll();
        }
        break;
// add-end

Native进程发送AT命令
Step 1:
/vendor/mediatek/proprietary/hardware/ril/gsm/librilmtk/ril.cpp
static int handleSpecialRequestWithArgs(int argCount, char** args){
//在函数最后添加 add-start
else if (strcmp(cmd, "YOUR_CUSTOM_CMD_SEND_TO_RIL") == 0) { //YOUR_CUSTOM_CMD_SEND_TO_RIL修改为自定义名称
    memset(org_args, 0, sizeof(org_args));
    sprintf(org_args, "AT_COMMAND_YOU_WANT_TO_SEND"); //这里替换成为想要发送的AT命令
    int targetSim = 0;// 0发送给卡1,1发送给卡2
    issueLocalRequestForResponse(RIL_LOCAL_REQUEST_SEND_COMMAND, org_args, strlen(org_args), (RIL_SOCKET_ID)targetSim);
    close(s_fdOem_command);
    s_fdOem_command = -1;
    return 1;
} else {
    // invalid request
    LOGD("invalid request");
    goto error;
}

//在函数最后添加 add-end
Step 2:
//在需要发送AT命令的文件中添加下面代码，然后调用send_to_ril()
//add-start
#define YOUR_CUSTOM_SOCKET_NAME "rild-oem"
//add-end

//add-start
static int connect_socket() {
    int fd = socket_local_client(YOUR_CUSTOM_SOCKET_NAME, ANDROID_SOCKET_NAMESPACE_RESERVED, SOCK_STREAM);
    if (fd < 0) {
        //这里表示socket连接不成功，建议在这里处理。比如延迟1s再调用上面的函数连接socket，尝试几次。从log看，rild会比audio晚3s。
        //KLOG_ERROR(LOG_TAG, "Fail to connect to socket rild-ocm. return code: %d", fd);
        return -1;
    }
    return fd;
}

//cmd: YOUR_CUSTOM_CMD_SEND_TO_RIL 自定义命令
static int send_to_ril(char *cmd) {
    int ret = 0;
    int command_len = strlen(cmd);
    char *command = NULL;
    int fd = connect_socket();
    if (fd < 0) {
        ret = -1;
        goto error;
    }
    command_len = command_len + 1;
    command = (char *)malloc(sizeof(char) * command_len);
    memset(command, 0, sizeof(char) * command_len);
    strcpy(command,cmd)
    ret = send_data(fd, 1, command_len, command);

  error:
    if (command != NULL) {
        free(command);
    }
    if (fd >= 0) {
        disconnect_socket(fd);
    }
    return ret;
}

static int send_data(int fd, int arg_count, uint32_t data_length, const void *data) {
    int ret = 0;
    //(send-1)send argCount
    if(send(fd, (const void*)&arg_count, sizeof(int), 0) != sizeof(int)) {
        ret = -1;
        goto error;
    }
    //(send-2)send data length
    if(send(fd, (const void*)&data_length, sizeof(int), 0) != sizeof(int)) {
        ret = -1;
        goto error;
    }
    //KLOG_INFO(LOG_TAG, "(send-3). data: %s", (char *)data);
    if(send(fd, (const void*)data, data_length, 0) != (int)data_length) {
        ret = -1;
        goto error;
    }
   error:
    KLOG_INFO(LOG_TAG, "[send_data] Ret:%d.", ret);
    return ret;
  }

int disconnect_socket(int fd) {
    if(fd < 0) {
        //KLOG_ERROR(LOG_TAG, "[disconnect_socket] Invalid fd: %d", fd);
        return -1;
    }
    return close(fd);
}
//add-end
```

## [FAQ20503] 如何查找某个语言在Setting语言列表中是哪项

```
举例说明：若需要找到语言列表下的孟加拉语，可以通过如下方式进行找到孟加拉语显示的字串是怎么样的？
（1）通过https://zh.wikipedia.org/wiki/ISO_639-1这个网站可以查到某个语言的language code，如要找孟加拉语，在这个网站上查到孟加拉语的language code是bn；
（2）进入 /external/icu/icu4c/source/data/lang/目录，根据要查看语言的language code，找到对应这个语言icu中字串的定义文件，如孟加拉语对应的文件bn.txt；
（3）打开这支文件查看languages下bn的定义，就是孟加拉语在settings中语言列表的显示；
（4）拖动Settings的语言列表即可查看到孟加拉语对应的名字，其他语言的查找方式类似。
```

## [FAQ20453] flash tool抓取串口log

```
flash tool下载或者做memory test时的一些log需要通过串口来打印，典型的是DDR模块相关的信息；但抓串口log常要飞uart 线，带来诸多不便

使用device.cfg.xml来让USB抓取串口log，不需要飞UART线。
device.cfg.xml放在flash tool目录的根目录，
文件内容如下：
<?xml version="1.0" encoding="utf-8"?>
<config>
    <!--log_level: trace, debug, info, warning, error, fatal -->
    <log_level>info</log_level>
    <!--log_channel: none, uart, usb, uart_usb -->
    <log_channel>usb</log_channel>
    <!--end_stage: 1stDA, 2ndDA-->
    <end_stage>2ndDA</end_stage>
</config>

说明：log_channel选择usb代表使用usb抓取串口log，抓到的串口log和flash tool原有的log在相同目录，C:\ProgramData\SP_FT_Logs\SP_FT_Dump_**-**-20**-**-**-**\DA_20******-******_0.log，选择uart代表需要硬件飞uart线抓取。
end_stage：1stDA代表是memory test时抓取，2ndDA代表是下载时抓取 
USB抓串口log相比飞线抓串口log会增加一点时间，1G大小的bin全擦下载大概多15S；
```

## [FAQ20309] 在N版本上如何编译SDK

```
首先，要编译SDK，需要向MTK申请banyan sdk的代码
其次，编译分两种，一种是Android SDk包，一种是Mediatek SDk包
Android SDK包
source build/envsetup.sh
lunch full_banyan_x86-eng
make BUILD_MTK_SDK=sdk -j24 -k sdk  2>&1 | tee android.log

Output: out/host/linux-x86/sdk/full_banyan_x86

note: The out does not contains system.img part.

Mediatek SDK包

source build/envsetup.sh
lunch full_banyan_x86-eng
make BUILD_MTK_SDK=sdk -j24 -k banyan_sdk_addon  2>&1 | tee android.log

Output: out/host/linux-x86/sdk_addon

note: The out does not contains system.img part.
```

## [FAQ20263] 设置中选择时区列表新增时区的显示如何随语言变化

```
在Settings->Date & time->Select time zone中增加某个时区后，如何使这个时区的显示，跟随语言变化。如：在系统语言为英语时时区名字显示英语，为俄语时显示俄语，等等。
若需要切换到某个语言下，新增时区在这个语言下显示的字串变成当前语言，那么需要对这个语言下新增时区的字串定义进行修改，如，添加了新时区Europe/Astrakhan，但是当切换到俄语的时候这个时区的显示没有变成俄语，具体修改方法如下：
（1）找到俄语下时区信息的定义文件，/external/icu/icu4c/source/data/zone/ru.txt
（2）在ru.txt中的zoneStrings域中添加新增时区的定义

zoneStrings{
    "Europe:Astrakhan"{
        ec{"xxx"}  //xxx为这个时区在当前语言下需要显示的字串
    }
}
Europe:Astrakhan添加的位置需要按照字母顺序进行排序，所以需要添加在Europe:Athens之前。
（3）修改之后重新编译icu，并重新编译版本即可生效。
其他语言修改方式一样，找到这个语言/external/icu/icu4c/source/data/zone/下对应的xxx.txt文件，并添加新增时区的定义即可。
```

## [FAQ19857] 采用Signature Scheme v2签名方式的APK预置失败

```
Google在N上引入了一项新的应用签名方案Signature Scheme v2，它能提供更快的应用安装时间和更多针对APK文件更改的保护
在N上预置APK时，如果APK是采用的Signature Scheme v2签名，采用原有的预置应用方式预置APK会失败：

Failure [INSTALL_PARSE_FAILED_NO_CERTIFICATES: Failed to collect certificates fr
om /data/app/vmdl1483607312.tmp/base.apk: META-INF/CERT.SF indicates /data/app/v
mdl1483607312.tmp/base.apk is signed using APK Signature Scheme v2, but no such
signature was found. Signature stripped?]

经过BUILD_PREBUILT后的apk与原apk是有差异的，因为v2是对apk整体签名，所以这个差异导致签名失效。
1、app预置到到工程中，用android.mk编译之后的APK是有区别的，android编译系统会用zipalign对APK进行字节对齐等操作
2、APK Signature Scheme v2这个是Google在N上新引入的签名方式。v2 签名将验证归档中每个文件的已压缩文件内容，如有任何自定义任务篡改 APK 文件或对其进行后处理（无论以任何方式），那么v2 签名会有作废的风险

在预置APK build进系统时候不让其走编译流程，在其他模块的 android.mk 加入下面的cp脚本：
$(shell cp $(LOCAL_PATH)/***/*.apk     $(TARGET_OUT)/vendor/operator/app)

APK能通过PMS扫描安装成功，可能还会报so找不到的问题，可以参考：
ID: FAQ19894  N上预置APK失败提示找不到so文件


如何知道APK是不是采用Signature Scheme v2签名？可参考：
FAQ20235	如何知道APK是不是采用Signature Scheme v2签名？

使用apksigner.jar工具的verify命令。这个工具位于SDK目录的build-tools目录下。打开cmd，把目录切到SDK\build-tools\版本号\lib下。
注：v2签名方式时在Android7.0后才推出的，所以只有版本>25的 SDK\build-tools\ 中才能找到apksigner.jar

java -jar /home/zq/Android/Sdk/build-tools/27.0.3/lib/apksigner.jar verify -v xxx.apk

Verifies
Verified using v1 scheme (JAR signing): true
Verified using v2 scheme (APK Signature Scheme v2): false
Number of signers

具体可以参考：https://developer.android.com/studio/command-line/apksigner.html#usage
```

## [FAQ20246] [EM]N版本User-Load工模中没有以往的功能项

```
从M1.MP3 branch开始（包含N0 N1 branch），对于User Load，出于系统安全或功能必要性的考虑，有些测试功能在工模UI上已移除入口。如确实有需要，可以按照SOLUTION的流程打开。
以打开User Load工模中Hardware Testing页面的Power项为例：

1.根据工模UI上显示的英文字符串，在以下文件中找到对应的name.
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/values/strings.xml
例如： <string name="power">Power</string>

2.根据1中找到的name，在以下文件找到对应Preference的key.
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/xml/telephony.xml
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/xml/connectivity.xml
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/xml/hardware_testing.xml
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/xml/location.xml
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/xml/log_and_debugging.xml
/vendor/mediatek/proprietary/packages/apps/EngineerMode/res/xml/others.xml
例如：Hardware Testing页面对应hardware_testing.xml文件，在该文件可以找到：
<Preference android:key="power" android:title="@string/power"

3.根据2的key，在以下文件的 removeUnsupportedItems()函数的if ( FeatureSupport.isUserLoad())代码块中，注释对应的removePreference即可.
/vendor/mediatek/proprietary/packages/apps/EngineerMode/src/com/mediatek/engineermode/PrefsFragment.java
例如：removePreference(screen, "power"); 改成 //removePreference(screen, "power");

PS:更加快捷的做法是，由于Preference的key值一般和工模UI显示的字串相像，于是一般可以跳到第三步直接注释代码。
但是按照1.2.3步走下来必不会出错。
```

## [FAQ20255] [Recovery mode][Android N1]Recovery mode不进行任何操作，无法pull cache/recovery/last_log

```
遇到以下场景：

1、按键进入recovery mode；不做任何操作。
2、adb reboot recovery；不做任何操作。
3、其他显示调用reboot recovery mode，但没有实质性的操作需求。

如果再次reboot 到normal mode，执行如下操作会报错：

adb shell pull cache/recovery/last_log
/system/bin/sh: pull: not found

/cache/recovery # ls -al
total 32
drwxrwx--- 2 system cache 4096 2010-01-04 03:44 .
drwxrwx--- 7 system cache 4096 2010-01-01 00:04 ..
-rw------- 1 root root 5 2010-01-04 03:47 last_locale
No last_log
[SOLUTION]
这是Google原生的做法，如果比较介意，可以通过修改如下code:
/bootable/recovery/recovery.cpp
bool modified_flash = false; // 改成 true
```

## [FAQ20213] how to find which progress switch on/off the wifi

```
Many times ,we will meet this problem ,the wifi was disabled or enabled  without the user swith the switcher ;
so next ,i will introduce the way which will be used to  find the  real "operator"?
from log ,
main_log ,search the key log :setwifistate
Line 25438: 04-25 14:35:26.382642 892 954 D WifiStateMachine: setWifiState: disabling
Line 26117: 04-25 14:35:26.793326 892 954 D WifiStateMachine: setWifiState: disabled
Line 26650: 04-25 14:35:29.152201 892 954 D WifiStateMachine: setWifiState: enabling
Line 26854: 04-25 14:35:29.432136 892 954 D WifiStateMachine: setWifiState: enabled
sys_log,search the key log :setwifienabled
Line 22510: 04-25 14:35:26.312304 892 906 D WifiService: setWifiEnabled: false pid=6102, uid=10081
Line 23459: 04-25 14:35:27.253092 892 1572 D WifiService: setWifiEnabled: true pid=6102, uid=10081
ok,next step is to find the pid = 6102 uid = 10081 maps who?

event_log ,search the key log :6102;
04-25 11:25:08.720815   892   907 I am_pss  : [6102,10081,com.cshare.transfer,132882432,109949952]

it means is the app whose packect name is com.cshare.transfer turn on/off the wifi ;

ps:
a progress only has one UID ,but a UID maybe correspond to many progress ;
PID is the progress ID,every progress's pid is different;
TID is the thread ID ,a progress include many thread;

so if only want to find the progress ,we can use PID;
if we need find the TID ,we need conbine the PID with TID;
if we want to find the user group,we can use UID;
```

## [FAQ20206] 如何使用adb command来设置cpu频率和核数

```
透過ADB Shell設定CPU開核與freq的command與用法如下:
# Disable PPM
echo 0 > /proc/ppm/enabled
# Enable PPM (Default)
echo 1 > /proc/ppm/enabled
echo 0 > /proc/ppm/enabled
Fixed # Core for each cluster
echo X Y > /proc/ppm/policy/ut_fix_core_num Where,
X = -1, 0 ~ 4. Core# for cluster 0
Y = -1, 0 ~ 4. Core# fot cluster 1
echo 4 4 > /proc/ppm/policy/ut_fix_core_num

Fixed OPP for each cluster
echo X Y > /proc/ppm/policy/ut_fix_freq_idx Where,
X = -1, 0 ~ 15. OPP for cluster 0
Y = -1, 0 ~ 15. OPP for cluster 1
echo 1 2 > /proc/ppm/policy/ut_fix_freq_idx
範例:
echo 1 > /proc/ppm/enabled
echo 4 4 2 > /proc/ppm/policy/ut_fix_core_num   <= 開4小核 4大核 2最大核
echo 0 0 0 > /proc/ppm/policy/ut_fix_freq_idx    <小核用最高頻，大核用最高頻，最大核用最高頻

可以先從CPU最高效能全開來測試，然後逐步調降適當的設定
建議可以安裝附件的PerMon的APK，可以即時顯示CPU 的核數與freq在畫面上
可以用來確認CPU設定是否生效
若有確定較好的設定，就可以修改custom folder的設定
```

## [FAQ20189] 如何关闭手机防盗

```

PPL（手机防盗）是我司为满足出货中国大陆的手机pass CTA安全等级能力测试开发的。
出货海外的项目不需要这个apk的，可以直接拿掉。

拿掉方法：
1. 关闭MTK_PRIVACY_PROTECTION_LOCK
2. init.rc中拿掉ppl_agent的启动

service PPLAgent /vendor/bin/ppl_agent
    class main
    user root
    group system cache
```

## N平台预置apk,无法打开

```
aaltool apk 点击打开失败；打印类似log；

01-01 02:20:55.889 3100 3100 D DropBoxReport: java.lang.UnsatisfiedLinkError: dlopen failed: library "libaal.so" not found

且在/system/vendor/lib/以及/system/vendor/lib64/下都有libaal.so

[SOLUTION]
Android N 之后, third party app 会被限定不能使用非AOSP library (ex: libaal)
需用 eng load, push license file暫時打開權限

1、build aaltool 时，build出来的libaaltool_jni.so push到手机/system/vendor/lib 和 /system/vendor/lib64 下；

2、新建public.libraries.txt，内容如下：
libc++.so
libaal.so
libaaltool_jni.so
libbinder.so
libutils.so
libdpframework.so
libandroid_runtime.so

3、push public.libraries.txt到手机 /vendor/etc/目录，重启之后就可以正常使用；
adb push public.libraries.txt /vendor/etc/
```

## [monkey] [FAQ20170] MTBF或monkey test中ArrayList/CopyOnWriteArrayList发生ArrayIndexOutOfBoundsException如何解决？

```
发生ArrayIndexOutOfBoundsException是直接使用了get()的原因。
CopyOnWriteArrayList是ArrayList的一个线程安全变体，但CopyOnWriteArrayList的写操作是安全的，而读操作是不安全的，很可能在其他线程中已经将某个index值读走或者删除了。

针对此问题的解法：
解法一：可将该问题反馈至google，请google帮忙修改此问题
解法二：使用迭代器来进行遍历来规避此问题

下面是推荐的修改方法：
// change begin
// NOTE: because of the use of CopyOnWriteArrayList, we *must* use an iterator to
// perform the dispatching. The iterator is a safe guard against listeners that
// could mutate the list by calling the various add/remove methods. This prevents
// the array from being modified while we iterate it.
[SOLUTION]
private void handleScreenTurnedOn() {
    final int count = mCallbacks.size();
    for (int i = 0 ; i < count; i++) {
        KeyguardUpdateMonitorCallback cb = mCallback.get().get();
        if (cb != null) {
            cb.onScreenTurnedOn();
        }
    }
}

上面的用法可以改为如下用iterator遍历的方式

private void handleScreenTurnedOn() {
    if (mCallbacks != null && mCallbacks.size() > 0) {
        for (WeakReference<KeyguardUpdateMonitorCallback> cb : mCallbacks) {
            if (cb != null && cb.get() != null) {
                cb.get().onScreenTurnedOn();
            }
        }
    }
}

上面只是列举了一个Keyguard的例子，android整个代码范围还有很多这种case
因为这些都是google design，而且涉及到的面很广，所以不便于在代码里面一个一个这样的做修改。
目前采取的措施是：在遇到这种数组访问越界的地方，按照上述的修改思想做改动，平台代码这边不会release正式patch
```

## [FAQ20175] MTBF或monkey test中发生java.lang.IllegalArgumentException: pointerIndex out of range如何解决？

```
在test过程中，经常会碰到如下Java Exception：java.lang.IllegalArgumentException: pointerIndex out of range
这是因为在多点触控操作下，在获取底层的pointer index的时候发生了异常导致返回值为-1
详细log如下所示
 
 
这是google code没有考虑到获取到的index为非法值导致的JE，因此在java层做法是加上一个判断，避免发生JE
 
[SOLUTION]
解法办法是：找到发生JE的文件，在处理touch event的地方，加上判断
```

## 如何关闭SIM热插拔功能

```
关闭SIM热插拔功能需在ap和modem端操作如下：
1. AP端：在projectConfig.mk中将MTK_SIM_HOT_SWAP设置为no即可.
2. modem端：makefile中设置SIM_HOT_SWAP = NONE
```

## [SIM ME lock][FAQ09894] [SIM_ME_LOCK]在锁卡时如何只锁MCC(移动国家码)

```
根据 MNC 的情况，有两种处理方式：
【方法一】
一个国家一般只有有限几个MCCMNC，比如国内中国移动，中国联通与中国电信三家运营商一共有：46000，46001，46002，46003，46005，46006，46007
我们在锁卡配置时将以上7个MCCMNC 全部配置，就相当于我们锁了MCC 460 的卡。
所以如果客户有这种要求，请要求他们提供该国家MCC下所有MNC，然后全部配置即可。注意，在smart phone 上默认最多锁 10 组MCCMNC，如果超出此个数，请参考： [FAQ14236]
锁卡配置完成后，请一定 new 编译并全擦下载测试，否则可能会导致死机或者配置不生效。

【方法二】
如果只有 MCC，不确定MNC,  可以只配置MCC，并修改 sml_Check 比较部分的代码；只要比较3位，代码修改为下面即可；
1） 在 sml_Check 中修改只比较前3 位；
修改后(添加红色部分代码)：
for (idx = 0; idx < meta->num; idx++) {
    offset = idx * size_of_cat;
    code_len = sml_GetCode(cat, imsi, gid1, gid2, sim_mnc_len, (pdata+offset), code);
    kal_prompt_trace(MOD_SMU, "[LOCK MCC]: code[0]=%x,code[1]=%x, (*(pdata+offset))=%x, (*(pdata+offset+1))=%x", code[0],code[1],(*(pdata+offset)),(*(pdata+offset+1)));
    if (size_of_cat == code_len) {
        /* Just lock MCC, e.g.  MCC:460,  MCCMNC=0x46, 0x0F,0xFF */
        /* if ((source == 1) && (cat == SML_CAT_N) && (((*(pdata+offset+1)) & 0x0F) == 0x0F))  */ /*If have slot 0 and slot 1, just lock slot 1*/

        if ((cat == SML_CAT_N) && (((*(pdata+offset+1)) & 0x0F) == 0x0F)) { 
            /*code is from SIM, pdata is from NVRAM, just compare 3 number */
            if ((code[0]==(*(pdata+offset))) && ((code[1]& 0xF0)==((*(pdata+offset+1))& 0xF0))) {
                kal_prompt_trace(MOD_SMU, "[LOCK MCC]: return true.");
                result = KAL_TRUE;
                break;
            }
        } else if (kal_mem_cmp(code, (pdata+offset), code_len)==0) {
               kal_prompt_trace(MOD_SMU, "[LOCK common]: return true.");
               result = KAL_TRUE;
               break;
        }
    }
}

修改前：
for (idx = 0; idx < meta->num; idx++) {
    offset = idx * size_of_cat;
    code_len = sml_GetCode(cat, imsi, gid1, gid2, sim_mnc_len, (pdata+offset), code);
    if (size_of_cat == code_len) {
        if (kal_mem_cmp(code, (pdata+offset), code_len)==0) {
            result = KAL_TRUE;
            break;
        }
    }
}

2）NVRAM_EF_SML_DEFAULT 中按照正常锁卡参数步骤配置
2.1 set lock state
要配置 SML_CAT_N；
2.2 set lock key
2.3 set lock code
对于只锁 MCC的code，MNC需要设置为 FFF
下面是code 部分举例：
/* Category N code */
{0x71,0x6F,0xFF, /*716*/
0x46,0x00,0x2F, /*46002*/ 
如果验证有任何疑问，需要在修改的代码前后各分支都加trace，同时把 code[0], code[1], (*(pdata+offset))), (*(pdata+offset+1)))  的值都打印出来，分析执行情况与预期的差异。
```

## [FAQ13063] [Bluetooth] [AT Command]如何在手机端显示蓝牙耳机电量

```
在 HeadsetStateMachine.java 文件中 processUnknownAt 方法中添加对此AT命令的处理函数
实现此AT命令的处理函数 processAtIphoneaccev(),并在此函数中对此AT命令的参数做解析，并按照电池电量的参数来发出Notification更新状态栏的电量图片信息即可。UI显示部分需自己实现。
在此AT命令处理函数中发出Notification即可在状态栏显示蓝牙耳机电量
```

## [FAQ14885] 在文件管理器中无法分享rar压缩包

```
在default情况下，Android无法通过蓝牙发送、接收rar文件。(可能是因为没有自带解压工具的原因)
如果需要实现收发rar文件，可依据下面方法进行修改 。

1.
packages/apps/Bluetooth/AndroidManifest.xml 的 activity android:name=".opp.BluetoothOppLauncherActivity"
的android.intent.action.SEND以及android.intent.action.SEND_MULTIPLE中分别加入了
<data android:mimeType="application/rar" />

2.
packages/apps/Bluetooth/src/com/android/bluetooth/opp/Constants.java
public static final String[] ACCEPTABLE_SHARE_INBOUND_TYPES = new String[]里
添加了"application/rar"
```

## [FAQ12229] [Bluetooth][Settings]已配对蓝牙设备重命名，重新配对名字不更新

```
测试机蓝牙名称A5QP,辅助机蓝牙名称T650w，第一次配对成功后，再取消配对，修改辅助机的蓝牙名称为12345，此时再次配对，发现测试机显示配对T650W成功，而不是配对12345成功。
修改\packages\apps\Bluetooth\src\com\android\bluetooth\btservice\RemoteDevices.java文件：
添加1条语句，位置如下：
void devicePropertyChangedCallback(byte[] address, int[] types, byte[][] values) {
    switch (type) {
        case AbstractionLayer.BT_PROPERTY_BDNAME:
            device.mName = new String(val);
            device.mAlias = device.mName;        //added MTK
            intent = new Intent(BluetoothDevice.ACTION_NAME_CHANGED);
            ......
            break;
        case AbstractionLayer.BT_PROPERTY_REMOTE_FRIENDLY_NAME:
            break;
    ｝
｝
```

## [FAQ17562] 调用图片或视频文件时没有缩略图显示的原因和解决办法

```
设置墙纸、编辑邮件或者信息时调用图片或视频文件，最近显示的图片或视频没有缩略图显示，
在选择界面按右上角的选项设置成网格视图，也没有缩略图显示，如下面两幅图所示：

DocumentsUI中没有显示缩略图的原因，需要checkro.config.low_ram这个属性是否为true？
 
用adb shell getprop ro.config.low_ram 即可查看
相关代码在如下位置：
/frameworks/base/packages/DocumentsUI/src/com/android/documentsui/dirlist/DirectoryFragment.java
boolean svelte = am.isLowRamDevice() && (mType == TYPE_RECENT_OPEN);
mIconHelper.setThumbnailsEnabled(!svelte);

am.isLowRamDevice()最终是调用到下面的方法去做做判断
frameworks/base/core/java/android/app/ActivityManager.java
public static boolean isLowRamDeviceStatic() {
    return "true".equals(SystemProperties.get("ro.config.low_ram", "false"));
}
 
如果项目开启了GMO feature，则low_ram的property会被设为true
如何check是否有打开GMO feature？
=>请参考ID: FAQ15139  如何确认项目是否打开GMO feature(LCA)？

若GMO enable，则不显示缩略图为正常现象，这是GMO为了节省memory使用而做的调整，不是一个显示异常的问题。

若GMO disable，却还是不显示缩略图，则需先排查需要通过DocumentsUI来打开图片或视频文件的那个app给这些文件所带的类型，是否有缩略图；
若app(如Gallery)那边就没有，则需app那边先排查，若app里面显示缩略图正常，则需DocumentsUI这边去分析为何不显示缩略图的原因。

何为GMO？要enable还是disable GMO？
关于GMO feature要enable还是disable，是根据项目的RAM/ROM等配置来定，在项目开案的时候，CPM就会宣导GMO feature相关的信息。
若不确定是否要enable或disale GMO feature，以及如何enable和disable的设置方法，都可以咨询CPM，他们会有文档指导如何操作。
```

## [FAQ20133] VoWifi连接之后，通知栏显示名称客制化

```
需要将com.mediatek.ims修改为运营商名称。 
 
通知里面这个地方的值是由字段"android.substName"来决定，如果没有的话，就使用发送通知的Package的名称。
另外要注意的是，如果设置这个字段，要求发送该通知的应用拥有对应的权限（android.permission.SUBSTITUTE_NOTIFICATION_APP_NAME）。
 
如下修改方法验证可行：
 1. ImsNotificationController.java中所有发送通知的地方，都需要加入extras的参数，也就是下面添加了注释的地方，参考如下：
/vendor/mediatek/proprietary/packages/services/Ims/src/com/mediatek/ims/ImsNotificationController.java
final Bundle extras = new Bundle();//mtk add
extras.putString("android.substName", "运营商名称");//mtk add
Notification noti = new Notification.Builder(mContext)
.setContentTitle(wfcText)
.setContentText(mContext.getResources()
.getString(R.string.wfc_notification_summary))
.setSmallIcon(wfcIcon)
.setTicker(wfcText)
.setOngoing(true)
.addExtras(extras)//mtk add
.build();

2. 添加权限：
/vendor/mediatek/proprietary/packages/services/Ims/AndroidManifest.xml添加如下权限：
<uses-permission android:name="android.permission.SUBSTITUTE_NOTIFICATION_APP_NAME" />
```

## [FAQ20153] 当下载数量多于3个，状态栏下载图标会合并成一个显示

```
1. 打开Chrome/Browser
2.下载任意图片，视频或 apk
3. 点击Link下载文件,连续下载3个文件后，在下载第4个文件时，状态栏下载图标会合并成一个显示
 
这个就是google的design
在N上google有新增notification group，第三方APP可以用setGroup去将notification设定到一个group；如果第三方APP没有设定group，那么google design会自动将4个相同的notification设定为一个group，所以会发生此问题

如果这题要修改，那么可以尝试修改frameworks/base/packages/ExtServices/src/android/ext/services/notification/Ranker.java
这个source code file里的private static final int AUTOBUNDLE_AT_COUNT = 4;就是自动group的number

具体的做判断的地方是在public void onNotificationPosted(StatusBarNotification sbn) 方法中：
if (notificationsForPackage.size() >= AUTOBUNDLE_AT_COUNT) {
    for (String key : notificationsForPackage) {
        notificationsToBundle.add(key);
    }
}
建议不修改这个design，因为这个design会直接影响到所有第三方APP
```

## [FAQ20045] 设置中的添加语言列表多出XA和XB两种语言

```
如果不希望在添加语言列表中看到这两种语言可以使用如下方式进行修改：
方法一：
（1）将/frameworks/base/core/res/res/values/locale_config.xml中的：
<item>ar-XB</item> <!-- Right-to-left pseudolocale -->
和
<item>en-XA</item> <!-- Left-to-right pseudolocale -->
移除掉。
（2） /frameworks/base/core/java/com/android/internal/app/LocaleStore.java文件中，
public static void fillCache(Context context)   函数的如下代码都去掉：
/* for (String localeId : LocalePicker.getPseudoLocales()) {
    LocaleInfo li = getLocaleInfo(Locale.forLanguageTag(localeId));
    if (isInDeveloperMode) {
        li.setTranslated(true);
        li.mIsPseudo = true;
        li.mSuggestionFlags |= LocaleInfo.SUGGESTION_TYPE_SIM;
    } else {
        sLocaleCache.remove(li.getId());
    }
}*/
 
方法二：
不需要修改locale_config.xml文件，只需按照如下方式修改代码。
/frameworks/base/core/java/com/android/internal/app/LocaleStore.java文件中，
public static void fillCache(Context context)函数按照如下方式对代码进行屏蔽：
for (String localeId : LocalePicker.getPseudoLocales()) {
LocaleInfo li = getLocaleInfo(Locale.forLanguageTag(localeId));
/* if (isInDeveloperMode) {
li.setTranslated(true);
li.mIsPseudo = true;
li.mSuggestionFlags |= LocaleInfo.SUGGESTION_TYPE_SIM;
} else {*/
sLocaleCache.remove(li.getId());
// }
}
```

## [FAQ19971] SystemUI的数据类型图标定制

```
客户需求：
PS注册某一种类型的网络时，插入不同的SIM卡，激活数据连接，显示不同的图标类型。
如，PS注册LTE网络的时候，插入一些运营商的SIM，状态栏和下拉快速设置栏显示“4G”,插入另一些运营商的SIM时，显示为“LTE”。

以"PS注册LTE类型,插入SIM：73211,显示“4G” "举例：

方案一：根据不同的mccmnc配置不同的config文件
framework/base/packages/SystemUI/res/values-mcc732-mnc111/config.xml 里面配置“config_show4GForLTE”为true
缺点：由于config配置文件是否被执行到，涉及到编译框架的问题，一旦不生效，很难排查

方案二：
/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/policy/MobileSignalController.java mapIconSets()方法：获取SIM卡的mccmnc, 使用mccmnc进行定制
if (mConfig.show4gForLte) {
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.FOUR_G);//显示成“4G”
} else {
    mNetworkToIconLookup.put(TelephonyManager.NETWORK_TYPE_LTE, TelephonyIcons.LTE);//显示成“LTE”
}

注意:以上两种方案适用于M & N 平台
```

## [FAQ17869] 某些应用发送粉色背景的通知

```
有时用户能在手机上看到下图中粉色背景的通知。这种粉色背景的通知很少见，个别应用才会有。
这种通知背景色是google default design.
以下图为例，这是一条stk notification，在StkAppService.java中launchIdleText(int slotId)中调用NotificationManager.notify()发送。

应用发送的通知其layout最终是引用framework模板：alps\frameworks\base\core\res\res\layout\status_bar_latest_event_content.xml 
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
     android:id="@+id/status_bar_latest_event_content"
     android:layout_width="match_parent"
     android:layout_height="wrap_content"
     android:background="#FFFF00FF"
     ......
这里默认的notification layout背景色FFFF00FF就是图中粉红色。
如果App最终调用该模板且没有重新定制background颜色，通知就是粉红色背景。
 
如果希望修改，不建议直接修改status_bar_latest_event_content.xml.
可以找到发送粉色背景通知的应用，在发送时设置通知背景色：
mPublicNotificationBuilder = new Notification.Builder(context).setColor(r.getColor(com.android.internal.R.color.system_notification_accent_color));
```

## [FAQ12707] 如何修改navigationbar上按键的显示顺序

```
N上的方案：
在N上，由NavigationBarInflaterView负责NavigationBar的view生成。而下方按钮顺序是由config_navBarLayout来决定。
默认顺序，从左往右为：back,home,recent。对应的配置值为：
<string name="config_navBarLayout">space,back;home;recent,menu_ime</string>

可以按照需求，修改这个顺序，比如下面的顺序就是home，back，recent
<string name="config_navBarLayout">space,home;back;recent,menu_ime</string>

M、L、K上的方案：
Navigation bar的layout定义在Navigation_bar.xml (frameworks\base\packages\systemui\res\layout)下。
三个虚拟按键被包含在android:orientation="horizontal"的LinearLayout中，按照定义顺序默认从左至右依次显示BACK, HOME, RECENT。如需改变三个按钮的排列顺序，只需调整他们在LinearLayout中的定义位置即可。
```

## [FAQ13787] [WallPaper]如何去掉系统所有的动态壁纸？

```
1、请将alps/device/mediatek/$project/ProjectConfig.mk中的
MTK_LIVEWALLPAPER_APP = yes
MTK_LIVE_PHOTO_SUPPORT = yes
修改为
MTK_LIVEWALLPAPER_APP = no
MTK_LIVE_PHOTO_SUPPORT = no
2、请查看：
alps/device/mediatek/common/device.mk 
alps/device/mediatek/$platform/device.mk 
alps/device/mediatek/$project/device.mk
alps/build/target/product/full_base.mk
这四只文件中是否有以下code：
PRODUCT_PACKAGES += LiveWallpapers
PRODUCT_PACKAGES += LiveWallpapersPicker
PRODUCT_PACKAGES += MagicSmokeWallpapers
PRODUCT_PACKAGES += VisualizationWallpapers
PRODUCT_PACKAGES += Galaxy4
PRODUCT_PACKAGES += HoloSpiralWallpaper
PRODUCT_PACKAGES += NoiseField
PRODUCT_PACKAGES += PhaseBeam
如果有的话，请全部删除。
 
修改后，请先执行make clean ，然后再重新new整个project 。
```

## [FAQ13630] [WallPaper]如何替换系统的默认静态壁纸？

```
请用目标壁纸替换掉
alps/frameworks/base/core/res/res目录下
drawable-nodpi
drawable-xhpi
drawable-xxhdpi
drawable-xxxhdpi
这四个folder下面的 default_wallpaper。
```

## [FAQ19575] [WallPaper]第一次开机只设置主屏幕壁纸，锁屏壁纸也变成桌面壁纸

```
这是Android N的默认设计，具体请参考WallpaperManagerService的setWallpaper方法，如下：

if (which == FLAG_SYSTEM && mLockWallpaperMap.get(userId) == null) {
    migrateSystemToLockWallpaperLocked(userId);
}
```

## [FAQ17634] 哪些类型的DRM文件可以设置为壁纸？

```
DRM文件中，只有FL类型的可以设置为壁纸
```

## [FAQ17560] [WallPaper]当前Storage Low时设置壁纸失败

```
这个是正常现象，WallpaperManagerService.java在设置壁纸时，会先去判断当前是否Storage Low，如果是就return，不会再去设置壁纸。
```

## [FAQ12506] [WallPaper]如何实现壁纸不随着workspace的滑动而滑动

```
在Workspace.java中把调用updateOffset的地方全部注释掉。
```

## [FAQ08968] [WallPaper]设置动态壁纸后，手机使用过程中恢复为默认静态壁纸

## [FAQ10982] [WallPaper]如何内置多张静态壁纸（图片）到系统中

## [FAQ10958] [WallPaper]系统WallPaper图片可以设置成屏幕大小的图吗？

```
系统默认的Wallpaper图片都是两倍屏宽，主要有2个目的：
1. 壁纸可以随着Launcher Workspace的滑动而滑动；
2. 屏幕横屏时，设置了show wallpaper flag的应用背景可以正常显示。
 
如果将Wallpaper宽高修改为与屏幕宽高相同，就会造成如下隐患：
1. Launcher Workspace的背景会被拉伸，表现不美观；
2. 设置了show wallpaper flag的应用背景在横屏时显示不全（右边会显示黑屏，例如recent界面)。
 
隐患1可以通过修改代码解决（下面的代码就是为了解决隐患1），隐患2也是存在的。因此不建议这样修改。
N/M： 
1. 请在WallpaperUtils.java的getDefaultWallpaperSize方法中，请找到如下代码：
if (res.getConfiguration().smallestScreenWidthDp >= 720) {
   defaultWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
   defaultHeight = maxDim;
} else {
   defaultWidth = Math.max((int) (minDim * WALLPAPER_SCREENS_SPAN), maxDim);
   defaultHeight = maxDim;
}
请先确认代码走哪个分支（这与手机分辨率有关），然后把defaultWidth 和defaultHeight 改为屏幕宽高。修改方法如下（以else分支示例）：
Point realSize = new Point();
windowManager.getDefaultDisplay().getRealSize(realSize);
if (isScreenLarge(res)) {
    defaultWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
    defaultHeight = maxDim;
} else {
    defaultWidth = realSize.x;
    defaultHeight = realSize.y;
}
KK/L：
1. 请在WallpaperCropActivity.java的getDefaultWallpaperSize方法中，请找到如下代码：
if (isScreenLarge(res)) {
    defaultWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
    defaultHeight = maxDim;
} else {
    defaultWidth = Math.max((int) (minDim * WALLPAPER_SCREENS_SPAN), maxDim);
    defaultHeight = maxDim;
}
请先确认代码走哪个分支（这与手机分辨率有关），然后把defaultWidth 和defaultHeight 改为屏幕宽高。修改方法如下（以else分支示例）：
Point realSize = new Point();
windowManager.getDefaultDisplay().getRealSize(realSize);
if (isScreenLarge(res)) {
    defaultWidth = (int) (maxDim * wallpaperTravelToScreenWidthRatio(maxDim, minDim));
    defaultHeight = maxDim;
} else {
    defaultWidth = realSize.x;
    defaultHeight = realSize.y;
}

2. 请找到WallpaperManagerService.java的loadSettingLocked方法，去掉如下代码

if (wallpaper.width < baseSize) {
    wallpaper.width == baseSize;
}
```

## [FAQ04295] 如何客制化Launcher的主菜单图标？

```
在Launcher上，为了保持手机UI风格的统一，希望把用户自己安装的第三方apk图标或者系统预置的应用图标用特定的图标来显示，如何修改？
1. 请修改AppInfo.java的构造函数，如下：
public AppInfo(Context context, LauncherActivityInfoCompat info, UserHandleCompat user, IconCache iconCache) {
    this.componentName = info.getComponentName();
    this.container = ItemInfo.NO_ID;
    flags = initFlags(info);
    firstInstallTime = info.getFirstInstallTime();
    iconCache.getTitleAndIcon(this, info, true /* useLowResIcon */);
    //mtk add
    if ( (info.getApplicationInfo().flags & android.content.pm.ApplicationInfo.FLAG_SYSTEM) != 0) {
        this.iconBitmap=Bitmap.createBitmap(72, 72, Bitmap.Config.ARGB_8888);  // 具体方法可以自行决定，这里只是例子
    }
    //mtk add 
    intent = makeLaunchIntent(context, info, user);
    this.user = user;
}

2. 如果是用户安装的第三方app，请修改AllAppsList.java，修改updatePackage方法如下：

AppInfo applicationInfo = findApplicationInfoLocked( info.getComponentName().getPackageName(), user, info.getComponentName().getClassName());
if (applicationInfo == null) {
    add(new AppInfo(context, info, user, mIconCache));
} else {
    mIconCache.getTitleAndIcon(applicationInfo, info, true /* useLowResIcon */);
    //mtk add
    在此处添加修改applicationInfo.iconBitmap的代码（同上）
    //mtk add 
    modified.add(applicationInfo);
}

3. 如果是系统预置的某个应用，请修改IconCache.java文件的cacheLocked方法，将

entry.icon = Utilities.createBadgedIconBitmap(info.getIcon(mIconDpi), info.getUser(), mContext);
修改为客制化的图标
举例如下：
if ("com.android.contacts".equals(componentName.getPackageName())) {
    Drawable drawable = getFullResIcon(mContext.getResources(), R.drawable.ic_hw_allbackup);
    entry.icon = Utilities.createBadgedIconBitmap(drawable, info.getUser(), mContext);
} else {
    entry.icon = Utilities.createBadgedIconBitmap(info.getIcon(mIconDpi), info.getUser(), mContext);
}
PS：72/72表示主菜单Icon的图标大小，color format是ARGB8888。这个设置默认把用户自己安装的apk Icon刷成黑色。createBitmap这个方法有多种重载方式，用户可以根据实际需求，通过方法参数（颜色/bitmap/图片资源id等）来构造自己的主菜单Icon风格。
```

## [FAQ19916] 状态栏显示条纹

```
这是google default的行为，google 原生机也可以复现
有两个问题导致现在的问题，一是异常情况下MinimizedSockShoadow 被异常画出，而DividerHandleView未被画出，刚好与正常情况相反，二是因为转屏原有DividerView 动画并没有被执行
同时fix这两个问题 都需要在google 原本flow修改比较多的地方。 涉及到google drag multi window divider控制multi window 大小以及DividerView 出现/消失动画流程。
无法做简单修改就可以完成，之前类似的问题我们也尝试过修改，但是有遇到过修改后验证通过了，但是给到客户后，又出现其他比较隐蔽且难fix的问题。导致客户花费更多时间去理清后来的问题。
对于比较复杂的修改，我们综合考虑建议不要去修改这部分的代码，主要是担心出现side effect，反而让客户遇到更多的麻烦
```

## [FAQ12143][DeskClock][RTL] 从LTR的系统语言切换为RTL的语言，时钟的Tab和内容不对应

```
操作步骤：
1.  当前系统语言为中文(LTR),进时钟界面查看
2.  更改系统语言为阿拉伯语(RTL)，进时钟界面查看
实际结果：
时钟tab和内容不对应，如tab显示的是闹钟，页面内容显示的是秒表
 
请贵司找到DeskClock.java文件，将用到getRtlPosition(int position)这个方法的地方，全部替换成直接使用position即可解决问题。
也就是说不需要调用 isRtl() 和 getRtlPosition()方法，直接用position就可以。
```

## [FAQ12998] Alarm Group功能介绍

```
这个功能主要是考虑到，在日常生活中，手机大部分处于灭屏的suspend状态，有一些应用会通过设置定时时钟的方式唤醒系统(screen仍然保持off)，这些app大多在灭屏状态下对唤醒的时间并不敏感。
为了减少background application透过设置(非)周期性的alarm 来trigger手机wake-up(screen off的状态下)，将这些alarm重新排队到同一个时间发生，减少手机wakup的次数，延长app被唤醒的时间间隔，以达到省电的效果。
目前该feature是binary release的，仅对第三方apk才会起效，而且需要在灭屏后手机sleep后的一段时间后才会起作用。
测试条件：
1、打开MTK_BG_POWER_SAVING_SUPPORT这个feature option
2、打开 设置->电池->后台智能省电 选项。
3、安装第三方apk情况下
4、不连接USB/Charger
5、灭屏后一段时间后才可以起效。

测试时可以通过勾选和不勾选的情况下对比测试电流情况，看看是否有省电效果。
请注意测试时不能连接usb/Charger，而且需要观察的是灭屏后一段时间后的电流效果。

本功能在KK2之后的版本会有支持。
```

## [FAQ11651] 闹钟响铃时拔电池，重启手机后，闹钟再次提醒

```
这是正常现象。
闹钟到时后，会设置为fired 状态，如果由于未知原因而stop了（如拔掉电池），会在下一次系统启动的时候判断自己是不是fired 状态，如果是，那么会再判断是不是已经timeout了（正常情况下，一个闹钟响一定时间后会自动missed掉），如果没有timeout ，那么就启动自己，如果已经timeout了，那么就不会再起了。
如果贵司觉得上述行为不是很好的话，可以自行修改AlarmStateManager.java文件中的 registerInstance 这个方法里面最前面的第二个 if 判断，将
 if(instance.mAlarmState == AlarmInstance.FIRED_STATE) 这个判断以及里面的内容注释掉。
鉴于目前设计有更好的用户体验，我司建议保持原始设计。
```

## [FAQ14939] 情景模式设置为静音模式，如何修改让闹钟仍然有声音

```
我司遵循google default design,当情景模式里的打扰为“禁止打扰”时，闹钟响铃不会有铃声和震动；当情景模式为静音时，打扰功能就是设置为“禁止打扰”的，因此闹钟是静音。
若贵司一定要改，可以参考以下解法：
DefaultZenModeHelperExt.java
@PluginImpl(interfaceName = "com.mediatek.common.notification.IZenModeHelperExt")
public class DefaultZenModeHelperExt implements IZenModeHelperExt {
   private static final String TAG = "DefaultZenModeHelperExt";
   @Override
   public boolean customizeMuteAlarm(boolean muteAlarm) {
       Log.d(TAG, "customizeMuteAlarm, muteAlarm = " + muteAlarm);
       muteAlarm = false; //add
       Log.d(TAG, "customizeMuteAlarm, muteAlarm = " + muteAlarm);
       return muteAlarm;
   }
}
```

## [FAQ14094] 进入deskclock，background颜色发生变化

```
这个是google L之后的新design，会根据当前的时间来显示不同的background，可以提升用户体验。
例如很晚的时候就是深色（从蓝色->暗色），比较中午的时候蓝色和进入的颜色一样.

具体的代码：
DeskClock.java # mBackgroundColorChanger # setBackgroundColor().

会对24小时配置24种色彩，然后设置一个起始颜色，设置一个渐变动画切换到对应时间点的。
如果要修改BACKGROUND_SPECTRUM[hourOfDay]可以采用一种配色。
```

## [FAQ10862] 如何抓取关机闹钟（Poweroff Alarm）相关log?

## [FAQ04293] 如何预置桌面上的应用程序图标、快捷方式图标、窗口小部件或者文件夹？

## [FAQ18449] Launcher主菜单图标从模糊变清晰

```
Launcher开机启动或者因为某些原因重启时，进入主菜单，主菜单图标会从模糊变清晰。 

这是Launcher的默认设计，第一次加载主菜单图标时，会先去decode一张low resource icon，然后再解析清晰的图片。
如果不想要这个效果，请按照以下修改：
1、修改AllAppsList.java的updatePackage方法为如下：
// Find enabled activities and add them to the adapter
// Also updates existing activities with new labels/icons
for (final LauncherActivityInfoCompat info : matches) {
    AppInfo applicationInfo = findApplicationInfoLocked(
        info.getComponentName().getPackageName(), user,
        info.getComponentName().getClassName());
    if (applicationInfo == null) {
        add(new AppInfo(context, info, user, mIconCache));
    } else {
        mIconCache.getTitleAndIcon(applicationInfo, info, false /* useLowResIcon */);//mtk modify
        modified.add(applicationInfo);
    }
}

2、修改AppInfo.java：
public AppInfo(Context context, LauncherActivityInfoCompat info, UserHandleCompat user, IconCache iconCache) {
    this.componentName = info.getComponentName();
    this.container = ItemInfo.NO_ID;
    flags = initFlags(info);
    firstInstallTime = info.getFirstInstallTime();
    iconCache.getTitleAndIcon(this, info, false /* useLowResIcon */);//mtk modify
    intent = makeLaunchIntent(context, info, user);
    this.user = user;
}
```

## [FAQ18346] 如何减小桌面的空白区域？

```
参考“FAQ04350 如何去除Launcher默认的google search bar？”去掉google search bar后，发现桌面上面的空白区域比较大（即下图红框框出来的区域）。要如何修改才能减少空白区域？

请调整DeviceProfile.java的layout(Launcher launcher)方法中Workspace的位置，尽量往上调，即修改如下的代码：
 
// Layout the workspace
PagedView workspace = (PagedView) launcher.findViewById(R.id.workspace);
lp = (FrameLayout.LayoutParams) workspace.getLayoutParams();
lp.gravity = Gravity.CENTER;
Rect padding = getWorkspacePadding(isLayoutRtl);
workspace.setLayoutParams(lp);
workspace.setPadding(padding.left, padding.top, padding.right, padding.bottom);
workspace.setPageSpacing(getWorkspacePageSpacing(isLayoutRtl));
```

## [FAQ13194] 如何去掉Home Sample？

```
用户要求去掉Launcher3，只使用第三方桌面。但是在去掉Launcher3后系统会多出Home Sample的桌面,请问如何去掉 Home Sample？ 
请将alps/build/target/product/core_base.mk中PRODUCT_PACKAGES 这个tag下面的Home项去掉即可。
```

## [FAQ19430] Launcher是否支持unread feature？

```
M之前，Launcher支持unread feature。默认只支持电话、短信、邮件、日历，三方App无法支持。
N之后，Unread Feature phase out。
如果您需要此Feature，请自行从M版Merge这个feature，MTK不再支持。因为此feature不仅要Launcher支持，还要Settings/Apps的支持。
```

## [FAQ14512] Launcher3如何让快捷方式默认创建在第一屏？

```
Launcher3在收到广播:com.android.launcher.action.INSTALL_SHORTCUT后，会自动在桌面上创建快捷方式，默认会创建在第二屏。如果让快捷方式默认创建在第一屏？ 
N/M:
请修改LauncherModel.java的findSpaceForItem方法，将如下代码：
int preferredScreenIndex = workspaceScreens.isEmpty() ? 0 : 1;

修改为：
int preferredScreenIndex=0;

L:
请修改LauncherModel.java的addAndBindAddedWorkspaceApps方法，将如下代码：
int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;

修改为：
int startSearchPageIndex = 0;
```

## [FAQ11441] Launcher3中主菜单的布局如何调整(譬如从5*4调整为4*4)?

```
Launcher3中主菜单的布局如何调整(譬如从5*4调整为4*4)?
N/M:
M版本以后主菜单使用的是RecyclerView，类似于ListView的控件，不支持调整布局。
L:
Launcher3主菜单布局的行数和列数，都是在DynamicGrid.java中动态计算的，xml中无法配置。
如果想修改主菜单的布局，调整行数和列数，请修改DynamicGrid.java中allAppsNumRows和allAppsNumCols的值。
```

## [FAQ08349] 如果Launcher支持横屏显示，如何避免Launcher重新创建？

```
如果Launcher可以横屏显示，开机时有时会创建两次。有时用户从横屏应用退出回到Launcher时，Launcher也会重新创建。如何避免Launcher重新创建？
[SOLUTION]
请修改Launcher的AndroidManifest.xml，对Launcher这个Activity添加android:configChanges属性，在这个属性中设置Launcher感兴趣的config变化(例如orientation)。

关于android:configChanges，请参考：
http://developer.android.com/guide/topics/manifest/activity-element.html#config
```

## [FAQ19891] 软件包对于32位和64位的支持情况

```
请打开软件包对应的ReleaseNote_for_MT6***_alps-mp-**.mp*.xlsx，找到Project_Package_Set_M6***这个sheet，查看右上角的Naming rule change。
Project Naming rule: [MTKomer name][chip]_number1number2_M
*Number is meaning in project name
First number means 64 bit SW
Second number means 6M / 5M / 4M / 3M SW
*In 6/5M package set
T means CMCC/TDD(OP01) project
U means CU    /FDD (OP02) project
*Bring "C" to identify that it's C2k/CT(OP09) project
*Bring "G" to identify that it's GMO project
*Bring "WW" to identify that it's WWOP project
/device/mediatek/k35v1_64_tee_vdo/即代表是64bit
64位和32位project不能自行切换，需要和敝司申请对应的project。
```

## [FAQ19897] how to modify the maximum connections of hotspot from frameworks?

```
In general,hotspot's maximam connection is limited by hardware,so if you want to modify the number,must to make sure the performance of hardware is enough;

packages/apps/Settings/res_ext/values/mtk_arrays.xml
<string-array name="wifi_ap_max_connection_entries">
    <item>1 user</item>
    <item>2 users</item>
    <item>3 users</item>
    <item>4 users</item>
    <item>5 users</item>
    <item>6 users</item>
    <item>7 users</item>
    <item>8 users</item>
    //add to ten 
    <item>9 users</item>
    <item>10 users</item>
    //add
</string-array>
so you can choose "10 users " when you setup hotspot;
```

## [FAQ11383] [others]手动关闭factory mode

```
为了防止end users在使用手机的过程中由于误操作进入factory mode,需要关闭factory mode.但是在产线流程中factory mode test又是必须存在的，这种情况下，就需要有一个打开或者关闭factory mode的“开关”存在，能够自由的控制factory mode。以72为例，介绍用pro_info来存储这个“开关”标记，这样既可以在LK/Uboot中访问这个标记，同时在上层APK中可以通过nvram的接口来读写设置这个标记。

1.客制化一个nvram item，请参考《customization inNvRAM.ppt》
注意事项_1：
a) 如平台使用的是【eMMC】，新LID对应struct的size必须是512 byte的倍数；
b) 如平台使用的是【NAND】，新LID对应struct的size必须是page size对齐（即4K或2K）。

2.客制化pro_info，请参考《Customization in NvRAM Product Info feature.pptx》
注意事项_2：
a) 如平台使用的是【eMMC】，g_new_nvram_lid[]里面新LID的size必须要128K对齐；
b) 如平台使用的是【NAND】， g_new_nvram_lid[]里面新LID的size必须要blocksize对齐（4K pagesize对应的是256K，2K pagesize对应的是128K）。

3.上层APK读写设置factory mode关闭的标记,请参考FAQ ：FAQ04542
4.lk中读取factory mode设置的标记.
1）-in alps\mediatek\platform\mt6572\lk\factory.c  factory_detection()中判断factory_check_key_trigger()之前添加一个if判断，读取flag为1，返回false
```

## [FAQ11384] [SW相关]设置3个组合键进入factory mode

```
为了减少end users在使用手机的过程中由于误操作进入factory mode的几率，增加了1个键，让客户进入factory mode需要同时按下3个组合键（Power Key+VolumDown+物理按键）。

1.在apls\mediatek\platform\mt65xx\lk\factory.c中的factory_check_key_trigger函数中修改
if(mtk_detect_key(MT65XX_FACTORY_KEY)&&mtk_detect_key(MT65XX_FACTORY_KEY2))
2.在cust_key.h中加入#define MTK65XX_FACTORY_KEY2 XX（参照MTK65XX_FACTORY_KEY定义对应的key）
3.第2步添加的MTK65XX_FACTORY_KEY2的值必须是在Cust_kpd.h中KPD_INIT_KEYMAP中已定义的物理按键的数值。
```

## [FAQ18526] [SAT]使用过程中，欢迎语突然又弹出来，是否正常？

```
在Flight mode/掉卡/SIM Switch/World Mode/World Phone切换都有可能会导致欢迎语弹出两次，
因为有重新给卡初始化的动作，
除了掉卡问题，需要driver同仁解决，
其他都是正常的，
因为这些情况下都会导致SIM卡重新上电，重新上电的话，手机就一定要再发一次terminal profile给卡，告知卡手机支持哪些SAT命令，从而会触发卡新上报欢迎语。
 
有些客户可能会考虑在界面上屏蔽这次欢迎语的上报，这样是不妥当的，因为有些卡是不会上报欢迎语的，第一条上报的display text是一些关键的信息。如果贸然屏蔽掉第一条上报的display text命令，会导致有些卡的关键信息看不到。
 
在radio log里的关键log:
掉卡的关键log:ESIMS:0,13；
SIM SWITCH关键log:AT+ES3G=* 或者AT+ESIMMAP=*；
World Mode切换：AT+ECSRA=2,*,*,*；
World Phone切换：Switching to *DD CSFB modem,其中这个*有可能是F，也有可能是T,就是说FDD和TDD之间的切换；
 
还有一些卡,是更新注册网络信息，或者没有任何原因的就会主动上报欢迎语,客户可以先自行在其他对比机插入同一张卡做对比测试，如在对比机上未发现类似情况，再提交eservice.
```

## [FAQ14370] 如何让返回键具有删除编辑内容功能

```
在编辑界面，如果正在编辑，就删除编辑的内容。如果编辑的内容为空，按下返回键就返回上一界面，请问该如何实现？

修改 Activity.java 中 onKeyUp 为如下：
public boolean onKeyUp(int keyCode, KeyEvent event) {
    if (getApplicationInfo().targetSdkVersion >= Build.VERSION_CODES.ECLAIR) {
        if (keyCode == KeyEvent.KEYCODE_BACK && event.isTracking() && !event.isCanceled()) {
            if (isResumed()) { 
                View decorView = this.getWindow().getDecorView();//MTK modifyBegin
                if (decorView != null) {
                    View focus = decorView.findFocus();
                    if (focus!=null&&focus instanceof EditText) {
                        EditText editText = (EditText)focus;
                        CharSequence text = editText.getText();
                        if (text!=null && text.length()>0) {
                            editText.setText("");
                            return true;
                        }
                    }
                }
                onBackPressed(); //MTK modify END
                return true;
            } else {
                Log.v(TAG, "Tracking Key Up, activity is resumed: " + isResumed());
                // Fix sub activity of tab activity which isn't in resumed state
                // Return false means didn't handle this key event
                return false;
            }
            /// @}
        }
    }
    return false;
}
```

## [FAQ19537] [Recovery][Common]recovery模式中选择Apply update from adb升级失败，电脑端提示“无法识别USB设备” 或"device not found"

```
建议参考下面的修改
1、alps/bootable/recovery/etc/init.rc
on property:cus.recoveryadb.prop=1
write /sys/class/android_usb/android0/enable 0
write /sys/class/android_usb/android0/idVendor 0E8D
write /sys/class/android_usb/android0/idProduct 201C
write /sys/class/android_usb/android0/f_ffs/aliases adb
write /sys/class/android_usb/android0/functions adb
write /sys/class/android_usb/android0/enable 1
write /sys/devices/platform/mt_usb/cmode 1

2、adb_install.cpp
set_usb_driver(bool enabled)函数中
添加property_set("cus.recoveryadb.prop", "1");

3、device/mediatek/common/sepolicy/property.te
添加type cus_recoveryadb_prop, property_type;
device/mediatek/common/sepolicy/property_contexts
添加cus.recoveryadb.prop u:object_r:cus_recoveryadb_prop:s0
device/mediatek/common/sepolicy/recovery.te
allow recovery cus_recoveryadb_prop:property_service set;
 
adb sideload 使用方法可参考  "FAQ04559 [Recovery][Common]从JB版本开始支持adb sideload命令"
```

## [FAQ06239] [new feature]通话录音时如何播放提示音给对方？

```
因为涉及到通话隐私问题，部分客户要求在通话录音时播放提示音给对方
下面这个修改同时会将本地的背景播放音乐等声音播放给对方

BGS UL gain默认为0，所以本方播放的声音对方不会听到
修改BGS UL gain，可以将本地播放的声音传给对方 
 
在点击通话录音之后
1.将BGS UL gain 设为最大
2.播放声音
3.播放完后将BGS UL gain还原为0

packages/apps/Dialer/InCallUI/src/com/android/incallui/CallButtonPresenter.java 
public void voiceRecordClicked() {
    //1.set the mBGSUlGain to 0xFF in hal
    AudioSystem.setParameters("SET_BGS_UL_GAIN=1");
    //2.play the warning tone here
    //3.set the mBGSUlGain to 0x0 in hal
    AudioSystem.setParameters("SET_BGS_UL_GAIN=0");

    TelecomAdapter.getInstance().startVoiceRecording();
    ......
}
  
AudioALSAHardware.cpp
//add this
static String8 keySET_BGS_UL_GAIN= String8("SET_BGS_UL_GAIN");
 
status_t AudioALSAHardware::setParameters(const String8 &keyValuePairs)
{
......
//add this start
if (param.getInt(keySET_BGS_UL_GAIN, value) == NO_ERROR) { 
param.remove(keySET_BGS_UL_GAIN); 
ALOGD("+%s(): %s", __FUNCTION__, "SET_BGS_UL_GAIN");
if(value==1){
    mStreamManager -> mBGSUlGain = 0xFF; 
}else{
    mStreamManager -> mBGSUlGain = 0x0; 
}
//add this end
}
}
```

## [FAQ17344] [SIM]怎样判别是否为“白卡”（测试卡）

```
怎样判别一张卡是否为“白卡”（测试卡）

[AP]
AP端可以获取对应SIM卡的属性值进行判断，0表示普通SIM卡，1表示测试卡。
"gsm.sim.ril.testsim",    --- 卡1
"gsm.sim.ril.testsim.2", --- 卡2
"gsm.sim.ril.testsim.3", --- 卡3
"gsm.sim.ril.testsim.4", --- 卡4

[Modem]

“白卡”中有些文件内容会有一些特殊规定用于标识“白卡”的身份:
A：MCC-MNC = 001-01 
B：EF_AD文件中的 ms_operation 的值为0x80/0x81/0x02/0x04
我们在读取EF_AD的时候会将之前读出的MCC/MNC满足情况一并做“白卡”判断，判断条件的关系有A&&B和A||B两种，判断条件的关系在test_sim_relation()中定义，若需要修改判断关系（&&或者||）直接修改此函数的return值即可，返回0对应||、返回1对应&&；
判断结果存放在SIM的全局context中（this_sim->is_test_sim），客户可调用is_test_sim()接口获得判断结果，参数为想获得信息的SIM编号：0x00/0x01/0x02/0x03分别对应SIM1、SIM2、SIM3、SIM4。
```

## [FAQ19583] [Audio App]android N 版本铃声设置显示“更多铃声”选项

```
默认在android M版本铃声设置对话框里面包含“更多铃声”选项。实际上在N版本里面也包含这项功能，只是未让它显示。铃声
设置对话框代码在 packages/providers/MediaProvider/src/com/android/providers/media/RingtonePickerActivity.java。
在 RingtonePickerActivity.java 的 onCreate 函数我们发现如下:

/// M: Get whether to show the 'More Ringtones' item
mHasMoreRingtonesItem = intent.getBooleanExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_MORE_RINGTONES, false);

因此我们只要在启动 RingtonePickerActivity 的时候把 RingtoneManager.EXTRA_RINGTONE_SHOW_MORE_RINGTONES
设置成true就好了。在 packages/apps/Settings/src/com/android/settings/RingtonePreference.java 文件的
onPrepareRingtonePickerIntent 函数添加代码如下:

ringtonePickerIntent.putExtra(RingtoneManager.EXTRA_RINGTONE_SHOW_MORE_RINGTONES, true);
```

## [FAQ10495] [SEC]如何修改SIM ME LOCK校验界面上的输入密码次数

```
在AP端默认给SIM ME LOCK的输入密码次数是5次，
如果想修改显示次数或屏蔽掉显示次数，请参考以下步骤。

在收到卡被SIM ME LOCK住时才会去获取对应Category的retry count, 并记录在数组mSimMeLeftRetryCount中。
Path: alps\frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\KeyguardUpdateMonitor.java

AP端显示界面处理:
L版本上(M版本与L版本相同)，
Path：alps\frameworks\base\packages\Keyguard\src\com\mediatek\keyguard\Telephony\ KeyguardSimPinPukMeView.java
getRetryMeString () 这个方法就是来控制次数显示的。
如果想屏蔽显示次数，这个方法return null。

在KK版本上，
Path: alps\frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\KeyguardSIMPinPukView.java
getRetryMe() 这个方法就是来控制次数显示的。
如果想屏蔽显示次数，这个方法return null。

如果想修改显示次数，
不能直接修改方法 meRetryCount 为指定的值；而需要修改 modem 端。
custom_nvram_sec.h(\custom\service\nvram), 修改对应category 的 SML_RETRY_COUNT_xxx_CAT 值。
下面截图是修改前的状态，默认是 5.
```

## [FAQ03989] [Notification]如何让通知不被清除或者点击后不消失？

```
APP发送通知后，点击clear按钮，如何让通知不被清除？或者点击通知后，通知不消失？

APP发送通知时，通知需要添加flag：
notification.flags |= Notification.FLAG_ONGOING_EVENT;
或者
notification.flags |= Notification.FLAG_NO_CLEAR;
```

## [FAQ19254] [Recents]更改系统时间后，按recent键无法进入最近应用列表界面

```
在设置中将系统时间修改为早于当前系统的时间，recent键点击无效，无法正常叫出最近应用列表界面。
这是google default design，用google 6.0对比机来测试也是这样的。
建议维持google原有设计，对于google原生的设计，我们不做修改
原因是：
RecentApp通过AMS的getRunningTasks() API取得目前正在执行中的task记录.
而通过最近一次使用的APP是否为RecentApp, 來判断按下HOME key时是否退出.
AMS会将最近使用的时间资讯(系统时间)记录起来并排序, 但在调整系统时间后造成先后顺序错乱,
导致RecentApp误判目前状态，进而无法退出。
涉及的模块是AMS和RecentApp.
如果AMS仿照RecentApp的修改, 將记录系统时间改为开机时间可能可以解决该问题，但会接影响AMS开放出去的API行为。Framework內部也会根据task时间资讯来做些判断(如Activity決定是否在开机时reset),得将这部分相关逻辑一并修正.
目前敝司经过全面评估，修改该问题后风险依然存在，因此建议维持
```

## [FAQ19361] 如何预置一个WIFI热点

```
JB版本：
请在  alps/external/wpa_supplicant_8/mtk-wpa_supplicant.conf  这个文件中增加 networt={} 即可。
network需要字段的含义可以查看wpa_supplicant_8/wpa_supplicant.conf文件中的注释“network block fields:”后的说明即可。

KK&L版本：
请在/hardware/mediatek/wlan/config/mtk-wpa_supplicant-overlay.conf文件中增加networ={} 即可。

M 版本路径：
/vendor/mediatek/proprietary/hardware/connectivity/wlan/config/mtk-wpa_supplicant-overlay.conf

如下面的例子，预置一个OPEN 和WPA2-PSK的网络：
ctrl_interface=/data/misc/wpa_supplicant
update_config=1
device_name=rk30sdk
manufacturer=rockchip
model_name=ONE TOUCH EVO8HD
model_number=ONE TOUCH EVO8HD
serial_number=0123456789
device_type=10-0050F204-5
config_methods=physical_display virtual_push_button keypad

network={
     ssid="aaaa"
     scan_ssid=1
     key_mgmt=NONE
}

network={
     ssid="bbbbb"
     scan_ssid=1
     psk="12345678"
     key_mgmt=WPA-PSK
}
```

## [FAQ19495] 调整开关机铃声音量大小

```
Android N:
alps/frameworks/av/services/audioflinger/Threads.cpp
AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTracks_l(Vector< sp<Track> > *tracksToRemove) {
    .....
#ifdef MTK_AUDIO
    // Do not change the volume, when boot sound open
    if (track->mFlags & IAudioFlinger::TRACK_BOOT) {
        vlf = 0.25f; // 
        vrf = 0.25f; // 改变vlf和vrf的值，取值范围0~1
    }
#endif
    ......
}


Android M & L：
alps/vendor/mediatek/proprietary/custom/(project)/hal/audioflinger/audio/Audio_Customization_Common.h 
#define BOOT_ANIMATION_VOLUME (0.25)
改变BOOT_ANIMATION_VOLUME的值，取值范围0~1
```

## [FAQ19357] N版本中，三方应用引用某些系统库导致无法运行

```
在N版本中为了增强安全性,三方应用也不能随意加载系统没有暴露出来的库，从而会导致三方应用无法运行。
详细内容参考google 官方说明：https://source.android.com/devices/tech/config/namespaces_libraries.html
 
如下图所示，系统的应用，可以调用系统库，而三方应用，只能调用或者加载NDK 暴露出来的一些库，如libc.so。。。之类的和他自身的一些库。
但是如果某些应用有调用到系统 native库就会报出形如下面的Log：
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: java.lang.UnsatisfiedLinkError: dlopen failed: library "/system/lib64/libfmjni.so" needed or dlopened by "/system/lib64/libnativeloader.so" is not accessible for the namespace "classloader-namespace"
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at java.lang.Runtime.loadLibrary0(Runtime.java:977)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at java.lang.System.loadLibrary(System.java:1530)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at com.android.fmradio.FmNative.(FmNative.java:45)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at com.android.fmradio.FmNative.openDev(Native Method)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at com.szwj.autoats.fmradio.FMRadioService.openDevice(FMRadioService.java:576)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at com.szwj.autoats.fmradio.FMRadioService.onCreate(FMRadioService.java:1361)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at android.app.ActivityThread.handleCreateService(ActivityThread.java:3253)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at android.app.ActivityThread.-wrap5(ActivityThread.java)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1617)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at android.os.Handler.dispatchMessage(Handler.java:110)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at android.os.Looper.loop(Looper.java:203)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at android.app.ActivityThread.main(ActivityThread.java:6251)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at java.lang.reflect.Method.invoke(Native Method)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:1063)
01-06 20:34:05.255959 4629 4629 E AndroidRuntime: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:924)

如果被依赖的库评估安全性可以开放出来的，则可以将其添加到/device/mediatek/common/public.libraries.vendor.txt名单列表当中。
如果不可以开放到，则此问题属于和N版本不兼容的，需要APP开发者自行处理。
```

## [FAQ15571] [SELinux] Android N 版本进程无法直接访问data目录的说明

```
Google 在android M 版本后, 通过SELinux 的neverallow 语法强制性限制了普通进程访问data 目录的权限. 严禁除init system_server installd system_app 之外的其他进程直接操作/data 目录比如在data 目录下面创建文件，写文件，重命名文件等等.

有很多客户都会在data 目录下创建文件, 保存资讯, 在M 版本上这个操作会被SELinux 直接拦截下来，并且没法直接添加访问system_data_file 的权限，N版本上更加严格, system_app也会被拦截下来.
 
N版本:
neverallow appdomain system_data_file:dir_file_class_set { create write setattr relabelfrom relabelto append unlink link rename };
 
M版本对system_app有是开放权限：
neverallow { appdomain -system_app } system_data_file:dir_file_class_set { create write setattr relabelfrom relabelto append unlink link rename };
 
需要按下面的流程操作：
(1).  在init.rc 或者 其他的init.xxx.rc 的on post-fs-data 段 添加:
mkdir /data/xxxx 0770 root system

(2). 在/device/mediatek/common/sepolicy/file.te 里面添加：
type xxxx_data_file, file_type, data_file_type;

(3). /device/mediatek/common/sepolicy/file_contexts 里面添加：
/data/xxxx(/.*)? u:object_r:xxxx_data_file:s0

(4). 给你的进程添加权限, 比如你的进程的SELinux domain 是 yyyy
allow yyyy xxxx_data_file:dir create_dir_perms;
allow yyyy xxxx_data_file:file create_file_perms;

这样你才能绕过Google 的设置. 这个xxxx 目录随你定义.
```

## [FAQ19362] 如何设置mobilelog modemlog networklog size大小

```
第一次开机之前就需配置
配置路径：
M\N 版本：\device\mediatek\common\mtklog
mtklog-config-bsp-eng.prop
mtklog-config-bsp-user.prop
mtklog-config-basic-eng.prop
mtklog-config-basic-user.prop

默认存储大小：
com.mediatek.log.mobile.maxsize = 500
com.mediatek.log.mobile.total.maxsize = 1000
com.mediatek.log.modem.maxsize = 2000
com.mediatek.log.net.maxsize = 600
按照需要修改对应选项即可, 需要注意com.mediatek.log.mobile.maxsize要小于com.mediatek.log.mobile.total.maxsize

2. 其他情况：
1）UI界面设置
mtklogger UI---->Settings---->mobilelog---->Limit Current Log Size
mtklogger UI---->Settings---->mobilelog---->Limit Total Log Size
mtklogger UI---->Settings---->modemlog---->Limit Log Size
mtklogger UI---->Settings---->networklog---->Limit Log Size

2）adb shell command设置,请参考FAQ06939 如何用adb 控制MTKLogger

注意：mobilelog涉及两个size大小设置，需要保证Limit Current Log Size < Limit Total Log Size
```

## [FAQ19217] wifi连接获取IP失败

```
连接WiFi获取ip失败，首先可查看MSG_ID_MMI_ABM_IPADDR_CHANGE_REQ中use_dhcp中是否有被设置为KAL_TRUE,具体log信息参考如下：

请在以下函数中添加代码默认使用DHCP。
void srv_dtcnt_wlan_ipaddr_change_req(MMI_BOOL use_dhcp, srv_dtcnt_wlan_ipaddr_update_struct *ipaddr_info) {
/*----------------------------------------------------------------*/
/* Local Variables */
/*----------------------------------------------------------------*/
      mmi_abm_ipaddr_change_req_struct *p;
      srv_dtcnt_prof_wlan_struct *profile = NULL;

/*----------------------------------------------------------------*/
/* Code Body */
/*----------------------------------------------------------------*/
      MMI_TRACE(MMI_CONN_TRC_G6_DTCNT, SRV_DTCNT_WLAN_IPADDR_CHANGE_REQ, use_dhcp, g_srv_dtcnt_wlan_ctx.state);
      if (g_srv_dtcnt_wlan_ctx.state != SRV_DTCNT_WLAN_STATE_CONNECTED) {
           return;
      }

     p = OslAllocDataPtr(mmi_abm_ipaddr_change_req_struct);
     DTCNT_SRV_ILM_MEMSET(p);

     if (g_srv_dtcnt_wlan_ctx.connected_wlan_profile != NULL) {

          kal_prompt_trace(MOD_MMI,"mtk_debug g_srv_dtcnt_wlan_ctx.connected_wlan_profile != NULL ");//添加trace跟踪
          profile = g_srv_dtcnt_wlan_ctx.connected_wlan_profile;
          p->use_dhcp = g_srv_dtcnt_wlan_ctx.connected_wlan_profile->use_dhcp;
      } else {
          use_dhcp = 1;//添加Code；
          p->use_dhcp = use_dhcp;
          if (!use_dhcp)
          {
                    MMI_ASSERT(ipaddr_info);
           }
       }
       ...
}
```

## [FAQ14131] 在预编译阶段提取apk的odex文件以加快开机速度

```
1 预编译提取apk的odex文件，请在BoardConfig.mk中定义：
WITH_DEXPREOPT := true

打开这个宏之后，无论是有源码还是无源码的预置apk预编译时都会提取odex文件。
（如有发现user版本未提取odex，请检查device.mk文件配置：
   ifeq ($(TARGET_BUILD_VARIANT),user)
       WITH_DEXPREOPT := true
       DONT_DEXPREOPT_PREBUILTS := true  //此句注释掉
   endif 
）

对于64bit的芯片,若apk只有32bit的lib或者只能作为32bit运行，请在预置apk时在android.mk中添加下边的TAG标记此apk为32bit：

LOCAL_MULTILIB :=32
 

2 若需要在预编译时跳过一些apk的odex提取，可以使用下边的方法：
\build\core\dex_preopt_odex_install.mk中添加：
ifeq ($(LOCAL_MODULE),helloworld)
LOCAL_DEX_PREOPT:=
endif
build_odex:=
installed_odex:=
....
Ifeq包起来的部分为需要添加的,helloworld可替换为需要跳过提取odex的apk的LOCAL_MODULE名字
 
注意：
打开WITH_DEXPREOPT 的后，预置太多apk，会导致system.img 过大，而编译不过。遇到这种情况请调大system.img的大小限制。
-------------------  more in   Android N   ----------------------
N版本当中如果预置了GMS包，则对无源码的APK不做预编译处理。如果需要都做，需要在如下代码做修改：
路径：/device/mediatek/common/BoardConfig.mk
......
ifeq ($(BUILD_GMS),yes)
DONT_DEXPREOPT_PREBUILTS := true   ------------------>请把此处关掉，即赋值false。
else
ifeq ($(TARGET_BUILD_VARIANT),userdebug)
DEX_PREOPT_DEFAULT := nostripping
endif
endif
......
 
修改完后，dex2oat操作即在编译时完成，不会影响开机时间。
 
补充说明：Android N中平台添加该特性，是因为WITH_DEXPREOPT := true打开这个之后，就会将有源码以及无源码的所有预置APK在host上做预编译并且塞到system partition中。

但由于內部project storage size的限制，这些预置APK做完dexpreopt之后会超过system partition的size. 因此选择一个折中方案，即加上限制，
对于无源码的APK(ex: GMS)不做dexpreopt的行为。如果客户的system partition足够大塞的下这些预编译完的内容，可以把这段代码拿掉也不会有什么影响。
```

## [FAQ19348] [Audio volume]如何修改第三方来电提示音音量

```
第三方来电提示音 嘟嘟声 过小
InCallTonePlayer.java
private static final int RELATIVE_VOLUME_HIPRI = 80;
修改RELATIVE_VOLUME_HIPRI的值
范围0~100
```

## [FAQ12380] [Audio APP]如何在Google Play Music中播放Drm歌曲？

```
1、请使用adb shell ps，查看com.google.android.music的process的名称。Play Music应该会有两个process：
com.google.android.music:ui
com.google.android.music:main
2、请在mediatek\frameworks\av\drm\mtkwhitelist\DrmMtkDef.cpp中的数组TRUSTED_APP和TRUSTED_PROC中添加com.google.android.music的process，并相应地修改mediatek\frameworks\av\include\drm\DrmMtkDef.h中TRUSTED_APP_CNT和TRUSTED_PROC_CNT的数值。
3、请在packages\providers\MediaProvider\src\com\android\providers\media\DrmHelper.java的setDefaultProcessNames()内的数组permitedProcessNames中添加com.google.android.music的process。

如果是 L 或 L 之后的版本, 上述文件(DrmMtkDef.cpp / DrmMtkDef.h )路径为:
/vendor/mediatek/proprietary/frameworks/av/drm/mtkwhitelist/DrmMtkDef.cpp
/vendor/mediatek/proprietary/frameworks/av/include/drm/DrmMtkDef.h

M版本：
vendor/mediatek/proprietary/frameworks/av/drm/mtkwhitelist/DrmMtkDef.cpp
中向TRUSTED_APP和TRUSTED_PROC中添加com.google.android.music的process

2，/packages/providers/MediaProvider/src/com/android/providers/media/DrmHelper.java
中initDrmPermistProcessList中添加process。
如果不生效，请查看log,如：

MediaPlayerService: setDataSource with fd: untrusted client [10462][com.google.android.music:ui], denied to access drm fd [19]
可知Google music的process的名称是：com.google.android.music:ui，将process的名称修改。
```

## [FAQ17975] Android M 首次开机不随sim卡自适应语言修改方案

```
不能更新的原因是在update config时Android M上去掉了对locale改变的update, 按如下方法改成与Android L上一致即可。如果修改之后仍不能自适应语言，请在修改之后再参考FAQ14489 Android L sim卡自适应语言问题 的修改方法。
 
/frameworks/opt/telephony/src/java/com/android/internal/telephony/MccTable.java
public static void updateMccMncConfiguration(Context context, String mccmnc,
boolean fromServiceState) {
Slog.d(LOG_TAG, "updateMccMncConfiguration mccmnc='" + mccmnc + "' fromServiceState=" + fromServiceState);

if (Build.IS_DEBUGGABLE) {
String overrideMcc = SystemProperties.get("persist.sys.override_mcc");
if (!TextUtils.isEmpty(overrideMcc)) {
mccmnc = overrideMcc;
Slog.d(LOG_TAG, "updateMccMncConfiguration overriding mccmnc='" + mccmnc + "'");
}
}

if (!TextUtils.isEmpty(mccmnc)) {
int mcc, mnc;

String defaultMccMnc = TelephonyManager.getDefault().getSimOperatorNumeric();
Slog.d(LOG_TAG, "updateMccMncConfiguration defaultMccMnc=" + defaultMccMnc);
//Update mccmnc only for default subscription in case of MultiSim.
// if (!defaultMccMnc.equals(mccmnc)) {
// Slog.d(LOG_TAG, "Not a Default subscription, ignoring mccmnc config update.");
// return;
// }

try {
mcc = Integer.parseInt(mccmnc.substring(0,3));
mnc = Integer.parseInt(mccmnc.substring(3));
} catch (NumberFormatException e) {
Slog.e(LOG_TAG, "Error parsing IMSI: " + mccmnc);
return;
}

Slog.d(LOG_TAG, "updateMccMncConfiguration: mcc=" + mcc + ", mnc=" + mnc);
Locale locale = null; //添加这行
if (mcc != 0) {
setTimezoneFromMccIfNeeded(context, mcc);
locale = getLocaleFromMcc(context, mcc); //添加这行
}
if (fromServiceState) {
setWifiCountryCodeFromMcc(context, mcc);
} else {
// from SIM
try {
Configuration config = new Configuration();
boolean updateConfig = false;
if (mcc != 0) {
config.mcc = mcc;
config.mnc = mnc == 0 ? Configuration.MNC_ZERO : mnc;
updateConfig = true;
}
if (locale != null) { //添加这行
config.setLocale(locale); //添加这行
updateConfig = true; //添加这行
} //添加这行

if (updateConfig) {
Slog.d(LOG_TAG, "updateMccMncConfiguration updateConfig config=" + config);
ActivityManagerNative.getDefault().updateConfiguration(config);
} else {
Slog.d(LOG_TAG, "updateMccMncConfiguration nothing to update");
}
} catch (RemoteException e) {
Slog.e(LOG_TAG, "Can't update configuration", e);
}
}
} else {
if (fromServiceState) {
// an empty mccmnc means no signal - tell wifi we don't know
setWifiCountryCodeFromMcc(context, 0);
}
}
}
```

## [FAQ16264] [Audio APP]首次进入收音机(FM) app，播放的频率不一定是代码中默认的频率，为什么？如何修改为代码中的频率？

```
烧机之后首次进入收音机，播放的频率不一定是代码中默认的频率，为什么？如何修改为播放的频率为代码中的频率？
1、首次进入FM，播放的频率不一定是代码中写入的频率原因是：
烧机之后首次进入FM，频率会使用DEFAULT_STATION，但使用时会判断DEFAULT_STATION是否是valid的station，若不是，则自动跳转到下一station。若是，则使用DEFAULT_STATION。
 
2、修改方法是：不进行判断是否是valid Station，直接播放
在FmService.java文件中firstPlaying修改如下：
private boolean firstPlaying(float frequency) {
Log.d(TAG, "firstPlaying, freq: " + frequency);
if (mPowerStatus != POWER_UP) {
Log.w(TAG, "firstPlaying, FM is not powered up");
return false;
}
//delete below
boolean isSeekTune = false;
float seekStation = FmNative.seek(frequency, false);
int station = FmUtils.computeStation(seekStation);
if (FmUtils.isValidStation(station)) {
isSeekTune = FmNative.tune(seekStation);
if (isSeekTune) {
playFrequency(seekStation);
}
}
// if tune fail, pass current station to update ui
if (!isSeekTune) {
seekStation = FmUtils.computeFrequency(mCurrentStation);
}
//delete above

//add below
boolean isSeekTune =true; 
playFrequency(frequency);
//add above

return isSeekTune;
} 
```

## [FAQ15188] 通过NITZ获取时区出错

```
获取时区步骤分析： 
1：有些基站发送NITZ的信息是没有包含时区信息的，
2：需要通过国家码在ICU中获取时区，获取到的时区可能是多个时区，同时返回第一个时区。
3：ICU返回的时区很可能与客户需求不匹配，因此我司定义了一个数组让客户可以自定义国家码与之对应的时区（一个国家码只能对应唯一的一个时区）
我司原本定义与国家码对应的时区可能不符合贵司需求，或是没有定义就会引起这个问题

可以通过LOG判定问题
如果在radio_log 中出现下面的LOG则确定是此问题引起：
uses TimeZone of Capital City:

需要在GsmServiceStateTracker文件中mTimeZoneIdOfCapitalCity 这个数组加入或是修改对应的国家码以及时区；

举例
如获取到的是New_York时区而贵司需求是Los_Angeles时区
请搜索LOG如果出现
GsmSST  : [GsmSST0] uses TimeZone of Capital City:America/New_York
确定是此问题
修改如下
private String[][] mTimeZoneIdOfCapitalCity = {
{"us", "America/New_York"}，
修改为
{"us", "America/Los_Angeles"}， 
};
```

## [FAQ14476] 手机时间最多只能选到2037年12月30日

```
这个是GOOGLE默认设计的。
因为时间选择最后一天时候，切换时区会有问题.
如在西八区,选最后一天的时间为2037年12月31日23:59分，此时切换到东八区，这时无法显示东八区的正确时间。
因此建议接受这个设计。 
```

## [FAQ12388] 如何修改某种语言的默认时间格式(12小时制，24小时制)

```
如果没有设置默认系统的时间显示格式（12小时制或者24小时制），系统切换不同语言显示时间格式是不同的，
比如波斯语是24小时制，中文是12小时制，这是在哪里控制的呢？
[SOLUTION]
这是icu的时间格式觉定的“H”代表24小时制，“h”代表12小时制，如波斯语如下
android kk external\icu4c\data\locales\fa.txt
android L   external\icu\icu4c\source\data\locales\fa.txt 
gregorian{
DateTimePatterns{
"H:mm:ss (zzzz)",
"H:mm:ss (z)",
"H:mm:ss",
"H:mm",
"EEEE d MMMM y",
"d MMMM y",
"d MMM y",
"y/M/d",
}
如果改成12小时制的话，只需把上面红色部分改成下面就行
"H:mm:ss (zzzz)",
"h:mm:ss (z)",
"h:mm:ss",
"h:mm",
注意修改完后请先编译icu资源（ FAQ04011 ），在new工程，否则不会起效果。
```

## [FAQ03998] “日期和时间->自动确定日期和时间->使用网络提供时间”功能是怎样实现的？

```
现在android通过网络同步时间有两种方式：NITZ和NTP，它们使用的条件不同，可以获取的信息也不一样；勾选这个功能后，手机首先会尝试NITZ方式，若获取时间失败，则使用NTP方式

1.NITZ(network identity and time zone)同步时间
NITZ是一种GSM/WCDMA基地台方式，必须插入SIM卡，且需要operator支持；可以提供时间和时区信息

中国大陆运营商基本是不支持的

2.NTP(network time protocol)同步时间
NTP在无SIM卡或operator不支持NITZ时使用，单纯通过网络（GPRS/WIFI）获取时间，只提供时间信息，没有时区信息（因此在不支持NITZ的地区，自动获取时区功能实际上是无效的）

NTP还有一种缓存机制：当前成功获取的时间会保存下来，当用户下次开启自动更新时间功能时会结合手机clock来进行时间更新。这也是没有任何网络时手机却能自动更新时间的原因。

此外，因为NTP是通过对时的server获取时间，当同步时间失败时，可以检查一下对时的server是否有效，并替换为其他server试一下。

3.如何判断手机通过哪种方式更新时间
设置一个错误的时区，查看时区是否有被更新正确，若时间和时区都有更新正确，那么就是GSM网路有送NITZ消息上来；

若只有时间更新，而时区没有变化，就是NTP方式，即它通过网络（GPRS/WIFI）连接到server去获取时间。
```

## [FAQ06450] 【DatePicker】如何修改DatePicker月份显示

```
问题描述：在设置日期时会用到DatePicker这个控件，控件中分为年月日3个部分显示，在某些语言下（比如俄语），月份名称比较长，会超出控件范围。

修改方法：以俄语为例，将月份改短。

ICS版本：
修改 frameworks\base\core\res\res\values-ru-rRU\donottranslate-cldr.xml文件

下面的这几行：
<string name="month_medium_january">1 月</string>
<string name="month_medium_february">2 月</string>
<string name="month_medium_march">3 月</string>
<string name="month_medium_april">4 月</string>
 
其他（GB，JB，KK）版本：
修改external\icu4c\data\locales\ru.txt的monthNames。
（L，M）版本：
修改external\icu\icu4c\data\locales\ru.txt的monthNames。
修改后需要重新编译ICU资源，可以参考另一个FAQ： FAQ04011
```

## [FAQ06455] 【Zone】如何在设置中添加时区

```
解决方案：以加入Nigeria时区为例，应该如下修改：
1.找到该国家在zoneinfo中的时区信息。
时区信息的文件可以从 ftp://munnari.oz.au/pub/ 下载到最新的，解压 tzdata201x*.tar.gz 后，在每个地区的txt文件中有城市的时区信息，搜索是否有您要添加的城市，则该时区可以添加；如果没有搜索到相关的国家或城市，则需要考虑使用别的城市的时区。
比如在 africa.txt 中搜索 Nigeria，可以找到下面的内容：
# Nigeria
# Zone NAME  GMTOFF RULES FORMAT [UNTIL]
Zone Africa/Lagos 0:13:36 - LMT 1919 Sep
1:00 - WAT
这样可以看到，尼日利亚只有一个城市可以作为时区ID，这个ID就是Africa/Lagos。

2.修改 packages/apps/Settings/res/xml-xx-rYY/timezones.xml 或 packages/apps/Settings/res_ext/xml-xx-rYY/timezones.xml （xx-rYY表示不同的语言和区域）,添加下面的内容（notice:如果只在xml-en-rUS下加那只在设置为en_US时才会有该时区，需要在每种语言下都添加）：
<!-- timezones.xml 用于在setting中增加一个时区设置项 -->
<timezone id="Africa/Lagos">Lagos</timezone>
( Android M )
时区ID的定义是放在 frameworks/base/packages/SettingsLib/res/xml/timezones.xml 文件中的，在这里面添加时区需要从新编译frameworks.

3.修改 framework/base/core/res/res/xml/time_zones_by_country.xml ，添加下面的内容
<!--time_zones_by_country.xml 这个用于自动匹配时区时使用，通过country code找一个时区 -->
<!-- Nigeria, 1:00 -->
<timezone code="ng">Africa/Lagos</timezone>
<!-- 这里的code="ri"表示国家代码，比如中国对应cn，美国对应us，不清楚可以维基百科查询ISO_3166-1-->

4.重新编译Setting
```

## [FAQ04318] 如何修改出厂默认日期和默认时区

```
一、修改默认时间
1、修改RTC默认日期：
Android L之前：
\alps\mediatek\custom\[project]\preloader\ inc\cust_rtc.h
\alps\mediatek\custom\[project]\kernel\rtc\rtc\rtc-mt65XX.h
Android L或M：
bootable\bootloader\preloader\custom\[project]\inc\cust_rtc.h
#define RTC_DEFAULT_YEA         2012
#define RTC_DEFAULT_MTH        2
#define RTC_DEFAULT_DOM        1

2、修改默认日期：
framework\services\java\com\android\server\NetworkTimeUpdateService.java
systemReady()
if(isFirstBoot){
Time today = new Time(Time.getCurrentTimezone());
today.setToNow();   // 将时间恢复到RTC时间
today.set(1, 0, mDefaultYear ); //设立出厂默认日期，mDefaultYear是默认年份
如果想恢复出厂设置后，系统时间不变，可使用today.setToNow();
如果想恢复出厂设置后，系统时间也恢复成出厂时间，可使用today.set(1, 0, mDefaultYear );
这个today.set方法有6个参数的重载，可以精确到秒，具体使用方法请自行查询API，所以在这里设置系统默认时间就可以了。

如果要設置出廠默認年份需要修改
1)   mediatek\frameworks\base\res\res\values\config.xml将default_restore_year 修改成 2013
（Android L：vendor\mediatek\proprietary\frameworks\base\res\res\values）
<!-- default year for first power on-->
<integer name="default_restore_year">2013</integer>

2)   frameworks\base\services\java\com\android\server\NetworkTimeUpdateService.java
if(today.year <= 2010){ //删除此行判断条件
    today.set(today.monthDay, today.month, 2013);
    Log.d(TAG, "Set the year to 2013");
    SystemProperties.set(BOOT_SYS_PROPERTY, "false");
    SystemClock.setCurrentTimeMillis(today.toMillis(false));
}

修改后的表现可通过Setting菜单->时间日期设置):

3、修改默认时区：
在系统属性中增加下面字段(假设改为Moscow)
Android L之前：
mediatek\config\[project]\system.prop
Android L:
device\mediatek\[project]\system.prop
persist.sys.timezone = Europe/Moscow注意：默认时区的修改会影响默认时间的值，会根据与格林尼治标准时间差来更新时间，这是正常现象。如当前设置为中国标准时间GMT+8:00，则手机的出厂时间会变为8:00。
```

## [FAQ11211] 使用一些字库后，字符整体偏上

```
有些字库字形设计不是很标准，字形高度偏小，这样导致使用字库后，字符相对icon整体上移，如下藏语显示问题：

解决这个问题可以使用其他字库来解决，对于JB3、JB5、JB9也可以通过修改代码解决，如下
修改文件：TextPaint.java(alps\frameworks\base\core\java\android\text)

1、新增如下函数
/**
 * @hide
 */
public int getFontMetricsInt(String text, int start, int end, FontMetricsInt fm) {
    Rect bounds = new Rect();
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    if (text == null) {
        start = end = 0;
    } else if (text.length() < end) {
        end = text.length();
    }
    super.getTextBounds(text, start, end, bounds);
    super.getFontMetricsInt(fm);
    if (bounds.top < fm.top) {
        fm.top = bounds.top;
        fm.ascent = bounds.top;
    }
    if (bounds.bottom > fm.bottom) {
        fm.bottom = bounds.bottom;
        fm.descent = bounds.bottom;
    }
    return fm.descent - fm.ascent + fm.leading;
}

2、修改如下函数
/**
 * @hide
 */
public int getFontMetricsInt(char[] text, FontMetricsInt fm, int pos, int len) {
    if (text == null || text.length == 0) {
        return super.getFontMetricsInt(fm);
    }
    return getFontMetricsInt(String.valueOf(text) , 0, text.length, fm);
}
```

## [FAQ10881] 数字、日期、时间客制化问题

```
世界各地的风俗和语言习惯不同，其数字、货币、时间、日期、国家名称显示形式也是不尽相同。
Android引入了ICU4C(External)解决了这些国际化的问题，下面列出了常见的客制化的问题。

1、数字、货币
各个国家数字以及数值表示方式不同，如英文2.46，阿拉伯语为٢‎,٤‎٦‎，而俄文却是2，46。如果系统语言为俄文，想要把数字显示成英语格式，按照如下：
NumberFormat inf = NumberFormat. getInstance(new Locale(“en”));
String str = nf.format(2.46);
有关货币、int、percent等类型格式化具体可参考NumberFormat.java

2、时间、日期
关于时间格式化和数字差不多，具体例子如下：
SimpleDateFormat sdf = new SimpleDateFormat(“hh:mm”，new Locale(“en”));
String result = sdf.format(mCalendar.getTime());
SimpleDateFormat sdf = new SimpleDateFormat(“EEEE, MMMM d”，new Locale(“en”));
String result = sdf.format(mCalendar.getTime());

3、其他ICU资源
一些ICU字串，如日期、语言、时区、国家等的翻译在External/icu4c/data/下各个子目录下，常见如：
lang：各种语言对其他语言的翻译,常见地方为Setting的语言列表。
locale：月份、星期、日期、AM/PM等日期相关的翻译。
zone：时区名称定义。
region：地区、国家名称。

如果修改了ICU资源，必须重新编译ICU资源，在Remake工程，否则不会起效果。具体编译方法可以参考：FAQ04011
```

## [FAQ17708] 时区列表中名称无法修改

```
参考  FAQ08718【TimeZone】如何修改时区的显示名称。
修改时区名字后时区列表某些时区没又效果,不过设置中的时区显示已经修改OK.

请将timepicker.java中的
private void addTimeZone(String olsonId) {

//            if (mLocalZones.contains(olsonId)) {
//                mZoneNameFormatter.setTimeZone(tz);
//                displayName = mZoneNameFormatter.format(mNow);
//                Log.d(TAG,"lijinhai addTimeZone  mLocalZones1 displayName="+displayName);
//            } else {
//              }

将IF这个分支全部去掉，直接跑else里面的内容就OK了。
```

## [FAQ17514] [Recovery]Recovery mode FAQ搜寻指南

```
Recovery mode 依据不同问题归类为几个属性标签如下

[Debug/Log]   :debug log , adb 相关问题
[OTAError]      :升级过程报错相关问题
[UI/Key]         : UI 界面与 custom key 配置相关问题
[Otapackage]  : 制作升级包相关问题
[SecureOTA]   : secure boot project 升级相关问题
[FactoryReset]: 恢复出厂设置， 预置资源问题
[Common]      : 典型问题
[升级lk、Preloader]:lk、Preloader升级问题
[Others]         : 其他未分类问题

1.大版本升级相关问题
FAQ18202 [Recovery][Common]Android L ->M版本OTA/T卡升级注意事项
FAQ13472 [Recovery][Common]从KK(4.4)版本通过OTA升级到L(5.0)版本的问题集锦
FAQ11465 [Recovery][OTAError]JB升级到KK在升级界面出现一个警告提示“Warning ,No file_contexts”
FAQ11447 [Recovery][Common]从JB(4.2)版本通过FOTA升级到KK(4.4)版本的注意事项

2.UI 界面与 custom key 配置相关问题
FAQ14484 [Recovery][UI/Key]如何修改L版本recovery mode 小机器人界面进入菜单，由volume up&power改为直接按power(如同KK以前版本)
FAQ13766 [Recovery][UI/Key]L 版本进入recovery mode的方式有改变
FAQ09061 [Recovery][UI/Key]recovery相关按键的配置与客制化
FAQ08110 [Recovery][UI/Key]如何修改recovery mode下字体的大小
FAQ06386 [Recovery][UI/Key]JB2版本关机状态按PowerOn+VolUp键进入RecoveryMode直接显示菜单
FAQ04463 [Recovery][UI/Key]android 4.1版本（Jelly Bean ）后的平台Recovery Mode下直接进入menu 
FAQ03439 [Recovery][UI/Key]如何进入recovery mode立即显示menu菜单

3.升级报错
FAQ18367 [Driver - Recovery] Android M error: Invalid OTA package,missing scatter Installation aborted
FAQ18250 [recovery][common]Android M upgrade occurs “Error: Invalid OTA package, missing scatter”
FAQ14973 [Recovery][OTAError]Adb sideload OTA升级失败报错："E: unknown volume for path [/sideload/pakage.zip]”
FAQ14782 [Recovery][OTAError]L版本开启MTK_SHARED_SDCARD 后OTA包放入内卡如何MOTA升级成功？
FAQ14769 [Recovery][OTAError]L版本OTA升级遇到error："system has been remounted R/W; reflash device to reenable OTA updates"
FAQ11475 [Recovery][OTAError]升级报错"Error: System property does not match"怎么办？
FAQ11106 [Recovery][OTAError]SECURE OTA 升级包里面缺少SEC_VER.txt导致升级失败
FAQ11048 [Recovery][OTAError]从外置SD卡升级过程断电，再升级，无法看到"apply sdcard2:update.zip"提示！
FAQ04471 [Recovery][OTAError]MOTA/FOTA升级失败，怎么办？
 
 
4.升级包制作与签名相关
FAQ12479 [Recovery][Otapackage]为什么制作差分包时未使用-k 选项有时可以升级成功、有时却失败？
FAQ11470 [Recovery][Otapackage]如何制作差分包且正确签名？
FAQ11464 [Recovery][Otapackage]JB升级到KK如何正确编译差分升级包update.zip？
FAQ03534 [Recovery][Otapackage]如何给OTA升级包重新签章
FAQ03441 [Recovery][Otapackage]如何制作和使用OTA（sdcard）升级包
FAQ03440 [Recovery][Otapackage]如何制作user版本的T卡升级包
FAQ02507 [Recovery][Otapackage]如何编译完整升级包
 
5.编译与编译报错问题
FAQ14456 [Recovery][Otapackage]system.img>2G导致编译otapackage时报错如何处理
FAQ14455 [Recovery][Otapackage]打开MTK_CIP_SUPPORT=yes后make otapackage报错KeyError:"/custom"
FAQ10545 [Recovery][Otapackage]The "brom_lite" is not found in the SD card upgrade package for JB9？
FAQ10544 [Recovery][Otapackage]MT6572+ UBIF文件系统build出来的OTA包不含system.img该怎么办？
FAQ07599 [Recovery][Otapackage]./mk otapackage报错总结
FAQ03436 [Recovery][Debug/Log]如何单独 build recovery image
 
6.MTK_SHARED_SDCARD 宏相关问题
FAQ12478 [Recovery][Common]关于打开MTK_SDCARD_SWAP 宏后MTK目前升级方案
FAQ12477 [Recovery][Common]关于打开MTK_SHARED_SDCARD宏后MTK目前升级方案
 
7.恢复出厂设置，预置资源问题
FAQ17418 [Recovery][Build] 预置资源（如apk）到userdata，otapackage之后的userdata.img没有此资源 
FAQ13434 [Recovery][FactoryReset]L 开启MTK_SHARED_SDCARD，恢复出厂设置还能实现keep_list功能吗？
FAQ12384 [Recovery][FactoryReset]不打开Shared sdcard功能，内置SD卡中预制资源，删除资源，恢复出厂设置恢复
FAQ11954 [Recovery][Others]如何实现恢复出厂后不重新启动手机？FAQ10734 [Recovery][FactoryReset]开启了MTK_SHARED_SDCARD之后；恢复出厂设置如何保留预置资源？
FAQ06388 [Recovery][FactoryReset]89 JB2平台上factory reset从LK进入Recovery Mode画面切换有黄条
FAQ05341 [Recovery][FactoryReset]如何避免data分区的.keep_list和.restore_list被意外损坏导致special factory reset不成功
FAQ03437 [Recovery][FactoryReset]special factory reset preserve or restore apk to /data/app
FAQ03434 [Recovery][Others]恢复出厂设置之后如何将时间变为初始值
 
8.Secure boot project 的升级问题
FAQ14751 [Recovery][SecureOTA]L 版本Security OTA升级方法
FAQ11106 [Recovery][OTAError]SECURE OTA 升级包里面缺少SEC_VER.txt导致升级失败
FAQ05739 [Recovery][SecureOTA]OTA升级secutiry device的注意点
FAQ17784 [Recovery][Common]Android M OTA build (Include Security OTA)
 
9.Debug log ,adb 功能相关
FAQ15046 [Recovery][Debug/Log]L版本Recovery Mode打开adb功能
FAQ12130 [Recovery][Common]如何通过adb command 完成自动SD卡升级？
FAQ10547 [Recovery]adb shell df 命令显示的系统分区Size不准确 ？
FAQ09814 [Recovery][Debug/Log]如何在recovery mode下抓取coredump
FAQ08726 [Recovery][Debug/Log]How to enable adb in Recovery Mode
FAQ04559 [recovery][Common]从JB版本开始支持adb sideload命令
FAQ03442 [Recovery][Debug/Log]如何在recovery mode下抓取LOG
 
10.升级包保存或删除问题
FAQ12492 [Recovery][Others]SD卡升级包升级后，如何删除升级包文件？
FAQ10759 [Recovery][Others]MOTA升级成功后想保留OTA升级包该怎么办？
 
11.内外卡,data路径相关问题
FAQ18251 [Recovery][common] Android M Adoptable SD卡无法在recovery mode识别和使用
FAQ17442 [Recovery][Common]Android L和M 版本data加密后升级包放入/data分区如何升级？
FAQ12491 [Recovery][Common]Recovery mode 选择"apply update from sdcard"直接进入data/目录是否正常？
FAQ08109 [Recovery][Common]在recovery mode下同时挂载内置T卡和外置T卡
FAQ05443 [Recovery][Others]从data区读取状态来确定升级用内外置卡导致升级不成功
FAQ04366 [Recovery][Common]JB版本的recovery mode下使用外置T卡升级修改方法
FAQ03432 [Recovery][Common]Recovery mode下mount外置T卡的方法(emmc)

12.重启相关问题
FAQ12481 [Recovery][Others]Recovery mode在cache/recovery目录下新建一支文件，重启后，新建文件消失了
FAQ11015 [Recovery][Others]通过组合键进入recovery模式选择sdcard菜单升级，升级完如何自动重启？
FAQ03431 [Recovery][Others]OTA升级在recovery mode下无法返回normal mode

13.lk、Preloader等分区升级相关问题
FAQ18188 [Recovery][Common]Android M 版本如何升级logo等rawdata分区方法？
FAQ17441 [Recovery][Common]Android M 版本如何升级lk 、preloader ？ 
FAQ12947 [Recovery]Update LOGO&LK&PRELOADER via OTA upgrade

14.其他升级问题
FAQ18467 add selinux policy in OTA
FAQ14482 [Recovery][Others]如何在recovery mode下单独关闭selinux 而不影响normal mode
FAQ04813 [Recovery]使手机设置菜单里的序列号为手机的barcode值
FAQ03435 [Recovery][Common]如何查看手机上的build时间戳
```

## [FAQ12127] 插入俄罗斯SIM卡获取时区不对

```
手机插入俄罗斯SIM卡，发现根据MCC获取的时区不是Moscow，
如KK版本插入俄罗斯卡，发现当前时区是Europe/Kaliningrad，L版本则是Europe/Andorra
[SOLUTION]
这是因为系统在通过MCC获取时区时是先获取sim卡所属国家所有的时区列表，然后把列表的第一个作为返回值。
因为Moscow不是第一位，因此出现上面这种情况，
一般从log中会有这样的下面的关键字打出，
KK版本：
06-03 10:05:27.069   864   864 D GSM     : [GsmSST0] pollStateDone: try to fixTimeZone mcc:250 mccTz:Europe/Kaliningrad
06-03 10:05:27.069   864   864 D GSM     : [GsmSST0] pollStateDone: using default TimeZone
06-03 10:05:27.069   864   864 D GSM     : [GsmSST0] pollStateDone: zone != null zone.getID=Europe/Kaliningrad
Android L：
04-14 05:21:51.436  3596  3596 D GSM     : [GsmSST1] pollStateDone: try to fixTimeZone mcc:250 mccTz:Europe/Andorra zone.getID=Europe/Andorra
04-14 05:21:51.436  3596  3596 D GSM     : [GsmSST1] pollStateDone: using default TimeZone
04-14 05:21:51.436  3596  3596 D GSM     : [GsmSST1] pollStateDone: zone != null zone.getID=Europe/Andorra
这个问题可以修改defaultTimeZoneForMcc返回值解决如下：
MccTable.java alps\frameworks\opt\telephony\src\java\com\android\internal\telephony 
public static String defaultTimeZoneForMcc(int mcc) {
    MccEntry entry;
    entry = entryForMcc(mcc);
    if (entry == null || entry.mIso == null) {
        return null;
    } else {
        Locale locale;
        if (entry.mLanguage == null) {
            locale = new Locale("", entry.mIso);
            Slog.d(LOG_TAG, "defaultTimeZoneForMcc: mcc=" + mcc + ", mIso=" + entry.mIso);
        } else {
            locale = new Locale(entry.mLanguage, entry.mIso);
            Slog.d(LOG_TAG, "updateMccMncConfiguration: mcc=" + mcc +
                                    ", mLanguage=" + entry.mLanguage +
                                    ", mIso=" + entry.mIso);
        }
        String[] tz = TimeZoneNames.forLocale(locale);
        if (tz.length == 0) return null;  
         if(mcc==250) return "Europe/Moscow"；////add this line
        return tz[0];
    }
}
 
Android M: 
/frameworks/opt/telephony/src/java/com/android/internal/telephony/MccTable.java
public static String defaultTimeZoneForMcc(int mcc) {
    MccEntry entry = entryForMcc(mcc);
    if (entry == null) {
        return null;
    }
    Locale locale = new Locale("", entry.mIso);
    String[] tz = TimeZoneNames.forLocale(locale);
    if (tz.length == 0) return null;
    if(mcc==250) return "Europe/Moscow"；////add this line
    return tz[0];
}
```

## [FAQ17902] 如何关闭灭屏时colorFade渐变动画

```
在displayPowerController.java文件updatePowerState函数，将performScreenOffTransition的赋值修改为false
```

## [FAQ19228] [Audio APP] android 7.0 充电提示音无效

```
其实是需要无线充电的时候才会发出声音
 
代码逻辑如下：
这个设定是更改 setting 里面的 Settings.Global.CHARGING_SOUNDS_ENABLED
最后会被 frameworks/base/services/core/java/com/android/server/power/Notifier.java 去检测
private void playWirelessChargingStartedSound() {
    final boolean enabled = Settings.Global.getInt(mContext.getContentResolver(),
    Settings.Global.CHARGING_SOUNDS_ENABLED, 1) != 0; //更改的是 Settings.Global.CHARGING_SOUNDS_ENABLED
    final String soundPath = Settings.Global.getString(mContext.getContentResolver(),
    Settings.Global.WIRELESS_CHARGING_STARTED_SOUND);
    if (enabled && soundPath != null) {
        final Uri soundUri = Uri.parse("file://" + soundPath);
        if (soundUri != null) {
            final Ringtone sfx = RingtoneManager.getRingtone(mContext, soundUri);
            if (sfx != null) {
                sfx.setStreamType(AudioManager.STREAM_SYSTEM);
                sfx.play();
            }
        }
    }
    mSuspendBlocker.release();
}


而这个检测方法是在 PowerManagerService 中被调用的
看逻辑是只在无线充电的时候才会有声音

PowerManagerService.java中updateIsPoweredLocked函数中，
if (dockedOnWirelessCharger) {
    mNotifier.onWirelessChargingStarted();
}
```

## [FAQ19277] [Audio APP] android 7.0 FMRadio 的正确更新方式

```
有客户遇到原生的 FMRadio app 用 install 的方式安装后打开会出现 force close, 查看 log 是加载 library 出错
01-01 04:35:22.406100 12311 12311 E AndroidRuntime: FATAL EXCEPTION: main
01-01 04:35:22.406100 12311 12311 E AndroidRuntime: Process: com.android.fmradio, PID: 12311
01-01 04:35:22.406100 12311 12311 E AndroidRuntime: java.lang.UnsatisfiedLinkError: dlopen failed: library "/system/lib64/libfmjni.so" needed or dlopened by "/system/lib64/libnativeloader.so" is not accessible for the namespace "classloader-namespace"
01-01 04:35:22.406100 12311 12311 E AndroidRuntime: at java.lang.Runtime.loadLibrary0(Runtime.java:977)
01-01 04:35:22.406100 12311 12311 E AndroidRuntime: at java.lang.System.loadLibrary(System.java:1530) 

这是因为安装方式不正确，android 7.0 开始，FMRadio 默认是安装在 system/priv-app/FMRadio/下面，所以如果有开发过程中有验证需求，需要把 FMRadio.apk push 到 system/priv-app/FMRadio/ 下面，然后重启验证。

如果是用 adb install 的方式，会安装到 data/app/ 下面, 不具有加载 system library 的权限
```

## [FAQ19280] 开机后，首次图案解锁失败

```
请如下修改：
/system/gatekeeper/gatekeeper.cpp
uint32_t GateKeeper::ComputeRetryTimeout(const failure_record_t *record) {
    if (record->failure_counter > 0 && record->failure_counter <= 10) {
        if (record->failure_counter % 5 == 0) {
            return 30000;
        }
    } else {
        return 30000;
    }
    return 0;
}
修改成如下：
uint32_t GateKeeper::ComputeRetryTimeout(const failure_record_t *record) {
    if (record->failure_counter > 0 && record->failure_counter <= 10) {
        if (record->failure_counter % 5 == 0) {
            return 30000;
        }
    } else if(record->failure_counter == 0){ //增加了fail次数为0的判断
        return 0;
    } else{
        return 30000;
    }
    return 0;
}
```

## [FAQ19296] 将歌曲设为闹钟铃声，删除该歌曲后，来闹钟后，铃声只响一声，如何修改为正常响很多声？

```
1，问题原因是当mRingtone == null时，未setloop，所以不会循环播放。
2， 修改如下：
AsyncRingtonePlayer.java (packages\apps\deskclock\src\com\android\deskclock)

private static class RingtonePlaybackDelegate implements PlaybackDelegate {

public void play(Context context, Uri ringtoneUri, boolean inCall) {

LogUtils.d(TAG, "lll RingtonePlaybackDelegate Play ringtoneUri="+ringtoneUri,new Exception("callstack"));
if (Looper.getMainLooper() == Looper.myLooper()) {
LogUtils.e(TAG, "Must not be on the main thread!", new IllegalStateException());
}

LogUtils.i(TAG, "Play ringtone via android.media.Ringtone.");

if (mAudioManager == null) {
mAudioManager = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
}

final boolean inTelephoneCall = inCall; //isInTelephoneCall(context);
if (inTelephoneCall) {
ringtoneUri = getInCallRingtoneUri(context);
}

// attempt to fetch the specified ringtone
mRingtone = RingtoneManager.getRingtone(context, ringtoneUri);
// Attempt to enable looping the ringtone.
/// M: if the alarm's uri exists but the real file is missing
if (mRingtone == null
|| !AlarmClockFragment.isRingtoneExisted(context, ringtoneUri.toString())) {
// fall back to the default ringtone
final Uri defaultUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM);
mRingtone = RingtoneManager.getRingtone(context, defaultUri);
}

//该段代码移动如下
try {
mSetLoopingMethod.invoke(mRingtone, true);
} catch (Exception e) {
LogUtils.e(TAG, "Unable to turn looping on for android.media.Ringtone", e); 
// Fall back to the default ringtone if looping could not be enabled.
// (Default alarm ringtone most likely has looping tags set within the .ogg file)
mRingtone = null;
}
//该段代码移动如上

// if we don't have a ringtone at this point there isn't much recourse
if (mRingtone == null) {
LogUtils.i(TAG, "Unable to locate alarm ringtone.");
return;
}
if (Utils.isLOrLater()) {
mRingtone.setAudioAttributes(new AudioAttributes.Builder()
.setUsage(AudioAttributes.USAGE_ALARM)
.setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
.build());
}
// Attempt to adjust the ringtone volume if the user is in a telephone call.
if (inTelephoneCall) {
LogUtils.v("Using the in-call alarm");
try {
mSetVolumeMethod.invoke(mRingtone, IN_CALL_VOLUME);
} catch (Exception e) {
LogUtils.e(TAG, "Unable to set in-call volume for android.media.Ringtone", e);
}
}
mAudioManager.requestAudioFocus(null, AudioManager.STREAM_ALARM,
AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);
mRingtone.play();
}
```

## [FAQ19290] 如何查看TCP Buffer size大小

```
查看:
情况1:log中包含数据连接的过程
A.查看radio_log,搜索关键字setup_data_call,确定default PDP建立连接的时间点.
B.查看sys_log,搜索关键字Setting tx/rx TCP buffers,查看测试时间点或建立数据连接时间点设置的值
 
情况2:netlog中含有dump-networking log,搜索关键字tcp_rmem及tcp_wmem,查看readBuffer及writeBuffer.
提示:只有手动停止mtklog,netlog中才会包含dump-networking log.
 
修改:
文件:DataConnection.java
方法:搜索关键字 TCP_BUFFER_SIZES,会看到根据网络环境设置的各种buffer size,可以根据需要进行修改.
如: private static final String TCP_BUFFER_SIZES_LTE="524288,1048576,2097152,262144,524288,1048576";
表示4G环境下,设置的tcp buffer sizes的值,其中前三个值是readBuffer,后三个值是writeBuffer.
```

## [FAQ19263] 查看热点支持连接数

```
用 grok 在代码中搜索 max_num_sta 即可

alps/kernel-4.9/drivers/staging/wilc1000/host_interface.h	19 #define MAX_NUM_STA	9 macro 

1. find out the file( /data/misc/wifi/hostapd.conf ), in hotspot device;

P:/data/misc/wifi/softap.conf

2. find out the key (max_num_sta), the valuse of the key is the hotspot's capability.

forexample:
if the max_num_sta equal 8, so the hotspot's capability can support 8 stations at the same time.
```

## [FAQ11035] 如何通过USB接口抓UART log

```
M版本以及以后的版本不再支持此Feature！
 
目前6572和6582 之后平台可以使用USB线抓取UART log，具体的操作方法如下

[SOLUTION]
L 版本：
步骤1.请打开如下两个宏：

preloader：
alps/bootable/bootloader/preloader/platform/$platform/default.mk
CFG_USB_UART_SWITCH

kernel:
alps/kernel-3.10/arch/arm/configs/xxx_defconfig
CONFIG_MTK_UART_USB_SWITCH

步骤2. enable from engineer mode
输入*#*#3646633#*#*
Hardware -> UART/USB Switch ->进去可以切换mode

注意：
1.切换前不能插入cable
2.DP ->TX ; DM -> RX
3. 连线需要连UART线，不能连USB线

L以前版本：
6572 6571平台：
在 Mediatek/custom/<proj>/preloader/inc/cust_bldr.h 里将 CFG_USB_UART_SWITCH 宏打开
6582 6592平台：
Mediatek/custom/<proj>/preloader/cust_bldr.mak里将 CFG_USB_UART_SWITCH 宏打开，

具体代码您可以参考alps/mediatek/platform/mt6582/preloader/src/drivers/Platform.c的platform_pre_init（）函数~
```

## [FAQ18106] 如何将ATF log输出到uart？

```
ATF启动后，只有开始部分log有吐到uart，后面就仅仅放在ATF log buffer里，由mtklogger收集。
有些情况下需要看ATF log，而无法通过mtklogger查看，就需要通过uart查看了，下面给出在ATF打开uart log的方法。
 
修改位置在：
L版本 : vendor/arm/atf-1.0/bl31/bl31_main.c
M版本 : vendor/mediatek/proprietary/trustzone/atf/v1.0/bl31/bl31_main.c
里的bl31_main()里的clear_uart_flag()注释掉即可：
void bl31_main(void) {
    ......
#ifndef SVP3_ENABLE
    bl31_prepare_next_image_entry();
#else
    bl31_prepare_kernel_entry(1); // prepare 64 bits kernel directly
#endif
    printf("[BL31] Final dump!\n\r");
    //clear_uart_flag(); //这行注释掉
    printf("[BL31] SHOULD not dump in UART but in log buffer!\n\r");
}
```

## [FAQ06190] 默认打开自动更新时间

```
Q：进入设置——》日期和时间——》自动确定日期和时间，现自动确定日期和时间默认为关闭，需要改为默认是：使用网络提供时间 。该如何修改？
A：请修改
defaults.xml (alps\frameworks\base\packages\settingsprovider\res\values)
<bool name="def_auto_time">false</bool> //将false改为true (可能默认就是true)

如果是CMCC定制的项目,请修改
defaults.xml(alps\vendor\mediatek\proprietary\operator\OP01\packages\apps\Plugins\res\values)
<bool name="def_auto_time_op01">false</bool> //将false改为true
 
默认打开后,不一定能自动更新时间,因为这个需要网络环境支持NITZ自动更新才能成功.
```

## [FAQ08879] [SIM]如何获取卡对应的plmn

```
获取卡对应的plmn 

plmn 由MCC MNC组成
MCC全称是Mobile Country Code，3位数组成，用户不同国家的一个识别码；
MNC全称是Mobile Network Code，不同运营商的MNC有区别(MNVO除外)，2位或者3位，这个长度是存放在IccCard的EF_AD当中。

MCC/MNC是从IccCard中读取出来的.以sim卡为例，SIMRecords.java读取，属于Phone 进程的模块。
除了Phone进程，其他应用要获取MCC/MNC不能直接到SIMRecords.java中拿。
所以有考虑到这一点，在读取出mcc/mnc时将其保存，PhoneInterfaceManager.java有提供接口给其他进程呼叫。
L & M & N 版本:
TelephonyManager.java           public String getSimOperator(long subId);

L之前的版本:
TelephonyManager.java           public String getSimOperator(int simId);

使用方法:
try{
    ITelephony tel = ITelePhone.Stub.asInterface(ServiceManager.getService(Context.TELEPHONY_SERVICE));
    String MccMnc = null;
    if(tele != null) {
        //L & M & N 版本
        MccMnc = tel.getSimOperator(subId);
        //L 之前的 版本
        MccMnc = tel.getSimOperator(simId);
    }
}catch (RemoteException ex){
}
PS: 如果只取Mcc的话，MccMnc.subString(0,3)即可
```

## [FAQ19143] Android N common版本上中文英文字串网址识别错误

```
Android N上，接收短信时，如果收到的内容有中文和网址时，网址匹配不正确。例如：带有网址和中文时，中文和网址全部带有下划线，中文www.baidu.com中文，整个都会有下划线，需要改成只有www.baidu.com有下划线。Google原生的WEB_URL Pattern都是follow RFC spec定义的，建议不要修改，如果必须要改，可参照下面的solution. 此修改不影响CTS测项，但可能对其它Unicode URL的匹配有影响(如果是Android N之前的版本请参考FAQ13616)。

vendor/mediatek/proprietary/frameworks/base/packages/FwkPlugin/src/com/mediatek/op/util/DefaultPatterns.java

package com.mediatek.op.util;

import android.util.Patterns;
import android.util.Log;

import com.mediatek.common.PluginImpl;
import com.mediatek.common.util.IPatterns;
import com.mediatek.common.util.IPatterns.UrlData;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
* Customize the web URL parsing.
*
*/
@PluginImpl(interfaceName = "com.mediatek.common.util.IPatterns")
public class DefaultPatterns implements IPatterns {
    private static final String TAG = "DefaultPatterns";

    // The regular expressions for filtering out bad url starting and ending
    private static final String mValidCharRegex = "a-zA-Z0-9\\-_";
    // First group: Find the invalid url characters before "xxxx:// or xxx.".
    // Second group: "xxxx:// or xxx."
    private static final String mBadFrontRemovingRegex = String.format(
            "(^[^.]*[^%s.://#&=]+)(?:[a-zA-Z]+://|[%s]+.)", mValidCharRegex, mValidCharRegex);
    // First group: Find the top level domain, ex:".xxx".
    // The ending ")" is for google map url, which may end with a coordinate,
    // ex:"(32.012345, 118.54321)"
    // Second group: The rest characters after the TLD to the end of the string,
    // except some special character may appear in url, ex: "./?=&%"
    private static final String mBadEndRemovingRegex = String.format(
            "([\\.\\:][%s)]+[/%s]*)([\\.\\:]?[^%s\\.\\:\\s/]+[^\\.=&%%/]*$)",
            mValidCharRegex, mValidCharRegex, mValidCharRegex);

    // Helper function for exgular expression group replacing.
    private static final String replaceGroup(String regex, String source, int groupToReplace,
             String replacement) {
             return replaceGroup(regex, source, groupToReplace, 1, replacement);
    }

    // Helper function for exgular expression group replacing.
    private static final String replaceGroup(String regex, String source, int groupToReplace,
             int groupOccurrence, String replacement) {
             Matcher m = Pattern.compile(regex).matcher(source);
             for (int i = 0; i < groupOccurrence; i++) {
                      if (!m.find()) {
                               return source;
                      }
              }
             return new StringBuilder(source).replace(m.start(groupToReplace), m.end(groupToReplace),
                       replacement).toString();
    }

    @Override
    public UrlData getWebUrl(String urlStr, int start, int end) {
              Log.d("@M_" + TAG, "getWebUrl, " + urlStr + " start=" + start + " end=" + end);
              if (urlStr != null) {
                       /// Filter out invalid characters at the begin of the url
                       Pattern p1 = Pattern.compile(mBadFrontRemovingRegex);
                       Matcher m1 = p1.matcher(urlStr);
                       if (m1.find()) {
                                 urlStr = replaceGroup(mBadFrontRemovingRegex, urlStr, 1, "");
                                 start = end - urlStr.length();
                        }

                       /// Filter out invalid characters at the end of the url
                       Pattern p2 = Pattern.compile(mBadEndRemovingRegex);
                       Matcher m2 = p2.matcher(urlStr);
                       if (m2.find()) {
                                  urlStr = replaceGroup(mBadEndRemovingRegex, urlStr, 2, "");
                                  end = start + urlStr.length();
                        }
               }
               Log.d("@M_" + TAG, "getWebUrl, return: " + urlStr + " start=" + start + " end=" + end);
               return new UrlData(urlStr, start, end);
    }

    @Override
    public int getPatternType() {
               return PATTERN_CHINA;
    }
}
```

## [FAQ19188] 3G常用feature支持情况在log中查看方法

## [FAQ19211] [Android5.1]开机动画desc.txt描述文件分析

```
1、desc.txt文件格式分析
desc.txt文件由若干行组成，每一行代表一种描述。下面以一个具体的例子为例，具体说明

480 640 20 
p   1   0    folder1 
p   2   20  folder2 
c   0   0    folder3 
c   1   0    folder4 

  1行用来描述开机动画在屏幕显示的大小及速度。具体为：开机动画的宽度为480个像素，高度为640个像素，显示频率为每秒20帧，即每帧显示1/20秒。
  下面的每一行代表一个片段，显示的时候会按照顺序从上到下依次显示。第1个字符为片段类型，有'c'和'p'两种，两者的区别后面会结合代码说明。
  2个数字为该片段重复显示的次数，如果为‘0’，表示会无限重复显示；第3个数字为两次显示之间的间隔，单位为第一行中定义的每帧显示的时间；第4个字符串为该片段所在的文件夹，一个片段可以由多个png图片组成，都存放在folder文件夹中。
“p 1 0 folder1”-------代表该片段显示1次，与下一个片段间隔0s，该片段的显示图片路径为bootanimation.zip/folder1。
“p 2 20 folder2”--------代表该片段显示2次，且两次之间显示的间隔为20*(1/20)=1s，与下一个片段间隔20*(1/20)=1s，该片段的显示图片路径为bootanimation.zip/folder2。
“c 0 0 folder3”-------代表该片段无限循环显示，且两次显示的间隔为0s，与下一个片段间隔0s，该片段的显示图路径为bootanimation.zip/folder3。
“c 1 10 folder4”--------代表该片段显示1次，显示后暂停10*(1/20)=0.5s，该片段的显示图路径为bootanimation.zip/folder4。


2、"p"片段和“c”片段的区别
  在早期Android版本中只有“p”片段，且movie()中的显示代码如下：
for (int i=0 ; i<pcount && !exitPending() ; i++) { 
  const Animation::Part& part(animation.parts[i]); 
  const size_t fcount = part.frames.size(); 
  glBindTexture(GL_TEXTURE_2D, 0); 

  for (int r=0 ; !part.count || r<part.count ; r++) { 
       for (int j=0 ; j<fcount && !exitPending(); j++) { 
            const Animation::Frame& frame(part.frames[j]); 
            ....... 

} 

  里面的主要参数和函数说吗如下：
pcount---显示片段的数量，比如上面的例子，pcount=4
p.count---该片段的重复显示次数。
fcount---该片段中png图片的数量
exitPending()---如果SurfaceFlinger服务通知bootanimation停止显示动画，则该函数返回值为true，否则为false。
  第一个for循环用于顺序显示所有片段，第二个for循环用于重复显示该片段，第三个for循环用于顺序显示该片段中所有的png图片。
  分析代码，可知：若exitPending()返回值为true，即SurfaceFlinger服务要求bootanimation停止显示动画，则不管当前显示到哪个片段或png图片，都会导致退出for循环，从而停止开机动画的显示。
  在Android5.1中，加入了“c”片段。对与以"c"标识的片段，即使exitPending()返回值为true，也会继续显示。
我们分析一下源码，首先看一下movie()中解析desc.txt的代码：

// Parse the description file 
for (;;) { 
...... 
if (sscanf(l, "%d %d %d %d", &width, &height, &fps, &flg) >= 3) { 
  animation.width = width; 
  animation.height = height; 
  animation.fps = fps; 
} 
else if (sscanf(l, " %c %d %d %s #%6s", &pathType, &count, &pause, path, color) >= 4) { 
  Animation::Part part; 
  part.playUntilComplete = pathType == 'c'; 
  part.count = count; 
  part.pause = pause; 
  part.path = path; 
  part.audioFile = NULL; 
  if (!parseColor(color, part.backgroundColor)) { 
        ALOGE("> invalid color '#%s'", color); 
        part.backgroundColor[0] = 0.0f; 
        part.backgroundColor[1] = 0.0f; 
        part.backgroundColor[2] = 0.0f; 
  } 
  animation.parts.add(part); 
} 
  s = ++endl; 
} 
  可以看到，如果pathType==‘c’，part.playUntilComplete等于true，否则为false。接着，看一下显示代码：
for (size_t i=0 ; i<pcount ; i++) { 
  const Animation::Part& part(animation.parts[i]); 
  const size_t fcount = part.frames.size(); 
  glBindTexture(GL_TEXTURE_2D, 0); 

  for (int r=0 ; !part.count || r<part.count ; r++) { 
        // Exit any non playuntil complete parts immediately 
        if(exitPending() && !part.playUntilComplete) 
              break; 
  ...... 

        for (size_t j=0 ; j<fcount && (!exitPending() || part.playUntilComplete) ; j++) { 
        ...... 
        checkExit(); 
  } 
  usleep(part.pause * ns2us(frameDuration)); 
  // For infinite parts, we've now played them at least once, so perhaps exit 
  if(exitPending() && !part.count) 
        break; 
  } 
  ...... 
} 
  可以看到，如果exitPending()返回值为true且part.playUntilComplete=false，则会break。即：当SurfaceFlinger服务要求bootanimation停止显示动画时，以‘p’标识的片段会停止，而以'c'标识的片段会继续显示。这就是两者之间的主要区别。
  这里有个问题：重复循环显示的'c'标识片段，会不受任何约束的一直显示下去，这显然是不合适的。
于是在第二个for循环体最后，有如下代码：

// For infinite parts, we've now played them at least once, so perhaps exit 
if(exitPending() && !part.count) 
  break; 
意思是，如果检测到SurfaceFlinger服务要求bootanimation停止显示，且该片段的显示次数为'0'，即重复循环显示，则会break停止显示。

  估计"c"标识的意思是continue，即：即使SurfaceFlinger要求bootanimation停止动画，bootanimation也不会立刻停止动画，它会等c标识片段都显示完毕后，再停止。
这样，我们可以利用'c'和'p'片段的区别，设计出更灵活的开关机动画。

[FAQ03051] 非运营商定制项目如何客制化自己的开关机动画、开关机铃声
```

## [FAQ17334] [SIM_ME_LOCK]MCCMNC锁卡失败

```
如果锁卡的目标合法MCC-MNC是:738002,可是锁卡后目标卡(即738002的卡)进不到待机界面。(提示:Enter NP/SP等等Code，输入正确密码后才能进入)。但是使用中国移动(46000)或是中国联通(46001)等MCC-MNC是5位的卡测试，锁网功能正常。 

这个现象是这些特殊卡的EF_AD中没有指定MNC的长度造成的。

  
[SOLUTION]
MCC-MNC 长度 = mcc_length + mnc_length;
mcc_length : 固定是3。
Mnc_length : 与SIM卡有关，2 或 3，初始值为0，mnc_length 是在SIM卡初始化时从 EF_AD 第四个字节获取，有效值是2 或 3;

当 EF_AD 第四个字节无效时，mnc_length = 0；匹配失败，导致锁卡失败。

所以，当SIM 卡 EF_AD 第四个字节无效，没有写 mnc_length 时，确保锁卡MCC-MNC为5位或6位都有效的方法：

确保 SML_MNC_LENGTH_NEST 的值为 1，并修改 sml_GetCode 为如下：

kal_uint8 sml_GetCode( sml_cat_enum cat, 

kal_uint8 * imsi, 

kal_uint8 * gid1, 

kal_uint8 * gid2, 

kal_uint8 sim_mnc_len,

kal_uint8 * pdata,

kal_uint8 * code) 
{ 
     kal_uint8 mnc_len=0;

     if (SML_MNC_LENGTH_NEST == 1)     //Get mnc length from SIM 
     {
         if ((sim_mnc_len == 2) || (sim_mnc_len == 3)) 
         { 
            mnc_len = sim_mnc_len; 
         } 
         else
         { 
            if(((*(pdata+2)) & 0x0F) == 0x0F) 
            { 
                 mnc_len = 2; 
            } 
            else
            { 
                 mnc_len = 3; 
            } 
         } 
     } 
     else      //Get mnc length from NVRAM 
     { 
         if(((*(pdata+2)) & 0x0F) == 0x0F) 
         { 
             mnc_len = 2; 
         } 
         else
         { 
             mnc_len = 3; 
         } 
     } 
     return sml_Catcode(cat, imsi, gid1, gid2, mnc_len, code); . 
} 
```

## [FAQ12867] [SIM]如何读取SIM卡的EFspn

```
获取SPN值有两种方法：
第一种：通过保存开机时上报的spn值。
因为MMI operator string 显示的时候会用到，所以默认已经会在开机时报给MMI 了
PRT_MSG_ID_MMI_CPHS_MMI_INFO_IND
srv_nw_name_cphs_mmi_info_ind_hdlr
srv_nw_name_cphs_mmi_info_ind_hdlr_int
msg->spn 里有带SPN 的值，直接保存这个值。
第二种：用SIM access 的API 去获得SPN。
1）MMI_BOOL srv_sim_get_file_info(
        U16 file_index,
        U8 *file_path,
        mmi_sim_enum sim_id,
        SrvSimCallbackFunc callback,
        void *user_data)
获取SIM file 大小等信息 ，file_index ：FILE_SPN_IDX  callback 函数 是获得了SIM file info之后会被call 到
参数 的structure(srv_sim_file_info_struct *)param->data
然后实现call back 函数：主要去做的是 根据获得了file size ，再去读具体的SIM file 的内容。
2）MMI_BOOL srv_sim_read_binary(
        U16 file_index,
        U8 *file_path,
        U16 offset,
        U16 length,
        mmi_sim_enum sim_id,
        SrvSimCallbackFunc callback,
        void *user_data)
调用这个去读SIM file 的内容 ，其中file_index FILE_SPN_IDX   ，length ：用之前第一步获得的file size

注意：
srv_sim_read_record  ： 用于读取SIM file 类型是 linear fixed 或者 cyclic  的sim 文件 ，即 文件的存储内容是一条一条的record 的，每条record 大小一样。例如EFsms 存sms 的sim file
srv_sim_read_binary ：用于读取SIM file 类型是 transparent 的sim 文件即 文件的存储内容 没有record ，只是连续的一串data 。 像SPN就是transparent 的type
SIM file 的类型 ，及数据内容各个byte 的含义 都可以在Spec 里找到，可以在网上down到ETSI 51.011
```

## [FAQ10433] [SEC]修改SIM ME lock解锁码与IMEI号保持对应关系

```
有运营商需求，SIM ME LOCK的解锁码由手机的IMEI根据一个算法动态计算而来.

默认SIM ME LOCK的解锁码是由modem 配置固定的，无法根据IMEI来动态设置modem的密码，那么这个部分就需要客制化。

建议客制化的做法如下:

Modem 端原始密码继续按照文档doc进行锁网配置；
AP 端用户密码需要用IMEI 经过一个算法计算后得到一个新密码；
AP 端用户输入这个新密码后，再通过算法解密，判断密码是否有效，有效则用原始密码发给Modem进行解锁；
这种方案相当于AP 端解锁密码界面处理多了一步算法处理。

AP端处理密码的部分:
1. 这个和IMEI 有关系的解密部分，还是要贵司自行完成
a. 如何获取对应卡槽的IMEI，请参考FAQ02913 如何获取IMEI号

解密的code可以添加在如下位置

L 版本:

alps\frameworks\base\packages\keyguard\src\com\mediatek\keyguard\telephony\KeyguardSimPinPukMeView.java

//CheckSimMe.run()
mResult = ITelephonyEx.Stub.asInterface(ServiceManager.getService("phoneEx"))

.supplyNetworkDepersonalization(subId, mPasswd);

//其中的mPasswd 就是从界面上输入的数字

KK版本alps\frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\KeyguardSimPinPukView.java 
//CheckSimMe.run()
mResult = ITelephonyEx.Stub.asInterface(ServiceManager.checkService("phoneEx")).supplyNetworkDepersonalization(mPasswd, mSimId);

//其中的mPasswd 就是从界面上输入的数字

解密的code 请在执行supplyNetworkDepersonalization() 之前进行

解密完之后确认密码正确，则将原始密码作为参数mPasswd 传入

另外对输入的数字有一个判断函数，目前只允许输入8个，而贵司输入IMEI计算后的密码如果超过8个数字则不符合spec要求，
请参考FAQ12171 [SEC]锁网密码允许输入超过8个数字
```

## [FAQ03693] [AT Command][SIM]如何用AT命令修改PIN

```
如何用AT命令修改PIN

1. 请用AT+CPWD修改PIN,要在enable PIN的情况下，才能修改PIN，所以要先用AT+CLCK enable PIN。
参考以下步骤：
AT+CLCK="SC",1,"1234"                //enable PIN，此操作需要PIN
AT+CPWD="SC","1234","1111"       //修改PIN

2. 如果需要disable PIN，那么需要先下AT+CPIN verify，再进行disable。
参考如下步骤：
AT+CPIN="1111"
AT+CLCK="SC",0,"1111"                     //disable PIN
```

## [FAQ19185] android N 后无法读取个别 system property 说明.

```
某个system property 明明已经写入成功, 但是通过adb 无法读取到, 或者某个程序无法读取到.

其原因是android N 版本上, Google 对System Property 的流程做了大的调整, 其中最大的影响就是对读取 system property 也做了限制, 统一由SELinux 来操作控制. 根据SELinux Context 分割成多个互不关联的buffer trie/binary tree structure. 这些buffer 统一采用mmap 的搭建, 而对应mmap 的file 都放在 /dev/__properties__. 通常SELinux Context 都是按照system property 前缀划分的, 可以审查property_contexts 来查看. 
因为system property 太多, Google 并且这样的改动, 导致原本get prop 没有权限限制而都有了权限限制, 为了使得影响尽可能减小, Google 又对原本的system property 进行了划分. 除ctl.* 的控制属性之外, 常见的有:

Google 默认:

property_type : 是property 最基本的attribute, 定义时都必须包含.

core_property_type: 系统基本property, 每个进程都可以访问的property.  //domain.te get_prop(domain, core_property_type)

log_property_type: Log 类型的property, 每个进程都可以访问的property. //get_prop(domain, log_property_type)

MTK 新增:

mtk_core_property_type: mtk 系统基本property, 每个进程都可以访问的property. //get_prop(domain, mtk_core_property_type)

特别注意的是, get prop 访问失败时, 不会有SELinux 提示, 因为Google 在domain.te 里面添

dontaudit domain property_type:file audit_access;

为了大家好统一撰写SELinux Policy, Google 定义了两个macro.  即get_prop 和 set_prop 


[SOLUTION]

如果你的system property 不涉及什么私密信息, 你就直接在定义你的prop 的SELinux type 时, 加一个core_property_type, 这样每个进程都可以看到. 如果比较私密, 那么对应要查看的process , 则要使用get_prop 宏添加SELinux 权限.

然后最后提醒一点, get prop 读取不出来, 没有任何的异常的SELinux 打印.
```

## [FAQ02917] [SEC]SIM ME LOCK(锁网/锁卡)功能介绍和使用

```
做SIM-ME Lock 相关feature开发，请先参考DCC文档《SIM-ME Lock For Customer》 和《SIM_ME_Lock宝典》。
```

## [FAQ12103] [SEC]AP端怎样实现锁卡功能可无限次输入错误密码

```
实现这个功能需要在AP和modem同时做修改。
一、Modem端:
将sml_verify()函数中的如下代码注释掉之后make new重新编译：
meta->retry_count--;

二、AP 端:
除了modem端的修改，还需要在AP的UI显示做修改。

L 版本上:
Path: alps\frameworks\base\packages\keyguard\src\com\android\keyguard\KeyguardUpdateMonitor.java
public void minusSimMeLeftRetryCountOfPhoneId(int phoneId) {
    int simMeRetryCount = mSimMeLeftRetryCount.get(phoneId) ;
    if (simMeRetryCount > 0) {
        //mSimMeLeftRetryCount.put(phoneId, simMeRetryCount - 1);  //去掉减1动作， 改为:
        mSimMeLeftRetryCount.put(phoneId, simMeRetryCount);
    }
}

KK版本:
收到卡被SIM ME LOCK住时才会去获取对应Category的retry count, 并记录在数组mSimMeLeftRetryCount中。
每输入一次错误密码，都会调用minusSimMeLeftRetryCount()来减少次数。
修改如下：
Path: alps\frameworks\base\packages\keyguard\src\com\android\keyguard\KeyguardUpdateMonitor.java
public void minusSimMeLeftRetryCount(int simId) {
    if (mSimMeLeftRetryCount[simId] > 0 ) {
      //注释 mSimMeLeftRetryCount[simId]--;
    }
}
关于界面上次数的显示如果也要同步修改
请参考FAQ10495 [SEC]如何在AP端修改SIM ME LOCK输入密码次数
```

## [FAQ19165] [SEC]初次进入PIN/PUK校验界面显示PIN/PUK Retry剩余次数

```
需要修改文件位于
/frameworks/base/packages/Keyguard/src/com/mediatek/keyguard/Telephony/KeyguardSimPinPukMeView.java
修改代码如下：
public void resetState(boolean forceReload) {
    ......
    if (simState == IccCardConstants.State.PIN_REQUIRED) {
        msg = rez.getString(R.string.kg_sim_pin_instructions_multi, displayName);

        //for PIN
        msg += "Remaining Attemps: " + getRetryPinString(mPhoneId);
        mUnlockEnterState = STATE_ENTER_PIN;
    } else if (simState == IccCardConstants.State.PUK_REQUIRED) {
        msg = rez.getString(R.string.kg_puk_enter_puk_hint_multi, displayName);

        //for PUK
        msg += "Remaining Attemps: " + getRetryPuk(mPhoneId);
        mUnlockEnterState = STATE_ENTER_PUK;
    }
    ......
}
```

## [FAQ02916] [Common]如何判断sim卡是否有插入

```
M版本：
PhoneInterfaceManager.java里面有提供hasIccCardUsingSlotId 方法；

使用方法如下：
import com.android.internal.telephony.ITelephony;

final ITelephony iTel=ITelephony.Stub.asInterface(ServiceManager.getService(“phone”));
boolean isSimInsert = false;
try {
    if (iTel != null) {
        isSimInsert = iTel.hasIccCardUsingSlotId(slotId);
    }
} catch (RemoteException e) {
    e.printStackTrace();
    isSimInsert = false;
}

L版本：
PhoneInterfaceManagerEx.java里面有提供hasIccCard方法；
使用方法如下：
import com.mediatek.internal.telephony.ITelephonyEx;

final ITelephonyEx phoneEx=ITelephony.Stub.asInterace(ServiceManager.checkSetvice(“phoneEx”));
if(phoneEx!=null){
// slotId: PhoneConstants.SIM_ID_1, PhoneConstants.SIM_ID_2
long subId=getSubIdBySlot(slotId);
boolean isInsert= phoneEx. hasIccCard (subId);
}

KK版本：
PhoneInterfaceManagerEx.java里面有提供hasIccCard方法；
使用方法如下：
import com.mediatek.common.telephony.ITelephonyEx;

final ITelephonyEx phoneEx=ITelephony.Stub.asInterace(ServiceManager.checkSetvice(“phoneEx”));
if(phoneEx!=null){
boolean isInsert= phoneEx. hasIccCard (slotId);
}

KK之前的版本：
PhoneInterfaceManager.java里面有提供isSimInsert方法；
使用方法如下：
import com.android.internal.telephony.ITelephony;

final ITelephony phone=ITelephony.Stub.asInterace(ServiceManager.checkSetvice(“phone”));
if(phone!=null){
boolean isInsert=phone.isSimInsert(slotId);
}
```

## [FAQ02914] [Common]如何获取IMSI号

```
IMSI（International Mobile SubscriberIdentification Number）国际移动用户识别码
是区别移动用户的标志，储存在SIM卡中。
请参看 TelephonyManagerEx.java 里面的方法getSubscriberId().
例如：
L版本、以及以后版本：
TelephonyManagerEx mTelephonyMgr = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE_EX);
if (mTelephonyMgr != null) {
    String sim1IMSI = mTelephonyMgr.getSubscriberId(PhoneConstants.SIM_ID_1);
    String sim2IMSI = mTelephonyMgr.getSubscriberId(PhoneConstants.SIM_ID_2);
}

KK及之前版本：
String imsi = "";
TelephonyManagerEx mTelephonyMgr = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE_EX);
if (mTelephonyMgr != null) {
    String sim1IMSI = mTelephonyMgr.getSubscriberId(PhoneConstants.GEMINI_SIM_1);
    String sim2IMSI = mTelephonyMgr.getSubscriberId(PhoneConstants.GEMINI_SIM_2);
}
```

## [FAQ02913] [Common]如何获取IMEI号和MEID号

```
IMEI号是GSM的概念，CDMA对应的是MEID号。

IMEI（International Mobile Equipment Identity）是国际移动设备身份码，目前GSM/WCDMA/LTE手机终端需要使用IMEI号码。在单卡工程中一个手机对应一个IMEI号；双卡工程中一张卡对应一个IMEI号，双卡共有两个IMEI号。

MEID (Mobile Equipment Identifier) 移动设备识别码，是CDMA手机的唯一身份识别码。

 

通过GSMPhone对象来调用getDeviceId()函数，获取到的就是IMEI号。

通过CDMAPhone对象来调用getDeviceId()函数，获取到的就是MEID号。

 

一、如何获取IMEI号

M0.mp7/M0.mp9版本（包含C2K和非C2K项目）、

M0.mp1版本非C2K项目、

L版本非C2K项目上：

GSMPhone.java中的getDeviceId()

L上面已经没有GeminiPhone；

使用方法如下：

Phone mPhone1=PhoneFactory.getPhone(PhoneConstants.SIM_ID_1);

Phone mPhone2=PhoneFactory.getPhone(PhoneConstants.SIM_ID_2);

 

if (mPhone1 != null) {

    String imei_sim1 =  mPhone1.getDeviceId();

}

if (mPhone2 != null) {

    String imei_sim2 =  mPhone2.getDeviceId();

}

 

M0.mp1版本C2K项目、

L版本C2K项目上：

L版本C2K项目上，一张卡同时对应一个CDMAPhone和一个GSMPhone，要获取对应卡的IMEI号，需要先获取到对应的GSMPhone对象，具体可以通过下面的方法来获取：

    SIM1-> CDMAPhone = PhoneFactory.getPhone(0).getNLtePhone()

    SIM1-> GSMPhone = PhoneFactory.getPhone(0).getLtePhone()

    SIM2->  CDMAPhone = PhoneFactory.getPhone(1).getNLtePhone()

    SIM2->  GSMPhone = PhoneFactory.getPhone(1).getLtePhone()

 

获取到GSMPhone对象后，通过该对象来调用getDeviceId()函数。

 

KK版本上：

GSMPhone.java    中getDeviceId()

GeminiPhone.java 其中getDeviceIdGemini()已经没有了，而getDeviceId()获取的是default phone的IMEI；

所以直接使用GSMPhone.java中getDeviceId()方法； 

Demo code:

GeminiPhone mGeminiPhone;

String imei_sim1=mGeminiPhone.getPhonebyId(PhoneConstants.GEMINI_SIM_1).getDeviceId();

String imei_sim2=mGeminiPhone.getPhonebyId(PhoneConstants.GEMINI_SIM_2).getDeviceId();

 

KK之前的版本：

下面是获得IMEI号的接口和demo code

API：

GSMPhone.java     中getDeviceId()

GeminiPhone.java  中getDeviceId() 和 getDeviceIdGemini()

 

Demo code:

import com.android.internal.telephony.Phone;

import com.android.internal.telephony.gemini.GeminiPhone;

import com.android.internal.telephony.PhoneFactory;

Phone phone;

phone = PhoneFactory.getDefaultPhone();

String  imei=(GeminiPhone)phone.getDeviceId();

 

GeminiPhone mGeminiPhone;

String imei_sim1 = mGeminiPhone.getDeviceIdGemini(PhoneConstants.GEMINI_SIM_1);

String imei_sim2 = mGeminiPhone.getDeviceIdGemini(PhoneConstants.GEMINI_SIM_2);

 

二、如何获取MEID号

M0.mp7/M0.mp9版本C2K项目：

通过CDMAPhone.java的getDeviceId()函数来获取。

请在插入电信卡的情况下调用，避免插入非电信卡没有创建CDMAPhone对象，会获取不到。

 

M0.mp1版本C2K项目、

L版本C2K项目上：

参考上面的说明，要获取MEID号，需要先获取对应卡的CDMAPhone对象，具体可以通过下面的方法来获取：

    SIM1-> CDMAPhone = PhoneFactory.getPhone(0).getNLtePhone()

    SIM1-> GSMPhone = PhoneFactory.getPhone(0).getLtePhone()

    SIM2->  CDMAPhone = PhoneFactory.getPhone(1).getNLtePhone()

    SIM2->  GSMPhone = PhoneFactory.getPhone(1).getLtePhone()

 

获取到CDMAPhone对象后，通过该对象来调用getDeviceId()函数。

 

如果电信卡插在卡1上，则使用上面SIM1的方法来获取卡1的CDMAPhone对象。

如果电信卡插在卡2上，则使用上面 SIM2 的方式来获取卡2的CDMAPhone对象。

 

如果同时插入两张电信卡，由于同一时刻只支持一张电信卡，则只有主卡可以获取到MEID号，可以通过PhoneFactory.getDefaultPhone().getNLtePhone() 来获取主卡的CDMAPhone对象。
```

## [FAQ19109] [Audio Framework] Soundpool java 类的使用说明

```
app 层在使用 soundpool java 类时，通常会用到以下几个方法：
Soundpool sp = new SoundPool(x,x,x); //new 一个实例
sp.load(x,x,x,x);//加载对应的音源
sp.play(x,x,x,x,x,x); //播放对应的音源
 
然而当上述方法调用之后，在 native 层其实会有一些 memory 被 native 的 soundpool 类所 cache 住
如果 app 在使用上述三个方法之后，不调用相关的释放 native 资源的方法
就会造成 native 的 memory leak.
 
所以 app 在使用完 soundpool 之后，一定要记得调用 soundpool 的 release 接口
sp.release();
release 接口调用的次数要等同于new soundpool 的次数，这样才不会造成内存泄漏
像其它 MediaPlayer, AudioTrack,ToneGenator java 类的使用也是一样的，在用完后必须调用其 release 接口
 
FAQ:
soundpool 在调用 release 之前是否需要调用 unload 接口去 unload 前面所 load 的资源呢？
==》答案是否定的，在 release 接口被调用的时候会统一做 unload 资源的动作，因此release 之前无须逐一去 unload 所加载的资源
```

## [FAQ02911] [Common]如何判断是usim卡还是sim卡

```
L版本、及以后版本：
参见PhoneInterfaceManagerEx.java中的getIccCardType()方法；

import com.mediatek.internal.telephony.ITelephonyEx;

final ITelephonyEx mTelEx = ITelephonyEx.Stub.asInterface(ServiceManager.getService("phoneEx"));
// slotId: PhoneConstants.SIM_ID_1, PhoneConstants.SIM_ID_2
long subId=getSubIdBySlot(slotId);
if(mTelEx!=null)String Type = mTelEx.getIccCardType(subId);

KK版本：
参见PhoneInterfaceManagerEx.java中的getIccCardType()方法；

import com.mediatek.common.telephony.ITelephonyEx;
final ITelephonyEx mTelEx = ITelephonyEx.Stub.asInterface(ServiceManager.getService("phoneEx"));
//slotId: PhoneConstants.GEMINI_SIM_1, PhoneConstants.GEMINI_SIM_2
if(mTelEx!=null)String Type = mTelEx.getIccCardType(slotId);

KK之前的版本：
PhoneInterfaceManager.java中API: getIccCardTypeGemini

import com.android.internal.telephony.ITelephony;
final ITelephony iTel = ITelephony.Stub.asInterface(ServiceManager
                                     .getService(Context.TELEPHONY_SERVICE));
try {
         if (FeatureOption.MTK_GEMINI_SUPPORT) {
                if ("USIM".equals(iTel.getIccCardTypeGemini(slotId)))
                   //do something
         } else {
                   if ("USIM".equals(iTel.getIccCardType()))
                       //do something
         }
} catch (Exception e) {
         Log.d(TAG, "catched exception.");
         e.printStackTrace();
}
```

## [FAQ18923] [Audio framework] 开启开机安全校验后，首次开机铃声播放不全

```
开启开机安全校验后，首次开机铃声播放不全，播到中途被截断掉
其原因是：
开启了开机安全校验后
首次开机安全校验完毕后
会重新启动 framework，此时会将 mediaserver 等一系列注册过的 service 都 kill 掉
再重新启动
因为音乐的播放需要依赖于 mediaserver
当 mediaserver 被 kill 时，铃声便会随着中止
 
此为正常现象，没有规避方法
```

## [FAQ18327] Android M 首次开机随sim卡自适应语言错误原因及修改方案

```
Android M上默认不会随sim卡去自适应语言。
对于M上有些首次开机不是系统默认配置的语言问题，是因为安装了GMS包，M上虽然没有去自适应语言，但是有从sim卡的EF中去读取语言并保存起来（只是默认没有使用它去更新语言而已），GMS包中有使用这个保存的语言用它去更新语言，所以安装了GMS包后会自适应为EF文件中读取到的语言。 EF文件中读取到的语言一般是这个sim卡所属国家的语言，但有些坏的sim中EF文件存储的是其它国家的语言，所以自适应语言时也会自适应为其它国家的语言。

对于有GMS包的情况如果想修改成不随卡中EF文件自适应的情况，可如下修改：
packages/services/Telephony/src/com/android/phone/PhoneInterfaceManager.java
@Override
public String getLocaleFromDefaultSim() {
    return null;//直接return null
}

如果想修改Ｍ的默认设计希望能随sim卡自适应，但不根据EF文件读取的语言自适应（根据sim卡mcc自适应）可去参考　FAQ17975　Android M 首次开机不随sim卡自适应语言修改方案。
```

## 支持OTA升级及OTA升级的相应资料、OTA升级与FOTA的区别

```
支持情况：目前MT6573/75/77都支持OTA升级
相关资料：有关OTA升级的参考资料请参考DMS的以下路径：
/3G Phone Data/Smart Phone/Software_Customer/Standard Package/MT6577 SW Doc Package/Application/OTA Update
客户端的代码请参考：alps/mediatek/source/packages/GoogleOta*三支文件

DM/fota和mota的区别：是两种软件版本升级的方式，只需采用其中之一即可。
fota: 是需要拿到三方RedBend的license，升级包的发布与管理是由运行商控制的，在实现过程中需要从运行商那申请开通DM（增强售后服务）功能，在升级过程中需要收费；
mota: 是敝司自行实现的一套升级方式，其中server端和客户端都已经实现，且免费提供给客户，是不需要三方介入。
```

## [FAQ09094] RTL语言下电话号码显示问题

```
1、一些复杂语言字符显示以及layout是从右向左的，比如阿拉伯语、波斯、乌尔都语、希伯来语。因此经常会遇到一些情况是，其他非RTL字符串(比如英文、数字等)在和这些语言字符组合时，当系统语言如果是RTL语言，那么非RTL字符串也会变成从右向左显示；还有就是一些ap，比如Phone、联系人等，在ap设置了一些属性之后电话号码会变成从右向左显示，例如：135 4567 4562 会变成4562 4567 135 如果要实现系统语言为阿拉伯语等RTL语言时，一些非RTL字串按照自己显示顺序(LTR)显示，可以按照如下方法修改,
(A)    如果这些字串是在string.xml中定义，可以把相关字串加上控制符使其从左向右显示，如下
<string name="lockpassword_pin_too_long"> RTL字串\u202D <xliff:g id="number" example="17">%d</xliff:g>\u202C RTL字串</string>

也可以使用 '\u202A ，'\u202C';

(B)    如果是在代码中动态生成可以新增如下函数，进行处理
///M: to fix number display order problem in Dialpad in Arabic/Hebrew/Urdu
private String numberLeftToRight(String origin) {
    return TextUtils.isEmpty(origin) ? origin : '\u202D' + origin + '\u202C';// 也可以使用'\u202A ，'\u202C';
}

例如：通话界面拨打一个没有姓名的电话，如果在AndroidManifest.xml(JB2及以后版本) 声明文件的<application>元素中，添加了   android:supportsRtl=true这个属  性，电话号码就会出现如下情况

解决方法就是修改CallCard.java(alps\packages\apps\Phone\src\com\android\phone)的函数如下红色部分

private void updateDisplayForPerson(CallerInfo info,int presentation,boolean isTemporary,Call call,Connection conn)
……
// Promote the phone number up to the "name" slot:
// displayName = number;
displayName = numberLeftToRight(number);

2、 对于RTL语言下TextView或者EditText“+18545784578”显示成“18545784578+”，这是google默认的问题，对比机也有类似的问题
目前没有比较好的解决方法，如果确实要修改，可以在TexView地方加上特殊处理，如下对“+86”号码的处理。

TextView.java  alps\frameworks\base\core\java\android\widget

private void setText(CharSequence text, BufferType type,
boolean notifyBefore, int oldlen) {
if (text == null) {
    text = "";
}

///add this code
Configuration con = mContext.getResources().getConfiguration();
String l = con.locale.getLanguage();
if(l.equals("ar")||l.equals("fa")||l.equals("iw")){///RTL language

Pattern pattern
= Pattern.compile(                      // sdd = space, dot, or dash
"(\\+[0-9]+[\\- \\.]*)?"        // +<digits><sdd>*
+ "(\\([0-9]+\\)[\\- \\.]*)?"   // (<digits>)<sdd>*
+ "([0-9][0-9\\- \\.]+[0-9])"); // <digit><digit|sdd>+<digit>
Matcher matcher = pattern.matcher(text);
while(matcher.find()){
String subnumber = match.group(0);
int index = text.toString().indexOf(subnumber);
String newnumber = '\u202D' + subnumber + '\u202C';
text = text.toString().replace(subnumber, newnumber);
}

}

///add this code

// If suggestions are not enabled, remove the suggestion spans from the text
```

## [FAQ04153] 如何内置/预置/预编译文件(执行程序，应用程序，apk, jar, lib 等任意文件)到系统中

```
方法一.
假设要内置的软件名称为iperf.exe
1. 将iperf.exe放到Codebase的任意一个目录下(该目录必须能够在搜索Android.mk时被搜索到)，比如system/iperf/iperf.exe
2. 在system/iperf目录下添加一个Android.mk文件，内容如下：
LOCAL_PATH:= $(call my-dir)
PRODUCT_COPY_FILES += $(LOCAL_PATH)/iperf.exe:system/iperf/iperf.exe
重新编译Codebase即可，该文件将被内置到手机的system/iperf目录下
PS：这种方法禁止复制APK文件
 
方法二.
可采用prebuilt的方法，但是对文件格式有要求
具体请参考DCC上如下文档：Android_Build_System_for_customer_4.1.pptx
请参见“Build host/target prebuilt” 一节
```

## [FAQ10299] 如何加速./mk snod打包

```
mm命令快速编译一个模块之后，一般用adb push到手机看效果，如果环境不允许用adb push或模块不经常改，希望直接放到image里，则可以用./mk snod，这个命令仅仅将system目录打包成system.img，然后方便直接下载，但是这个命令还是很慢（慢在搜索所有的Android.mk），有一种方法可以加速该编译到1分钟以内

./mk snod

修改alps/build/core/main.mk：
subdir_makefiles :=\
    $(shell build/tools/findleaves.py --prune=out --prune=.repo --prune=.git $(subdirs) Android.mk)
修改为：
ifneq ($(MAKECMDGOALS),snod)
subdir_makefiles :=\
    $(shell build/tools/findleaves.py --prune=out --prune=.repo --prune=.git $(subdirs) Android.mk)
endif

以上避免了不必要的耗时操作，加速./mk snod编译
```

## [FAQ09811] [NW]如何区分MNO和MVNO

```
MVNO(Mobile Virtaul Network Operator)虚拟网络运营商，没有自己的实体网络，通过租用MNO(Mobile Network Operator)的网络来提供网络服务。
我们知道Spec规定operator之间是通过MCC/MNC （Mobile Country Code/Mobile Network Code）来区分的；而MVNO和对应MNO的MCC/MNC是相同的，那就需要MVNO定义额外的栏位（通常都是SIM卡中某支文件）来和对应MNO做区分；具体这个额外的栏位是什么是每个MVNO自己定义的，需要向MVNO确认。
 
[SOLUTION]
 
目前MTK支持区分MVNO的方式有四种（KK以前没有EF_GID1方式），每种包含运营商名称Spn显示和APN两个方面的需求；Spn显示方面每种区分方式对应一个xml的配置表：
1. EF_SPN方式，对应MVNO配置到Virtual-spn-conf-by-efspn.xml中
2. EF_IMSI方式，对应MVNO配置到Virtual-spn-conf-by-imsi.xml中
3. EF_PNN方式，对应MVNO配置到Virtual-spn-conf-by-efpnn.xml中
4. EF_GID1方式，对应MVNO配置到Virtual-spn-conf-by-efgid1.xml中
 
需要向MVNO确认的信息如下：
1. 区分方式是以上哪种，从而决定相关信息需要配置到哪个xml中
2. MVNO的MCC/MNC是什么
3. MVNO的区分栏位的值是什么
4. MVNO需要显示成什么
5. MVNO是否有自己的APN需要配置（还是直接使用对应MNO的），如果需要，值是什么
 
KK以前（JB*.MP）:
一 SPN的设定：
 
(1)通过EF_SPN区分
这中方式是读取SIM中的文件EF_SPN，结合SIM的mccmnc+spn,在virtual-spn-conf-by-efspn.xml 中查找有没有对应的记录，如果有这表示这个SIM是MVNO的卡，同时取name字段的内容当作运营商名称。
如果知道MVNO的SIM卡中的SPN是“abc”，MNO的MCC/MNC是10000，期望显示运营商名是”MVNO“，那就这样加记录(在Virtual-spn-conf-by-efspn.xml中)
<virtualSpnOverride mccmncspn="10000abc“ name="MVNO">
 
(2)通过EF_IMSI区分
这中方式是imsi中有一段特殊的数字标识用于和MNO区分
例如MNO的MCC/MNC是46692，MVNO的IMSI是466923302848289，IMSI的第9位(注意：是0 base, 所以index要填08)起连续2个数字为特殊标识(28)，期望显示的运营商名称是“MVNO”，那就这样加记录(Virtual-spn-conf-by-imsi.xml中)
<virtualSpnOverride mccmnc="46692" index="08" length="02" pattern="28" name=“MVNO”>
 
(3)通过EF_PNN区分
EF_PNN是SIM中的一个option的文件，里面存放一组网络运营商名称(PLMN Network Name)。这种方式即是读取EF_PNN中的第一个pnn来匹配。如果MNO的MCC/MNC是10000，MVNO中EF_PNN的第一个pnn是“abc”，期望显示的运营商名称是“MVNO”，那就这样加记录(Virtual-spn-conf-by-efpnn.xml中)
<virtualSpnOverride mccmncpnn="10000abc“ name="MVNO">
 
 
二 APN的设定
其对应的文件是apns-conf.xml，和spn-conf.xml相同的目录。对比SPN，APN就简单许多，APN填写和SPN区分选择有联系。 这里举例说明，原MNO的APN的设定
 <apn carrier="Orange Entreprise"
      mcc="100"
      mnc="00"
      apn="MNO的apn"
      user="MNO的user"
      password="MNO的password"
      type="default,supl"
  />
 
(1)通过EF_SPN区分
区分是通过spn字段，和spn记录中的spn字段相同
假如spn中MVNO对应记录是<virtualSpnOverride mccmncspn="10000abc“ name="MVNO">;
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      spn="abc" <<增加这个字段
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
  />
 
(2)通过EF_IMSI区分
通过imsi的pattern区分，和spn中的pattern相同。
假如spn中的MVNO记录是<virtualSpnOverride mccmnc="46692" index="08" length="02" pattern="28" name=“MVNO”>
那这个对应的MVNO的AP是
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      imsi="28" <<增加这个字段
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
  />
 
(3)通过EF_PNN区分
区分是通过pnn字段，和spn记录中的pnn字段相同
假如spn中MVNO对应记录是<virtualSpnOverride mccmncpnn="10000abc“ name="MVNO">;
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      pnn="abc" <<增加这个字段
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
  />
 
KK以后（包含KK）：
一 SPN的设定：
所有MVNO区分方式的virtual xml的构成都应该是mccmnc+pattern
 
(1)通过EF_SPN区分
这中方式是读取SIM中的文件EF_SPN，结合SIM的mccmnc+spn,在virtual-spn-conf-by-efspn.xml 中查找有没有对应的记录，如果有这表示这个SIM是MVNO的卡，同时取name字段的内容当作运营商名称。
如果知道MVNO的SIM卡中的SPN是“abc”，MNO的MCC/MNC是10000，期望显示运营商名是”MVNO“，那就这样加记录(在Virtual-spn-conf-by-efspn.xml中)
<virtualSpnOverride mccmncspn="10000abc“ name="MVNO">
 
(2)通过EF_IMSI区分
这中方式是imsi中有一段特殊的数字标识用于和MNO区分
例如MNO的MCC/MNC是46692，MVNO的IMSI是466923302848289，IMSI的第9位起连续2个数字为特殊标识(28)，期望显示的运营商名称是“MVNO”，那就这样加记录(Virtual-spn-conf-by-imsi.xml中)
<virtualSpnOverride imsipattern="4669246692×××28×××××" name=“MVNO”>
 
(3)通过EF_PNN区分
EF_PNN是SIM中的一个option的文件，里面存放一组网络运营商名称(PLMN Network Name)。这种方式即是读取EF_PNN中的第一个pnn来匹配。如果MNO的MCC/MNC是10000，MVNO中EF_PNN的第一个pnn是“abc”，期望显示的运营商名称是“MVNO”，那就这样加记录(Virtual-spn-conf-by-efpnn.xml中)
<virtualSpnOverride mccmncpnn="10000abc“ name="MVNO">
 
(4)通过EF_GID1区分
EF_GID1是SIM中的一个option的文件，里面存放了n个byte的数据；如果MNO的MCC/MNC是10000，MVNO的EF_GID1的内容是"11"，期望显示的运营商名称是"MVNO"，那就这样加记录(Virtual-spn-conf-by-efgid1.xml中)
<virtualSpnOverride mccmncgid1="1000011" name="MVNO">
 
二 APN的设定
其对应的文件是apns-conf.xml，和spn-conf.xml相同的目录。对比SPN，APN就简单许多，APN填写和SPN区分选择有联系。 这里举例说明，原MNO的APN的设定
 <apn carrier="Orange Entreprise"
      mcc="100"
      mnc="00"
      apn="MNO的apn" 
      user="MNO的user"
      password="MNO的password"
      type="default,supl"
  />
 
(1)通过EF_SPN区分
区分是通过spn字段，和spn记录中的spn字段相同
假如spn中MVNO对应记录是<virtualSpnOverride mccmncspn="10000abc“ name="MVNO">;
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
      mvno_type="spn"                  <<增加这两个字段
      mvno_match_data="abc"
  />
 
(2)通过EF_IMSI区分
通过imsi的pattern区分，和spn中的pattern相同。
假如spn中的MVNO记录是<virtualSpnOverride imsipattern="4669246692×××28×××××" name=“MVNO”>
那这个对应的MVNO的APN是
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
      mvno_type="imsi"                  <<增加这两个字段
      mvno_match_data="46692×××28×××××"
  />
 
(3)通过EF_PNN区分
区分是通过pnn字段，和spn记录中的pnn字段相同
假如spn中MVNO对应记录是<virtualSpnOverride mccmncpnn="10000abc“ name="MVNO">;
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
      mvno_type="pnn"                  <<增加这两个字段
      mvno_match_data="abc"
  />
 
(4)通过EF_GID1区分
区分是通过gid1字段，和spn记录中的gid1字段相同
假如spn中MVNO对应记录是<virtualSpnOverride mccmncgid1="1000011" name="MVNO">;
 <apn carrier="Orange Entreprise"  <<设定中显示的名称
      mcc="100"
      mnc="00"
      apn="MVNO的apn"
      user="MVNO的user"
      password="MVNO的password"
      type="default,supl"
      mvno_type="gid"                  <<增加这两个字段, 注意是gid而不是gid1
      mvno_match_data="11"
  />
 
 
 
有些地区的MVNO要求忽略国内漫游（national roaming），如果有此需求可以参考：
ID: FAQ11783
[NW]MVNO忽略国内漫游（ignore national roaming）
 
如果按照上述配置后，锁屏界面/下拉列表界面 显示的名字和配置的不同，可能按照spec显示了更高优先级的名字，比如NITZ/EONS…

遇到这类问题属于网络运营商名称显示，可以同时参考如下FAQ：

ID: FAQ08919
[NW]网络运营商名称显示规则（锁屏界面，下拉列表）---网络名称 客制化方法 和 问题处理flow
```

## [FAQ13635] Android L APP 如何获取sys file system 中节点的写权限

```
Google 默认禁止app , 包括system app, radio app 等直接写/sys 下面的文件, 认为这个是有安全风险的。如果直接放开SELinux 权限, 会导致CTS 无法通过.

通常遇到此类情况，你有两种做法:
(1). 通过system server service 或者 init 启动的service 读写, 然后app 通过binder/socket 等方式连接APP 访问. 此类安全可靠, 并且可以在service 中做相关的安全审查, 推崇这种方法.

(2). 修改对应节点的SELinux Security Label, 为特定的APP, 如system app, radio, bluetooth 等内置APP开启权限, 但严禁为untrsted app 开启权限. 具体的做法下面以 system app 控制/sys/class/leds/lcd-backlight/brightness 来说明.

1. 在device/mediatek/common/sepolicy/file.te 定义brightness SELinux type
type sys_lcd_brightness_file, fs_type,sysfs_type;

2. 在device/mediatek/common/sepolicy/file_contexts 绑定 brightness 对应的label, 注意对应的节点是实际节点，而不是链接.以及整个目录路径中也绝不能包含链接(无数同仁有犯这个错误，特意提醒)
/sys/devices/platform/leds-mt65xx/leds/lcd-backlight/brightness u:object_r:sys_lcd_brightness_file:s0

3. 在device/mediatek/common/sepolicy/system_app.te 中申请权限.
allow system_app sys_lcd_brightness_file:file rw_file_perms;

4. 为其它的process 申请相关的权限，如system_server, 在device/mediatek/common/sepolicy/system_server.te
allow system_server sys_lcd_brightness_file:file rw_file_perms;

原则上我们都推崇使用第一种方式处理.
```

## [FAQ18956] 如何追踪上层调用GC的位置

```
因为GC会让进程suspend起来，所以某些时候如果java层有调用GC，那么就会对系统的performance有影响。这时候需要找出是哪个位置调用 GC的。找到调用GC的方法如下：

修改代码，如下黄色部分代码所示：

/art/runtime/gc/heap.cc

 2383collector::GcType Heap::CollectGarbageInternal(collector::GcType gc_type, GcCause gc_cause, 
2384                                               bool clear_soft_references) {
2385  Thread* self = Thread::Current();
2386  Runtime* runtime = Runtime::Current();
2387  // If the heap can't run the GC, silently fail and return that no GC was run.
// mtk add begin
{
   ReaderMutexLock mu(self, *Locks::mutator_lock_);
            Thread* self = Thread::Current();
            self->Dump( LOG(WARNING)<<"uncaughtException happend" );
}
// mtk add end
2388  switch (gc_type) {
2389    case collector::kGcTypePartial: {
2390      if (!HasZygoteSpace()) {
2391        return collector::kGcTypeNone;
2392      }
2393      break;
2394    }
2395    default: {
2396      // Other GC types don't have any special cases which makes them not runnable. The main case
2397      // here is full GC.
2398    }
2399  }

2.采用模块化编译，只编译libart.so即可（在art/runtime目录下面有android.mk文件，所以可以进到这个目录里面进行mm操作）

3.将上面的生成的32位libart.so和64位的libart 分别push到/system/lib和system/lib64/目录下面

4.重启手机，并复现问题

然后，提供mtklog，这时候，在mainlog中就会有GC的函数调用栈。
```

## [FAQ13246] GPS问题分类--MTK ALPS GPS的特殊知识

```
1.FULL start、COLD start、WARM start、HOT start这些启动方式是什么意思？
定位过程中最重要的辅助资讯包括时间、位置、星历。

FULL start：没有任何的辅助资讯。相当于end user第一次买到手机后使用定位应用的场景。
COLD start：有时间辅助资讯，end user不会遇到该场景。
WARM start：有时间、位置辅助资讯，end user此次定位距离上次定位超过2～4个小时。
HOT start：有所有的辅助资讯，end user此次定位距离上次定位小于2～4小时。

所以对于end user经常会遇到的场景是WARM/HOT start。

2.各种启动方式的TTFF是多少？
TTFF的结果和测试环境、测试的手法、硬件的GPS 性能强相关。
MTK给出的数据是基于在open sky的环境下，有6颗卫星SNR》40db。
FULL start TTFF：小于50s。
COLD start TTFF：小于40s。
WARM start TTFF：小于35s。
HOT start TTFF：小于5s。
```

## [FAQ18381] [APP]语音控制的语言选项默认是汉语，如何将默认设置为English？

```
进入“设置>语言和输入法> 语音控制”，默认语音控制语言为汉语，如何改为默认语音控制语言为English？

请在vendor/mediatek/proprietary/packages/apps/VoiceCommand/res/xml/voicelanguage.xml文件中进行修改：

<?xml version="1.0" encoding="UTF-8"?>
<Languages>
<Language TypeName="简体中文" ID="1" Code="zh-CN" FileName="keyword/1.xml" />
<Language TypeName="繁體中文" ID="2" Code="zh-TW" FileName="keyword/2.xml" />
<Language TypeName="English" ID="3" Code="en-US" FileName="keyword/3.xml" />
<DefaultLanguage ID="1" />
</Languages>

请修改代码如下：<DefaultLanguage ID="3" />。
```

## [FAQ14027] 如何直接打开aee db文件？

```
当发生异常后，除了有mtklog外，还有aee_exp目录下的db，很多异常分析都是基于db的。db是一个压缩的2进制文件，无法直接打开。
GAT里的logviewer可以直接打开解压，但是操作繁琐，这里提供一个直接双击打开db的方法。

[SOLUTION]
在windows操作系统上，可以将某个文件关联一个应用程序，双击这个文件就可以启动该应用程序打开。比如txt文件，双击后notepad.exe会打开txt文件。
那么db关联的应用程序是什么么？是aee_extract.exe，这个工具在gat-win32-3\prebuilt\spsstools\bin\aee_extract.exe。
请使用最新版本的GAT（版本至少是3.15），将*.dbg文件关联到aee_extract.exe就可以双击打开解压db了。
关联有很多方法：比如双击db，选择应用程序，勾选永久使用该程序打开就可以了。
```

## [FAQ10590] 如何预置规范的动画包？

```
一、保证bootanimation.zip压缩包下的图片Size和格式完全统一

二、请写规范的配置文件desc.txt
desc.txt每个参数的实际意义，以如下的case为例：
480 854 10
p 1 0 part0
p 0 0 part1

1.第一行的参数前两位480和854分别表示要显示动画的width和height. 默认情况下应该与Display的width和height一致，如果设置比Display的size要小，则动画会居中显示，周边将用黑框填充.
2.第一行的第三个参数10是定义动画播放的预订帧率(FPS),这个帧率fps是指：每秒动画播放的帧数。此帧数是一个理想值，并不一定代表动画实际帧率，假设预订帧率为FPS_I，预订每一帧解析的时间t_I,  则t_I=1/FPS_I。实际帧率的规则是：
假设某一帧从解析到渲染耗时为t_r，当t_r<=t_l，则渲染完这一帧后，动画这个thread会sleep(t_l-t_r)的时间，也就说这一帧最后的耗时就t_l；
假设某一帧从解析到渲染耗时为t_r，当t_r>t_l，则渲染完这一帧后，动画这个thread会马上开始下一帧，也就说这一帧最后的耗时就t_r。
所以，desc.txt内设置的这个帧率并不能代表动画的实际帧率，实际的帧率是和系统开机的performance有关，因此不是说在desc.txt设置帧率越大越好，反而容易出现当某一帧耗时较长，就容易给用户某一帧卡顿的体验，目前这个FPS的值一般设置在13左右。
当然，设置FPS为13并不是说系统的performance比较低，本身在开机动画阶段，系统进入Bootup Android阶段，许多进程需要启动，系统的主要工作应该集中与开机启动的进程，因此不建议动画的图片过于复杂，导致系统开机的Performance变差。

3.第二行和第三行情况类似，一般用于分别设置顺序播放和无限循环播放的相关参数.
第一个参数p是google default的设计，请保留以p开头。
第二个参数1表示这一行对应folder所需要循环播放的次数，如果是0则表示是无限循环播放，直到系统ready后通过被动退出。
第三个参数0表示这一行对应folder里面的每一帧图片依次解析渲染完成后，要进入下一个循环，动画这个线程需要pause多久。
第四个参数part0表示对应设置规则的folder的path。

Note1：默认的设计，都是将顺序播放的动画放在一个folder，定义这个folder所需要循环的次数；在无限循环的folder内放置一张图片，保证动画没有收到退出指令的时候，动画可以一直显示.
Note2:由于循环播放的folder中的每帧都是以纹理对象存储在纹理内存中再upload到GPU做渲染的，以便下次循环播放不需要重新解析.如果动画包中的图片太多或者图片的size很大时，则会导致占用较多的memory,因此为保证开机的performance,开机动画不建议太复杂.
```

## [FAQ06044] 制作开机动画(bootanimation.zip)注意事项

```
bootanimation.zip是开机动画的图片压缩包，里面放的都是一帧一帧的图片。
注意：里面除了desc.txt以外不能存在其他非图片格式的文件，否则会引起bootanimation程序崩溃，崩溃的log示例如下：
可以看到在播放Thumbs.db时发生了bootanimation的NE
[SOLUTION]
不要在windows系统下打包bootanimation.zip，因为如果浏览图片后，windows将会生成隐藏文件Thumbs.db，请在linux下打包
```

## [FAQ13768] 功耗问题eservice提交流程

```
因为功耗问题很多情况下会涉及到HW/SW多个模块，
因此在Mediatek内部，功耗问题的处理流程有一定的规则。
 
如果客户在提交eservice的时候能遵循如下的规则，
那么在Mediatek这边问题会处理得更加顺利，对提高问题处理效率会有显著帮助

(1) 飞行模式底电流
A: 如果漏电小于10mA-------->同时提交HW/SW的eservice
B: 如果漏电大于10mA-------->提交SW的eservice
 
(2) 飞行模式平均电流-------->提交SW的eservice
 
(3) 传导待机/通话功耗
*先保证飞行模式功耗正常
A: 如果某些band有问题（比如2g fail，3/4g ok）-------->提交RF的eservice
B: 如果所有的band都有问题-------->提交SW的eservice
 
(4) 实网待机/通话功耗
*先保证传导功耗正常
A: 如果联网/选网/通话功能存在异常（modem不正常）-------->提交RF的eservice
B: 如果正常附着网络各项功能正常-------->提交SW的eservice
 
(5) wireless connecivity相关功耗问题（wifi，BT，GPS，FM，NFC）
A: 如果打开飞行模式，再单独打开其中某个模块功耗异常-------->提交SW的eservice（标题里写明是哪个模块的功耗问题，比如“wifi功耗”）
B: 如果只有在关闭飞行模式的情况下，功耗才会异常（说明跟modem有一定关联）-------->按照(4)的流程处理
C: 如果涉及某个模块的非常专业的测试（其他模块的人可能看不懂）-------->提交SW的eservice (标题里写明测试项，比如“wifi XXX测试”)
```

## [FAQ18817] 【MediaScanner】手机开启加密后，一些内置文件在down完版本后第一次开机搜索不到，重启后正常

```
手机开启加密后，内置的文件在down完版本后第一次开机搜索不到，重启后正常。
修改 MediaScannerReceiver.java
1. 增加定义 
private static final String DECRYPT_STATE = "trigger_restart_framework";
 
2. 修改 getHandler()
private Handler getHandler() {
    if (sHandler == null) {
        sHandler = new Handler() {
            @Override
            public void handleMessage(Message msg) {
                Context context = (Context) msg.obj;
                int waitTime = msg.arg1;
                MtkLog.v(TAG, "Check whether all storage mounted, have waited " + waitTime + "ms");
                if (MSG_CHECK_ALL_STORAGE_MOUNTED == msg.what) {
                    /// When all storage mounted or check time out, begin to scan
                    // modify start
                    // if (waitTime > TIMEOUT_VALUE || isAllStorageMounted(context)) {
                    if (DECRYPT_STATE.equals(SystemProperties.get("vold.decrypt"))&& (waitTime > TIMEOUT_VALUE || isAllStorageMounted(context))) {
                        // modify end
                        MtkLog.v(TAG, "All storages have mounted or check time out, begin to scan.");
                        scan(context, MediaProvider.EXTERNAL_VOLUME);
                        removeCallbacksAndMessages(null);
                        sHandler = null;
                    } else {
                        MtkLog.v(TAG, "Some storage has not been mounted, wait it mounted until time out.");
                        Message next = obtainMessage(msg.what, waitTime + CHECK_INTERVAL, -1, msg.obj);
                        sendMessageDelayed(next, CHECK_INTERVAL);
                    }
                    //}
                }
            };
        }
        return sHandler;
    }
    /// @}
}
```

## [FAQ18816] 【AudioProfile】插入印度SIM 卡，相机拍照声音开关控制无效

```
插入印度卡后，关闭camera拍照声的情况下也有声音，使用其他SIM卡不会有问题。

是由于客户印度卡mcc为404,405，所以调用frameworks/base/core/res/res/values-mcc404/config.xml中的config_camera_sound_forced 的值，而这个值为true，从而导致强制使用拍照声音，修改为false就可以了。
当然，在Audioservice.java里readCameraSoundForced()，强制赋值false也是可行的
```

## [FAQ14783] ZZ_INTERNAL每个栏位的含义

```
异常分析是基于exp db的，db的类型多种多样，除了db文件名可以表明粗略的异常类型外，还有ZZ_INTERNAL文件里的内容也做了粗略的分类。
现在有些基于后台收集db的机制，面对大量的db，需要做不同目标的分类，ZZ_INTERNAL是很好的参考源，因此熟悉这个文件的内容格式就很重要了。
 
ZZ_INTERNAL包含10列，每1列用逗号隔开。举例如下：
Hardware Reboot,0,0,99,/data/core/,0,,HW_REBOOT,Tue Aug  4 21:42:18 CST 2015,1
 
以下是各列详解：
第1列：exception class，有KE/NE/JE/EE等。所有类型都定义在：alps/kernel-3.10/include/linux/aee.h
AE_EXP_CLASS
枚举类型里，除了AE_RESMON,AE_MODEM_WARNING是Mediatek内部使用外，其他都有。
System API DUMP是native layer主动报出的问题，对应AE_SYSTEM_NATIVE_DEFECT，
Kernel API Dump是Kernel layer主动报出的问题，对应AE_KERNEL_PROBLEM_REPORT。
Manual Dump是同时按上下音量键5s/10s左右触发的。

第2列：pid，如果没有该信息则为0或者0xAEE00000(-1361051648)
第3列：tid，如果没有该信息则为0或者0xAEE00000(-1361051648)
第4列：固定是99
第5列：固定是/data/core/
第6列：exception level，0: fatal, 1: exception, 2: warning, 3: reminding。定义在：alps/kernel-3.10/include/linux/aee.h
AE_DEFECT_ATTR

第7列：exception type info string
如果是NE，则这个栏位是signal名称，比如：SIGSEGV，KE则为空，SWT则为：system_server_watchdog，等等。

第8列：module name or process name
e.g. KE db可能为KE at <function>

第9列：UTC time
第10列：固定是1
 
aee部分可以到DCC上参考Mediatek Logging SOP.pptx。
```

## [FAQ11598] 如何处理工厂模式(factory mode)崩溃的问题？

```
工厂模式下系统会跑到kernel，并运行factory程序，如果factory发生NE崩溃了，该如何分析处理？此时可没有mtklogger在抓取log的。
 
如果factory发生NE崩溃，kernel会按默认处理，将生成coredump，文件存放在/data/core/目录下，文件名为zcore-xxx.zip，其中xxx为factory的pid
此时提供该zcore-xxx.zip和保留的out/target/product/$proj/symbols/system/bin/factory一起提交到e-service。
 
note:
如果发现/data/core/目录下没有该文件，请在alps/device/mediatek/MT67xx/factory_init.rc文件中添加
import init.aee.rc
```

## [FAQ09747] 对于没有coredump的Native exception，如何抓取coredump

```
关于什么是coredump请参考FAQ (ID: FAQ06108) COREDUMP ；
coredump对于定位应用NE死在代码的什么位置，以及当时的死机现场至关重要；
所以对于NE issue大部分是否都需要帮忙抓取coredump来分析；
所以抓到log发现是NE issue后，请用GAT解开DB，来查看下面的文件mtklog/aee_exp/db.xx/PROCESS_COREDUMP是否存在；
但是有少数情况下会出现抓取不到的现象，针对此情况，请按照下面的方法来抓取； 
 
1.对于GB3/JB3以前的版本
(1)删除手机中system/bin/debuggerd,
(2)重启手机,然后手动设置adb shell
    然后执行:
    echo "|/system/bin/aee_core_forwarder /data/core/ %p %s UID=%u GID=%g"   > /proc/sys/kernel/core_pattern
    (注意如果每次重启手机都要设置一次)
(3)然后复现问题，这样coredump会生成到/data/core/目录下。
(4)复现后，捞出/data/core目录里的文件， coredump就在这里
2.对于GB3/JB3及以后的版本
1. eng build 默认都有coredump 在mtklog/aee_exp 文件夹中db，解压db文件后可以看到
2. 如果需要在user build下抓取coredump，请按以下设置，然后抓取，也会在mtklog/aee_exp 文件夹中db
    adb shell aee -d coreon
    adb shell reboot
```

## [FAQ06108] /data/core/zcore-xxx.zip是什么？有什么用？

```
1. zcore-xxx.zip是压缩的coredump,文件名叫做PROCESS_COREDUMP
2. coredump是linux的概念，在应用层的程序发生崩溃后，linux会将当前的进程空间保存为coredump，以供后续分析(可以用gdb等工具分析)，详细信息可以到网络搜索资料
在android系统中，也会将natvie程序崩溃(native exception，简称NE)而产生的coredump保存到/data/core目录下，原本的保存的文件名一般为core.$pid,其中$pid为崩溃进程的pid
3. 一般coredump文件都很大，因此MTK将其压缩，名字叫zcore-$pid.zip
4. 在JB2之前该文件直接解压就可以拿到PROCESS_COREDUMP，之后则需要GAT解压（目前还没做好）
5. 正常情况下的NE，MTK会生成相应的mtklog/aee_exp/db.xx，会将PROCESS_COREDUMP一起打包进去，而不会生成/data/core/zcore-xxx.zip,除非特殊情况才会生成到/data/core目录下，比如MTK异常处理机制本身异常了
6. user版本即使发生NE也不会生成zcore-xxx.zip，所以不用当心
7. 如果经常发生NE的话，可能导致/data/core目录下存在很多zcore-xxx.zip,把占用大量的data空间。此时应该将发生NE的问题解决，然后在清除zcore-xxx.zip
```

## [FAQ14333] 异常发生后如何将log里对应的地址转换为所在的文件和行号？

```
在发生各种异常时，通常从log看到的是各种地址和数据，这些信息基本无法阅读，分析也很困难。
我们需要将这种人类无法阅读的信息转换成容易理解的信息。比如将函数地址转换成所在的文件和行号。
在log里恰恰含有大量这种地址信息。因此转换为所在文件和行号有助于我们分析问题。
 
[SOLUTION]
这个转换需要借助一个GNU工具：arm-linux-androideabi-addr2line（ARM 32位版本）或aarch64-linux-android-addr2line（ARM 64位版本）
工具位置（具体以实际目录位置为准）：
ARM 32位版本：prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.8/bin/arm-linux-androideabi-addr2line
ARM 64位版本：prebuilts/gcc/linux-x86/aarch64/aarch64-linux-android-4.9/bin/aarch64-linux-android-addr2line
使用方法：
arm-linux-androideabi-addr2line -Cfe $symbol_file 0xyyyyyyyy
其中的0xyyyyyyyy是从log提取的地址。$symbol_file为地址所在的符号文件，该文件包含调试信息。
 
该工具需要搭配对应的符号文件才行，那这个符号文件是什么呢？这要看你要查询的地址是属于哪个符号文件的了。
举例：log里的地址是lk的，那lk对应的符号文件是：out/target/product/$proj/obj/bootloader_obj/build-$proj/lk
如果是kernel的，对应的符号文件是：out/target/product/$proj/obj/kernel_obj/vmlinux（老版本的位置在kernel/out/vmlinux）
如果是preloader的，对应的符号文件是：out/target/product/$proj/obj/preloader_obj/bin/preloader_$proj.elf
 
实例1：
有一次在lk里发生了重启，抓取uart log如下：
kedump add: SYS_MINI_RDUMP[0] 1000/1000@a00
[1460] data abort, halting
[1460] r0 0x41e49ec8 r1 0x41e31b03 r2 0x41e49ed7 r3 0x00000000
[1460] r4 0x43ff0000 r5 0x43ff0bae r6 0x41e31b04 r7 0x43ff0bd6
[1460] r8 0x41e31ad4 r9 0x00000014 r10 0x00001a00 r11 0x00000000
[1460] r12 0x00000061 usp 0x00000000 ulr 0x00000000 pc 0x41e1b918
[1460] spsr 0x00000173
/* 之后就重启了 */
我们需要知道在什么地方发生异常了，PC是当时发生异常的地址。拿到对应的lk，用如下命令转换：
arm-linux-androideabi-addr2line -Cfe lk 0x41e1b918
kedump_to_expdb
bootable/bootloader/lk/app/mt_boot/aee_KEDump.c:219
很明显就可以看到是aee_KEDump.c的219行出问题了，赶紧查看代码分析吧。
 
实例2：
在kernel发生了panic，抓取kernel log（db里的SYS_KENREL_LOG）如下：
[17600.585313]<1>-(1)[1602:wpa_supplicant]PC is at sock_rfree+0x20/0x38
[17600.585327]<1>-(1)[1602:wpa_supplicant]LR is at netlink_skb_destructor+0x14/0x1c
......
[17600.590428]<1>-(1)[1602:wpa_supplicant]Call trace:
[17600.590442]<1>-(1)[1602:wpa_supplicant][<ffffffc000832784>] sock_rfree+0x20/0x38
[17600.590458]<1>-(1)[1602:wpa_supplicant][<ffffffc000836cb0>] skb_release_head_state+0x5c/0xe4
异常发生在sock_rfree()函数里，但是不知道哪一行异常了，异常的地址是ffffffc000832784，拿到对应的vmlinux，转换：
aarch64-linux-android-addr2line -Cfe vmlinux 0xffffffc000832784
sk_mem_uncharge
kernel-3.10/include/net/sock.h:1415
问题在sock.h的1415行异常，需要进一步分析。
 
注意：
这个符号文件必须是和烧录的image一起生成的，如果被重新编译过生成的，那么log里的地址和符号文件可能对应的不上，工具可能输出错误的结果。
如果不确定符号文件是32位还是64位，则直接使用64位版本。
```

## [FAQ06047] 如何学习Debug Native Exception?

```
Native Exception，简称NE，是发生于C/C++ code里面最常见的一种异常，对于简单的NE，我们可以根据backtrace印出的调用逻辑来推断产生的原因。但是稍复杂一些的NE，比如memory corruption造成地址访问异常，比如某个变量在多层函数调用之间被异常篡改，比如函数指针未初始化造成的异常跳转等等，仅仅依靠log和backtrace就变得稍显力不从心了。

对于此类case，就需要深入了解architecture相关的知识以及各种相关的工具来进行汇编语言层次的分析。鉴于相关的知识分布比较发散，我们将debug NE需要的相关知识罗列在此供参考学习。
```

## [FAQ10278] DB文件会生成在哪里以及生成的个数是多少？

```
一. DB的路径
DB的路径只有两种路径：/data/aee_exp或者/sdcard/mtklog/aee_exp。其中/sdcard一般是内置sdcard。DB实际存放路径的规则如下：

(1)ENG版本
ENG版本默认是打开MTKLogger，所以一般情况下DB优先放到在/sdcard/mtklog/aee_exp。但是当发生的是KE重启这类异常，此时MTKLogger还没起来，则aee_exp会生成在/data/aee_exp。

(2)USER版本
USER版本默认是关闭MTKLogger，所以此时DB是生成在/data/aee_exp。但是如果在USER版本将MTKLogger打开，则aee_exp是生成在/sdcard/mtklog/aee_exp。

二. aee_exp下的DB个数

USER版本关闭MTKLogger的情况下，只有发生的是Fatal级别的异常才会抓取DB(包含KE，异常reboot，system_server出现异常的JE和NE以及software WatchDog)。且aee_exp最多保存4个DB文件，名称如db.xx.dbg，其中xx为“00”，“01”，“02”，“03”，再发生异常时依次覆盖“01”，“02”，“03”，会一直保留最老的“00”。
除此之外的其它情况下是会抓取包括Exception级别的异常DB，且aee_exp最多会保存20个DB文件(db.00.dbg，db.01.dbg，......db.19.dbg)，再发生异常时依次覆盖“01”，“02”，“03”......"19"，会一直保留最老的“00”。
```

## [FAQ18402] [SAT]SIM Refresh后STK Name更新太慢

```
执行SIM refresh 后，若需要更新 STK name, STK name显示更新太慢。 
 
[SOLUTION]
现象：SIM refresh 后重新初始化 SIM 卡，会上报 set up menu. STK ap 过了很长时间才收到，导致 STK name 更新太慢。 
原因：STK 默认的设计是后台广播，若开机初始化阶段消息太多，导致 STK 广播延时明显。
修改：将stk的广播置为前台广播来规避这个问题，请在catservice.java文件的 broadcastCatCmdIntent 里，在发送广播之前，加上：
intent.addFlags(Intent.FLAG_RECEIVER_FOREGROUND);
    
类似如下情况的问题，若需要较早支持进入 SIM Toolkit, 也可以参考此说明修改：
例如：插入支持 STK SIM，重启手机，当开机弹出运营商提示框后，点击SIM Toolkit应用，提示“App isn't installed”, 过一段时间才能进入。
 
类似问题 log 情况，按时间顺序说明如下：
//开机或 refresh 后，sim 上报的 set up menu 指令，CatService 收到 set up menu.
12-31 18:08:01.844194 1490 1490 D CAT : CatService: handleMessage[10]
12-31 18:08:01.844357 1490 1490 D CAT : CatService: SET_UP_MENU
12-31 18:08:01.845522 1490 1490 D CAT : CAT: mSetUpMenuFromMD: true
12-31 18:08:01.846026 1490 1490 D CAT : CatService: SS-sendTR: command type is 37
12-31 18:08:01.846284 1490 1490 D CAT : CatService: encodeOptionalTags() Unsupported Cmd details=CmdDetails: compRequired=true commandNumber=1 typeOfCommand=37 commandQualifier=0
12-31 18:08:01.846435 1490 1490 D CAT : CatService: TERMINAL RESPONSE: 810301250082028281830100
12-31 18:08:01.849209 1490 1490 D CAT : CatService: Sending CmdMsg: com.android.internal.telephony.cat.CatCmdMessage@bf8cac0 on slotid:0

//catservice 发广播
12-31 18:08:01.851211 846 1664 V ActivityManager: Broadcast: Intent { act=android.intent.action.stk.command flg=0x10 (has extras) } ordered=false userid=0 callerApp=ProcessRecord{bdd92c0 1490:com.android.phone/1001}

//54秒后，STK AP 才收到广播。
12-31 18:08:55.672267 1490 1490 D ActivityThread: BDC-Calling onReceive: intent=Intent { act=android.intent.action.stk.command flg=0x10 cmp=com.android.stk/.StkCmdReceiver (has extras) }, receiver=com.android.stk.StkCmdReceiver@db84bac
12-31 18:08:55.685323 1490 1490 D ActivityThread: BDC-RECEIVER handled : 0 / ReceiverData{intent=Intent { act=android.intent.action.stk.command flg=0x10 cmp=com.android.stk/.StkCmdReceiver (has extras) } packageName=com.android.stk resultCode=-1 resultData=null resultExtras=null}
 
12-31 18:08:55.690877 1490 1490 D CAT : StkAppService: StkAppService onStart sim id: 0, op: 1, Bundle[{SLOT_ID=0, cmd message=com.android.internal.telephony.cat.CatCmdMessage@4dff87b, op=1}]
12-31 18:08:55.690980 1490 1490 D CAT : StkAppService: StkAppService onStart mPhone: Handler (com.android.internal.telephony.PhoneProxy) {41d633d}, mPhoneStateChangeReg: true
12-31 18:08:55.691419 1490 2387 D CAT : StkAppInstaller: Init thread
12-31 18:08:55.691523 1490 2387 D CAT : StkAppService: handleMessage opcode[1], sim id[0]
12-31 18:08:55.691643 1490 2387 D CAT : StkAppService: cmdName[SET_UP_MENU]
```

## [FAQ01799] data分区下产生data/core/core.xxxx文件的时机与用途

```
data分区下产生 data/core/core.xxxx 文件的时机与用途
当发生了 Native Exception 的时候产生的
用于分析 Native Exception 的时候使用
```

## [FAQ09614] 当发生native exception时，需要提供哪些资料或者文件来分析

```
当发生Native exception(以下简称NE)后，一般发生NE的进程会崩溃退出，
但如果发生NE的进程是system server的话，手机会在android层重启；
所以从手机直观的现象就可以初略的判断是否是发生NE；
然后您可以用GAT工具解析，mtklog/aee_exp文件夹下的db文件，EX：db.00；
解析后会生成相应文件夹，EX：db.00.dbg.DEC，该文件夹下的文件就是分析NE所需要的一些文件了；
您可以打开文件__exp_main.txt来查看：Exception Class: Native (NE)
则可以判断为NE，然后您可以按照[solution]中的要求提供咨询给mtk来分析；
 
1.完整的mtklog文件夹，mobilelog和相应的aee_exp db文件不可或缺，所以默认请提供完整mtklog文件夹；
2.在[description]中解析出来db文件目录下，打开文件_exp_detail.txt，参考里面的backtrace，提供backtrace中
所显示的全部库文件，库文件目录为：out/target/product/[project]/symbols/system/lib
PS:必须提供symbols目录下库文件，才会带有debug调试信息；
3.在[description]中解析出来db文件目录下，打开文件PROCESS_MAPS，查看第一行,提供第一行对应的app文件；
ps:因为bin文件一定是system/bin目录下的，如果maps中的第一行不是这个目录，您可以在整个maps文件中查找/system/bin后，请提供这些文件给我们，一般来说，除了linker外，只会有另外一个主体bin文件了，但是具体的codebase中的路径请参考如下路径
路径为：out/target/product/[project]/symbols/system/bin；  也必须是symbols目录下的；
```

## [FAQ11414] android KK 4.4 版本后，user 版本su 权限严重被限制问题说明

```
Google 不遗余力的提高android系统的安全性, 而针对su 这个即令人恨，又令人爱的命令，就痛下杀手。下面我从三个方面说明.
1. 限制user 版本adbd process 的capabilities bound set. 循环CAPBSET_DROP 动作，将Process 的root capabilities 进行了强行限制。仅仅保留了CAP_SETUID, CAP_SETGID 这两项，用于run-as 使用，可参考alps/system/core/adb/adb.c 中的 drop_capabilities_bounding_set_if_need 函数。
这样导致的情况是，在user 版本中usb debug 的su 受到极大的限制，仅仅能够模拟对应的uid/gid, 而无法拿去真正的root 权限.

2. 限制所有app 的capabilities bound set, 在android 4.4 上，zygote fork app 时，特意对所有fork 出来的子进程，进行了CAPBSET_DROP 动作，将Process 的root capabilities 进行了强行限制。 使得即使这些APK 徒有Root 权限，而无真实的capabilites. 在4.4.4 以及L 版本上, 还会使用prctl 下PR_SET_NO_NEW_PRIVS 指令, 限制子进程权限的提升.
这样导致的情况是, app 执行su 时，其权限受到了严格的管控，比如无法逃脱DAC 权限管控。但因为依旧具有root uid/gid, 所以在framework 层的permission 限制上依旧畅通无阻。
详情请参考FAQ: https://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ11538

3. SElinux 权限限制。 在user 版本上，没有导入有效的SU SElinux policy, 这样一旦本身受SElinux 限制的process 使用su 时，同样会受到SElinux 的限制。

(3.1). 在KK 版本只有4个process 会受到此影响，即zygote, netd, installd, vold.
消除这种限制的手法即是external/sepolicy/android.mk 里面的
ifeq ($(TARGET_BUILD_VARIANT),user)
    BOARD_SEPOLICY_IGNORE+=external/sepolicy/su.te
else
    BOARD_SEPOLICY_IGNORE+=external/sepolicy/su_user.te
endif

更新成:
ifeq ($(TARGET_BUILD_VARIANT),user)
    BOARD_SEPOLICY_IGNORE+=external/sepolicy/su_user.te
else
    BOARD_SEPOLICY_IGNORE+=external/sepolicy/su_user.te
endif

(3.2). 在L 版本则所有的Process 都会受到这样的影响.

sepolicy_policy.conf := $(intermediates)/policy.conf
$(sepolicy_policy.conf): PRIVATE_MLS_SENS := $(MLS_SENS)
$(sepolicy_policy.conf): PRIVATE_MLS_CATS := $(MLS_CATS)
$(sepolicy_policy.conf) : $(call build_policy, $(sepolicy_build_files))
@mkdir -p $(dir $@)
$(hide) m4 -D mls_num_sens=$(PRIVATE_MLS_SENS) -D mls_num_cats=$(PRIVATE_MLS_CATS) \
-D target_build_variant=$(TARGET_BUILD_VARIANT) \
-D force_permissive_to_unconfined=$(FORCE_PERMISSIVE_TO_UNCONFINED) \
-s $^ > $@
$(hide) sed '/dontaudit/d' $@ > $@.dontaudit

将-D target_build_variant=$(TARGET_BUILD_VARIANT) 改成 -D target_build_variant=eng 
```

## [FAQ03827] 如果抓一个正在运行的程序的Native Backtrace？

## [FAQ04310] 如何修改时区data文件

```
Android时区信息是由data文件保存，KK之前的版本是三个文件(zoneinfo.dat, zoneinfo.idx,zoneinfo.version)，KK之后只有一个文件(tzdata)。由于各国的时区信息是会变化的，例如2014年6月13日，俄罗斯宣布从2014年10月26日之后全国时区推后一小时，比如莫斯科之前是GMT+4，修改后是GMT+3；如某个时区去掉2015年永久取消夏令时；但是android中的该文件不会自动更新，所以测试过程中会遇到手机的时区信息显示不正确。这种情况下，就需要更新手机的时区信息文件。
[Solution]
一、下载tztada包
在网址ftp://ftp.iana.org/tz/releases/下载tzdata*.tar.gz，对于KK下载2014f版本，如果是KK之前的版本请下载2013年的版本。解压后拷贝到路径\bionic\libc\tools\zoneinfo下。找到时区所在文件，是按照城市所在洲命名的文件。
 1、夏令时(如Mexico在文件northamerica)
   # Rule NAME FROM TO TYPE IN ON AT SAVE LETTER/S
      Rule Mexico 1939 only - Feb 5 0:00 1:00 D
      Rule Mexico 1939 only - Jun 25 0:00 0 S
      Rule Mexico 1940 only - Dec 9 0:00 1:00 D
      Rule Mexico 1941 only - Apr 1 0:00 0 S
      Rule Mexico 1943 only - Dec 16 0:00 1:00 W # War
      Rule Mexico 1944 only - May 1 0:00 0 S
      Rule Mexico 1950 only - Feb 12 0:00 1:00 D
      Rule Mexico 1950 only - Jul 30 0:00 0 S
      Rule Mexico 1996 2000 - Apr Sun>=1 2:00 1:00 D
      Rule Mexico 1996 2000 - Oct lastSun 2:00 0 S
      Rule Mexico 2001 only - May Sun>=1 2:00 1:00 D
      Rule Mexico 2001 only - Sep lastSun 2:00 0 S
      Rule Mexico 2002 max - Apr Sun>=1 2:00 1:00 D
      Rule Mexico 2002 max - Oct lastSun 2:00 0 S 
      红色字体1:00表示有夏令时，要加一小时；0表示不用加。前面的时间是执行夏令时的时间段。如果要求2014年开始每年4月1日到10月31日执行夏令时，其余时间取消夏令时可以新增如下2句：
      Rule Mexico 2014 max - Apr 1 2:00 1:00 D
      Rule Mexico 2014 max - Oct 31 2:00 0 S
 2、时区(如Moscow在文件europe)
     Zone Europe/Moscow 2:30:17 - LMT 1880
     2:30:17 - MMT 1916 Jul 3 # Moscow Mean Time
     2:31:19 Russia %s 1919 Jul 1 2:00
     3:00 Russia %s 1921 Oct
     3:00 Russia MSK/MSD 1922 Oct
     2:00 - EET 1930 Jun 21
     3:00 Russia MSK/MSD 1991 Mar 31 2:00s
     2:00 Russia EE%sT 1992 Jan 19 2:00s
     3:00 Russia MSK/MSD 2011 Mar 27 2:00s
     4:00 - MSK 2014 Oct 26 2:00s
     3:00 - MSK
  新增2014年10月26日之后执行GMT+3时区

3、KK版本需要修改ICU对应的时区信息，比如Moscow

修改文件external\icu\icu4c\data\misc\zoneinfo64.txt（可以参考FAQ04553下载最新的ICU资源对比修改 ）
把Moscow时区部分使用下面替换掉，然后参考FAQ04011 重新编译icu资源
 /* Europe/Moscow */ :table {
    trans:intvector { -1688265017, -1656819079, -1641353479, -1627965079, -1618716679, -1596429079, -1593829879, -1589860800, -1542427200, -1539493200, -1525323600, -1522728000, -1491188400, -1247536800, 354920400, 370728000, 386456400, 402264000, 417992400, 433800000, 449614800, 465346800, 481071600, 496796400, 512521200, 528246000, 543970800, 559695600, 575420400, 591145200, 606870000, 622594800, 638319600, 654649200, 670374000, 686102400, 695779200, 701812800, 717534000, 733273200, 748998000, 764722800, 780447600, 796172400, 811897200, 828226800, 846370800, 859676400, 877820400, 891126000, 909270000, 922575600, 941324400, 954025200, 972774000, 985474800, 1004223600, 1017529200, 1035673200, 1048978800, 1067122800, 1080428400, 1099177200, 1111878000, 1130626800, 1143327600, 1162076400, 1174777200, 1193526000, 1206831600, 1224975600, 1238281200, 1256425200, 1269730800, 1288479600, 1301180400, 1414274400 }
    typeOffsets:intvector { 9017, 0, 7200, 0, 7200, 3600, 9079, 0, 9079, 3600, 9079, 7200, 10800, 0, 10800, 3600, 10800, 7200, 14400, 0 }
    typeMap:bin { "0304030504050706070807060106070607060706070607060706070607060706070602010607060706070607060706070607060706070607060706070607060706070607060706070607060906" }
    links:intvector { 462, 618 }
  }


二、 修改完成后需要执行脚本生成data文件，具体执行可以参考
   KK之前的版本：FAQ05710 
   KK之后的版本(L,M)：FAQ12532
三、关于俄罗斯时区的问题
请参考：FAQ13442，FAQ13443
```

## [FAQ04857]【USB名称修改系列】第2项-如何修改PTP在PC"我的电脑"中显示的label名称

```
USB PTP功能在pc端 “我的电脑” 盘符卷标字符串客制化

[SOLUTION]
以下两种方式采用其中一种即可：
a) 修改/alps/framework/av/media/mtp/MtpServer.cpp

MtpResponseCode MtpServer::doGetDeviceInfo() {
這裡面有個

property_get("ro.product.model", prop_value, "MTP Device");
//此处添加修改prop_value数组的值的code，值即为要客制化的字符串

string.set(prop_value);//或者直接修改此句code为 string.set(“label name”);

之后rebuild project

b) 修改ro.product.model的值
在alps/build/tools/buildinfo.sh 中查找ro.product.model对应的宏的名称，此处为PRODUCT_MODEL；
在alps/build/target/product/<project>.mk文件中添加或修改该宏的定义,如：
PRODUCT_MODEL  := mylabelname
注意不能有空格。

注意：在JB9上为了WHQL测试的通过，已经在mtpDatabae.java中将相应修改label名称的代码注释，所以JB9如果

要修改名称要注意这一点。另外也可以在alps\mediatek\config\[project_name]\system.prop文件中ro.sys.usb.mtp.whql.enable设置为1，这样也可以避免这个WHQL测试的问题~
```

## [FAQ07081] 【USB名称修改系列】第5项-如何修改MTP在PC设备管理器中制造商的名称

```
修改方法：
1. 修改build/tools/buildinfo.sh中的 ro.product.manufacturer

2. frameworks\av\media\mtp\MtpServer.cpp 的doGetDeviceInfo()
property_get("ro.product.manufacturer", prop_value, "unknown manufacturer");
string.set(prop_value);
修改此处的prop_value
```

## [FAQ03524] 【USB名称修改系列】第3项-如何修改MTP在PC"我的电脑"中显示的label名称

```
MTP功能在PC端盘符名称显示如何修改？
[SOLUTION]
以下两种方式采用其中一种即可：

a) 修改/Alps/frameworks/base/media/java/android/mtp/MtpDatabase.java
private int getDeviceProperty(int property, long[] outIntValue, char[] outStringValue) {
    String deviceName;
    deviceName = SystemProperties.get(“ro.product.name”);
    deviceName = “yournamehere”;
    int lengthDeviceName = deviceName.length();

b) 修改ro.product.name的值
在alps/build/tools/buildinfo.sh 中查找ro.product.name对应的宏的名称，此处为PRODUCT_NAME；
在alps/build/target/product/<project>.mk文件中添加或修改该宏的定义,如：
PRODUCT_NAME    := mylabelname
注意不能有空格
```

## [FAQ17359] [SAT]怎么去掉"Sending text message"的popup提示界面

```
有些运营商的特殊SIM卡会上报SAT命令，定时要求手机向网络发送短信，按照11.14规范，我们是应当让User知道手机当前在发送短信；
但为了不影响User使用感受，客户希望不弹出Popup 框导致按键无响应的情况，那么可以做以下修改(修改方法适用与10A之后的Pluto MMI)：
1>、如果只是希望在STK菜单之外的界面时去除Sending text message的Popup 框，
将以下函数：
void mmi_sat_send_sms_process(srv_sat_proactive_sim_struct *cmd_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_sat_group_data_struct *group_data = NULL;
    srv_sat_send_sms_struct *send_sms = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    send_sms = (srv_sat_send_sms_struct *)(&cmd_info->cmd_data);
    group_data = mmi_sat_init_group_data(cmd_info->sim_id, cmd_info->cmd_type, send_sms, MMI_FALSE);
    group_data->func_p = (FuncPtr)mmi_sat_send_sms_scrn_entry;
    mmi_sat_instant_cmd_show_by_nmgr(mmi_sat_scrn_pre_entry, group_data);
}
修改为：
void mmi_sat_send_sms_process(srv_sat_proactive_sim_struct *cmd_info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_sat_group_data_struct *group_data = NULL;
    srv_sat_send_sms_struct *send_sms = NULL;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    send_sms = (srv_sat_send_sms_struct *)(&cmd_info->cmd_data);
    if(mmi_sat_is_in_screen(cmd_info->sim_id))
    {
        group_data = mmi_sat_init_group_data(cmd_info->sim_id, cmd_info->cmd_type, send_sms, MMI_FALSE);
        group_data->func_p = (FuncPtr)mmi_sat_send_sms_scrn_entry;
        mmi_sat_instant_cmd_show_by_nmgr(mmi_sat_scrn_pre_entry, group_data);
    }
    else
    {
        srv_sat_terminal_response_send_sms_stage1(cmd_info->sim_id);
    }
}
2>、如果想直接去掉所有case下的sending text message界面。
那么直接将上述函数中：
    group_data = mmi_sat_init_group_data(cmd_info->sim_id, cmd_info->cmd_type, send_sms, MMI_FALSE);
    group_data->func_p = (FuncPtr)mmi_sat_send_sms_scrn_entry;
    mmi_sat_instant_cmd_show_by_nmgr(mmi_sat_scrn_pre_entry, group_data);
替换成：
srv_sat_terminal_response_send_sms_stage1(cmd_info->sim_id);
 
 
针对 slim 之后的版本，没有 mmi_sat_send_sms_process，请参考下面说明修改。
 
请在 satApp.c 中，mmi_sat_get_process() 修改如下case, 修改后，在 stk menu 之外界面的 send sms 不会显示。

修改前：

case SRV_SAT_CMD_SEND_SMS:
send_sms = (srv_sat_send_sms_struct *)(&cmd_info->cmd_data);
group_data = mmi_sat_init_group_data(cmd_info->sim_id, cmd_info->cmd_type, send_sms, MMI_FALSE , mmi_sat_send_s_scrn_entry);

修改后：

case SRV_SAT_CMD_SEND_SMS:
if(mmi_sat_is_in_screen(cmd_info->sim_id))
{
kal_sys_trace("[stk] show send sms.");
send_sms = (srv_sat_send_sms_struct *)(&cmd_info->cmd_data);
group_data = mmi_sat_init_group_data(cmd_info->sim_id, cmd_info->cmd_type, send_sms, MMI_FALSE , mmi_sat_send_s_scrn_entry);
break;
}
else
{
kal_sys_trace("[stk] not show send sms.");
srv_sat_terminal_response_send_sms_stage1(cmd_info->sim_id);
return;
}

若测试有问题：
1. 请提供一个问题复现的log，从开机到问题复现，
filter: MOD_SIM(all class on), MOD_L4C(all class on), MOD_MMI_COMMON_APP(TRACE_GROUP_3).MOD_MMI_FW(trace_group_1)
2. 请提供修改的代码文件。
```

## [FAQ03920] [NvRAM] NvRAM product info的客制化以及注意事项

```
89之后的平台，MTK提供了Product info feature，支持Normal Mode下使用NvRAM接口写入数据， factory reset不会擦除，也避免了Normal Mode备份引起的掉电风险。
ICS2.MP/ICS.MP部分版本可以通过打patch支持，需要申请patch：ALPS00329542（JB 和TDD ICS2 branch 除外）

###Steps###
1. 打开MTK_PRODUCT_INFO_SUPPORT
修改alps/mediatek/config/$project/ProjectConfig.mk： MTK_PRODUCT_INFO_SUPPORT=yes
详情可参考DCC上文档《Customization in NvRAM Product Info feature》Page 10

2. 新增NvRAM项
如需在AP端新增NvRAM项，可以参考DCC上文档《Customization in NVRAM》；如不需要增加NvRAM项，请直接跳至Step3。
注意事项_1：
a) 如平台使用的是【eMMC】，新LID对应struct的size必须是512 byte的倍数；
b) 如平台使用的是【NAND】，新LID对应struct的size必须是page size对齐（即4K或2K）。

3. 将新加LID配置到product info
将对应的LID写入CFG_file_info.c的g_new_nvram_lid[]，填入正确的start_address和size；如不需要配置新加LID，请看注意事项_2。
注意事项_2：
a) 如平台使用的是【eMMC】，g_new_nvram_lid[]里面新LID的size必须要128K对齐；
b) 如平台使用的是【NAND】， g_new_nvram_lid[]里面新LID的size必须要blocksize对齐（4K pagesize对应的是256K，2K pagesize对应的是128K）。
c) g_new_nvram_lid[]里各LID总size不能超过partition table里pro_info的size。默认情况下，【eMMC】平台pro_info大小为3M，【NAND】平台pro_info大小为1M。

4. AP_CFG_REEB_PRODUCT_INFO_LID的配置
a) 如不需要配置AP_CFG_REEB_PRODUCT_INFO_LID在g_new_nvram_lid[]里面，可以直接移除，新加LID的start_address需要改成0。
b) 如保留AP_CFG_REEB_PRODUCT_INFO_LID在g_new_nvram_lid[]里面，则需要注意CFG_file_info.c的aBackupToBinRegion[]里面去掉AP_CFG_REEB_PRODUCT_INFO_LID。

5. Default value配置问题
如普通nvram项的配置，欲写入product info的nvram也需要在进行配置在g_akCFG_File[]（CFG_file_info.c），并在对应的xx_default.h和xx_file.h申明和定义default value。
但是，此处与普通nvram项不同的地方在于，当前的design中，写入product info的nvram项，自定义的default value是不生效的。
首次开机获取到的值，完全取决于当前/dev/pro_info这个raw分区里面的值：默认情况下，NAND的是0xff，eMMC的是0x00。

###After Customization###
客制化之后，配置到g_new_nvram_lid[]的LID对应的NvRAM data不再以文件形式存在/data/nvram/，而是直接写到了/dev/pro_info，数据不会同时存在两个地方。

【Platform】
目前，89之后的平台均支持，89之前的打了patch也支持。
```

## [FAQ13590] SD卡不识别等问题

```
1. 如果是所有SD卡都不识别，则请查看
[FAQ04249] 【sdcard-common】新开项目SDCard不识别，如何debug？
[FAQ07310] 【sdcard-driver】sd卡热插拔需要注意的几点？
[FAQ09005] [Storage]emmc LCA 版本T卡（sdcard）异常

2.部分SD卡不识别或只读，低概率出现：
请修改
\mediatek\custom\${project}\kernel\core\src\board.c
(/kernel/drivers/misc/mediatek/mach/mt6***/${project}/core/board.c)
struct msdc_hw msdc1_hw = {
.flags = //去除MSDC_UHS1、MSDC_DDR后看效果，如果没有改善接着再去除MSDC_HIGHSPEED看下
}
如果上面的修改对问题有改善，基本说明贵司的layout或者SD卡存在问题，
请提交硬件eService检查贵司的SD卡相关硬件设计和layout，谢谢！
```

## [FAQ09562] 关机动画和铃声没有完整播放就灭屏了

```
在我司默认的关机流程设计中，一般会根据运营商设置一个灭屏的时间，这个时间是基于运营商测试要求和用户体验考虑的。一般情况下，7S以内灭屏，可以让用户感知关机很快，而且在网络情况良好，系统稳定的情况下，关机的时间一般也会在10S以内；即使由于一些特殊原因，比如网络情况不好，也希望灭屏时间短，让用户体验更好。

如果关机铃声或者关机动画的时间大于灭屏的时间，就会出现动画和铃声没有播放完成就灭屏的情况。虽然可以修改代码，等待关机铃声和动画播放完成再灭屏，但是一般不建议关机铃声和动画太长，这样即使在系统比较稳定的情况下也会造成关机时间长的用户体验；而且当用户客制化其它关机铃声和关机动画时，关机的时间也会随之改变。因此，建议采用默认设计，缩短关机铃声和关机动画的时长。
```

## [FAQ05394] [Build]BT Profiles 详细介绍

```
蓝牙有很多Profile，代表这着向用户的许多种蓝牙应用，下面逐一详细介绍这些Profile。

MTK_BT_PROFILE_OPP：Object Push Profile  普遍用于文件、名片的传输，从文件管理器中通过蓝牙分享即使用该协议
MTK_BT_PROFILE_SIMAP  ：SIM Access Profile  车载蓝牙会通过该协议使用手机上的SIM服务，如通话等，仅将手机作为SIM卡槽，使用车载蓝牙的自带的无线通信模块
MTK_BT_PROFILE_PRXM   ：Proximity Monitor 
MTK_BT_PROFILE_PRXR   ：Proximity Reporter  以上两个选项为远程距离感应服务的两个角色，当使用该服务连接的两个设备距离拉大到一定范围（可设定）后，双方设备就会发出声音或震动的提示。典型应用是防丢器
MTK_BT_PROFILE_HIDH   ：Human Interface Device Host 该协议的典型应用为连接蓝牙键盘、鼠标等I/O外设
MTK_BT_PROFILE_FTP    ：File Transfer Profile 可以使用该设备浏览另一方蓝牙设备的文件系统，并可以对文件、目录进行下载、上传、修改、删除等操作
MTK_BT_PROFILE_PBAP   ：Phone Book Access Profile  电话本存取服务。高级蓝牙耳机或车载蓝牙可能会通过该协议获取手机通信录、通话记录等信息
MTK_BT_PROFILE_BPP    ：Basic Printing Profile  可通过此设备连接蓝牙打印机，不过其实OPP/BIP/SPP等协议均有可能用于连接打印机（取决于打印机支持哪种协议）
MTK_BT_PROFILE_BIP    ：Basic Imaging Profile  用于传输图片。从图库中分享图片即优先使用该协议。
MTK_BT_PROFILE_DUN    ：Dial-up Networking  用于蓝牙拨号上网
MTK_BT_PROFILE_PAN    ：Personal Area Network 蓝牙共享网络。具体说明及限制可参考ID: FAQ05031 ID: FAQ03951
MTK_BT_PROFILE_HFP    ：Hands-free Profile  连接蓝牙耳机、车载蓝牙最常用的协议，用于完成蓝牙基础通话、三方通话的功能。使用手机的无线通信模块，仅在手机和耳机、车载蓝牙之前传输AT控制命令和语音数据。
MTK_BT_PROFILE_A2DP   ：Advanced Audio Distribution Profile 播放音乐最常用的协议，通过音乐播放器听音乐时即会使用该协议将音乐传递到蓝牙耳机。
MTK_BT_PROFILE_MAPC = no     MAP Profile client
MTK_BT_PROFILE_MAPS = no     MAP Profile server 这两项为信息存取服务的两个角色。该协议用于在蓝牙设备见传输短信、彩信和电子邮件信息
MTK_BT_PROFILE_SPP    ：Serial Port Profile 虚拟串口协议。该协议是一个通用的模拟串口协议。Google 自带程序BluetoothChat即使用该协议。该协议通常被用来连接特种蓝牙外设，如特种打印机、指纹识别器等
MTK_BT_FM_OVER_BT_VIA_CONTROLLER = no      FM收听的声音通过BT传送给蓝牙耳机，在MT6628上该宏不能开
MTK_BT_POWER_EFFICIENCY_ENHANCEMENT = yes  对应到BT功率效能方面的feature，维持default设置就好
MTK_BT_PROFILE_AVRCP13 = no
MTK_BT_PROFILE_AVRCP14 = no    AVRCP用于控制音乐播放，如上一曲、下一曲、暂停、播放等。后面的数字都是指AVRCP的版本（1.3和1.4版本），default是AVRCP 1.0
MTK_BT_PROFILE_TIMEC = no    Time profile client
MTK_BT_PROFILE_TIMES = no    Time profile server 目前这两项MP版本未开放使用
```

## [FAQ04112] Android adb shell 无法启动 insufficient permissions for device 解决方案

```
原因是对应的usb device 没用权限访问，需要添加venderid. 
解决办法1：lsusb查看vendorId号，然后在/etc/udev/rules.d/目录下增加（或修改）51-android.rules文件。
增加一条记录：
SUBSYSTEM=="usb", SYSFS{idVendor}=="xxxx", MODE="0666" 其中xxxx是通过lsusb查看得到的值
常见的情况如下，我都列出来了：
# htc
SUBSYSTEM=="usb", SYSFS{idVendor}=="0bb4", MODE="0666"
# Motorola
SUBSYSTEM=="usb", SYSFS{idVendor}=="22b8", MODE="0666"
# Acer 0502
SUBSYSTEM=="usb", SYSFS{idVendor}=="0502", MODE="0666"
# Dell 413c
SUBSYSTEM=="usb", SYSFS{idVendor}=="413c", MODE="0666"
# Huawei 12d1
SUBSYSTEM=="usb", SYSFS{idVendor}=="12d1", MODE="0666"
# LG 1004
SUBSYSTEM=="usb", SYSFS{idVendor}=="1004", MODE="0666"
# Nvidia 0955
SUBSYSTEM=="usb", SYSFS{idVendor}=="0955", MODE="0666"
# Samsung 04e8
SUBSYSTEM=="usb", SYSFS{idVendor}=="04e8", MODE="0666"
# Sharp 04dd
SUBSYSTEM=="usb", SYSFS{idVendor}=="04dd", MODE="0666"
# Sony Ericsson ofce
SUBSYSTEM=="usb", SYSFS{idVendor}=="0fce", MODE="0666"
# ZTE 19d2
SUBSYSTEM=="usb", SYSFS{idVendor}=="19d2", MODE="0666"
解决办法2：
在51-android.rules中只写一句：
SUBSYSTEM=="usb", ENV{DEVTYPE}=="usb_device", MODE="0666"
```

## [FAQ04319] 如何修改默认小时制

```
修改文件alps\frameworks\base\packages\SettingsProvider\res\values\defaults.xml
增加代码<string name="time_12_24" translatable="false">24</string>
红色标记表示24小时制，也可以改为12（12小时制）

修改文件alps\frameworks\base\packages\SettingsProvider\src\com\android\providers\settings\DatabaseHelper.java
找到函数 loadSystemSettings()，在函数中增加以下语句：
loadStringSetting(stmt, Settings.System.TIME_12_24, R.string.time_12_24);
```

## [FAQ17417] 添加语言时如何查询该语言对应的language code和country code

```
在添加一种语言时，需要在配置文件中添加这个语言对应的language code和country code, 如何查询语言对应的language code和country code请参考如下方法。

(1)可先参考FAQ03761,其中有介绍google 支持的语言和mtk支持的语言，从中可查询到每种语言对应的language code和country code.
(2)对于当前系统没有支持的语言在上述FAQ中查询不到，可参考下面两个网址去查询。
language code：
https://zh.wikipedia.org/wiki/ISO_639-1
country code：
https://zh.wikipedia.org/wiki/ISO_3166-1
```

## [FAQ18291] country code table

## [FAQ17457] 如何判断系统是否支持一种语言

```
判断系统是否支持某种语言，可参考如下方法。

（1）参考FAQ17417，查询这种语言对应的language code和country code. 如旁遮普语（印度），对应的就是pa_IN(pa是language code, IN是country code);
（2）参考FAQ04009中添加语言的步骤。
1.是否有对应语言的icu资源。（可以看到external\icu\icu4c\source\data下coll、curr、lang、locales、region，zone这些子文件夹中都有pa.txt和pa_IN.txt）
2.系统中是否有对应字库。可以参考FAQ12255看看系统中是否有这种语言的对应字库。
3.在frameworks/base/core/res/res/下是否有对应的values-xx-rYY的文件夹(xx是language code, YY是country code，下同).
4.每个app对应的res目录下面是否有values-xx文件夹或values-xx-rYY文件夹.
5.如果是复杂语言，还需看看是否有对应的字体引擎（FAQ04009最后部分有介绍如何判断是否是复杂语言，判断复杂语言引擎支持情况可参考FAQ12442）。

如果以上回答都是yes,那就表示支持，如需打开它，参考FAQ04009中的第一步将它加在对应配置文件中。如不支持，对着上面步骤看看是缺少什么，对着FAQ04009一步一步添加即可。
```

## [FAQ10002] 如何修改Notifation Action Button的Icon和Text的位置

```
在阿拉伯,波斯等RTL语言下，对于一些含有action button的UI虽然app使用了android:supportsRtl属性，但是仅仅是action之间的位置发生翻转，而每个button的Icon和Text位置却没调换。
比如(下图所示)未接来电的systemui下拉通知栏的icon和text位置没有调换
如果要调整其位置，可以通过setTextViewCompoundDrawables(int viewId, int left, int top, int right, int bottom)函数去实现想要的效果。
下面的修改是在波斯语、阿拉伯语下把action button的图片放到文字的右边。

import java.util.Lcoale;
Notification.java（alps\frameworks\base\core\java\android\app）
private RemoteViews generateActionButton(Action action) {
    final boolean tombstone = (action.actionIntent == null);
    RemoteViews button = new RemoteViews(mContext.getPackageName(), tombstone ? R.layout.notification_action_tombstone : R.layout.notification_action);
    //modify
    String language = Locale.getDefault().getLanguage();
    if (language.equals("ar") || language.equals("fa")) {
        button.setTextViewCompoundDrawables(R.id.action0, 0, 0,action.icon, 0);
    } else {
        button.setTextViewCompoundDrawables(R.id.action0, action.icon, 0, 0, 0);
    }
    //modify
}

如果在其他地方要修改Button或者TextView的image和text的位置，可以直接调用TextView的函数setCompoundDrawables(Drawable left, Drawable top,Drawable right, Drawable bottom)就行。
```

## [FAQ12442] 如何判断复杂语言引擎支持情况

```
复杂语言处理引擎都是按照各个语言字符分别处理的，即如果2种语言字符相同，则他们可以共用一套引擎，比如阿拉伯语、波斯语、乌尔都语使用同一套引擎；印度语、孟加拉语使用一套引擎。
系统在处理字串时先是根据字串编码范围把字串分成若干小段，比如“asbc中国نحنddf”会分成“asbc”、“中国”、"نحن"、“ddf”4个子串，每个字串用一个Script标记这个字串是属于哪种语言。后面再根据这个Script变量分别调用不同的harfbuzz引擎对这些子串进行处理。
如下是KK版本支持的语言引擎接口。
harfbuzz-shaper.cpp(external\harfbuzz_ng\src\hb-old)
const HB_ScriptEngine HB_ScriptEngines[] = {
    // Common
    { HB_BasicShape},
    // Greek
    { HB_GreekShape},
    // Cyrillic
    { HB_BasicShape},
    // Armenian
    { HB_BasicShape},
    // Hebrew
    { HB_HebrewShape},
    // Arabic
    { HB_ArabicShape},
    // Syriac
    { HB_ArabicShape},
    // Thaana
    { HB_BasicShape},
    // Devanagari
    { HB_IndicShape},
    // Bengali
    { HB_IndicShape},
    // Gurmukhi
    { HB_IndicShape},
    // Gujarati
    { HB_IndicShape},
    // Oriya
    { HB_IndicShape},
    // Tamil
    { HB_IndicShape},
    // Telugu
    { HB_IndicShape},
    // Kannada
    { HB_IndicShape},
    // Malayalam
    { HB_IndicShape},
    // Sinhala
    { HB_IndicShape},
    // Thai
    { HB_BasicShape},
    // Lao
    { HB_BasicShape},
    // Tibetan
    { HB_TibetanShape},
    // Myanmar
#ifdef ZAWGYI_SUPPORT
    { HB_ZawgyiShape },
#else
    {HB_MyanmarShape},
#endif
    // GeorgianRecents
    { HB_BasicShape},
    // Hangul
    { HB_HangulShape},
    // Ogham
    { HB_BasicShape},
    // Runic
    { HB_BasicShape},
    // Khmer
    { HB_KhmerShape},
    // N'Ko
    { HB_ArabicShape}
};
JB版本的文件目录external\harfbuzz\src\，结构稍有不同。
PS：如果是新增一种复杂语言，可以先看看这个语言的字符是不是和已经支持的语言字符一样，如果是，则不需新增引擎。
```

## [FAQ09199] 切换到阿拉伯语、波斯等RTL语言音量调节图标没变化

```
这是 google 的 issue, google 也已经在最新的 JB 修正了, 修正的方法如下
1. \alps\frameworks\base\media\java\android\media\AudioService.java
在 handleConfigurationChanged() 增加一行  mVolumePanel.setLayoutDirection(config.getLayoutDirection()); 如下

private void handleConfigurationChanged(Context context) {
    try {
        .......
        mVolumePanel.setLayoutDirection(config.getLayoutDirection());
    } catch (Exception e) {
        Log.e(TAG, "Error retrieving device orientation: " + e);
    }
}
2. \alps\frameworks\base\core\java\android\view\VolumePanel.java 请新增一 API

public void setLayoutDirection(int layoutDirection) {
    mPanel.setLayoutDirection(layoutDirection);
    updateStates();
}
```

## [FAQ08961] 当前语言设置为阿拉伯语时，有的ListView的Item没有右对齐

```
ListView的Item是由TextView组成的，TextView会判断字符串是什么语言，如果是英文就左对齐，如果是阿拉伯语就右对齐。
如果需要使阿拉伯语下这样的TextView右对齐，下面有两点建议：
1、请把这些字串翻译成阿拉伯语，ListView的Item自然会右对齐；
2、如果不想翻译，可以在Adapter的getView方法中判断当前语言，如果当前语言是阿拉伯语，可以设置Item的Gravity属性为RIGHT，大概如下：
String locale = Locale.getDefault().getLanguage();
if(locale.equals("ar")){
   textView.setGravity(Gravity.RIGHT);
}else{
   textView.setGravity(Gravity.LEFT); 
}
```

## [FAQ09127] 为什么输入RTL字符时，光标分成两段

```
首先需要知道RTL语言和LTR语言，RTL(right to left)语言是指这种语言的字符的输入和显示顺序是从右到左的，一般情况下该语言字符串在手机中都会靠右显示，常见的RTL语言如阿拉伯语(ar)，波斯语(fa)，乌尔都语(ur)，希伯来语(he/iw)等；与之对应的，LTR(left to right)语言是指从左到右输入和显示的语言，世界上大多数语言属于LTR语言，常见的英语，中文，意大利语，德语，西班牙语，葡萄牙语等等都是LTR语言。

光标分2个部分的原因是：RTL和LTR语言的显示方向是不一样的，当它们混合输入时会出现光标跳动，比如一开始输入阿拉伯语，方向是从右到左，输入英语时，方向是从左到右，此时光标会跳动到最左边的阿拉伯语上。这种混合输入可以到google网站上去体验一下。
而采用多种语言算法之后，就不会出现这种光标跳动现象了，当输入方向发生变化时，会将光标分为2个部分，分别在需要变化方向的字符的2旁，有一个是主光标，一个是副光标。主光标是根当前字符的输入方向一致的，而副光标是原本的光标位置。
 
因此，这样的设计是为了多种文字混合输入时，给用户较好的体验，并非BUG。
```

## [FAQ10009] 阿拉伯语、波斯语等RTL语言下部分控件位置不对

```
一些RTL语言比如阿拉伯语、波斯语，其layout布局以及Text显示方向是从右到左的，android4.2版本及以后新增属性android:supportsRtl可以实现这种功能。然而对于一下特殊的字符串，比如波斯语和英文混合的字串、纯英文字串以及一些特殊的控件并不能实现从右到左显示。对于这些问题，下面给出一些例子和解法。

 关于supportsRtl的使用可以参考：FAQ08672

1、混合字符或者纯英文下，TextView没有居右。

A、找到其定义的layout文件

用 match_parent替换wrap_content，如果替换后还是没有效果新增

android:textDirection="locale”这个属性。

例如Preference summary英文下没有居右，可以如下修改

frameworks\base\core\res\res\layout\Preference_holo.xml

<TextView android:id="@+android:id/summary"

android:layout_width="match_parent"

……

android:textDirection="locale"

B、如果找不到其layout，可以在code中使用如下函数进行设置

setGravity(Gravity.RIGHT);

setTextDirection(TEXT_DIRECTION_RTL);

例如spinner控件波斯语下英文字串没有居右，可以如下修改

public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {

String language = Locale.getDefault().getLanguage();

if(language.equals("ar")||language.equals("fa")){

   TextView textview =(textview )view;

textview.setGravity(Gravity.RIGHT);

 }

……

2、对于一些控件没有居右或者layout布局错乱的问题

应检查layout的“left/right”布局属性，是否已经改为对应的”start/end”属性。具体例子可以参考FAQ08672。

3、对于一些图片方向不对的问题

对于这些图片需要按照RTL重新设计，然后放到drawable-ldrtl-hdpi文件夹下。比如actionbar的那个竖线，使用的地方如下

<selector xmlns:android="http://schemas.android.com/apk/res/android">

<item android:state_pressed="true"

android:drawable="@drawable/btn_cab_done_pressed_holo_dark" />

<item android:state_focused="true" android:state_enabled="true"

android:drawable="@drawable/btn_cab_done_focused_holo_dark" />

<item android:state_enabled="true"

android:drawable="@drawable/btn_cab_done_default_holo_dark" />

上面那些图片位置在frameworks\base\core\res\res\drawable-hdpi，重新绘制后放到

frameworks\base\core\res\res\drawable-ldrtl-hdpi目录下

4、其他RTL相关的问题可以参考，

FAQ10002： 如何修改Notifation Action Button的Icon和Text的位置

FAQ09199： 切换到阿拉伯语、波斯等RTL语言音量调节图标没变化

FAQ09094： RTL语言下电话号码从右向左显示的问题

FAQ08961：当前语言设置为阿拉伯语时，ListView的Item有的左对齐，有的右对齐

FAQ09127： 为什么输入RTL语言时，光标分成两段显示
```

## [FAQ08672] 如何实现界面布局根据阿拉伯语、波斯语等RTL语言而反转

```
android4.2 新增了RTL布局镜面反射，这种镜面反射其实就是根据语言显示方向调整layout布局，但google只是对少数app进行了设置，比如setting。如果想要在其他应用中使用这特性可以按照如下进行修改：
1、在AndroidManifest.xml声明文件的<application>元素中，添加” android:supportsRtl=true”。
2、把android:targetSdkVersion="16" 改成17。
3、修改应用程序中layout的“left/right”布局属性，改为对应的”start/end”布局。

注意：状态栏比较特殊，如果要发送的通知也可以使用RTL布局，除了修改SystemUI模块的AndroidManifest.xml文件，还需要修改发送通知的ap的AndroidManifest.xml文件。

如修改radiabutton使其有这种效果，可以修改文件
packages\apps\Settings\res\layout\preference_radiobutton.xml
如下地方
<RadioButton
    android:id="@+id/preference_radiobutton"
    android:layout_width="wrap_content"
    android:layout_height="match_parent"
    android:layout_alignParentEnd="true"
    android:paddingStart="30dip"
    android:paddingEnd="20dip"
    android:focusable="false"/>

<TextView android:id="@+id/preference_title"
    android:layout_width="wrap_content"
    android:layout_height="match_parent"
    android:textAppearance="?android:attr/textAppearanceMedium"
    android:layout_alignParentStart="true"
    android:layout_marginStart="9dip"
    android:layout_marginTop="6dip"
    android:layout_marginBottom="6dip"
    android:paddingEnd="60dip"
    android:maxLines="1"
    android:singleLine="true"
    android:ellipsize="marquee"
    android:focusable="false"/>

关于supportsRtl的详细介绍可以浏览如下网页

http://android-developers.blogspot.tw/2013/03/native-rtl-support-in-android-42.html
```

## [FAQ08718] 【TimeZone】如何修改时区的显示名称

```
目前对于有些地区，很多国家会使用一个时区，显示的名称也是一样，比如对于欧洲，很多城市使用“欧洲中部时间”“中欧夏令时”，非洲国家也是类似的。对于有些客户，可能有定制显示需求，对于某些时区，不显示“xx中部时间”，而是显示“xx时间”，比如下面会以荷兰阿姆斯特丹为例，目前在手机Setting中选择“Amsterdam,Berlin”后在Date&Time界面会显示“Central European Summer Time”，下面是修改荷兰语下这个显示为自定义名称的过程。

【Solution】：

时区Europe/Amsterdam目前显示出来的时间是“欧洲中部时间”或“欧洲中部时间”，如果要修改荷兰语下显示为“阿姆斯特丹时间”或其他自定义的显示，请follow下面的修改：

1. 找到时区ID
时区id并不是城市名称，手机显示到时区列表上的时区名称与时区id有映射关系，可以通过查看Settings中的timezones.xml来确定，package/apps/Settings/res/xml-zh/timezones.xml是中文。这样可以找到Amsterdam,Berlin的时区id是Europe/Amsterdam。

2. 修改metaZones.txt文件（android kk external\icu4c\data\misc\
  android L external\icu\icu4c\source\data\misc\
  android M external\icu\icu4c\source\data\misc\）
1)    修改mapTimezones
修改的目的是把时区添加到自己定义的显示规则中，这样通过时区ID  Europe/Amsterdam就可以得到该显示规则Europe_Amsterdam。这个步骤分2步：

a)      定义自己的显示规则名称
         比如我定义了新的规则Europe_Amsterdam， 需要在mapTimezones中添加进去，mapTimezones中顺序是按字母排序的，所以Europe_Amsterdam这个规则要添加到Europe_Central的前面，如下：

Europe_Amsterdam{

}

b)     将要修改的时区从原规则中删除，添加到自定义的规则中
找到要修改的时区，比如Europe/Amsterdam在Europe_Central中，

剪切NL{“Europe/Amsterdam”}，粘贴到自定义的时区显示规则中，如下所示：

Europe_Amsterdam{

NL{“Europe/Amsterdam”}

}

如果此文件中没有包含要修改的时区，那么就需要添加此时区，添加的内容如上面所示，时区前面的两个字母是国家代码。

2)    修改metaZoneinfo
添加meta信息,这样就可以通过显示规则名称Europe_Amsterdam得到meta信息Europe:Amsterdam。

“Europe:Amsterdam”{
{“Europe_Amsterdam”}
}

3. 修改zone/nl.txt文件（adnroid kk external\icu4c\data\
android L external\icu\icu4c\source\data\

android M external\icu\icu4c\source\data\）
不同的txt文件代表的是不同语言，语言和区域代码可通过查询ISO-3166-1和ISO-639标准确定。

定义在界面显示的字串，这样根据之前得到的meta信息可以得到要显示的字串。

同样的，名称是按照字母排序的，所以在Europe_Central前面添加，如下：

“meta: Europe_Amsterdam”{

ld{“夏令时间显示名称”}

ls{“标准时间显示名称”}

}

4. 编译ICU资源
请参考FAQ04011进行编译和测试
```

## [FAQ11960] 印尼语下时间格式显示成hh.mm

```
KK版本系统语言切换到印尼语，发现时间格式显示成hh.mm,如果想要改成hh：mm改如何操作。

这个时间格式来自于底层ICU资源，如下定义
external/icu4c/data/locales/id.txt
gregorian{
    DateTimePatterns{
    "h.mm.ss a zzzz",
    "h.mm.ss a z",
    "h.mm.ss a",
    "h.mm a",
    ……
如果是其他语言有类似问题可以参照修改
```

## [FAQ11512] 语言名称客制化问题

```
Android语言名称定义在external/icu4c/data/lang/各个语言txt文件中 ，如zh.txt(中文简体):
Languages{
    aa{"阿法文"}
    ab{"阿布哈西亚文"}
    ace{"亚齐文"}
……

调用这些字串接口定义在Locale.java（libcore\luni\src\main\java\java\util)，主要函数如下：
(1)获得指定语言环境(locale)下语言名称
public String getDisplayLanguage(Locale locale)

(2)获得系统默认语言环境的语言名称
public String getDisplayLanguage()

(3) 获得指定语言环境(locale)下带有使用国家的语言名称
public String getDisplayName(Locale locale)

(4) 获得系统默认语言环境下带有使用国家的语言名称
public String getDisplayName()
因此如果要客制化语言名称可以有如下几种方法
1、修改ICU资源，如把aa{"阿法文"}改为aa{"阿发闻"}
这个修改需要编译ICU资源才会起效，如何编译可以参考：FAQ04011
2、修改Locale.java相关函数，如修改菲律宾语返回值，可以参考FAQ11034
3、也可以在app层做相关修改，如setting app中的中文定制，具体可以参考FAQ09198

需要注意的是方法1、2的修改可能导致CTS测试fail，有些语言名称是不能修改的，具体可以参考LocaleTest.java(libcore\luni\src\test\java\libcore\java\util)
```

## [FAQ08671] 音频ID3、文本编码问题

```
Android在编码这块主要指的是音频ID3解码和文本解码。
1、  音频ID3解码。
Android默认支持的编码格式有，utf-8、unicode、shiftJIS、gbk(gb2312)、big5、iso8859-1、EUCKR。

2、  文本解码。
Android默认的文本解码使用的是htmlviewer。其编码识别原理是根据文本字符计算各个编码的可信度，可信度高的就会用来解码。这种原理其实是为每种编码建立一个“常用字符表”，然后计算每种编码的匹配度。在计算可信度的时候有一些特殊处理，比如当字符个数比较少(少于10个)，此时可信度非常低，如果文本字符又不是“常用的字符表”中的字符，这样可信度几乎为0。例如，中文txt如果字符个数少于10，且不是“常用字符表”中的字符就会出现乱码。基于其的编码识别的缺陷，MTK在ICS及以后的版本就关闭了htmlviewer对txt文本的识别。需要补充的一些常用编码是支持的，但是解码可信度却不一定高，详情可参考如下：

<a>常用编码列表fCSRecognizers

csdetect.cpp(alps\external\icu4c\i18n)

<b>常用字符表

csrmbcs.cpp(alps\external\icu4c\i18n)

如中文gb18030，commonChars_gb_18030[]
如果需要更好的支持文本解码，建议内置第三方文本解码器。
```

## [FAQ18543] [NW]如何设置CDMA only模式

```
如果要设置为CDMA Only模式，需要进入*#*#3646633#*#* 工模做如下设置：
1. 工模--> C2K IR Setting,选择CDMA Only；然后重启，重新启动后，只会开启CDMA Modem的Radio。
2. 工模--> CDMA Network select，里面可以选择Hybrid / CDMA 1x Only / EVDO Only
```

## [FAQ10020] 一些字符显示不清晰(修改TTF字体文件)

```
这个问题可以通过修改字库解决，方法如下：

1、找到孟加拉语字库Lohit-Bengali.ttf(external/lohit-fonts/lohit-bengali-ttf/)
2、使用字库工具打开上述字库文件。字库工具FontCreater5.6载网址为：    http://so.pc6.com/?keyword=FontCreat&searchType=down
3、Ctrl+F查找$0985这个字形,右键->”编辑”,调整其笔画粗细,如下图所示：
4、修改后可以push到system/fonts下,然后重新开机查看效果

[FAQ12287] 如何修改或添加字库字体
[FAQ09950] 越南语字母ỡ显示为õ
[FAQ04224] KK版本字库文件介绍
```

## [FAQ09896] 动态切换字体过程中内存占用不断增加的解决办法

```
按照如下原DMS文档(现已更新)，实现了切换字体功能
Font Install and Runtime Change On ICS guideline.doc
 
按照参考文档完成此feature之后,发现不断在不同字体之间切换,手机内存占用会不断增加
这是因为typeface的createFromAsset接口有BUG,每调用一次该接口,native memory占用就会增加,这个问题属于Google Bug,目前尚无完美的解决方案,但是可以使用下面的方法work around.
 
[SOLUTION]
1.修改framework中的typeface.java文件
增加以下代码:
import java.util.Hashtable;
 private static final String TAG = "Typefaces";
 private static final Hashtable<String, Typeface> cache = new Hashtable<String, Typeface>();
 public static Typeface get(AssetManager mgr, String assetPath) {
  synchronized (cache) {
   if (!cache.containsKey(assetPath)) {
    try {
     Typeface t = Typeface.createFromAsset(mgr, assetPath);
     cache.put(assetPath, t);
    } catch (Exception e) {
     return null;
    }
   }
   return cache.get(assetPath);
  }
 }
 
2.修改Textview.java,
将Typeface.createFromAsset(...)替换成新加的Typeface.get(...)接口
根据我司提供的文档,需要修改的地方有2处,分别在textview构造函数,与setTextAppearance函数中.
```

## [FAQ08948] 【DateFormat】如何修改设置中待选的日期格式

```
日期格式选择时，弹出窗口中的日期格式是从R.array.date_format_values中拿到的。
文件：package/apps/Settings/res/values/arrays.xml （所有语言都是这个文件）
描述：
 <string-array name="date_format_values" translatable="false">
        <!-- The blank item means to use whatever the locale calls for. -->
        <item></item>
        <item>MM-dd-yyyy</item>
        <item>dd-MM-yyyy</item>
        <item>yyyy-MM-dd</item>
        <item>EE-MMM-d-yyyy</item>
        <item>EE-d-MMM-yyyy</item>
        <item>yyyy-MMM-d-EE</item>
    </string-array>
第一个空的item即为默认的日期格式，请不要修改；
第2-7个对应显示出来的6个日期格式，可以修改，也可以增加新的格式。
 
需要注意的是，在格式中只能用系统能够识别的字符来制定格式，yyyy是年份，MM是月份，dd是日，EE是星期几。
 
相关逻辑：
然后，在DateFormat的getDateFormatStringForSetting方法中，对取得的格式进行了处理，对于每一项都会进行替换处理。
 
比如对于yyyy-MMM-d-EE这个格式，在系统语言为中文时，就会找到
Donottranslate-cldr.xml (mediatek\frameworks\base\res\res\values-zh-rCN)中的下面这一项：
<string name="year_month_day_wday">"%s年 %s %s日, %s"</string>
这样显示到界面上就是“2013年12月31日，星期一”
对于 KK和L ，M版本定义在：
frameworks\base\core\res\res\values-zh-rCN\donottranslate-cldr.xml中的numeric_date_template；

 
对于非中文的其他语言，会调用Donottranslate-cldr.xml (mediatek\frameworks\base\res\res\values)中的对应字符串进行替换。
所以中文和其他语言是不一样的。 
```

## [FAQ17570] [Audio APP]安装多个音乐播放器时，如何将某个播放器设为默认播放器

```
需要修改 
/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java
 
共有如下3步：
1：在 systemReady 方法的最后加入 setDefaultMusicPlayer(); 方法的调用
2：后面是实现setDefaultMusicPlayer 这个方法，具体实现代码如下：
 
public void setDefaultMusicPlayer() { 
final String strComponentName = "com.android.music/com.android.music.AudioPreviewStarter";//这是定义希望默认启动的播放器对应有 activity 全名，本例是以 com.android.music 为例
ComponentName defaultLauncher = ComponentName.unflattenFromString(strComponentName);
Log.e(TAG,"defaultLauncher========"+defaultLauncher);
if (defaultLauncher != null) {
Intent intent = new Intent(Intent.ACTION_VIEW);
intent.addCategory(Intent.CATEGORY_DEFAULT);
Uri uri = Uri.parse("file://");
intent.setDataAndType(uri, "audio/mpeg");
List<ResolveInfo> resolveInfoList = queryIntentActivities(intent, intent.getType(), 
PackageManager.GET_INTENT_FILTERS, 0);
if (resolveInfoList != null) {
int size = resolveInfoList.size();
Log.e(TAG,"size++++++++++=="+size);
Log.e(TAG,"defaultLauncher.getPackageName()=="+defaultLauncher.getPackageName());
for (int j = 0; j < size;) {
final ResolveInfo r = resolveInfoList.get(j);
Log.e(TAG,r.activityInfo.packageName+"/ activity: "+r.activityInfo.name);
if (!r.activityInfo.packageName.equals(defaultLauncher.getPackageName())) {
resolveInfoList.remove(j);
size -= 1;
}else{
j++;
}
}
ComponentName[] set = new ComponentName[size];
Log.e(TAG,"size============="+size);
int defaultMatch = 0;
for (int i = 0; i < size; i++) {
final ResolveInfo resolveInfo = resolveInfoList.get(i);
Log.d(TAG, resolveInfo.toString());
set[i] = new ComponentName(resolveInfo.activityInfo.packageName,
resolveInfo.activityInfo.name);
if (defaultLauncher.getClassName().equals(resolveInfo.activityInfo.name)) {
defaultMatch = resolveInfo.match;
}
}
Log.e(TAG,"defaultMatch="+ Integer.toHexString(defaultMatch));
try{ 
IntentFilter filter = new IntentFilter(); 
filter.addAction(Intent.ACTION_VIEW); 
filter.addCategory(Intent.CATEGORY_DEFAULT); 
filter.addDataType("audio/mpeg");//add this line 
Log.e(TAG,"defaultMatch============"+defaultMatch);
addPreferredActivity2(filter, defaultMatch, set,defaultLauncher);
}catch (IntentFilter.MalformedMimeTypeException e) { 
e.printStackTrace(); 
}
}
}
}

public void addPreferredActivity2(IntentFilter filter, int match,ComponentName[] set, ComponentName activity) {
Log.d(TAG,"addPreferredActivity2 is called.");

synchronized (mPackages) { 
Slog.i(TAG, "Adding preferred activity " + activity + ":");
filter.dump(new LogPrinter(Log.INFO, TAG), " ");
mSettings.editPreferredActivitiesLPw(0).addFilter(new PreferredActivity(filter, match, set, activity,true));
mSettings.writePackageRestrictionsLPr(0); 
}
}
 
3: 修改此文件中的 findPreferredActivity 方法，在如下参考行相对位置加入对应代码：
if (always && !pa.mPref.sameSet(query, priority)) {//参考行
//add begin
if(intent !=null && intent.getAction().equals("android.intent.action.VIEW") && intent.getType().equals("audio/mpeg")){
Slog.i(TAG, "Result set NOT change for "
+ intent + " type " + resolvedType);
Slog.v(TAG, "Returning preferred activity: "
+ ri.activityInfo.packageName + "/" + ri.activityInfo.name);
changed = false;
return ri;
}
//add end
Slog.i(TAG, "Result set changed, dropping preferred activity for "
+ intent + " type " + resolvedType);//参考行
if (DEBUG_PREFERRED) {
Slog.v(TAG, "Removing preferred activity since set changed "
+ pa.mPref.mComponent);
}
pir.removeFilter(pa);
// Re-add the filter as a "last chosen" entry (!always)
PreferredActivity lastChosen = new PreferredActivity(
pa, pa.mPref.mMatch, null, pa.mPref.mComponent, false);
pir.addFilter(lastChosen);
changed = true;
return null;
}
```

## [FAQ08273] [Audio Profile]如何设置视频来电的默认铃声

```
背景：
原始设计语音来电铃声和视频来电铃声是一起设置的。即设置的默认铃声同时是语音来电和视频来电的铃声。
 
需求：
只想单独设置视频来电的默认铃声。
 
实现思路：
参考原先来电铃声的设置机制，给视频来电铃声单独设置属性写默认的铃声名称，然后在文件扫描时，判断扫描到的文件是设置的默认视频铃声的文件名，则在database中填写视频来电的键值为此铃声；
 
PS:被设置的铃声首先要存在于系统中，关于如何添加系统铃声请参考”FAQ06323[Audio Profile]如何添加以及删减特定的默认通知铃声，如何设置默认铃声”；
 
[SOLUTION]
 
1，添加Video Call默认铃声的属性：
alps\build\target\product\core.mk中添加“ro.config.video_call”：

PRODUCT_PROPERTY_OVERRIDES := \
    ro.config.notification_sound=Proxima.ogg \
    ro.config.alarm_alert=Alarm_Classic.ogg \
    ro.config.ringtone=Backroad.ogg \
    ro.config.video_call=VideocallRt.ogg

 
2，添加对扫描到文件的判断是否是默认Vide Call的默认铃声：
alps\frameworks\base\media\java\android\media\mediascanner.java:

1),添加成员变量用做后面的判断：
private String mDefaultRingtoneFilename;
private String mDefaultVideocallFilename;
private boolean mDefaultRingtoneSet;
private boolean mDefaultVideoCallSet;
private static final String RINGTONE_SET = "ringtone_set";
private static final String VIDEOCALL_SET = "videocall_set";

2):添加读取video call默认铃声的系统属性：
private void setDefaultRingtoneFileNames() {
        mDefaultRingtoneFilename = SystemProperties.get(DEFAULT_RINGTONE_PROPERTY_PREFIX
                + Settings.System.RINGTONE);
        mDefaultVideocallFilename = SystemProperties.get(DEFAULT_RINGTONE_PROPERTY_PREFIX
                + Settings.System.VIDEO_CALL);//add this line
...
    }
 
3):添加对扫描到的文件是否是视频来电默认铃声的判断：
参考标有//start modify”和//end modify”中间包含的为添加整段code，"//add this line"和”Modify this line"为添加添加的语句和修改的语句。
并请留意“else if (ringtones && doesSettingEmpty(RINGTONE_SET)&&!videocall) {”中要一定注释掉对VideoCall的设置：

private Uri endFile(){
       boolean isVideoCall = false; //add this line;
       boolean isVoiceCall = false; //add this line, in case the video call and voice call have same ringtone;
.....
 if (notifications &&((mWasEmptyPriorToScan && !mDefaultNotificationSet) ||
                        doesSettingEmpty(NOTIFICATION_SET))) {
                                ....   
//start modify
} else if(ringtones && ((mWasEmptyPriorToScan && (!mDefaultRingtoneSet||!mDefaultVideoCallSet)) || doesSettingEmpty(RINGTONE_SET)|| doesSettingEmpty(VIDEOCALL_SET))) {
                    if (TextUtils.isEmpty(mDefaultRingtoneFilename) ||
                            doesPathHaveFilename(entry.mPath, mDefaultRingtoneFilename)) {
                        needToSetSettings = true;
                         isVoiceCall = true; //add this line
                        /// M: Adds log to debug setting ringtones.
                        Xlog.v(TAG, "endFile: needToSetRingtone=true.");
                    }
                    if (TextUtils.isEmpty(mDefaultVideocallFilename) ||
                            doesPathHaveFilename(entry.mPath, mDefaultVideocallFilename)) {
                        needToSetSettings = true;
                        isVideoCall = true;
                        /// M: Adds log to debug setting ringtones.
                        Xlog.v(TAG, "endFile: needToSetRingtone=true.");
                    }

                } else if (alarms && ((mWasEmptyPriorToScan && !mDefaultAlarmSet) ||
                        doesSettingEmpty(ALARM_SET))) {
                      ...                   
}
 
...
if(needToSetSettings) {
                if (notifications && doesSettingEmpty(NOTIFICATION_SET)) {
                  .....
//start modify
                } else if (ringtones && (doesSettingEmpty(RINGTONE_SET)||doesSettingEmpty(VIDEOCALL_SET)) {
                    if(isVideoCall ){
                     setSettingIfNotSet(Settings.System.VIDEO_CALL, tableUri, rowId);
                    setProfileSettings(RingtoneManager.TYPE_VIDEO_CALL, tableUri, rowId);
                    mDefaultVideoCallSet = true;
                    setSettingFlag(VIDEOCALL_SET);
                    }
                   if(isVoiceCall ){
                    setSettingIfNotSet(Settings.System.RINGTONE, tableUri, rowId);
                   // setSettingIfNotSet(Settings.System.VIDEO_CALL, tableUri, rowId); //modify this line
                    setSettingIfNotSet(Settings.System.SIP_CALL, tableUri, rowId);
                    setProfileSettings(RingtoneManager.TYPE_RINGTONE, tableUri, rowId);
                   // setProfileSettings(RingtoneManager.TYPE_VIDEO_CALL, tableUri, rowId);//modify this line
                    setProfileSettings(RingtoneManager.TYPE_SIP_CALL, tableUri, rowId);
                    mDefaultRingtoneSet = true;
                    setSettingFlag(RINGTONE_SET);
                    }

                    Xlog.v(TAG, "endFile: set ringtone. uri=" + tableUri + ", rowId=" + rowId);
                 //end modify
                }else if (alarms && doesSettingEmpty(ALARM_SET)) {
                   ....
            }
```

## [FAQ13579] [Audio framework]后台播放music，如何判断是哪个app播放

```
这是一个 change feature 的实现
此 feature 的目的是查询当前是哪个 app 正在播放音乐

[SOLUTION]
1: 修改 frameworks\base\media\java\android\media\IAudioService.aidl, 加入方法声明:
String getFocusedPackageName();

2: frameworks\base\media\java\android\media\AudioService.java 中加入方法:
public String getFocusedPackageName(){
    return mMediaFocusControl.getFocusedPackageName();
}

3: MediaFocusControl.java 增加方法
protected String getFocusedpackageName(){
    synchronized(mAudioFocusLock){
    if(mFocusStack.empty()){
        return "";
    }else
        return mFocusStack.peek().getPackageName();
    }
}

4: FocusRequester.java增加方法
public String getPackageName(){
    return mPackageName;
}
 
则上层通过调用 AudioService 的 getFocusedPackageName 接口即可获取到需要的数据
 
相关FAQ:
FAQ12909 [Audio Common]耳机按键功能定制: 单击:播放/暂停音乐，双击:下一首，三击:上一首
FAQ14329 [如何在Framework层互斥两个第三方音乐播放器]
FAQ14660 音量警告提示框选择OK，重启后再按侧键增大音量希望还会弹出音量警告提示框
FAQ15283 [Audio Driver] 手机放音乐时连接音箱, 将音箱音量调到最大时，音乐暂停
```

## [FAQ09402] [Audio App]WMA格式的支持/关闭

```
WMA格式的支持:
1.客户需要跟微软签订license
2.MTK内部查询确认客户有license后，申请patch:
a.在KK版本之前
mediatek/config/$project/projectconfig.mk中开启MTK_ASF_PLAYBACK_SUPPORT= yes
b.在KK版本之后（含）
mediatek/config/$project/projectconfig.mk中开启
MTK_WMA_PLAYBACK_SUPPORT=yes
MTK_SWIP_WMAPRO=yes
 
WMA格式的关闭:
有些客户没有跟微软签订license, 却发现也可以播放 wma 文件, 此时需要通过以下方法关闭 wma 文件的播放支持
到 mediatek/config/common/ProjectConfig.mk 中找到以下两个宏的定义 (KK 版本)
MTK_WMV_PLAYBACK_SUPPORT
MTK_WMA_PLAYBACK_SUPPORT
把它们的值都改为 no
```

## [FAQ18471] 俄罗斯收到Class0短信下拉状态条和锁屏界面显示空白内容

```
1.首先要确认是否用户收到的Class0短信，查看方式在Radiolog中查找CMT，将CMT后面带的数字例如 07919762020033F1240B919752101008F90010616032019201210355F618
复制到PDUspy工具中，粘贴在Manual --》incoming中，然后点Decode。解析出来的画面如下：红色框中显示的就是Class0 message.
 
按照spec 规定class 0 的 SMS 的，表示 只是给用户显示，不能存储。
目前的design没有显示内容和号码和 不能点击的原因，是因为class 0的信息没有存储到数据库中。

在google default code中class0 sms没有弹notification的功能 ，
所以针对这样的问题 ，
一种解决方法，和google 原始的设计 一样，直接 注释 掉 notifyClassZeroMessage ，当有class0 的sms 不在notifycation 里提醒。
 
另一种，如果一定要弹notification的功能，若需要考虑显示的话，则可以考虑显示最近一条的信息。可以考虑参考如下方法修改：

1. 修改MessagingNotification.notifyClassZeroMessage()，将body传递进去
public static boolean notifyClassZeroMessage(Context context, String address, String body) {
2. 并在notification中显示出来，大约在MessagingNotification的1888行
Notification notification = new Notification.Builder(context)
.setContentTitle(address)
.setContentText(body)
.setSmallIcon(R.drawable.stat_notify_sms).build();
3. 修改其调用的地方SmsReceiverService, 大约在676行
MessagingNotification.notifyClassZeroMessage(this, msgs[0]
.getOriginatingAddress(), messageChars.toString());

还有哪些短信类型？？？？？？
PDUSpy工具下载？？？？？？
```

## [FAQ07233] 如何在设置中默认打开EPO，AGPS功能以提高用户体验

```
alps\mediatek\frameworks\base\agps\etc\agps_profiles_conf.xml
  <agps_conf_para
    agps_enable="no"  ==> 改成"yes"
    disable_after_reboot="no" ==> 保持"no"
alps\mediatek\frameworks\base\epo\etc\epo_conf.xml
  <epo_conf_para
   epo_enable="no"  ==> 改成"yes"
   auto_enable="no"  ==> 改成"yes”
```

## [FAQ02932] 把AGPS默认打开，请问如何修改

```
如果是第一次开机就默认开启A-GPS，您只需要修改
alps\vendor\mediatek\etc\agps_profiles_conf.xml文件中的agps_enable 有被设置为如下即可：
agps_enable="yes"

另外，A-GPS的开启还需要其他的一些条件，包括
1.有开启GPS
2.当前有已经连接的数据连接。

所以，如果是上个文件中的值有被设置为yes，而在开机时GPS没有开启，或者是数据连接没有开启，也不会自动开启A-GPS。需要end user手动进入到setting内开启。

UI将Agps开启并不表示Agps的会话立即被触发，只是表示有机会被GPS调用而启动。
```

## [FAQ02930] 设置 - 位置 - AGPS设置 - 使用配置 默认是GOOGLE， 如何修改默认成别的值,如Nokia

```
修改agps_profiles_conf.xml中的
default_profile="GOOGLE"
修改为
default_profile="NOKIA"
即可。
```

## [FAQ02929] AGPS的协议版本

```
FDD2上面的A-GPS已經有通過FTA的所有測項,CP + SUPL v1.0.

JB2之后版本支持SUPL2.0兼容1.0 
不過由于实际网络没有支持SUPL 2.0的server
为了避免发出的SUPL START带2.0版号会被Sever拒绝，出厂设置都是设成仅支持SUPL1.0

所以 SUPL 2.0 仅限于Lab测试使用

在JB5有修正设计，即使手机设置没有Enable  SUPL 2.0
但是网络发起定位（NI）的SUPL-INIT中，Sever田的版号是2.0 我们就会以2.0的版号回复
所以JB5开始SUPL 2.0的开关只会影响手机发起的（SI）部分只會影響手機發起(SI)部分

/alps/mediatek/frameworks/base/agps/etc/agps_profiles_conf.xml
supl_version: (for UP only)
choose which SUPL version you want to use
Available value: 1, 2

目前设置
supl_version="1"
```

## [FAQ03537] AGPS SUPL服务器客制化

```
1，获取当前有效AGPS配置接口
AgpsProfileManager mProfileMgr = AgpsProfileManager.getProfileManager(context);
MtkAgpsProfile profile = mProfileMgr.getCurrentProfile()；
String name = profile.name;                      // 进行查询或者设置的依据
String slpName = profile.slpName;          // 在AGPS设置中的UI显示
String backupsName = profile.backupSlpNameVar;  // 只是个备份名字，暂无其他作用
String addr = profile.addr;                          // SUPL IP地址
int port = profile.port;                        // SUPL 端口
int tls = profile.tls;                      // 是否要安全认证，0不需要，1需要
int showType = profile.showType; 
// 显示类型，0表示总是显示，1表示工厂模式下显示，2根据运营商码显示

2，获取系统内其他AGPS配置接口
MtkAgpsProfile profile = mProfileMgr.getProfile("name");
// name 在实际使用中只能用已经成功在数据库中保存的profile code 进行代替(如GOOGLE，NOKIA或者自己配置成功的)。

3，设置当前有效AGPS接口
mProfileMgr.setCurrentProfile（"GOOGLE"）；
// GOOGLE 可以用NOKIA或者自己修改后的profile code 代替。
mProfileMgr.switchAgpsProfile()； // 这个函数调用后才可以使得刚才设置项立即生效。

4，修改系统内的AGPS配置接口
// updateItem(String profile_name, String item_name, String value)
mProfileMgr.updateItem(mProfileMgr.getCurrentProfileCode(), //当前有效AGPS服务器
    mProfileMgr.PROFILE_PORT, "7275");
// 这种更改的方法profile_name可以是所有已经写入到系统的profile.name，
// item_name只能是mProfileMgr.PROFILE_NAME/mProfileMgr.PROFILE_ADDRESS/
// mProfileMgr.PROFILE_PORT/mProfileMgr.PROFILE_TLS中的一个

5，新增一个有效Agps服务器接口
ContentValues values = new ContentValues();
values.put(AgpsProfileColumns.PROFILE_CODE, "NewServer");
values.put(AgpsProfileColumns.PROFILE_IP_ADDRESS, "173.173.173.173");
values.put(AgpsProfileColumns.PROFILE_SLP_NAME, "NewServerName");
values.put(AgpsProfileColumns.PROFILE_BACKUP_SLP_NAME_VAR, "NewServerNameBackup");
values.put(AgpsProfileColumns.PROFILE_PORT, "7275");
values.put(AgpsProfileColumns.PROFILE_TTL, "1");
values.put(AgpsProfileColumns.PROFILE_SHOW_TYPE, "0");
profile_manager.insertOrUpdateProfile(profileCode, values);

6，为了达到恢复出厂设置，可以采用以下接口实现：
AgpsProfileManager mProfileMgr = AgpsProfileManager.getProfileManager(context);
mProfileMgr.resetAllProfile();
```

## [FAQ02934] MTK EPO

```
这项技术是通过MTK相关的设备，通过预测技术，将未来一段时间内的卫星星历数据放到mtk服务器，然后手机端可以从该服务器下载，这样，在没有A-GPS去supl服务器下载卫星星历数据的情况下，也可以实现快速定位。

如果手机端同时开启EPO和Agps，那么GPS首先考虑利用EPO进行辅助定位。
```

## [FAQ02933] A-GPS设置中“网络定位请求”一项，有什么功能？

```
A-GPS模式分两种

SI 模式：　用户发起定位请求。
NI 模式： 服务器发起定位请求。(开启网络定位请求项) 这个情况下，网络端会通过wap push的方式给手机，手机收到后，会发GPS设备进行定位，然后将获得的位置再送回给网络服务器。
开启网络定位请求,就是可以让A-GPS工作在NI模式。
目前NI定位只适用于实验室或者欧美一些国家的运营商网络。
```

## [FAQ17726] 如何打开和关闭GMO

```
根据ReleaseNote_for_MT6735M_L1.MP3中的Project_Package_Set_M6735M查看版本是否支持GMO(AP Project(sub)这一列，是否有带G的project，G代表GMO)
DCC上下载文档 《Feature_Option_Info_Table_6.0.xls》查看MTK_GMO相关的宏定义
修改这几个宏定义为no(支持GMO的project默认为yes)
[FAQ15139]如何确认项目是否打开GMO feature(LCA)？
```

## [FAQ14105] L版本打开WITH_DEXPREOPT宏后首次开机仍慢

```
参照 "[FAQ13573]L版本首次开机慢" 打开宏WITH_DEXPREOPT:=true后，首次开机无效果仍然慢；
说明开机之后又去提取预置apk的odex文件(原本应该是在预编译阶段就生成的)；
主要原因是预置apk的Android.mk对32bit和64bit的配置不准确导致。

[SOLUTION]
搜索main log关键字：dex2oat : /system/bin/dex2oat 
▪这条log打印出就代表这个apk有在做dex2oat且是32还是64的指令集

I dex2oat : /system/bin/dex2oat --zip-fd=11 --zip-location=/system/app/***.apk --oat-fd=12 --oat-location=/data/dalvik-cache/arm or arm64/system@app@**@**.apk@classes.dex --instruction-set=arm or arm64 --instruction-set-features=default --runtime-arg -Xms64m --runtime-arg -Xmx512m --swap-fd=13

▪oat-location表示odex文件存储位置
▪Instruction-set表示此apk的primaryCpuAbi对应的指令集(arm对应32bit / arm64对应64bit)


请严格遵守：
1、对于64bit的芯片,若apk只32bit的lib或者只能作为32bit运行，请在预置apk时在android.mk中添加下边的TAG标记此apk为32bit：
LOCAL_MULTILIB :=32 
(比如出现上述做dex2oat arm的log,则需这样设定)

2、而对于有源码无lib库的apk,请注释掉LOCAL_MULTILIB :=32 
(比如出现上述做dex2oat arm64的log,则需这样注释掉)

3、开机之后既提取arm又提取arm64的apk,请设定LOCAL_MULTILIB :=both
(比如出现上述做dex2oat arm以及arm64的log,则需这样设定)

总之，对32bit 和 64bit 的apk做不同处理。

[FAQ13573]L版本首次开机慢
[FAQ14102]L版本开机提示“Android正在升级或启动”
[FAQ13232]L预置apk
[FAQ13697]L版本如何将第三方so库打包到apk
```

## [FAQ18076] android 6.0 M userdebug版本执行adb remount失败

```
userdebug版本如果需要remount system分区来push文件debug，不需要重新编译版本disable dm-verity，只需要执行以下adb命令即可。
adb root
adb disable-verity
adb reboot

重新启动后再执行:
adb root
adb remount即可把system分区remount成rw。

贵司向system分区push文件后，请不要再adb enable-verity，否则就会无法开机，因此push文件后，system分区数据就发生了变化。

adb disable-verity/enable-verity 命令只能在userdebug模式下使用。user版本不支持关闭dm-verity。
如果您的adb不支持adb disable-verity命令，请更新android sdk platform-tools到最新版本。或直接到以下的link下载最新版的独立adb tool。
http://forum.xda-developers.com/showthread.php?t=2317790

其他相关信息请参考https://source.android.com/security/verifiedboot/index.html
```

## [FAQ18367] [Recovery][Common]Android M 升级出错：Error:Invalid OTA package,missing scatter Installation aborted.

```
Android M 编译差分包的命令有所修改，继续采用L版本的差分包命令会导致错误：Error:Invalid OTA package,missing scatter Installation aborted.

参考文档OTA and Android SD upgrade application note.docx 3.3.4节
M版本编译升级包的命令，注意命令中的-s参数。

./build/tools/releasetools/ota_from_target_files  -s ./device/mediatek/build/releasetools/mt_ota_from_target_files  --block -k <key_path> -i V2_org.zip V4_new.zip   V2_4.zip

注意：
一定要带上-s ./device/mediatek/build/releasetools/mt_ota_from_target_files 

[FAQ18250] [recovery][common]Android M upgrade occurs “Error: Invalid OTA package, missing scatter”
```

## [FAQ02499] Android USER 版本与ENG 版本差异

```
Android USER 版本与ENG 版本的差异, 用户版本与工程版本的差异

[Keyword]
USER ENG user eng 用户版本 工程版本 差异

[Solution]
Google 官方描述: USER/USERDEBUG/ENG 版本的差异, 参考alps/build/core/build-system.html 的详细说明
eng This is the default flavor. A plain make is the same as make eng.
*       Installs modules tagged with: eng, debug, user, and/or development.
*       Installs non-APK modules that have no tags specified.
*       Installs APKs according to the product definition files, in addition to tagged APKs.
*       ro.secure=0
*       ro.debuggable=1
*       ro.kernel.android.checkjni=1
*       adb is enabled by default.
*       Setupwizard is optional
user make user
This is the flavor intended to be the final release bits.
*       Installs modules tagged with user.
*       Installs non-APK modules that have no tags specified.
*       Installs APKs according to the product definition files; tags are ignored for APK modules.
*       ro.secure=1
*       ro.debuggable=0
*       adb is disabled by default.
*       Enable dex pre-optimization for all TARGET projects in default to speed up device first boot-up
userdebug make userdebug
The same as user, except:
*       Also installs modules tagged with debug.
*       ro.debuggable=1
*       adb is enabled by default.
 
MTK 补充说明差异:
(1) Debug/LOG 方面，原则上user 版本只能抓到有限的资讯，eng 可以抓到更多的资讯，Debug 能力更强，推崇使用eng 版本开发测试
*       因ro.debuggable 的差异，eng 版本默认开启了app 的JDWP，以及uart console debug; 相对应的user 版本关闭, 导致在DDMS 上无法看到app process 的列表.
*       MTK System LOG 在ICS 以后，在user 版本默认关闭全部LOG， 在eng 版本中默认打开，以便抓到完整的资讯
*       在eng 版本上，LOG 量 >= user 版本的log 量，一些地方会直接check eng/user 版本来确认是否打印LOG
*       user 版本默认关闭uart, eng 版本默认开启uart
*       在eng 版本上，开启ANR 的predump, 会抓取ftrace，可以得到更多ANR的资讯
*       在eng 版本上，可用rtt 抓取backtrace，可开启kdb 进行kernel debug, 可用ftrace 抓取cpu 执行场景
*       MTK aee 在ENG 版本抓取更多的异常资讯，比如native exception 会抓取core dump 信息
*       eng 版本linux kernel 开启了大量的debug 选项，可以抓取出更多的资讯，如可以使用sysrq-trigger, KDB, User 版本则关闭
 
(2) 性能方面(Performance)，原则上进行性能测试请使用user 版本测试
*       user 版本为提高第一次开机速度，使用了DVM 的预优化，将dex 文件分解成可直接load 运行的odex 文件，eng 版本不会开启这项优化
*       user 版本相关kernel debug 关闭，有利于提高linux kernel 的性能
*       user 版本更少的LOG 打印，更少的debug 代码，以及uart 的关闭，原则上user 版本的性能要优于eng 版本
 
(3) 安全方面(security)的影响
*       eng 版本默认关闭了adb 的PC RSA指纹验证，而user 版本默认开启, 如果没有验证 PC RSA 指纹, adb 连接时将提升devices offline
*       因user/eng 版本设置ro.secure不同，导致user 版本adb 只拥有shell 权限，而eng 版本具有root 权限
*       eng 版本内置了su, adb 具有root 权限, 导致系统的安全性严重受到影响
 
(4) 如何确认user/eng 版本
*       Java 层，check android.os.Build 类中的TYPE 值
*       native 层，property_get("ro.build.type", char* value, "eng"); 然后check value 值
*       Debug 时， adb shell getprop ro.build.type 返回值如果是user 即user 版本，eng 即eng 版本
*       Log 确认,  mobile log/Aplog_xxxxx/versions 中查看ro.build.type 属性
 
(5) 如何编译user/eng 版本
*       默认编译是eng 版本，如果需要编译user 版本，请加入参数 -o=TARGET_BUILD_VARIANT=user 如:
        ./mk -o=TARGET_BUILD_VARIANT=user mt6595_phone new
```

## [FAQ17441] [Recovery][Common]Android M 版本如何升级lk 、preloader ？

```
Android M 版本升级lk 、 preloader 方法。 
 
[SOLUTION]
 
M版本有些平台是默认升级lk和preloader，这些平台有6755,6750,6797等。
有些平台需要修改一些代码来实现。这些平台有6735,6580,6737等。
note：
修改代码等情况，可能导致平台的划分不一定准确，请一定仔细阅读下面所有的内容。
 
判断是否默认升级：
查看MTXXXX_Android_scatter.txt文件。搜索关键字：
is_upgradable
 
一.存在is_upgradable关键字
比如：
- partition_index: SYS19
partition_name: lk
file_name: lk.bin
is_download: true
type: NORMAL_ROM
linear_start_addr: 0xa900000
physical_start_addr: 0xa900000
partition_size: 0x100000
region: EMMC_USER
storage: HW_STORAGE_EMMC
boundary_check: true
is_reserved: false
operation_type: UPDATE
is_upgradable: true
empty_boot_needed: true
reserve: 0x00
 
is_upgradable的值决定是否升级对应分区，true表示升级，false表示不升级。这种情况下lk和preloader是默认升级的，不需要修改文件。但是如果修改了分区表等情况，可能会改变默认的设置，所以这一步一定要确定：preloader，lk和lk2三个分区的is_upgradable都是true，如果为false，请参考FAQ18188修改分区表OTA_Update字段。
 
二.不存在is_upgradable关键字
修改方法：
1、Full OTA update：
修改build/core/makefile
修改前：
$(hide) ./device/mediatek/build/releasetools/mt_ota_preprocess.py $(zip_root) $(PRODUCT_OUT) $(PRODUCT_OUT)/ota_update_list.txt 

修改后： 
$(hide) MTK_LOADER_UPDATE=yes MTK_PRELOADER_OTA_BACKUP=no ./device/mediatek/build/releasetools/mt_ota_preprocess.py $(zip_root) $(PRODUCT_OUT) $(PRODUCT_OUT)/ota_update_list.txt

2、Incremental OTA update：
编译差分升级包的命令加上如下蓝色部分：
./build/tools/releasetools/ota_from_target_files  -s ./device/mediatek/build/releasetools/mt_ota_from_target_files  --block -k <key_path> -i V2_org.zip V4_new.zip   V2_4.zip
```

## [FAQ18251] [Recovery][common] Android M Adoptable SD卡无法在recovery mode识别和使用

```
Android M 版本，当外置的SD卡被Adoptable 之后，即Format As internal Storage，此时，如果把升级包置于SD卡，进入recovery mode后是无法找到升级包并正常升级的。
[SOLUTION]
首先，外置SD卡可以被Adoptable 这个功能，是Android M 引入的一个new feature，其次，在被Format As internal Storage之后，SD卡会被加密并被Format成Ext4格式，而在recovery mode 是无法访问这时的SD卡，这个是Google原生的做法，MTK维持Google的做法，所以无法在recovery mode是无法挂载Adoptable后的SD的，谢谢！

这种情况下，如果要实现OTA升级，强烈建议您把升级包放入/data/ 下面，谢谢！

相关可参考：
FAQ17442
[Recovery][Common]Android M 版本data加密后升级包放入/data分区如何升级？
```

## [FAQ10991] 泰语、缅甸语等复杂语言圈圈问题

```
一些复杂语言如泰语、缅甸语、印地语，经常会看到一些带有虚线圈圈字符。这是一种正常的处理机制。对于那些不能单独存在的字符，在显示时额外添加虚线圈，以提供对于这些字符的含义的一些提示，使得这些字符在显示时能够有增加适当的位置，避免字符的无限叠加等问题。如在Windows7上的office2010中缅甸语也有同样的行为，如下图:
大多

MTK在JB版本引入了这种机制，如果想去掉圈圈这种机制，可以按照如下方法：
泰语：
JB、JB2版本：
修改文件external\harfbzz\src\harfbuzz-thai.c
注释如下代码
about line 418
    case tR:
//    charIndex[(*outputIndex)] = inputIndex;
//     outputBuffer[(*outputIndex)++] = errorChar;
        charIndex[(*outputIndex)] = inputIndex;
        outputBuffer[(*outputIndex)++] = currChar;
        break;
about line 426
    case tS:
//        if (currChar == CH_SARA_AM) {
//            charIndex[(*outputIndex)] = inputIndex;
//            outputBuffer[(*outputIndex)++] = errorChar;
//        }
        charIndex[(*outputIndex)] = inputIndex;
        outputBuffer[(*outputIndex)++] = currChar;
        break;
JB3、JB5版本由于变形引擎不同，默认是不带圈圈的，如果想使用这种机制，可以修改：
frameworks/base/core/jni/android/graphics/TextLayoutCache.cp
about line 820
switch (script) {
    case HB_SCRIPT_MYANMAR:
        return &GraphiteLayoutShaper::getInstance();
    case HB_SCRIPT_BENGALI:
    case HB_SCRIPT_THAI:  ////新增此句
     harfbuzzShaper.setShapingScript(getHBScriptFromHBNgScript(script));
        return &harfbuzzShaper;
缅甸语：
在KK,L,M版本上修改文件
 民间缅甸语  修改harfbuzz_ng\src\hb-old\harfbuzz-zawgyi.c文件，将该文件中
        //  reordered[len] = Mymr_C_DOTTED_CIRCLE;
        //   len += 1;
        屏蔽一共2处
 官方缅甸语 修改 harfbuzz_ng\src\hb-old\harfbuzz-myanmar.c文件，将该文件中
        //       reordered[len] = C_DOTTED_CIRCLE;
        //       ++len;
        屏蔽一共1处。
在JB版本上：
对于官方缅甸语JB3、JB5版本由于变形引擎不同，默认是不带圈圈的，如果想使用这种机制，可以修改：frameworks/base/core/jni/android/graphics/TextLayoutCache.cp
about line 820
switch (script) {
    case HB_SCRIPT_MYANMAR:
       //#ifndef ZAWGYI_SUPPORT
       // return &GraphiteLayoutShaper::getInstance();
           // #endif
           //注释上述红色代码

需要注意的是，去掉圈圈机制可以会导致一些字符变形问题，如连续输入上下标、母音等字符，后面的字将不断往前面的字上面叠。同时由于该solution没能做严格的测试，而有可能存在其他潜在的风险。在不能单独存在的字符单独出现时去除虚线圈的做法，并不合理，并可能存在其他问题。如果要去掉，需要评估风险。

缅甸语比较特殊，有官方(Paduak)和民间(Zawgyi)之分，二者不同的是编码机制不同，因此这2种缅甸语的字串翻译、处理引擎、字库都是不同的。如果遇到问题可以先按照如下方法排查：
1、 如果字串中出现一个圈圈可能是个别字串翻译问题，可以参考FAQ09106解决。
2、 如果浏览网页或者界面中出现大量圈圈、这可能是网页内容或者翻译和字库不匹配导致。如大多缅甸语网站是民间缅甸语的，如果使用官方的缅甸语引擎和字库访问的话，就会出现这个问题。
3、目前MTK仅仅在JB3及以后的版本可以支持民间缅甸语，但是需要申请patch(L和M上不必申请patch)，具体patch可以查看FAQ03761备注。

[FAQ09106] 如何去掉界面中缅甸语圈圈(JB,JB2)
```

## [FAQ18513] M版本如何关闭或打开log

```
關閉所有log
简单的说你可以执行如下两步:
關閉所有log
adb shell xlog filter-set off
然後
adb shell logcat -c

下面是具体的：
adb shell xlog filter-set off

開啟所有log
adb shell xlog filter-set on

開啟verbose等級以下的log
adb shell xlog filter-set verbose

開啟debug等級以下的log
adb shell xlog filter-set debug

開啟info等級以下的log
adb shell xlog filter-set info

開啟warn等級以下的log
adb shell xlog filter-set warn

開啟error 等級以下的log
adb shell xlog filter-set error
```

## [FAQ17683] 如何调整CPU corenum, freq, policy

```
cpufreq控制结点位于 /sys/devices/system/cpu/cpu0/cpufreq/
C:\Users\mtk71247>adb shell
root@NOBLEX:/ # cd sys/devices/system/cpu/cpu0/cpufreq
cd sys/devices/system/cpu/cpu0/cpufreq
root@NOBLEX:/sys/devices/system/cpu/cpu0/cpufreq # ls
ls
cpuinfo_cur_freq： 当前cpu正在运行的工作频率
cpuinfo_max_freq：该文件指定了处理器能够运行的最高工作频率 （单位: 千赫兹）
cpuinfo_min_freq ：该文件指定了处理器能够运行的最低工作频率 （单位: 千赫兹）
cpuinfo_transition_latency：该文件定义了处理器在两个不同频率之间切换时所需要的时间  （单位： 纳秒）
scaling_available_frequencies：所有支持的主频率列表  （单位: 千赫兹）
scaling_available_governors：该文件显示当前内核中支持的所有cpufreq governor类型
scaling_cur_freq：被governor和cpufreq核决定的当前CPU工作频率。该频率是内核认为该CPU当前运行的主频率
scaling_driver：该文件显示该CPU正在使用何种cpufreq driver
scaling_governor：通过echo命令，能够改变当前处理器的governor类型
scaling_max_freq：显示当前policy的上下限  （单位: 千赫兹）需要注意的是，当改变cpu policy时，需要首先设置scaling_max_freq, 然后才是scaling_min_freq
scaling_setspeed：如果用户选择了“userspace” governor, 那么可以设置cpu工作主频率到某一个指定值。

                             只需要这个值在scaling_min_freq 和 scaling_max_freq之间即可。
root@NOBLEX:/sys/devices/system/cpu/cpu0/cpufreq #

1、查看当前CPU支持的频率档位
root@NOBLEX:/sys # cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies
sys/devices/system/cpu/cpu0/cpufreq/scaling_available_frequencies              
1300000 1235000 1170000 1040000 819000 598000 442000 299000
root@NOBLEX:/sys #
2、查看当前支持的governor（手机型号可能略有不同）     
root@NOBLEX:/sys # cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors
sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors                
ondemand userspace powersave interactive performance
performance表示不降频，
ondemand表示使用内核提供的功能，可以动态调节频率，
powersvae表示省电模式，通常是在最低频率下运行，
userspace表示用户模式，在此模式下允许其他用户程序调节CPU频率。

root@NOBLEX:/sys # 
3、查看当前选择的governor
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
interactive
root@NOBLEX:/sys #

4、查看系统支持多少核数
root@NOBLEX:/ # cat sys/devices/system/cpu/present
cat sys/devices/system/cpu/present
0-3
root@NOBLEX:/ # 

5、全开所有cpu ，在实际设置时，还需要（有root权限才可以设置）

adb shell "echo 0 > /proc/hps/enabled" (关闭cpu hotplug)
adb shell "echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor" (固定最高频)
echo 1 > /sys/devices/system/cpu/cpuX/online
X表示(0~3，不同平台CPU core 数是不一样的)
例：6735平台
root@NOBLEX:/ # echo 1 >sys/devices/system/cpu/cpu1/online
echo 1 >sys/devices/system/cpu/cpu1/online
root@NOBLEX:/ # echo 1 >sys/devices/system/cpu/cpu2/online
echo 1 >sys/devices/system/cpu/cpu2/online
root@NOBLEX:/ # echo 1 >sys/devices/system/cpu/cpu3/online
echo 1 >sys/devices/system/cpu/cpu3/online

6、设置频率(可以先cat 出来当前的频率有哪些)
C:\Users\mtk71247>adb shell "cat /proc/cpufreq/cpufreq_ptpod_freq_volt"
[0] = { .cpufreq_khz = 1300000, .cpufreq_volt = 113750, .cpufreq_volt_org = 1250
00, },
[1] = { .cpufreq_khz = 1235000, .cpufreq_volt = 110000, .cpufreq_volt_org = 1231
25, },
[2] = { .cpufreq_khz = 1170000, .cpufreq_volt = 106250, .cpufreq_volt_org = 1206
25, },
[3] = { .cpufreq_khz = 1040000, .cpufreq_volt = 98750,  .cpufreq_volt_org = 1150
00, },
[4] = { .cpufreq_khz = 819000,  .cpufreq_volt = 95000,  .cpufreq_volt_org = 1100
00, },
[5] = { .cpufreq_khz = 598000,  .cpufreq_volt = 95000,  .cpufreq_volt_org = 1050
00, },
[6] = { .cpufreq_khz = 442000,  .cpufreq_volt = 95000,  .cpufreq_volt_org = 1000
00, },
[7] = { .cpufreq_khz = 299000,  .cpufreq_volt = 95000,  .cpufreq_volt_org = 9500
0, },

adb shell "echo 0 >proc/cpufreq/cpufreq_oppidx"

设置后再cat 看一下当前的设置是否成功
adb shell "cat proc/cpufreq/cpufreq_oppidx"
[MT_CPU_DVFS_LITTLE/0]
cpufreq_oppidx = 0
        OP(1300000, 113750),
        OP(1235000, 110000),
        OP(1170000, 106250),
        OP(1040000, 98750),
        OP(819000, 95000),
        OP(598000, 95000),
        OP(442000, 95000),
        OP(299000, 95000),

C:\Users\mtk71247>
    
7、查看当前状态有多少个CPU
adb shell cat sys/devices/system/cpu/online
0-3
```

## [FAQ13573] L版本首次开机慢

```
首次开机慢的原因：
一 L版本默认开启了加密功能，影响开机时间。
    请参考FAQ关闭加密功能。
    [FAQ14128]L版本如何关闭默认加密

二 L 版本首次开机会提取所有预置apk的odex文件，花费比较多时间。
    请参考FAQ修改为预编译时提取apk的odex文件。
    [FAQ14131] L版本预编译提取apk的odex文件，如何修改？
    [FAQ14105] L版本打开WITH_DEXPREOPT宏后首次开机仍慢

三 如果开机之后，发现单个APP优化的时候还比较长，请参考FAQ：
    [FAQ14117]单个APP优化时间过长的问题 

四 如果开机时间还不理想，建议关闭patch oat功能，请参考FAQ：
    [FAQ14132] 开启WITH_PREODEX之后，如何减少第一次开机之后data分区的大小 

五 如果遇到eng版本make命令生成不了odex文件，请参考FAQ:
    [FAQ15081] eng版本make命令生成不了odex的说明

实际测试情况：
使用手机：mt6752 L user版本
测试情况：
1 关闭WITH_DEXPREOPT且开启手机加密
首次开机时间：4:40
2        开启WITH_DEXPREOPT且关闭手机加密
首次开机时间：2:16
上述首次开机时间是mtk内部52手机测试时间，仅供参考。
首次开机时间和贵司具体预置的apk的数量有关。
请知悉，谢谢~
注意：
1 请不要预置太多apk，尽量减少不必要的apk，太多apk 会导致开机慢。
相关FAQ：
[FAQ14102]L版本开机提示“Android正在升级或启动”
[FAQ13232]L 预置apk
[FAQ13697]L 版本如何将第三方so库打包到apk
```

## [FAQ05755] 如何定位花屏和界面错乱等绘制异常的问题？

```
在如下3个大的check步骤中，请分别按照每一步的操作来进行排查；如果贵司有定位到某一个问题点，请在提eService时，将问题排查过程写清楚，并提供相应的资料到eService附件中，以便MTK做进一步分析。

 

1.通过DDMS或GAT tool获取异常界面的屏幕截图

[Android 5.0版本之前]DDMS 截图方法如下：Device --> Screen capture，点击Screen capture，就能抓到当前刷到LCM 屏上的那帧数据,或者通过Eclipse中的DDMS工具的screen capture功能，点击操作面板上的“照相机”图标即可。

=>如果屏幕截图是ok的，那么问题点就在LCM driver或timing，具体问题要具体分析。

=>如果屏幕截图not ok，那么你需要进入第2步去获取并查看FrameBuffer中的数据。

[Android 5.0版本及以后]

Android L版本上抓取到的DDMS截图，不是ovl output，而是GPU composer之后的画面。

若要抓取ovl output，可以输入如下命令

adb shell

system/bin/lcdc_screen_cap  /data/fb.bin

 

2.获取FrameBuffer中的数据

 

对于android 4.1及以后的版本，通过如下方法抓取FrameBuffer中的数据：

先做如下操作，再dump framebuffer数据

先进入手机中Settings->Developer options->Disable HW overlays

再勾选Disable HW overlays

 

抓取framebuffer 数据：
adb shell
cat /dev/graphics/fb0  > /data/fb.bin
然后将fb.bin adb push出来，通过工具查看fb.bin

=>如果此步骤的屏幕截图是ok，那说明是LCM controller做overlay时出了问题。

需要把寄存器值打出来(保存在kernel log中)，再抓kernel log做进一步分析

打印寄存器的值：

请在当前刷屏时，将LCM controller寄存器打印出来，寄存器打印命令如下：

adb shell

echo reg:lcd>sys/kernel/debug/mtkfb

这条命令会将LCM controller的寄存器打印到kernel log中

抓kernel log的方式：要么开启mobile log，要么单独用adb命令抓取kernel log；

用adb命令抓取kernel log的方法是：adb shell cat /proc/kmsg > kernel_log.txt

如果分析问题原因是出在这一步，遇到困难时，请将抓取的资料都提供到eService附件中。

=>如果此步骤的屏幕截图not ok，那么就需要进入第3步，抓取layerdump。

 
3、抓取layerdump

在异常界面下，手机连接usb，执行抓取layerdump，抓取的方法根据android的版本不同而不同，下面会分别列出不同版本的抓取方法：

android 4.0~4.4的版本，分别介绍在windows环境下和linux 环境下如何抓取layerdump

在Windows系统环境下，将如下内容copy到新建文本文件中，然后保存文件为SF_layerdump_all.bat 

保持手机连接usb并且在异常界面下，在电脑端双击鼠标执行该脚本(请在Windows系统下执行)，就会在脚本所在路径下生成一个文件SF_layerdump_all

将SF_layerdump_all和复现问题的mobile log一并提供到eService附件中。

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SET raw=%1
SET layerdump=%2

IF "%raw%"=="" SET raw=0
IF "%layerdump%"=="" SET layerdump=-1

adb shell setprop debug.sf.layerdump.raw %raw%
adb shell setprop debug.sf.layerdump %layerdump%
adb shell dumpsys SurfaceFlinger > SF_layerdump_all.log
adb shell mkdir /data/SF_dump
adb shell mv /data/*.png /data/SF_dump
adb shell mv /data/*.i420 /data/SF_dump
adb shell mv /data/*.yv12 /data/SF_dump
adb shell mv /data/*.RGBA /data/SF_dump
adb shell mv /data/*.RGB565 /data/SF_dump
rmdir /S /Q SF_layerdump_all
md SF_layerdump_all
move SF_layerdump_all.log  SF_layerdump_all
adb pull /data/SF_dump SF_layerdump_all/
adb shell rm /data/SF_dump/*

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

注意：如果异常画面是动态的，不是那种静止不动的画面，那么可以尝试多执行几次layerdump，尽量争取能抓到发生问题时的画面的layerdump

如果不方便在Windows系统下抓取layerdump，那么就在linux系统的Terminal 下，按照如下步骤执行下面的指令:

在复现问题前，下如下这条命令，做设置并打开layerdump的开关：

adb shell setprop debug.sf.layerdump.raw 1

adb shell setprop debug.sf.layerdump -1

在即将开始复现问题前，先将下面的指令准备好，在复现问题的画面，敲回车执行这条命令，就是做layerdump的动作，

如果复现问题的画面是动态的，请多下几次这条命令，尽量把复现问题的画面dump下来

adb shell dumpsys SurfaceFlinger >SF_layerdump_all.log

执行了上面的第3条命令之后，会在手机的/data/SF_dump目录下生成一些xxx.png或*.i420,*.yv12,*.RGBA,*.RGB565等文件，请把data/SF_dump这个目录pull出来提供给我们，还有SF_layerdump_all.log文件也一并需要提供。

android 5.0及以后的版本，在windows环境下如何抓取layerdump

在Windows系统环境下

若异常画面是静态稳定的，将如下内容copy到新建文本文件中，然后保存文件为SF_bqdump_L.bat

@echo off

adb shell rm /data/SF_dump/*
adb shell setprop debug.bq.dump "@surface"

adb shell "dumpsys SurfaceFlinger" > SF_bqdump_all.log

adb shell setprop debug.bq.dump ""

rmdir /S /Q SF_bqdump_all
md SF_bqdump_all
move SF_bqdump_all.log SF_bqdump_all
adb pull /data/SF_dump SF_bqdump_all/
adb shell rm /data/SF_dump/*

echo "Please view dump files in folder 'SF_bqdump_all'"
pause

若异常画面是一闪而过的，则需用如下脚本dump画面刷新过程的几十帧画面，下面是设置30帧：SF_cont_bqdump_L_30.bat

复现问题后，双击执行下面的脚本，接着按命令行提示“按电脑任意键继续”，然后等几秒钟，系统会自动dump复现过程的所有帧到指定目录

@echo off

adb shell rm /data/SF_dump/*

:: Modified this line to set surface count,default is 30
adb shell setprop debug.bq.dump "@surface#30"

adb shell "dumpsys SurfaceFlinger > /dev/null"

pause

adb shell setprop debug.bq.dump "@surface"

adb shell "dumpsys SurfaceFlinger" > SF_bqdump_all.log

adb shell setprop debug.bq.dump ""

rmdir /S /Q SF_bqdump_all
md SF_bqdump_all
move SF_bqdump_all.log SF_bqdump_all
adb pull /data/SF_dump SF_bqdump_all/
adb shell rm /data/SF_dump/*

echo "Please view dump files in folder 'SF_bqdump_all'"
pause

注意：抓取到layerdump后，请将layerdump的所生成的文件SF_layerdump_all(在Linux环境下就是手机的data/SF_dump目录和SF_layerdump_all.log文件)和复现问题的mobile log一并提交到eService上来。 

 

抓到layerdump之后，根据layerdump的结果，再做下一步分析；

如果layerdump看到的目标画面not ok，则参考如下FAQ做进一步确认，看是app本身的问题还是UI framework绘制的问题；

FAQ10366  如何抓取View Hierarchy for UI Automator?
```

## [FAQ14389] Feature Table加载原理和调试方法

```
不同branch的feature table的位置可能略有不同，在修改和调试过程中，可能对于加载机制有所疑惑
 
[DESCRIPTION]
 
   1  Feature Table文件的位置：   vendor/mediatek/proprietary/custom/<project>/hal/sendepfeature/<sensor_name>/config.ftbl.<sensor_name>.h
   因为历史原因，有的会位于vendor/mediatek/proprietary/custom/<project>/hal/imgsensor/<sensor_name>/config.ftbl.<sensor_name>.h
  
   2  如何确定Feature Table的位置究竟在哪里？
    vendor/mediatek/proprietary/hardware/matkcam/v1/common/paramsmgr/feature/custom/Android.mk
    此文件是如何编译feature table静态库的makefile.
    会有类似如下的语句：
    ifeq ($(wildcard $(MTK_PATH_CUSTOM)/hal/sendepfeature), )
       MY_CUST_FTABLE_PATH +=  $(MTK_PATH_CUSTOM_PLATFORM)/hal/sendepfeature
    endif
    这说明使用的是hal/sendepfeature目录里面的feature table文件。
   
   3 Feature Table文件是如何被编译的？
      如上面的makefile,  它的执行是：
      在指定的目录中寻找feature table文件，并把这些头文件加上#include 字样写到一个中间头文件custgen.config.ftbl.h，此中间头文件会被custom.cpp包含，最终编译到libcam.paramsmgr.feature.custom.a中.
   
 define my-all-config.ftbl-under
$(patsubst ./%,%, \
 $(shell find $(1) -maxdepth 1 \( -name "config.ftbl.*.h" \) -and -not -name ".*") \
 )
endef

 MY_CUST_FTABLE_FILE_LIST := $(call my-all-config.ftbl-under, $(MY_CUST_FTABLE_PATH))

LOCAL_MODULE := libcam.paramsmgr.feature.custom
LOCAL_MODULE_CLASS := STATIC_LIBRARIES
INTERMEDIATES := $(call local-intermediates-dir)
# custom feature table all-in-one file
MY_CUST_FTABLE_FINAL_FILE := $(INTERMEDIATES)/custgen.config.ftbl.h
LOCAL_GENERATED_SOURCES += $(MY_CUST_FTABLE_FINAL_FILE)
$(MY_CUST_FTABLE_FINAL_FILE): $(MY_CUST_FTABLE_FILE_LIST)
 @mkdir -p $(dir $@)
 @echo '//this file is auto-generated; do not modify it!' > $@
 @echo '#define MY_CUST_VERSION "$(MY_CUST_VERSION)"' >> $@
 @echo '#define MY_CUST_FTABLE_FILE_LIST "$(MY_CUST_FTABLE_FILE_LIST)"' >> $@
 @for x in $(MY_CUST_FTABLE_FILE_LIST); do echo "#include <`basename $$x`>" >> $@; done

#-----------------------------------------------------------
include $(BUILD_STATIC_LIBRARY)

  
  4 如何快速调试feature table?
  最终feature table静态库会被编译到libcam.paramsmgr.so中。
  具体的编译为：
 
 touch vendor/mediatek/proprietary/hardware/mtkcam/v1/common/paramsmgr/feature/custom/custom.cpp && \
 mmm -j24 vendor/mediatek/proprietary/hardware/mtkcam/v1/common/paramsmgr/ 2>&1 | tee ft.lib.log && \
 mmm -j24 vendor/mediatek/proprietary/<platform>/hardware/mtkcam/v1/common/paramsmgr 2>&1 | tee ft.so.log
   最后把生成的libcam.paramsmgr.so 根据32位或者64位push到设备的/system/lib目录或者/system/lib64目录中。
   一般，目前camera app使用的是32位的目录/system/lib.
  因为此动态库是mediaserver加载，用如下命令重启mediaserver来重新加载feature table:
  adb shell stop media && adb shell start media
 
  如果是调试camera app, 请先关闭camera app, 避免app缓存了feature table信息导致调试不生效。
 
  5 从log中如何查看feature table是否生效？
   您可以在log中搜索MtkCam/ParamsManager来确定是否生效，也可以搜索"s8Symbols="来确定加载的是否是指定sensor的feature table.
   "s8Symbols="的log信息来源于Feature.extern.cpp queryCustomFeature函数。
 
  6  深入了解feature table的机制：
   请在vendor/mediatek/proprietary/hardware/mtkcam/v1/common/paramsmgr/feature/custom/Android.mk中增加LOCAL_CFLAGS += -E 来获取custom.cpp预处理后feature table头文件的信息。
  编译feature table静态库，最终会保存在out/target/product/<project_name>/obj/STATIC_LIBRARIES/libcam.paramsmgr.feature.custom_intermediates/custom.o
 
 
 可以看出，就是把一些数据加到数组中，最后提供给外部一个query的函数来获取。
```

## [FAQ18051] M版本开机时间优化

```
在升级到M版本之后，谷歌在camera新增了一个叫“media.camera.proxy”的service，在开机过程中会去连接该service。
当连接不上时会try 5次，持续5秒左右。影响开机的performance。
 
如下是连接不上的Log：
01940 01-01 08:35:59.563987   222   222 I ServiceManager: Waiting for service media.camera.proxy...
02086 01-01 08:36:00.564399   222   222 I ServiceManager: Waiting for service media.camera.proxy...
02294 01-01 08:36:01.564777   222   222 I ServiceManager: Waiting for service media.camera.proxy...
02387 01-01 08:36:02.565194   222   222 I ServiceManager: Waiting for service media.camera.proxy...
02494 01-01 08:36:03.565630   222   222 I ServiceManager: Waiting for service media.camera.proxy...
 
可以打开/frameworks/av/services/camera/libcameraservice/CameraService.cpp
找到pingCameraServiceProxy这个函数
将
sp<IBinder> binder = sm->getService(String16("media.camera.proxy"));
改为
sp<IBinder> binder = sm->checkService(String16("media.camera.proxy"));
```

## [FAQ11485] [SELinux Debug]权限(Permission denied)问题如何确认是Selinux 约束引起？

```
android KK 4.4 版本后，如果发现进程无法访问某些文件，无法连接socket 等问题，并且发现errno 是EPERM(Operation not permitted) 或者 EACCES (Permission denied), 如何确认此类问题是因为SELinux 约束引起？
 
[Keyword]
android, SELinux, Permission denied, 访问限制,  权限问题
 
[Solution]
在Android KK 4.4 版本后，Google 有正式有限制的启用SELinux, 来增强android 的安全保护。
SELinux 分成enforcing mode 和 permissive mode, enforcing mode 会强制性限制访问; 而permissve mode 只审查权限, 但不限制, 即不会产生实质性影响.
 
KK 版本, Google 只有限制的启用SELinux, 即只有针对netd, installd, zygote, vold 以及它们直接fork 出的child process 使用enforcing mode, 但不包括zygote fork的普通app.

L  版本后, Google 全面开启SELinux, 所有的process 都使enforcing mode， 影响面非常广.
 
 
另外为了限制user 版本root 权限，针对su 有做特别的处理，可以参考FAQ android KK 4.4 版本后，user 版本su 权限严重被限制问题说明
 
目前所有的SELinux check 失败，在kernel log 或者android log(L版本后)中都有对应的"avc:  denied" 或者 "avc: denied"的LOG 与之对应。反过来，有此LOG，并非就会直接失败，还需要确认当时SELinux 的模式, 是enforcing mode 还是 permissve mode, 通常在LOG 上带有 permissive = 1 即是permissive mode, 否则permissve = 0 即是enforcing mode.
 
如果问题容易复现，我们可以先将SELinux 模式调整到Permissive mode，然后再测试确认是否与SELinux 约束相关.
在ENG 版本中:
adb shell setenforce 0
 
如果设置成permissive mode 后问题依旧，说明还有其他的权限问题约束，否则就是SELinux 方面的问题。
 
[相关FAQ]
[FAQ11414] android KK 4.4 版本后，user 版本su 权限严重被限制问题说明
[FAQ11486] 在Kernel Log 中出现"avc: denied" 要如何处理？
[FAQ11484] 如何设置确认selinux 模式
[FAQ11483] 如何快速Debug SELinux Policy 问题
```

## [FAQ04300] 如何预置APK

```
1, 如何将带源码的 APK 预置进系统？
2, 如何将无源码的APK预置进系统？
3, 如何预置APK使得用户可以卸载，恢复出厂设置时不能恢复？
4, 如何预置APK使得用户可以卸载，并且恢复出厂设置时能够恢复？

 [SOLUTION]
一、如何将带源码的APK预置进系统？
1)     在 packages/apps 下面以需要预置的 APK的 名字创建一个新文件夹，以预置一个名为Test的APK 为例
2)     将 Test APK的Source code 拷贝到 Test 文件夹下，删除 /bin 和 /gen 目录
3)     在 Test 目录下创建一个名为 Android.mk的文件，内容如下：

LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(call all-subdir-java-files)
LOCAL_PACKAGE_NAME := Test
include $(BUILD_PACKAGE) 

4)     打开文件 build/target/product/${Project}.mk （其中 ${Project} 表示工程名）
将 Test 添加到 PRODUCT_PACKAGES 里面。

5)     重新 build 整个工程

二、如何将无源码的 APK 预置进系统？
1)     在 packages/apps 下面以需要预置的 APK 名字创建文件夹，以预置一个名为Test的APK为例
2)     将 Test.apk 放到 packages/apps/Test 下面
3)     在  packages/apps/Test 下面创建文件 Android.mk，文件内容如下：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Module name should match apk name to be installed
LOCAL_MODULE := Test
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_CERTIFICATE := PRESIGNED
include $(BUILD_PREBUILT)

4)     打开文件 build/target/product/${Project}.mk （其中 ${Project} 表示工程名）
将 Test 添加到 PRODUCT_PACKAGES 里面。

5)     将从Test.apk解压出来的 so库拷贝到alps/vendor/mediatek/${Project}/artifacts/out/target/product/${Project}/system/lib/目录下，若无 so 库，则去掉此步；
6)     重新 build 整个工程

注：Google在KK上修改protection Level为System的permission控管机制
如果App使用System Level的permission，需要預置到/system/priv-app底下 (原在/system/app)。
举例来讲：
关于获取副SD卡的写入权限的案例，App需要在AndroidManifest.xml宣告WRITE_MEDIA_STORAGE permission获取副卡的写入权限

(Ref: KK/alps/frameworks/base/core/res/AndroidManifest.xml)
已知android.permission.WRITE_MEDIA_STORAGE属于SystemOrSignature level的permission，定义如下：

KK上，您需要采用以下方法，获取该permission：
修改Android.mk，增加LOCAL_PRIVILEGED_MODULE := true，以声明app需要放在/system/priv-app下。

三、如何预置APK使得用户可以卸载，恢复出厂设置时不能恢复？
1)     在 packages/apps 下面以需要预置的 APK 名字创建文件夹，以预置一个名为Test的APK为例
2)     将 Test.apk 放到 packages/apps/Test 下面；
3)     在  packages/apps/Test 下面创建文件 Android.mk，文件内容如下：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Module name should match apk name to be installed
LOCAL_MODULE := Test
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_CERTIFICATE := PRESIGNED
LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS)
include $(BUILD_PREBUILT)

4)     打开文件 build/target/product/${Project}.mk （其中 ${Project} 表示工程名）
将 Test 添加到 PRODUCT_PACKAGES 里面。

5)     重新 build 整个工程
注意：这个比不能卸载的多了一句
LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS)

四、如何预置APK使得用户可以卸载，并且恢复出厂设置时能够恢复？

有两种方法：
方法一：预置apk到system/vendor/operator下面
具体做法如下：
在packages/apps下面以需要预置的 APK 名字创建文件夹，以预置一个名为Test的APK为例：
1)     将Test.apk 放到 packages/apps/Test 下面；
2)     在packages/apps/Test下面创建文件 Android.mk，文件内容如下：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)

# Module name should match apk name to be installed
LOCAL_MODULE := Test
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_CERTIFICATE := PRESIGNED
LOCAL_MODULE_PATH := $(TARGET_OUT)/vendor/operator/app
include $(BUILD_PREBUILT) 
3)     打开文件 build/target/product/${Project}.mk （其中 ${Project} 表示工程名）， 将 Test 添加到 PRODUCT_PACKAGES 里面
4)     重新 build 整个工程
 
方法二：使用MTK_SPECIAL_FACTORY_RESET，再配合.keep_list / .restore_list
为了让用户在将预置的 APK 卸载后，恢复出厂设置时能恢复，敝司做了一个 Feature，但在ALPS.GB.TDFD.MP.V1.7和 ALPS.GB.FDD2.MP.V4.7版本后支持，若贵司版本低于此版本，请申请 Patch ALPS00092543；

大致的做法是：
- 在vendor/mediatek/project_name/artifacts/out/target/product/project_name/system目录下新建一个名为appbackup的文件夹，将该应用的apk文件copy到appbackup文件夹下
- 在mediatek/config/project_name/ProjectConfig.mk文件中添加定义：MTK_SPECIAL_FACTORY_RESET=yes
- 在vendor/mediatek/project_name/artifacts/out/target/product/project_name/data/app下创建一个.restore_list，并且在其中添加语句：
/system/appbackup/xxx.apk（注意，.restore_list中的每一行都要以"/system” 开头）

当卸载了data/app下的apk后，再恢复出厂设置，系统会从 .restore_list 中读取apk的名字，然后从 appbackup 文件中把apk重新拷贝到data/app下，从而恢复data/app下已经卸载了的apk。

同时，还需要在vendor/mediatek/project_name/artifacts/out/target/product/project_name/data/app目录下创建一个空文件，命名为.keep_list(.keep_list的用途是，如果安装了A,B,C三个APK到DATA，在恢复出厂设置时，想要将A保留，那么就将A写入到.KEEP_LIST,这样，A会被保留，B,C会被删除。如果没有这个文件，那么所有的APK都会被保留。具体可以参考FAQ03437和FAQ05341）。

以上操作过程，DCC 上面也有相应的文档可供参考，文档的名字叫： Android SD upgrade application note.docx，里面有一项：MTK special factory reset，就详细地介绍了以上操作步骤。

注：该方法从kk开始不建议使用，原因：从KK版本开始，DVM取dex文件的路径变成了绝对路径，而PMS和installd用的都是文件路径，如果用MTK_SPECICAL_FACTORY_RESET配合.restore_list的方式恢复apk的话，这种上下不sync会导致一些问题，比如：恢复出厂设置后三方应用报错、恢复出厂设置后user版本move to phonestorage报错、多次恢复出厂设置开机提示"Android系统正在升级"等。
```

## [FAQ14128] L版本如何关闭默认加密

```
L版本手机默认加密，那如何关闭默认加密呢?
  
[SOLUTION]
关闭加密功能有两种情况：

1      How to disable default encryption in your own image

(1)    Modify fstab.{ro.hardware} in ‘out’ folder
alps\out\target\product\[project]\root\ fstab.{ro.hardware}
Set the flag back to encryptable for /data

(2)    Re-pack boot.img
make ramdisk-nodeps; make bootimage-nodpes

(3)    Download the new boot.img by flashtool

2         How to disable default encryption in your codebase

a)        Modify fstab.{ro.hardware} in your codebase

device\mediatek\ [project]\ fstab.{ro.hardware}

If the project doesn’t have it own fstab.{ro.hardware} . Please create it

Modify device.mk to use the modified fstab.{ro.hardware} .

Set the flag back to encryptable for /data
b)        Re-build boot.img
make bootimage

c)        Download the new boot.img by flashtool
```

## [FAQ04464] [USB]如何修改USB连接后的默认功能

```
如何修改USB连接后通知栏中默认选择的功能

M版本：
在M版本上，手机连接PC，PC上能显示出MTP，但不能访问存储。默认的功能还是charging only。
Android M 版本Follow 的是Google Default Charging Only的行为，不建议修改。

L版本：
修改：
/device/mediatek/common/device.mk

# default usb function
ifeq ($(strip $(MTK_MASS_STORAGE)),yes)
ADDITIONAL_DEFAULT_PROPERTIES += persist.sys.usb.config=mass_storage
//修改上面成想要的功能，如 ADDITIONAL_DEFAULT_PROPERTIES += persist.sys.usb.config=mtp
else 
ADDITIONAL_DEFAULT_PROPERTIES += persist.sys.usb.config=mtp //这里也同步修改 
endif
修改后，需要重新完全编译。先执行make clean 再 make all

KK及以前版本：

以默认功能为MTP为例，可在main.mk中，使
ADDITIONAL_DEFAULT_PROPERTIES += persist.sys.usb.config=mtp
```

## [FAQ11901] 【Partition】客制化分区Partition问题汇总

```
客制化Partition的需求主要就是调整分区size和新增分区，目前MOL系统针对客制化分区的FAQ有很多个并且过于分散，本FAQ主要针对目前已有的FAQ进行汇总，同时也汇总了DCC上需要参考的相关文档。
 
如果有分区客制化的需求，请首先到DCC搜索以下几份文档参考:
(1)Partition Layout Introduction and Customization_V1.pptx
(2)MT6582_Partition_Layout_Introduction_and_Customization_V2.pptx
(3)How_to_Add_an_Image_Partition.ppt
(4)How to add a ext4 partition_MT6572.pptx
(5)How to add a ext4 partition_MT6572_AOSP.pptx
(6)How to add a ext4 partition _MT6589（JB）（customer）.pptx
(7)How to add a UBIFS partition.pptx

基本上参考这几份文档就比较明确如何做分区客制化操作了。

相关的FAQ汇总如下:
(1) 分区含义介绍
[FAQ03559][Storage]MTK platform partition meaning 
(2) 添加raw data分区
[FAQ04465]【partition】如何在77或89平台上添加raw data分区 

(3) emmc添加ext4分区
[FAQ04466]【partition】如何在JB平台上添加ext4分区 

(4) nand flash添加UBIFS分区
[FAQ06763][Storage]如何在mt6572 UBIFS 上创建新分区 

(5) nand flash添加FAT分区
[FAQ04352][Storage]如何实现在nand上创建一个FAT分区

(6) 分区大小设定
[FAQ06257]Flash上新建分区的大小限定
[FAQ04658]【partition】android\cache\userdata三个partition大小设定 
[FAQ11957] 【Partition】一套代码多个项目只有一个分区表，如何调整不同项目的Partition Size

(7) 修改分区表
[FAQ04503]【partition】partition_table中各sheet的名称的含义
[FAQ11445]【Partition】修改了分区表文件partition_table_MT65XX.xls，但是没有生效 
[FAQ09996]同一套代码实现不同的项目使用不同的客制化分区表 

(8) 去掉内置T卡分区
[FAQ04137][Storage]如何将emmc上的内置sdcard拿掉 
[FAQ06774]ICS\ICS2\JB版本上如何去掉内置SD卡
```

## [FAQ05616] [BMT]采用Fuel Gauge可能出现的几种电量现象及解释

```
首先应该熟悉两个变量，bat_volt_check_point是UI上面显示的值。
gFG_capacity_by_C,库仑计计算的电量值.也等于SOC的值.
公式 DOD1 = DOD0 + (-Car/Qmax).
DOD1对应当前的电量值.
DOD0对应初始的电量值.
Car 为t时间内, 流过Rfg电阻电流的电量.
Qmax为电池的容量.
下面几种情况会更新DOD0的值，
1.开机头10S.
2.插拔USB.
3.电池充满的状态
4.电池容量为15%和0%的情况

正常情况下如果，库仑计获取的初始电量DOD0的值比较准确，
那么，gFG_capacity_by_c的值会很准，
实际上，gFG_capacity_by_c跟实际的电量会有点小偏差。不过该值
会在充电过程中与实际电量同步起来。譬如充电过程中是在100%
不充电过程中是在15%和0%
 
[PLATFORM]
MT6575 MT6515 MT6577 MT6517  MT6589

请结合
alps\mediatek\platform\mt6589(mt6575/mt6577)\kernel\driver\power\
mt6320_battery.c
mt6575_battery.c
mt6577_battery.c
中mt6575_battery_update或是mt6320_battery_update来理解.

采用Fuel gauge方案。
1.充电情况
A.充电到99%，可能需要等上一段比较长的时间才能到100%.
----->采用FG的计算电量的变量gFG_capacity_by_C先到达100，而实际上，电池还没有充满，此时会
先将UI显示即Bat_Volt_Check_point定格在99.直到电池满足充满条件时，才会让Bat_Volt_Check_point
值变成100，并在UI上面显示100，此时底层的值为gFG_capacity_by_C以及Bat_Volt_check_point为100.
上层会show满的图片，并停止充电。
电池充满的条件是，进入top_off mode,并且充电电流小于200mA，这个值具体看软件的定义。

B.充电从90%(可能是其他值)到100%需要的时间比较长
----->Battery充电进入硬件的CV阶段，此时充电电流减小。对于库仑计的方式来计算电量，
DOD1 = DOD0 + Car/Qmax，Car = I*t，每增加一%，如果电流恒定，那么电量增加的时间是相等，在CC阶段，电流比较大，每增加1%的时间，
所需要的时间比较短，在CV阶段，电流减小，每增加1%的时间就会变长。
当battery 充满即满足charging full的条件。此时电量会每10S，Bat_Volt_check_point增加1%，在UI上面显示也会相应每10S增加1%一直到100%.
假设FG电量的方式gFG_capacity_by_c为96,电池满足充满的条件，此时，
Bat_volt_check_point(即UI显示)会每10S增加1，当Bat_volt_check_point为100时，
此时会调用FGADC_SW_RESET_parameter,直接将DOD1变成0，也即是
gFG_capacity_by_c变成100.
 
C.Recharging
----->电池充满后，会停止充电，此时系统由电池来供电，当电量低于4.11时，此时
又会重新充电，但是，UI上面会一直显示100%，假设这个时候拔掉USB，这个时候
电量会从100%每1min down 1%去syc FG的电量。
最差的情况，如果FG的电量变成96%，那么4min后，UI显示就变成96.
 

2.不充电情况
A.出现在20或者其他值，很快下降到15%，或者是在15%处停留时间比较久。
---->
这是因为15%是同步点，当电池真实电量成为15%，FG计算电量方式会同步到15%.
 
B.出现在8%或者其他值，然后很快掉到1%.
---->
当实际的电量达到0%，也即电池电压的值小于3.4V，此时，UI上面会每10S，下降1直到
0%，而FG的电量也会每10S，update一次，直到0.
 
C.1%停留的时间比较久.
---->
当FG的计算方式先达到0%,那么UI上面会保持为1%，直到真实的电池容量变为0，也即是
电池电压小于3.4V
 
以上的情况都是软件的正常处理流程.初始的电量DOD0获取正确, 电量就会准确.
而当有点小偏差，那么就会出现上述的一些情况.
```

## [FAQ05745] user版本进行OTA升级时如何抓取升级过程的log

```
【eng版本的log】
In recovery mode
    adb pull /tmp/recovery.log
Reboot to normal mode
    /cache/recovery/last_log

【user版本的log】
方法一：
In recovery mode
目前没有办法在user版本也看到recovery.log，目前的办法是
直接用eng版本的recovery.img替换user版本的recovery.img，然后抓取log。
Reboot to normal mode
在user版本也会产生/cache/recovery/last_log，但是可能会不能用adb pull出来！目前的办法是做完recovery，reboot到normal mode后，重新烧boot.img，用eng版本的boot.img替换user 版本的boot.img，然后将log pull出来！

方法二：
    升级或者恢复出厂设置后，手机断电，参考FAQ05169[Storage]如何从手机上readback任意分区的image回来？将cache分区回读，并且mount，得到cache/recovery目录的log。
```

## [FAQ03442] [Recovery]如何在recovery mode下抓取LOG

```
1、在recovery mode下,升级动作之后 adb pull /tmp/recovery.log

如果是KK版本：
2、在nomal mode下 adb pull /cache/recovery/last_log_r

如果是KK之后的版本：
2、在nomal mode下 adb pull /cache/recovery/last_log

此两种方法均可

如果是user版本：请参考：

FAQ05745：user版本进行OTA升级时如何抓取升级过程的log
```

## [FAQ18460] 低电提示提示一次后就不再弹出

```
手机在弹出HUN(head-up notification)低电提示后不充电继续使用，之后没有再弹出HUN提示低电。

此现象是Google默认设计，用户将某条HUN滑动收缩起来，HUN所在App在短期内发送的下一条HUN将不以HUN方式提醒用户. 用这种方式记录用户短期行为，避免再次骚扰用户.
```

## [FAQ18236] [Android M] M版本 bluedroid蓝牙问题分析需要哪些log及如何抓取

```
M版本开始使用google bluedroid stack原生架构
L版本用的是MTK blueangel stack 架构

[SOLUTION]
1. common 问题需要log: mtklog, hcilog.
注意:
(1)蓝牙的main log 需要打开更多的debug level 才能抓到，打开方式有2种：
a:把手机etc/bluetooth/bt_stack.conf文件pull 出来，把debug level 相关项都设置成6，
原路径push 覆盖， 看看modify time 是否是当时push的时间，再adb reboot.
b:请提交ES 来获取可以配置debug level的APK.
(2)Hcilog仍在“设置”中的“开发者选项”，勾选“启用蓝牙HCI信息收集日志”功能，hci log 保存在mtklog/btlog 路径下。
(3)Hcilog在蓝牙关开后会重新生成新的log, 所以对于蓝牙多次开关测试引起的问题，需要提供前面多份的hcilog.
(4)Hcilog的查看工具请下载安装：http://www.fte.com/support/download.aspx?mode=update&iid=1w

2. A2DP 播放声音（音乐，提示音，按键音,触屏音等）卡顿，无声,杂音等异常问题需要log: mtklog, hcilog, audiodump（请参考FAQ03727）
3. HFP SCO modem语音电话引起的杂音，卡顿，无声等异常问题需要log: mtklog, hcilog, vmlog（请参考FAQ03727）
4. HFP SCO 微信/QQ/skype/line 语音，和voip 网络电话等 引起的杂音，卡顿，无声等异常问题需要log: mtklog, hcilog, audiodump（请参考FAQ03727）
5. 当确认到是firmware contronller 问题时还需要log: air sniffer log(请DCC 下载Ellisys User Manual.pptx)
```

## [FAQ18459] 通话记录显示Unknown

```
问题描述：从平台拨打一个已经存在通话录里的联系人，在InCallUI界面，刚开始显示的信息还是存储的联系人的具体信息，但当通话接通的瞬间，InCallUI界面显示为Unknown，在通话结束后CallLog中存储的也是Unknown的信息。

关键Log分析：

1.在对应的radio.log中查看电话接通瞬间ECPI的返回信息

06-21 15:09:55.268856 976 994 D AT : AT< +ECPI: 1,6,0,1,0,0,"",128,""
06-21 15:09:55.268880 976 994 D AT : RIL_URC_READER Enter processLine:+ECPI: 1,6,0,1,0,0,"",128,""

如果是这种log，则说明是SIM卡开通了号码隐藏服务，后面就check拨打端和接听端SIM卡是否有开通对应的服务，进行对比测试。

Line 8225: 06-21 15:10:22.545596 976 994 D AT : AT< +ECPI: 1,6,0,1,1,0,"38163520502",145,""
Line 8226: 06-21 15:10:22.545619 976 994 D AT : RIL_URC_READER Enter processLine:+ECPI: 1,6,0,1,1,0,"38163520502",145,""

如果是这种log，则说明是本身平台处理的问题，需要继续看步骤2。

2.在radio.log中继续查看CLIR

Line 1899: 06-28 07:28:36.556097  1491  1491 D ImsPhoneCallTracker: [ImsPhoneCallTracker][Phone1] dial clirMode=0

如果是支持VOLTE，注册上IMS网络，则会看到这些log信息，clirMode=0则是问题所在；如果不是注册的IMS网络，则看不到这些log；这两种情况下都需要看步骤3分析对应的代码。

3.查看CallTracker中dial函数异常点（红色部分）

注册上IMS网络，需要查看ImsPhoneCallTracker.java中dial 函数：

非IMS网络，需要查看GSMCallTracker.java中的dial函数：

解决方法：

将步骤3中的红色部分作出如下修改：

将 CommandsInterface.CLIR_DEFAULT修改为CommandsInterface.CLIR_SUPPRESSION
```

## [FAQ18450] 3rd camera ap 画面亮度偏暗

```
3rd camera ap, e.g. google hangouts, whatsapp, skype 等preview or 视频通话时画面偏暗
 
在log中search "preview-fps-range="
12092 12569 V CameraFramework: set Key = preview-fps-range, value = 30000,30000
preview-fps-range=30000,30000;preview-fps-range-values=(5000,30000),(20000,20000),(30000,30000);
 
可以看到3rd ap 通过api: setPreviewFpsRange(30000, 30000)把fps固定在30, 此时camera AE会把shutter固定在30ms
 
在光线不好的环境下, 30ms shutter会让画面偏暗
 
[SOLUTION]
fps和画面亮度两者不可兼得:
 
1, fps固定在30, 在暗处画面偏暗是预期的行为, 牺牲画面亮度保证fps是3rd ap预期的行为, 不需要修改
2, feature table:
KEY_AS_(MtkCameraParameters::KEY_PREVIEW_FPS_RANGE), 
SCENE_AS_DEFAULT_SCENE(
ITEM_AS_DEFAULT_("5000,30000"), 
ITEM_AS_USER_LIST_(
"(15000,15000)", 
"(24000,24000)", 
"(30000,30000)",
 
改为:
 
KEY_AS_(MtkCameraParameters::KEY_PREVIEW_FPS_RANGE), 
SCENE_AS_DEFAULT_SCENE(
ITEM_AS_DEFAULT_("5000,30000"), 
ITEM_AS_USER_LIST_(
"(5000,30000)",
 
让平台只支持dynamic fps (5~30), 此时3rd ap下preview-fps-range=(30000,30000)不起作用
 
在暗处时牺牲了fps来提高画面亮度
```

## [FAQ18297] 为何Monkey测试时MTKlogger UI界面不可用

```
adb shell setprop ro.monkey true, MTKlogger UI界面不可用，start/stop按钮消失

这是敝司特意的设计，设计的目的是：防止monkey 测试过程中，误打开mtklogger，误关闭mtklogger导致抓不到log。
所以在monkey测试中，mtklogger UI是不让操作的，重启后可恢复。
```

## [FAQ18143] L/M版本首次/非首次开机时间优化

```
首次开机时间优化可先参考[FAQ13573]L版本首次开机慢  进行修改。

非首次开机时间优化需要check以下阶段是否存在问题：
Zygote阶段：
一般有两个耗时点：
预加载class/resource的时间。需要确认是否有添加很多系统资源。
这期间是否有很多GC动作；

SystemServer阶段：
（1）PMS scan package阶段，PMS扫描apk的时间与预置apk的数量及大小有关，预置apk的size越大、数量越多扫描时间会越长。一般建议如果一个apk的elapsed time大于100ms需要删除该预置apk。
01-09 08:30:01.487   750   750 D PackageManager: scan package: /system/framework/framework-res.apk , end at: 16266ms. elapsed time = 87ms.
01-09 08:30:01.499   750   750 D PackageManager: scan package: /system/framework/mediatek-res , end at: 16278ms. elapsed time = 11ms.
01-09 08:30:01.515   750   750 D PackageManager: scan package: /system/priv-app/BackupRestoreConfirmation , end at: 16295ms. elapsed time = 15ms.
01-09 08:30:01.544   750   750 D PackageManager: scan package: /system/priv-app/CDS_INFO , end at: 16323ms. elapsed time = 28ms.
01-09 08:30:01.574   750   750 D PackageManager: scan package: /system/priv-app/CalendarProvider , end at: 16354ms. elapsed time = 31ms.
。。。。。。
01-09 08:30:04.957   750   750 D PackageManager: scan package: /system/app/VoiceUnlock , end at: 19736ms. elapsed time = 29ms.
01-09 08:30:04.986   750   750 D PackageManager: scan package: /system/app/YGPS , end at: 19765ms. elapsed time = 28ms.
01-09 08:30:05.015   750   750 D PackageManager: scan package: /system/app/webview , end at: 19794ms. elapsed time = 29ms.
（2）PMS dexopt阶段：开机时apk作Running dexopt的操作比较耗时，需要参考[FAQ14131] L版本预编译提取apk的odex文件进行修改。
（3）开机过程出现camera I2C transfer timeout，需要排查camera加载慢的原因。
[292:mediaserver][mt-i2c]ERROR,481: id=0,addr: 10, transfer timeout
（4）Check各个service开机初始化过程的耗时情况，如果某个service初始化过程耗时，需要check这个具体service的行为。

BootAnimation阶段：
如果log中有打印Waiting for service media.camera.proxy... ，可以参考[FAQ18051]M版本开机时间优化进行修改；
当开机动画包中图片很多或占内存很大时会出现lowmemory的现象，导致开机较慢。建议将开机动画包bootanimation.zip中part1部分的图片控制在10张以内。

Keyguard阶段：check锁屏绘制是否存在延时
//画锁屏
01-09 08:30:17.710   891   891 D KeyguardViewMediator: handleShow
//锁屏画完
01-09 08:30:17.787   891   891 D KeyguardViewMediator: handleShow exit

相关FAQ：
[FAQ13573]L版本首次开机慢
[FAQ14128]L版本如何关闭默认加密
[FAQ18051]M版本开机时间优化
```

## [FAQ14812] 如何快速对系统重启问题进行归类

```
当手机发生系统重启，即导致kernel重启的异常时，会在手机中的/data/aee_exp目录下保存异常重启的db。工程师可以通过GAT的bug report功能，或者直接通过adb pull，把对应的db从手机中抓回来。进一步，对于异常重启的类型，需要通过GAT工具解开db档案（解开方式参考MTK-online上的文档GAT_User_Guide(Customer).docx之5.1的部分），对里面的SYS_KERNEL_LOG/SYS_LAST_LOG/SYS_REBOOT_REASON 内容进行解析，才能知道具体的重启的类型。
一般来说，导致kernel重启的异常重启，包括Kernel Panic, Watchdog Timeout, Hardware Reboot这三种类型。一个完整的Kernel Panic，其db解开来会包含如下的 档案：

[SOLUTION]
1. Kernel Panic
即linux kernel发生了无法修复的错误，从而导致panic。通过查看SYS_KERNEL_LOG的内容，kernel Panic进一步可以分为如下几类：
a. 普通的data abort。从SYS_KERNEL_LOG中，可以检索到如下的info:

Unable to handle kernel NULL pointer dereference at virtual address XXXXXXXX

如上的XXXXXXXX代表某个非法地址。这种类型是最多的。

b. oom 主动触发的panic。从SYS_KERNEL_LOG中，可以检索到如下的info:

Kernel panic - not syncing: Out of memory and no killable processes...

此种类型的panic一般是某个process或者APK耗尽了memory资源，从而kernel主动触发的panic重启。对于这种类型的重启，强烈建议工程师把如上的info填写到eService 的标题中，这样MTK可以对eService进行一次到位的分配。

c. undefined instruction，未定义指令异常。从SYS_KERNEL_LOG中，可以检索到如下的info:

Internal error: Oops - undefined instruction

此类异常较为少见，可能是CPU/DRAM 不稳定或者受干扰导致的问题。

d. bad mode异常，即PC处于一个无效的virtual address。从SYS_KERNEL_LOG中，可以检索到如下的info:

Bad mode in Synchronous Abort handler detected
...
[14820.652408]-(1)[682:VSyncThread_0][<ffffffc000088f90>] bad_mode+0x78/0xb0

此类异常较为少见，可能的原因是stack错乱，或者未注册回调函数引起。


2. watchdog 超时

a. 底层看门狗超时。从SYS_KERNEL_LOG中，可以检索到如下的info:

for arm64 platform
PC is at aee_wdt_atf_info+0x4c8/0x6dc
LR is at aee_wdt_atf_info+0x4c0/0x6dc

for arm32 platform
PC is at aee_wdt_irq_info+0x104/0x12c
LR is at aee_wdt_irq_info+0x104/0x12c

此类异常较为常见，多见于底层频繁irq/bus卡死，导致kicker无法被schedule，从而引起watch dog触发中断，引导系统进入FIQ处理流程，最终call到BUG触发重启。

b.上层hang_detect 触发看门狗超时。从SYS_KERNEL_LOG中，可以检索到如下的info:

[ 2131.086562] (0)[77:hang_detect][Hang_Detect] we should triger HWT ...
...

[ 2180.467416]-(0)[77:hang_detect]PC is at aee_wdt_irq_info+0x154/0x170

[ 2180.467426]-(0)[77:hang_detect]LR is at aee_wdt_irq_info+0x154/0x170
...

此异常类型较为常见，多见于GPU/SD卡/eMMC 无法满足surfacelinger/system_server的通讯需求，从而导致上层卡死，进而主动触发看门狗超时重启。对于这种类型的重启，强烈建议工程师把如上的Hang_Detect关键字填写到eService 的标题中，这样MTK可以对eService进行一次到位的分配。

3. Hardware Reboot

hardware reboot是watch dog直接发出reset信号，导致整个系统重启；在重启之前，并没有触发任何异常处理流程。一般情况下，hardware reboot对应的db不会有SYS_KERNEL_LOG 可以排查，只能从SYS_LAST_KMSG获知异常之前kernel的动作，以及从SYS_REBOOT_REASON 获知异常时的CPU寄存器值和其它参数。
从ZZ_INTERNAL 档案，可以知道发生了hardware reboot
Hardware Reboot,0,0,99,/data/core/,0,,HW_REBOOT,Fri Jul  3 14:31:53 CST 2015,1

就上面所罗列的诸多异常重启，工程师务必把如上黄底部分的log片段拷贝到eService的Description栏位，并把红色的关键字填写到eService的标题中，这样，可以大大加快eService的分配流程。
```

## [FAQ11737] 添加一些语言后，切换到该语言手机自动重启，添加ICU资源

```
新增一些语言比如 哈萨克斯坦语(kk)、奥罗莫语(om)等，添加成功后在Setting语言列表中切换到该语言，
手机重启且一直停留在开机动画界面。查看log可以发现如下特殊语句：
01-01 00:12:34.687  4365  4365 E ICU     : Couldn't find ICU yesterday/today/tomorrow for om_ET
01-01 00:12:34.687  4365  4365 W dalvikvm: Exception Ljava/lang/AssertionError; thrown while initializing Llibcore/icu/LocaleData;
01-01 00:12:34.687  4365  4365 W dalvikvm: Exception Ljava/lang/AssertionError; thrown while initializing
[SOLUTION]
 
原因一些语言的icu资源不全导致，external\icu4c\data\locales\om.txt确少fields项，下面是英语的部分定义，可以先把这段加进去验证，验证ok后需要做做翻译。

fields{
    day{
        dn{"Day"}
        relative{
            "-1"{"Yesterday"}
            "0"{"Today"}
            "1"{"Tomorrow"}
        }
    }
    dayperiod{
        dn{"AM/PM"}
    }
    era{
        dn{"Era"}
    }
    hour{
        dn{"Hour"}
    }
    minute{
        dn{"Minute"}
    }
    month{
        dn{"Month"}
        relative{
            "-1"{"Last month"}
            "0"{"This month"}
            "1"{"Next month"}
        }
    }
    second{
        dn{"Second"}
    }
    week{
        dn{"Week"}
        relative{
            "-1"{"Last week"}
            "0"{"This week"}
            "1"{"Next week"}
        }
    }
    weekday{
        dn{"Day of the Week"}
    }
    year{
        dn{"Year"}
        relative{
            "-1"{"Last year"}
            "0"{"This year"}
            "1"{"Next year"}
        }
    }
    zone{
        dn{"Time Zone"}
    }
}
```

## [FAQ09662] 如何实现字体切换功能

```
一、 实现单个字体切换

可以参考DMS文档：Font Install and Runtime Change On ICS guideline.doc

二、多个字体(多个字体一套风格，比如泰语字库、英文字库)

实现这个功能其实是采用了系统在加载字体时会为每个字体指定加载路径的原理，只要把我们要替换的字库文件编译到系统目录下，然后修改要替换的字体的路径就可实现这一功能。

1、添加字库

1)把对应的字库文件拷贝到frameworks/base/data/fonts下

2)修改fonts.mk (frameworks/base/data/fonts)

a、ICS
PRODUCT_COPY_FILES := \
......
frameworks/base/data/fonts/NewFontFile.ttf:system/fonts/DroidSansThai-My.ttf \
frameworks/base/data/fonts/NewFontFile.ttf:system/fonts/ Roboto-Regular-My.ttf \

b、JB

PRODUCT_PACKAGES:= \
DroidSansThai-My.ttf \
Roboto-Regular-My.ttf \
......

4)对于JB2，JB3，JB5，kk还需修改android.mk

           ifeq ($(MINIMAL_FONT_FOOTPRINT),true)

           ……
else # !MINIMAL_FONT
font_src_files +=

          ……

          DroidSansThai-My.ttf \
       Roboto-Regular-My.ttf \

5)对于GB版本只需修改Android.mk
           copy_from := \ 
           DroidSansThai-My.ttf \
            Roboto-Regular-My.ttf \
            ……
    注：请不要修改fallback_fonts.xml等xml文件，这个添加仅仅是让系统把字库编译到fonts目下。

 2、修改ttf加载路径

 #include <cutils/properties.h>//引入头文件

 SkFontHost_android.cpp（alps\external\skia\src\ports）

    static void getFullPathForSysFonts(SkString* full, const char name[]) {

    static char args[PROPERTY_VALUE_MAX];//定义变量

       property_get("persist.sys.usedmyfont", args, "no");//获取persist.sys.usedmyfont配置

       full->set(getenv("ANDROID_ROOT"));

       full->append(SK_FONT_FILE_PREFIX);

       if(strstr(args,"yes")){

            if(strstr(name,"DroidSansThai")){

                full->append("DroidSansThai-My.ttf");

             }else if(strstr(name,"Roboto-Regular")){

                full->append("Roboto-Regular.ttf");

             }else{

               full->append(name);

             }

        }else{

            full->append(name);

        }

 }

kk版本文件路径：

SkFontConfigInterface_android.（external\skia\src\ports）

3、实现上层切换功能

因为这一步比较容易实现，且不同需求ui设计不同，因此此步骤只提供大概思路，没有具体实现。

1)上层app(比如setting)实现可以切换字体的ui选项。

2)需要定义个配置变量persist.sys.usedmyfont：

当字体切换时SystemProperties.set("persist.sys.usedmyfont", "yes");

当使用默认字体时SystemProperties.set("persist.sys.usedmyfont", "no");

3)  因为这个功能是要重新加载字库文件，因此必须要实现切换字体后要重启手机功能。
```

## [FAQ11478] 语言设置为[Developer]Accented English点击显示报错

```
[DESCRIPTION] 语言设置为[Developer]Accented English点击显示报错 [SOLUTION] Language 中的[Developer] Accented English是一种虚拟mapping出来的语言，source code的resource中并没有实际的values-zz-rZZ 的resource与之对应。 针对settings中报的这个问题，是因为ResourceManager将alps/packages/apps/Settings/res/values/strings.xml 中的%1$s 中的占位符号进行了mapping翻译%1$š ，使得formart时找不到对应的占位符而出错。 这个问题的修改方法如下，将alps/packages/apps/Settings/res/values/strings.xml 中的%1$s 替换成 %1$s，避免占位符被mapping翻译。 因为属于google default resource issue，请自行修改验证。
```

## [FAQ11536] KK版本语言列表[Developer]Accented English问题

```
Android4.4进入到系统设置-语言和输入法-语言，界面就会语言选项里面多了第一个[Developer] Accented English。
这一项有什么用，如何把它去掉呢？
[SOLUTION]
KK:
[Developer] Accented English是一种虚拟mapping出来的语言，source code的resource中并没有实际的values-zz-rZZ 的resource与之对应。
切换到该语言也是仅仅Setting UI的字串发生变化.这是为开发者模式设计的，对于使用者没有多大作用。
添加这个语言项具体为如下红色部分：
LocalePicker.java (frameworks\base\core\java\com\android\internal\app)
public static ArrayAdapter<LocaleInfo> constructAdapter(Context context, final int layoutId, final int fieldId, final boolean isInDeveloperMode) {
    final Resources resources = context.getResources();
    ArrayList<String> localeList = new ArrayList<String>(Arrays.asList(Resources.getSystem().getAssets().getLocales()));
    if (isInDeveloperMode) {
        if (!localeList.contains("zz_ZZ")) {
            localeList.add("zz_ZZ");
        }
        /** - TODO: Enable when zz_ZY Pseudolocale is complete
         *  if (!localeList.contains("zz_ZY")) {
         *      localeList.add("zz_ZY");
         * }
         */
    }
    ……
}
如果要去掉该项，可以把红色部分注释掉。
 
L:
L上与KK不同,L上是判断如不在开发者模式就将"ar_XB"和"ar_XA"拿掉(如果有的话),没有使用"zz_ZZ".
 
有关[Developer]Accented English其他问题可以参考：FAQ11478
```

## [FAQ08190] 如何修改Sim卡语言自适应

```
一、  系统设定默认语言规则

1.  系统预置语言，即在 makefile 文件中定义的语言；
–  位置：mediatek/config/${Project}/ProjectConfig.mk，默认第一个是系统默认语言
2.  刷机过后，开机重启，如果未插卡，系统语言为预置的语言；
3.  插入SIM卡过后，系统语言根据 SIM 卡来改变， 默认会把刷机过后第一次插的 SIM 卡的语言设置为默认语言；(如果sim的mcc可以在内置的mcc表中找到)
4.  如果用户没有手动在 Settings 里面设置语言，以后系统语言一直是默认语言（第一次插的 SIM 卡的语言），即使是插入其它国家的卡，系统语言也不会变；
5.  如果用户在 Settings 里面手动设置了语言，以后系统语言会为设置后的语言，无论插入什么卡，系统语言不会变，一直为用户手动设置后的语言。

MTK默认设计是如果手机有插卡，那么在开机是会读取SIM的imsi取出mcc，然后通过mcc来查找对应的language，并设置为手机默认语言(相关文件MccTable.javaframeworks\opt\telephony\src\java\com\android\internal\telephony).
二、  修改默认语言

1. 如果想手机默认语言不随SIM的MCC走，请按照如下修改：
在setLocaleFromMccIfNeeded()函数中
//String language = MccTable.defaultLanguageForMcc(mcc); <<注释掉此语句
对于KK版本
在updateMccMncConfiguration()函数中
// locale = getLocaleFromMcc(context, mcc); <<注释掉此语句

2. 如果手机默认语言随SIM卡走
此为operator CT的定制feature，如果有开OP03 option,默认就支持该功能。
如果想非OP03也支持该功能，请按照如下修改:
alps/mediatek/frameworks/base/op/java/com/mediatek/op/telephony/TelephonyExt.java中, 使方法isSetLanguangBySIM()返回true，那么手机的默认语言会使用SIM中的EF_LI(6F05)或者EF_EPL(2F05)中的语言。这两个文件优先使用EF_LI中的，如果EF_LI没有匹配的在使用EF_EPL的。
```

## [FAQ08860] 添加语言后语言列表没有显示或者显示空白和乱码

```
在MTK_PRODUCT_LOCALES（KK及以前版本，L上是PRODUCT_LOCALES）中添某种语言代码，却没有在setting语言列表中找到该语言选项或者出现空白和乱码，出现这样的情况可以按照如下方法排查。

一、检查添加的语言代码是否正确

Android使用语言_区域来确定一种语言，比如en_US,zh_CN，前面两位表示语言，后面两位表示区域，语言和区域中间使用_隔开，多种语言中间用空格分隔。
语言代码遵循ISO_639-1标准，可以参考维基百科：ISO_639-1
http://zh.wikipedia.org/wiki/ISO_639-1

语言代码遵循ISO_3166-1标准，可以参考维基百科：ISO_3166-1
http://zh.wikipedia.org/wiki/ISO_3166-1

Note： Java中使用了几个过时的语言代码，与ISO_639-1中的不一样，见下表，因此在添加下面几种语言的时候需要额外注意：希伯来语，印尼语，意地绪语。

          ISO_639-1  Android/Java
希伯来语(Hebrew) he iw
印尼语(Indonesian) id in
意地绪语(Yiddish) yi ji

二、检查framework是否有对应的value文件夹
如果添加的语言代码是正确的，列表种还是没有，请检查framework的res下是否有相应的values-xx-rYY文件夹，例如

JB2、JB3在ProjectConfig.mk文件MTK_PRODUCT_LOCALES处加上bn_IN,ur_PK后，setting语言列表却找不到这2个语言，那是因为

frameworks/base/core/res/res/下缺少文件values-bn-rIN和values-ur-rPK,需要新建并在其里面新建文件arrays.xml(KK和L上是strings.xml)，内容如下：

<?xml version="1.0" encoding="utf-8"?>
<resources>
    <integer-array name="maps_starting_lat_lng">
        <item>20593684</item>
        <item>78962880</item>
    </integer-array>
    <integer-array name="maps_starting_zoom">
        <item>3</item>
    </integer-array>
</resources>

三、语言列表中出现空白或者乱码
这是由于缺少字库或者字库添加不正确造成的，可以参考FAQ04513
如果按照上面步骤检查后仍有问题，请联系MTK技术人员解决。
```

## [FAQ04553] ICU资源简单介绍

```
1、什么是icu4c
ICU4C是ICU在C/C++平台下的版本, ICU(International Component for Unicode)是基于用于支持软件国际化的开源项目。ICU4C提供了C/C++平台强大的国际化开发能力，软件开发者几乎可以使用ICU4C解决任何国际化的问题，根据各地的风俗和语言习惯，实现对数字、货币、时间、日期、和消息的格式化、解析，对字符串进行大小写转换、整理、搜索和排序等功能，必须一提的是，ICU4C提供了强大的BIDI算法，对阿拉伯语等BIDI语言提供了完善的支持。

在平台新增一种语言必须要添加对应的icu资源(如zh_CN.txt,my.txt)，并重新编译ICU。ICU资源可在http://site.icu-project.org/  网址上下载。

（1）打开网址选择左侧列表框的DownloadICU
（2）选择“offcial Release”中最新版本的ICU4C如50.1
（3）下载“ICU4C Source Code Download”框中第一个包如“icu4c-50 l-data.zip”

2、新增语言添加哪些icu资源
下载完icu4c code包解压为data文件夹下面对应会有coll、curr、lang、locales、region，zone几个子文件夹。各种语言的icu资源就在这些文件夹里面。如中文以及中文简体的资源为zh.txt,zh_CN.txt(中文代码为zh，大陆国家码为CN)。新增语言时只需把所需语言的icu资源分布添加到平台对应的文件夹下，并修改对应mk文件重新编译就行。

具体如何添加可参考FAQ： FAQ04009 
```

## [FAQ04326] 如何打开一种语言以及如何设置开机默认语言

```
如何打开语言支持计划中的语言？
如何打开一种新语言？
如何设置开机默认语言?

[Solution]
一、如何打开语言支持计划中的语言？
Android KK JB
关于MTK语言支持情况请参考：FAQ03761
请打开文件：mediatek/config/${Project}/ProjectConfig.mk
找到宏MTK_PRODUCT_LOCALES，把所需的语言代码添加进去，比如添加越南语"vi_VN"
如果没有找到MTK_PRODUCT_LOCALES，可能在mediatek/config/common/ProjectConfig.mk中.
ANDROID L 
MTK_PRODUCT_LOCALES这个宏已经没有使用，使用的是alps\device\公司名字\项目名字\项目名字.mk  中的PRODUCT_LOCALES请添加语言的时候在PRODUCT_LOCALES中添加。
例如我司自己内部的项目代号aubest52 那么添加语言路径是（device\mediatek\aubest52\full_aubest52.mk中的PRODUCT_LOCALES后面添加语言）其他流程和KK一致

二、怎么添加一种新语言
请参FAQ04009

2.1、如果打开后在语言列表中没有找到该语言 
请参FAQ08860

三、设置开机默认语言 
如果想把某种语言设置为开机默认语言，只需把这个语言的代码放到(Android L PRODUCT_LOCALES后面第一个即可),（Android KK MTK_PRODUCT_LOCALES的第一个即可)。
```

## [FAQ18376] [MMS]彩信发送Vcard，接收失败，内容为空

```
彩信发送Vcard，接收失败，内容为空。
有一种情况是网络在转发时修改了数据，如下左图是手机发送时的数据，右图是从网络接收时的数据，接收的数据多了一个par。
如果是这种情况，请参考下面的workaround 改法。

修改SlideshowModel.java 的createFromPduBody()方法如下：

// Create media models for each slide.
NodeList mediaNodes = par.getChildNodes();
int mediaNum = mediaNodes.getLength();
ArrayList<MediaModel> mediaSet = new ArrayList<MediaModel>(mediaNum);
// mtk add start 
boolean isIgnore = false;
for (int k = 0; k < mediaNum; k++) {
    SMILMediaElement sme1 = null;
    try {
        sme1 = (SMILMediaElement) mediaNodes.item(k);
    } catch (ClassCastException cce1) {
        MmsLog.e(TAG, cce1.getMessage());
        continue;
    }
    String tag = sme1.getTagName();
    String src = sme1.getSrc();
    if (tag.equals(SmilHelper.ELEMENT_TAG_REF)) {
        String suffix = src.contains(".") ? src.substring(src.lastIndexOf("."), src.length()) : "";        
        if (suffix.equals(".vcf") || suffix.equals(".vcs")  ) {
            isIgnore = true;
        }
    }
}
if (isIgnore) {
    continue;
}
// mtk add end

for (int j = 0; j < mediaNum; j++) {
    /// M: Code analyze 012, new feature, catch ClassCastException @{
    SMILMediaElement sme = null;
    try {
        sme = (SMILMediaElement) mediaNodes.item(j);
    } catch (ClassCastException cce) {
        MmsLog.e(TAG, cce.getMessage());
        continue;
    }
    
FAQ中是用什么工具分析的？？
```

## [FAQ14743] init 启动 Native Service 时出现Service xxxx needs a SELinux domain defined; please fix 警告的说明

```
init 启动 Native Service 时出现Service xxxx needs a SELinux domain defined; please fix 警告的说明
 
[Keyword]
SELinux, Native Service, init, domain

[Android Version]
Version >= android 5.0
 
[Solution]
在android 5.0 后, 默认启用了Enforcing SELinux. 有很多同仁经常会从kernel log 中看到这样的警告.
"[1:init]init: Warning! Service xxxx needs a SELinux domain defined; please fix!"

其原因是因为Google 要求init 启动service 时，都要进行SELinux domain 切换，即从init domain 切换到另外的domain. 这个是从安全方面考虑的, 默认init domain 的SELinux 权限很大, 可以做很多危险行为，比如mount image, kill process 等等. 如果普通service 使用 init domain, 就增大了可攻击的安全面.

Google 在CTS 中有对这一项进行检查， CTS fail of android.security.cts.SELinuxDomainTest # testInitDomain

通常情况下，如果init 启动的是一个可快速执行完的oneshot 的service, 即非deamon 程序, “一闪而过” 的话，可以不进行domain 切换. 此类CTS 检测不到.  如果init 启动的是常驻内存的deamon service, 那么一定要进行domain 切换.(L0/L1 版版本)

但在M版本上,Google 增强了这块的约束，通过使用neverallow init { file_type fs_type}:file execure_no_trans;严格限制了init 启动service 都必须进行domain 切换，否则service 无法启动!!!

下面是一个demo, 方便大家参考.
定义一个init 启动的service, demo_service, 对应的执行档是/system/bin/demo.
(1).  创建一个demo.te 在/device/mediatke/common/sepolicy 目录下, 然后在/device/mediatke/common/BoardConfig.mk 的BOARD_SEPOLICY_UNION 宏中新增 demo.te (注意: M 版本后取消了BOARD_SEPOLICY_UNION 宏，不需要再修改了，添加了文件即可)
(2).  定义demo 类型，init 启动service 时类型转换, demo.te 中
type  demo, domain;
type   demo_exec, exec_type, file_type;
init_daemon_domain(demo)
(3).  绑定执行档 file_context 类型
/system/bin/demo  u:object_r:demo_exec:s0
(4). 根据demo 需要访问的文件以及设备,  定义其它的权限在demo.te 中.

针对特别执行shell 的service , 需要特别处理, 因为/system/bin/sh 已经被定义成了shell_exec 的label. 而有很多这样的service 依赖于sh, 于是需要使用seclabel 操作.
(1). 在你的service 定义中写入 seclabel u:r:demo:s0
(2). 创建你的xxxx_service.te 文件, 和前面类似
type demo, domain;
domain_trans(init, shell_exec, demo)
(3). 根据demo 需要访问的文件以及设备,  定义其它的权限在demo.te 中.

如果大家需要更加深入理解SELinux ，可以参考:

MTK Online SELinux Topic,  没有比这更加完整的文档了.
http://online.mediatek.com/_layouts/15/mol/topic/ext/Topic.aspx?id=158
```

## [FAQ18043] 手机端删除文件之后在PC端查看MTP内容更新但可用容量未更新

```
操作步骤：
被测终端连接MTP至PC端，进入文件管理，删除话机U盘或者SD中的一个文件，进入PC端MTP设备查看
实际结果：
话机U盘或者SD卡的可用容量不变
预期结果：
删除文件后可用容量应该变大
备注：重新插拔数据线后连接MTP后可用容量正常
 
[Analyze]
 
PC端如果要更新MTP信息会通过/dev/mtp_usb节点向native层发送请求
当在手机端操作删除一个文件之后，PC端仅仅会发送更新存储器里面内容的请求，不会发送更新storage info的请求

01-02 02:54:36.733539 1123 1890 V MediaProvider: [MediaProvider] --- delete<<<: uri=content://media/external/file, count=1
01-02 02:54:36.742277 1123 3715 D MtpServer: operation: MTP_OPERATION_GET_OBJECT_HANDLES
01-02 02:54:36.742424 1123 3715 D MtpServer: doGetObjectHandles: storageID = 0x767a0001, format = 0x0, parent = 0xffffffff
01-02 02:54:36.747435 789 2539 D AudioTrack: AudioTrackThread::pauseInternal: ns = 12673505
01-02 02:54:36.747470 789 814 D SettingsInterface: from settings cache , name = dropbox:system_app_strictmode , value = null
01-02 02:54:36.747923 1123 3715 D MtpServer: sending response 2001
01-02 02:54:36.748851 1123 3715 D MtpServer: operation: MTP_OPERATION_GET_OBJECT_PROP_LIST
01-02 02:54:36.749223 1123 3715 D MtpServer: GetObjectPropList 66 format: NONE property: MTP_PROPERTY_OBJECT_FORMAT group: 0 depth: 0
01-02 02:54:36.749356 1123 3715 D MtpDatabase: getObjectPropertyList: handle = 0x42, property = 0xdc02
```

## [FAQ18383] 默认设置以飞行模式开机

```
若有需求在烧完版本后，需要以飞行模式开机，那么请按照如下修改方案进行修改
将/frameworks/base/packages/SettingsProvider/res/values/defaults.xml中
<bool name="def_airplane_mode_on">false</bool>
修改为
<bool name="def_airplane_mode_on">true</bool>

注：仅第一次开机有效，若在使用过程中有离开飞行模式，那么下次开机会保持离开飞行模式状态
```

## [FAQ11162] [SAT]移除google默认浏览器后,LAUNCH BROWSER发生异常

```
客户若将google默认的浏览器移除，则当SAT测试中执行与LAUNCH BROWSR命令相关的测项时都会报exception。

分析:
由于StkAppService.java中是写死调用google默认的浏览器来执行打开browser的动作。
如果把google默认的浏览器移除，那么就无法找到对应的Activity，引起exception。

那么这种case下，需要客户自行修改代码，修改为替换的browser app和activity 即可。
alps\mediatek\packages\apps\stk1\src\com\android\stk\StkAppService.java
private void launchBrowser(BrowserSettings settings) {
    if (settings == null) {
        return;
    }
    ...............
    intent.setClassName("com.android.browser", "com.android.browser.BrowserActivity");
将红色的字符修改为替换的browser app name和activity name。
而L0.MP5版本以及以后的版本包括 L1和M版本上这行 code已经去掉，并没有写死要启动的 activity。所以，L0.MP5以及以后的版本不用再做这个处理。
```

## [FAQ05657] [SAT]如何动态修改SIM卡应用名称

```
方法一：
以将STK app name动态修改成运营商名称为例子。
1、运营商的名称存储在以下SystemProperty中
卡1:  TelephonyProperties.PROPERTY_OPERATOR_ALPHA 
卡2:  TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2

2、使用运营商名字来动态修改package对应的app name(应用程序名字) 
2.1  如果是GB3版本，则
修改文件：ContextImpl.java
具体修改如下：
import android.os.SystemProperties;
import com.android.internal.telephony.TelephonyProperties;
@Override
public CharSequence getText(String packageName, int resid, ApplicationInfo appInfo) {
    ResourceName name = new ResourceName(packageName, resid);
    CharSequence text = getCachedString(name);
    if (text != null) {
         //add start
         if(packageName.equalsIgnoreCase("com.android.stk"))
         {
            Log.d("jby","packagemanager1,stkpackageName1:"+packageName);
             String tmptext=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA);
            if(!tmptext.isEmpty())
              if(!tmptext.equalsIgnoreCase("com.android.stk"))
                       text=tmptext;
         }
         else if(packageName.equalsIgnoreCase("com.android.stk2"))
         {
            Log.d("jby","packagemanager1,stkpackageName2:"+packageName);
            String tmptext=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2);
            if(!tmptext.isEmpty())
              if(!tmptext.equalsIgnoreCase("com.android.stk2"))
                            text=tmptext;
         }
         Log.d("jby","text="+text);
        //add end
        return text;
    }
    if (appInfo == null) {
        try {
            appInfo = getApplicationInfo(packageName, 0);
        } catch (NameNotFoundException e) {
            return null;
        }
    }
    try {
        Resources r = getResourcesForApplication(appInfo);
        text = r.getText(resid);
        putCachedString(name, text);
        //add start
         if(packageName.equalsIgnoreCase("com.android.stk"))
         {
            Log.d("jby","packagemanager1,stkpackageName1:"+packageName);
         String tmptext=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA);
            if(!tmptext.isEmpty())
              if(!tmptext.equalsIgnoreCase("com.android.stk"))
                            text=tmptext;
         } else if(packageName.equalsIgnoreCase("com.android.stk2")) {
            Log.d("jby","packagemanager2,stkpackageName2:"+packageName);
            String tmptext=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2);
            if(!tmptext.isEmpty())
              if(!tmptext.equalsIgnoreCase("com.android.stk2"))
                            text=tmptext;
         }
         Log.d("jby","text="+text);
          //add end
        return text;
    } catch (NameNotFoundException e) {
        Log.w("PackageManager", "Failure retrieving resources for" + appInfo.packageName);
    } catch (RuntimeException e) {
        // If an exception was thrown, fall through to return
        // default icon.
        Log.w("PackageManager", "Failure retrieving text 0x" + Integer.toHexString(resid) + " in package " + packageName, e);
    }
    return null;
}

2.2  如果是JB2以及JB2以后的版本，则
修改文件：ApplicationPackageManager.java
具体修改：参考上述的GB3版本修改，基本一样。

方法二：
1、如果是GB3、GB5版本，则
修改文件:
packages\apps\launcher2\src\com\android\launcher2\PagedViewIcon.java
具体修改：将applyFromApplicationInfo()方法中的setText，通过packageName来过滤，设置期望显示的名字。
例如：packageName = “com.android.stk1”, 期望显示的名字"我的名字"，则
if (packageName 等于info.componentName.mPackage) {
   setText("我的名字")
} else {
   setText(info.title);
}

2、如果是JB2以及JB2以后的版本，则
修改的文件： PagedViewIcon.java
两个SAT应用程序是共用一个packageName的，所以无法通过应用的包名来区分，必须通过类名来区分。
例如：插入卡槽2的SIM或USIM应用程序是通过启动"stkLauncherActivityⅡ"。
 将applyFromApplicationInfo()方法中的setText，通过TargetclassName来过滤，设置期望显示的名字。
   例如：TargetclassName = “stkLauncherActivityII”, 期望显示的名字"我的名字"，则
   if (TargetclassName 等于info.componentName.mClass) {
       setText("我的名字")
   } else {
       setText(info.title);
   }

L0 、L1 、M版本：
由于StkAppService启动的packageName和activity都只有一个，所以无法区分，因此，无法用这种方法做客制化。

例如：针对联通定制版，要实现STK应用名称从卡里读取并显示(JB2以及JB2以后的版本)。
由于SAT 应用是动态安装的。launcher 菜单中的 SAT应用图标是 Stk1.apk的图标。

1、从systemproperty中获取卡的运营商名称。
可以参考方法2中的2.1 的demo code，修改 ApplicationPackageManager.java 文件的 getText() 方法，从SystemProperties中获取对应的卡的运营商名称:
String tmptext=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA);
String tmptext=SystemProperties.get(TelephonyProperties.PROPERTY_OPERATOR_ALPHA_2);

2、两个SAT应用程序是共用一个packageName的，所以无法通过包名来区分，必须通过类名来区分。

例如插入卡槽2的sim或usim应用程序是通过启动"stkLauncherActivityII"
将applyFromApplicationInfo()方法中的setText，通过TargetclassName来过滤，设置期望显示的名字 为从步骤 1 获取到的名字。
例如：TargetclassName = "stkLauncherActivityII", 期望显示的名字"我的名字"
if (TargetclassName 等于info.componentName.mClass) {
    setText("我的名字");
} else {
    setText(info.title);
}
```

## [FAQ15507] 【VoLTE】如何让手机的增强型4GLTE开关默认处于关闭状态？

```
MTK默认的版本中，Setting里面的增强4GLTE开关（VoLTE）默认是开启的，如果想要将其默认设置为关闭状态的话请参考如下修改即可：

package com.android.providers.settings;
DatabaseHelper.java
loadSetting(stmt, Settings.Global.ENHANCED_4G_MODE_ENABLED, ImsConfig.FeatureValueConstants.ON);（两处地方），将ImsConfig.FeatureValueConstants.ON 改为 OFF

alps/device/mediatek/common/device.mk 文件中如下位置
ifeq ($(strip $(MTK_VOLTE_SUPPORT)), yes)
    PRODUCT_PROPERTY_OVERRIDES += ro.mtk_volte_support=1
    PRODUCT_PROPERTY_OVERRIDES += persist.mtk.volte.enable=1
endif
将persist.mtk.volte.enable=1
修改为 ：persist.mtk.volte.enable=0
```

## [FAQ18353] [Legacy Wi-Fi]如何用adb shell am命令关闭wifi后台扫描

```
adb shell am broadcast -a com.mtk.stopscan.activated // 关闭scan
adb shell am broadcast -a com.mtk.stopscan.deactivated // 开启scan
PS：注意不要进入到WifiSettings的页面，因为apk来的Scan，不会挡
```

## [FAQ12485] LatinIME输入键盘的右下角的"笑脸"按键替换成"回车换行"按键

```
JB和KK版本修改方法：
修改latinIME源码中的key_styles_common.xml内的enterKeyStyle 的定义为下面的定义即可（其实就是把大小写对应
的style跟原来比进行了互换）
<switch>
- <!--  Shift + Enter in textMultiLine field. 
  --> 
- <case latin:mode="im" latin:isMultiLine="true" latin:keyboardLayoutSetElement="alphabetManualShifted|alphabetShiftLockShifted">
  <key-style latin:styleName="enterKeyStyle" latin:parentStyle="emojiKeyStyle" /> 
  </case>
- <!-- 
 Smiley in textShortMessage field.
             Overrides common enter key style.
  --> 
- <case latin:mode="im">
  <key-style latin:styleName="enterKeyStyle" latin:parentStyle="shiftEnterKeyStyle" /> 
  </case>
  </switch>
 
L和M版本修改方法：
原理与之前的版本一致，只是修改的文件有所变化，L和M版本修改/packages/inputmethods/LatinIME/java/res/xml/key_styles_enter.xml文件中的如下代码：
小写状态下笑脸改为回车：
  <case latin:mode="im">
      <key-style latin:styleName="enterKeyStyle"
                     latin:parentStyle="emojiKeyStyle" /> 
  </case>
将emojiKeyStyle修改为defaultEnterKeyStyle
 
反之大写状态下要修改为笑脸：
    <case
           latin:isMultiLine="true"
            latin:keyboardLayoutSetElement="alphabetManualShifted|alphabetShiftLockShifted"
       >
            <key-style
                latin:styleName="enterKeyStyle"
                latin:keySpec="!icon/enter_key|!code/key_shift_enter"
                latin:parentStyle="defaultEnterKeyStyle" />
       </case>
将defaultEnterKeyStyle修改为emojiKeyStyle
 
Note：
  如果将"笑脸"键替换成"回车换行"按键后，想再次输入笑脸等表情，可以通过长按“回车换行”键，弹出表情按钮来操作。
```

## [FAQ12261] [Dialer]如何客制化俄文拨号盘？

```
4.2 JB 拨号盘显示是通过多张图片拼接起来显示的，4.4 KK的拨号盘是通过多个TextView显示字符串来实现的，
所以客制化KK的拨号盘只需要客制化对应字符串即可。
方法一:
FILE: alps\packages\apps\Dialer\res\values-ru\strings.xml 
在res\values-ru\strings.xml下面没有定义如下字符串，自己客制化为俄文即可：

<string name="dialpad_star_number">*</string>
<string name="dialpad_pound_number">#</string>
<string name="dialpad_0_letters">+</string>
<string name="dialpad_1_letters"></string>
<string name="dialpad_2_letters">ABC</string>
<string name="dialpad_3_letters">DEF</string>
<string name="dialpad_4_letters">GHI</string>
<string name="dialpad_5_letters">JKL</string>
<string name="dialpad_6_letters">MNO</string>
<string name="dialpad_7_letters">PQRS</string>
<string name="dialpad_8_letters">TUV</string>
<string name="dialpad_9_letters">WXYZ</string>
<string name="dialpad_star_letters"></string>
<string name="dialpad_pound_letters"></string>

优点：修改量小，容易实现；
缺点：如果同时显示英文和俄文字符，则不能单独设置颜色。

方法二:
参考之前英文字符的显示方法自己添加一个TextView来显示俄文字符，然后在res\values-ru\strings.xml中添加对应的字符串即可。
优点：同时显示英文和俄文字符时，可以单独设置俄文的字体颜色/字体大小/位置等。
缺点：修改量大。
```

## [FAQ18330] 开机向导中设置用户名称后，在设置多用户中当前用户名称没有修改

```
Google的开机向导设置用户名称，在设置多用户中，当前用户名称没有修改，始终是Owner
修改如下：
packages/apps/Settings/src/com/android/settings/users/ProfileUpdateReceiver.java

import android.os.SystemProperties;

public void onReceive(final Context context, Intent intent) {
    Log.d("ProfileUpdateReceiver", "Profile photo changed, get the PROFILE_CHANGED receiver.");
    // Profile changed, lets get the photo and write to user manager
    new Thread() {
        public void run() {
            Utils.copyMeProfilePhoto(context, null);
            ///M: Fix ALPS01262605
            String isGMS = SystemProperties.get("ro.com.google.gmsversion", null);
            if (isGMS != null) {
                copyProfileName(context);
            }
        }
    }.start();
}
```

## [FAQ18333] 设置->数据流量->WI-FI里面，选择跨年日期时，图片坐标最终日期不显示年

```
进入设置->数据流量->WI-FI里面，选择跨年日期( 终止日期的年跨过起始年份)时，图片坐标最终日期不显示年
例如选择日期Dec 7，2014 - Jan 4,2015里面；最终图片只显示Jan 4，不显示2015

这个android对时间显示的默认设计，如果跟现在时间是同一年，就不再额外显示年份，敝司觉得是合理的，如果贵司觉得这是个问题要修改，可以参考如下修改方式：
packages/apps/Settings/src/com/settings/DataUsageSummary.java
如下方法里，添加format time的flag FORMAT_SHOW_YEAR

public static String formatDateRange(Context context, long start, long end) {
    final int flags = FORMAT_SHOW_YEAR | FORMAT_SHOW_DATE | FORMAT_ABBREV_MONTH;
    synchronized (sBuilder) {
        sBuilder.setLength(0);
        return DateUtils.formatDateRange(context, sFormatter, start, end, flags, null).toString();
    }
}
```

## [FAQ12121] [SEC]如何调用接口来解锁SIM ME Lock

```
该FAQ介绍如何调用Telephony Framework的接口来解锁SIMME Lock。

在实现运营商的锁网需求时，如果不是MTK原生Keyguard，或者是用户单独开发的解锁界面，调用Telephony的接口函数时，建议参考MTK原生Keyguard的实现方式用一个新线程来实现。

 [SOLUTION]

Framework提供的解锁函数为 PhoneInterfaceManagerEx.java supplyNetworkDepersonalization()，可以调用此函数来解锁。

1. L版本上参考KeyguardSimPinPukMeView.java中的 CheckSimMe thread.run()函数调用方式，

实例如下：

      private class simMeCheckThread extends Thread {

        private final String mPasswd;
        private int mSlotId;
        private int mResult;
 
        protected simMeCheckThread (String passwd, long slotId) {

            mPasswd = passwd;
            mSlotId= slotId;
        }

        @Override
        public void run() {

            try {
 //注意L上slotId与subId的差别，需要进行转换
 long [] subIds = SubcriptionManager.getSubId(slotId);
                Log.d(TAG, "CheckMe, " + "slotId = " + slotId + ", subId = " + subIds[0]);
 //supplyNetworkDepersonalization()
                mResult = ITelephonyEx.Stub.asInterface(ServiceManager.getService("phoneEx"))
                        .supplyNetworkDepersonalization(subIds[0], mPasswd);

                Log.d(TAG, "CheckMe, " + "mSlotId=" + mSlotId + " mResult=" + mResult);
            } catch (RemoteException e) {
                Log.e(TAG, "supplyNetworkDepersonalization got exception: " + e.getMessage());
            }
        }
    }
 2. KK版本可以参考KeyguardSimPinPukView.java CheckSimMe thread 中的run()函数调用方式。

实例如下:

import com.mediatek.common.telephony.ITelephonyEx;
 
private class SimMeCheckThread extends Thread {
    int mSimId;
    String mPasswd;

    SimMeCheckThread(int mSimId, string mPasswd) {
        this.mSimId = mSimId;
        this.mPasswd = mPasswd;
    }

    @Override
    public void run() {
        try {
           Log.d(TAG, "simMeCheckThread-run() mSimId =" + mSimId +" mPasswd ="+mPasswd);
           //supplyNetworkDepersonalization()
           mResult = ITelephonyEx.Stub.asInterface(ServiceManager.checkService("phoneEx")).supplyNetworkDepersonalization(mPasswd, mSimId);
           Log.d(TAG, "simMeCheckThread-run()done mResult =" + mResult);                      
        } catch (Exception e) {
            Log.e(TAG, "supplyNetworkDepersonalization got exception: " + e.getMessage());

        }
    }
}
```

## [FAQ12108] [SEC]输入暗码来上锁和解锁SIM ME LOCK功能

```
运营商需求如下:
输入*#3411#来解锁SIM ME LOCK功能，重启后，非法的卡不需要输入解锁密码。
输入*#3412#来上锁SIM ME LOCK功能，重启后，非法的卡需要输入解锁密码。

[SOLUTION]
实现思路：
由于modem配置锁卡数据之后，是无法修改的。所以UNLOCK和LOCK的功能在AP端来模拟.
1）在modem端配置SML 参数，配置锁卡信息：默认是上锁状态，参考DMS上文档：SIM-ME lock，根据锁需要的 lock 配置相应的 NVRAM_EF_SML_DEFAULT。
2）在app端模拟解锁和上锁的功能。

修改步骤:

增加一个system property 记录是否有输入解锁暗码。默认值为false，就是上锁状态；如果默认值为true则为解锁状态。
针对插入非法卡时，开机时有被locked的处理。
L版本请修改：

alps/frameworks/base/packages/Keyguard/src/com/android/keyguard/KeyguardUpdateMonitor.java
private void proceedToHandleSimStateChanged(SimArgs simArgs) {
    if ((IccCardConstants.State.NETWORK_LOCKED == simArgs.simState) && KeyguardUtils.isMediatekSimMeLockSupport()) {
        //从system Property中取值判断
        //如果不需要输入解锁密码，则直接调用解锁函数进行解锁.
        //参考FAQ12121 [SEC]如何调用接口来解锁SIM ME Lock
        new simMeCheckThread(simArgs.subId, mPasswd).start();
        //mPasswd为modem配置的解锁密码.
    } else {

L之前的版本请修改：alps\frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\KeyguardUpdateMonitor.java

private final BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() {
} else if (TelephonyIntents.ACTION_SIM_STATE_CHANGED.equals(action)) {
if (IccCardConstants.State.NETWORK_LOCKED == simArgs.simState) {
    //从system Property中取值判断
    //如果不需要输入解锁密码，则直接调用解锁函数进行解锁.
    //参考FAQ12121 [SEC]如何调用接口来解锁SIM ME Lock
    new SimMeCheckThread(simArgs.simId, mPasswd).start();
    //mPasswd为modem配置的解锁密码.
否则就按照原有流程跑，就会正常显示输入锁卡密码界面，需要解锁。 

输入暗码的处理
输入*#3411#，解锁设置system Property 为true
输入*#3412#，上锁设置system property 为false
```

## [FAQ18375] 分析windowManagerService相关的问题，需要提交哪些log给MTK?

```
测试的过程中，我们有时候会遇到如下的一些问题，比如:
画面切换或者动画过程中闪屏
window顺序排列异常
转屏过程中出现画面异常
window size异常
........
这些问题，往往无法从默认的mtklog中分析出原因，需要window log才能做具体分析
 
[SOLUTION]
抓取window log的方式有两种:
1.adb shell命令动态打开,不需要build codebase
adb shell dumpsys window -d enable a
PS:不需要用adb shell stop/start重启adb,重启手机或者重启adb后都需要重新开启

2.修改WindowManagerService.java中相关的code
将windowManagerService.java中的所有带DEBUG标志的flag(比如DEBUG,DEBUG_XX)都修改为true,然后重新build frameworks/base/services/core 模块

window log包含在mtklog中，复现问题后直接提交mtklog给MTK即可
```

## [FAQ18349] 设置歌曲为来电铃声，删除歌曲后，来电铃声异常

```
1, packages/services/Telecomm/src/com/android/server/telecom/AsyncRingtonePlayer.java
private Ringtone getRingtone(Uri ringtoneUri) {
/* if (ringtoneUri == null) {
ringtoneUri = Settings.System.DEFAULT_RINGTONE_URI;//ringtone,which can be changed by customer
} */ 
//add begin
Log.d(this, "lll getRingtone ringtoneUri" + ringtoneUri);
if(ringtoneUri == null){
Uri defaultringtoneUri = RingtoneManager.getDefaultRingtoneUri(mContext, AudioProfileManager.TYPE_RINGTONE);//default ringtone 
AudioProfileManager audioProfileMgr = (AudioProfileManager) mContext.getSystemService(Context.AUDIO_PROFILE_SERVICE);
ringtoneUri = audioProfileMgr.getRingtoneUri(audioProfileMgr.getActiveProfileKey(), AudioProfileManager.TYPE_RINGTONE);
Log.d(this, "lll getRingtone ringtoneUri " + ringtoneUri+ " defaultringtoneUri " + defaultringtoneUri);
if (-1 == RingtoneManager.validRingtoneUri(mContext, ringtoneUri,RingtoneManager.TYPE_RINGTONE)) {
ringtoneUri = defaultringtoneUri;
}
Log.d(this, "lll getRingtone actual ringtoneUri" + ringtoneUri); 
}
Ringtone ringtone = RingtoneManager.getRingtone(mContext, ringtoneUri);
//add end

//ALPS01820873 ringtone maybe null
if (ringtone != null) {
ringtone.setStreamType(AudioManager.STREAM_RING);
}
return ringtone;
}
2,frameworks/base/media/java/android/media/RingtoneManager.java
public static int validRingtoneUri(Context context, Uri ringtoneUri, int type) //将public替换为private
```

## [FAQ18372] 静音或震动模式下开机仍然会有开机铃声，如何修改为没有开机铃声？

```
静音或震动模式下开机仍然会有开机铃声，是bootanimation_main.cpp文件中读取persist.sys.mute.state的值读取不到所致。
如何修改为静音或震动模式下没有开机铃声？

[SOLUTION]
1，原因是读取persist.sys.mute.state的属性值时，data分区未挂载，导致读取属性值失败。
2，修改方法如下： 
frameworks/base/cmds/bootanimation/BootAnimation.cpp
117static const int ANIM_ENTRY_NAME_MAX = 256;
118static const bool deal_with_encryption = true;//add
char* BootAnimation::initAudioPath() {
821 if (!bPlayMP3) {
822 XLOGD("initAudioPath: DON'T PLAY AUDIO!");
823 return NULL;
824 }
825
//----------------add--------------------
826 char crypto_state[PROPERTY_VALUE_MAX];
827 char type[PROPERTY_VALUE_MAX];
828 char status[PROPERTY_VALUE_MAX];
829 char volume[PROPERTY_VALUE_MAX];
830
831 property_get("ro.crypto.state", crypto_state, "-1");
832 property_get("vold.encryption.type", type, "-1");
833 XLOGD("[BootAnimation %s %d]ro.crypto.state=%s, vold.encryption.type=%s",
834 __FUNCTION__,__LINE__, crypto_state, type);
835 while (strcmp(type, "-1") == 0 &&
836 strcmp(crypto_state, "unencrypted") != 0 &&
837 deal_with_encryption == true){
838 usleep(100000);
839 property_get("ro.crypto.state", crypto_state, "-1");
840 property_get("vold.encryption.type", type, "-1");
841 }
842
843 while (strcmp(type, "default") == 0 && deal_with_encryption == true){
844 property_get("vold.decrypt", status, "-1");
845 if (strcmp(status, "trigger_restart_framework") != 0){
846 usleep(100000);
847 XLOGD("[BootAnimation %s %d]Decrypt status=%s",__FUNCTION__,__LINE__,status);
848 continue;
849 }
850 property_get("persist.sys.mute.state", volume, "-1");
851 int nVolume = -1;
852 nVolume = atoi(volume);
853 XLOGD("[BootAnimation %s %d]nVolume=%d",__FUNCTION__,__LINE__,nVolume);
854 if(nVolume == 0 || nVolume == 1){
855 XLOGD("initAudioPath: DON'T PLAY AUDIO!");
856 return NULL;
857 }
858 break;
859 }
860
//----------------add--------------------
861 int index = 0;
862 if (bBootOrShutDown) {
863 index = 0;
864 } else {
865 index = 1;
866 }
```

## [FAQ18334] 短信的通知音很长，此时再来电话后，会重叠播放；如何实现来电时，短信通知声应该停止播放？

```
1，将短信的通知铃声设置为播放时间比较长的Mp3或其它文件
2, 来短信，将播放所设定的短信通知铃声，此时来电，来电铃声与短信通知铃声重叠播放在一起
3，如何实现来电时，短信通知声应该停止播放？
 
frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java 
private void listenForCallState() { 
TelephonyManager.from(getContext()).listen(new PhoneStateListener() {
@Override
public void onCallStateChanged(int state, String incomingNumber) {

// Add begin
Log.d(TAG,"listenForCallState() state = " + state);
long identity = Binder.clearCallingIdentity();
if (state == AudioSystem.PHONE_STATE_RINGING){
try {
final IRingtonePlayer player = mAudioManager.getRingtonePlayer();
if (player != null) {
Log.e(TAG, "listenForCallState() player.stopAsync()");
player.stopAsync();
}
} catch (RemoteException e) {
} finally {
Binder.restoreCallingIdentity(identity);
}
}
// add end
if (mCallState == state) return;
if (DBG) Slog.d(TAG, "Call state changed: " + callStateToString(state));
mCallState = state;
}
}, PhoneStateListener.LISTEN_CALL_STATE);
}
```

## [FAQ18200] Android M 第三方camera APK, preview video偏暗

```
Andoird M中,在MtkDefaultCamParameter.cpp 中的setParameters函数会去吃config.ftbl.xxxmipiraw.h中设定的preview fps range,需要将config.ftbl.xxxmipiraw.h中Preview Frame Rate Range修改为（5000,30000）。 
   setParameters()
{
   .....
  const char* p = mpParamsMgr->getStr(CameraParameters::KEY_PREVIEW_FPS_RANGE);

  char* q;

  cam3aParam.i4MinFps = strtol(p,&q,10);

  cam3aParam.i4MaxFps = strtol(q+1,&q,10);
  .....
}
 config.ftbl.xxxmipiraw.h:

 FTABLE_CONFIG_AS_TYPE_OF_USER(
 KEY_AS_(MtkCameraParameters::KEY_PREVIEW_FPS_RANGE),
 SCENE_AS_DEFAULT_SCENE(
 ITEM_AS_DEFAULT_("5000,30000")
 ITEM_AS_USER_LIST_(
 "(15000,15000)",
 "(20000,20000)",
 "(24000,24000)",
 "(5000,30000)",
 "(30000,30000)",
```

## [FAQ09066] OTA 升级查询版本失败，log显示your version is illegal！ 解决办法

```
在使用MTK OTA升级的时候，出现查询版本失败的现象，查看log里面提示your version is illegal！报的error为1105
 
这是因为手机的信息，也就是old版本的信息与Server上提交old版本时候填写的信息不一致。 old版本，new版本在upload到server的时候，server上要求填写的项是来自于package包的build.prop文件。对应关系如下：
       build.prop                        upload.php
–      ro.build.display.id-----------------build number of the version
–      ro.product.locale.language---------------LANGUAGE
–      ro.product.manufacturer------------------OEM
–      ro.operator.oper--------------------OPERATOR
–      ro.product.device-----------PRODUCT
–      ro.build.fingerprint------------FINGERPRINT
–      ro.build.version.release--------------------android version
–      ro.product.name------------------------name of the version

请注意：

1、如果 build.prop 中ro.build.display.id的值包含keys或者不以ALPS开头，
upload.php的build number of the version需要填写build.prop中ro.mediatek.version.release的值，而不是ro.build.display.id的值
手机相关code在：SystemUpdate/src/com/mediatek/systemupdate/Util.java

String buildnumber = SystemProperties.get("ro.build.display.id");
//on AOSP branch,the value of 'ro.build.display.id' will like:
//'full_mt6582_phone_qhd-eng 4.4.2 KOT49H 1400738660 dev-keys'
if (buildnumber.contains("keys") || !(buildnumber.startsWith("ALPS"))) {
    Log.i("@M_" + TAG, "Get build number from 'ro.mediatek.version.release'");
    buildnumber = SystemProperties.get("ro.mediatek.version.release");
}
 
2、如果预置了GMS包，upload.php填写PRODUCT时需要在后面加上 [GMS]
手机相关code在：SystemUpdate/src/com/mediatek/systemupdate/Util.java
builder.append(oem).append("_").append(product);

if (isGmsLoad(context) || isGmsLoad2()) {
    builder.append("[gms]");
}
```

## [FAQ13241] [Gallery]PhotoPage如何全屏显示图片（如何动态设置虚拟按键？）

```
根据实际需要这种模式的显示的页面添加如下flag
 
1. Hide Bars 
int flags = 0;
flags|= View.SYSTEM_UI_FLAG_FULLSCREEN
  |View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
  |View.SYSTEM_UI_FLAG_IMMERSIVE
  |View.SYSTEM_UI_FLAG_LAYOUT_STABLE
  |View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
  |View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;
 
 setSystemUiVisibility(flags);
 
 View.SYSTEM_UI_FLAG_HIDE_NAVIGATION --> 隐藏navigationbar
 View.SYSTEM_UI_FLAG_FULLSCREEN --> 隐藏statusbar
 
2.Show Bars
 
int flags = 0;
flags|= View.SYSTEM_UI_FLAG_LAYOUT_STABLE
   |View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
   |View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN;
 
setSystemUiVisibility(flags);
 
    这3个flag 需要配合使用，清除所有的Flag，半透明显示SYSTEM UI ，同时使得当前Activity的UI 不被resize 并显示在SYSTEM UI 下面。
 
 ==========================
以PhotoPage为例，实现全屏沉浸模式，需要做如下改动：
 文件：PhotoPage.java
 
1. onResume()方法中增加如下code：
protected void onResume()｛
...
     // add by mtk start
     Window win = mActivity.getWindow();
     win.addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
     win.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
     // add by mtk end
...
｝
2. onDestroy()方法中增加如下code：

protected void onDestroy() {
...
     //add by mtk start
     Window win = mActivity.getWindow();
     win.clearFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
     win.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
     //add by mtk end

     super.onDestroy();
｝
3. showBars()方法增加如下code:

private void showBars() {
...
    //add by mtk start
    Window win = mActivity.getWindow();
    win.addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);
    win.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
    //add by mtk end

    mActionBar.show();
    mActivity.getGLRoot().setLightsOutMode(false);
...

｝
4. hideBars()增加如下改动：

private void hideBars() {
...

  mActionBar.hide();
   //add by mtk start

  Window win = mActivity.getWindow();
    win.clearFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);
    int flags = (View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
                    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
                    | View.SYSTEM_UI_FLAG_FULLSCREEN
                    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
                    | View.SYSTEM_UI_FLAG_LAYOUT_STABLE);
  win.getDecorView().setSystemUiVisibility(flags);
    win.setNavigationBarColor(Color.TRANSPARENT);
    //add by mtk end

  //mActivity.getGLRoot().setLightsOutMode(true);  //delete by mtk
...
｝
上述修改可以实现大图界面图片全屏显示，但会导致编辑、连拍按钮被Navigation Bar覆盖，如下图所示：

 

如下修改仅供参考：

Photopage_bottom_controls.xml 设置

 android:id="@+id/photopage_bottom_controls"
 android:padding="10dp"
 android:layout_width="match_parent"
 android:layout_height="wrap_content"
 android:layout_alignParentBottom="true"
 android:layout_alignParentLeft="true"
 android:orientation="horizontal"
 android:fitsSystemWindows=”true”<--! add by mtk -->
 android:visibility="gone">
ContainerLayer.java

1.增加头文件

import android.content.res.Resources;
import android.content.res.Configuration;
2.增加新方法

private static int getNavigationBarHeight(Activity activity){
     Resources resources = activity.getResources();
     int resId = resources.getIdentifier("navigation_bar_height", "dimen", "android");
     int height = resources.getDimensionPixelSize(resId);
     return height;
}
修改showLeftBottomIcon()方法
private void showLeftBottomIcon() {
     mContainer.setVisibility(View.VISIBLE);
 
     // add by mtk start
     int orientation = mActivity.getResources().getConfiguration().orientation;
     int h = getNavigationBarHeight(mActivity);
 
     if (orientation == Configuration.ORIENTATION_PORTRAIT) {
         mContainer.setX(0);
         mContainer.setY(-h);
     }else{
         mContainer.setY(0);
         mContainer.setX(-h);
     }
     //add by mtk end

     if (mMediaData.subType == MediaData.SubType.CONSHOT) {
         mConShotIcon.setVisibility(View.VISIBLE);
     }
 }
PhotoPage.java新增如下方法：

@Override
 public void onConfigurationChanged(Configuration config) {
     super.onConfigurationChanged(config);
     toggleBars();
 }
```

## [FAQ17784] [Recovery][Common]Android M OTA build (Include Security OTA)

```
case 1、不论是否开启Security boot功能，M 版本的OTA build方法都如下：

Full : ./build/tools/releasetools/ota_from_target_files –v --block -k $(key_path) –s device/mediatek/build/releasetools/mt_ota_from_target_files src.zip update.zip
Incremental : ./build/tools/releasetools/ota_from_target_files –v --block -k $(key_path) –s device/mediatek/build/releasetools/mt_ota_from_target_files –i src.zip tgt.zip update.zip

case 2、如果需要同时升级lk、preloader，请参考：
ID: FAQ17441
[Recovery][Common]Android M 版本如何升级lk 、preloader ？
```

## [FAQ14670] 如何关闭latinIME的联想输入功能

```
L版本的修改方法：
1：修改LatinIME code中的SettingsValue.java内的
readSuggestionEnabled函数内的
pref.getBoolean内的默认值为false。
2:修改LatinIME code中的SettingsValue.java内的 autoCorrectionThresholdRawValue
的初始值为
final String autoCorrectionThresholdRawValue = pref.getString(Settings.PREF_AUTO_CORRECTION_THRESHOLD, res.getString(R.String.auto_correction_threshold_mode_index_off));
 
M版本的修改方法：
1：修改LatinIME code中的SettingsValue.java内的
readSuggestionEnabled函数内的
pref.getBoolean内的默认值为false。

2:修改LatinIME code中的Settings.java内的 readAutoCorrectEnabled里面prefs.getBoolean内的默认值修改为false
public static boolean readAutoCorrectEnabled(final SharedPreferences prefs, final Resources res) {
    return prefs.getBoolean(PREF_AUTO_CORRECTION, false);
}
```

## [FAQ10957] LatinIME.apk和LatinImeGoogle.apk的区别

```
1.自4.2之后Latin输入法增加了手势输入（滑动输入）的功能，但是这个功能被google放在了GMS包中，所以自4.2之后GMS包中多了LatinImeGoogle.apk。
2.android源码中的latin输入法是LatinIME.apk，没有手势输入的功能。GMS包中的LatinImeGoogle.apk包括所有LatinIME.apk中的功能外加手势输入功能，但是没有源码。
3.只有安装了GMS之后才会有手势输入功能，在安装GMS包过程会用LatinImeGoogle.apk去替换LatinIME.apk。这就会导致客户在源码中对LatinIME.apk的修改，不能生效。例如，修改LatinIME默认的输入法语言、修改键盘的布局等。
```

## [FAQ12213] 设置默认输入法不成功

```
首先查看InputMethodManagerService.java中的systemRunning函数中是否有下面红色的代码，如果有则把红色后面蓝色的语句注释掉即可。如果没有红色代码可以参考FAQ06663。 
if (!mImeSelectedOnBoot) {
    Slog.w(TAG, "Reset the default IME as \"Resource\" is ready here.");
    /// M: Loading preinstalled ime from feature option. @{
    String preInstalledImeName = IMEFeatureOption.DEFAULT_INPUT_METHOD;
    Slog.i(TAG, "IMEFeatureOption defaultIME : " + preInstalledImeName);
    if (preInstalledImeName != null) {
        InputMethodInfo preInstalledImi = null;
        for (InputMethodInfo imi : mMethodList) {
            Slog.i(TAG, "mMethodList service info : " + imi.getServiceName());
            if (preInstalledImeName.equals(imi.getServiceName())) {
                preInstalledImi = imi;
                break;
            }
        }
        if (preInstalledImi != null) {
            setInputMethodLocked(preInstalledImi.getId(), NOT_A_SUBTYPE_ID);
        } else {
            Slog.w(TAG, "Set preinstall ime as default fail.");
            resetDefaultImeLocked(mContext);
        }
    }
    /// @}
    resetStateIfCurrentLocaleChangedLocked();
    InputMethodUtils.setNonSelectedSystemImesDisabledUntilUsed(
            mContext.getPackageManager(),
            mSettings.getEnabledInputMethodListLocked());
}
```

## [FAQ09939] 写短信输入法软键盘Done字串如何修改

```
解法1：如果其它APP的Done字符串也要更改一致，请用下面的方法修改
1:请修改
MTKRecipientEditTextView.java (alps\mediatek\frameworks-ext\ex\chips\src\com\android\ex\chips)
中将
public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
    ......
    //outAttrs.actionLabel = getContext().getString(R.string.done);// 将这行删除掉
    return connection;
}
2: 再在LatinIME的source code中搜索
label_done_key ,找到对应语言对该字符串的定义,修改为想要的字符串,重新mm LatinIME,修改就可以生效.

解法2：如果只想改短信中 MTKRecipientEditTextView 控件的done字符串，
请修改
MTKRecipientEditTextView.java (alps\mediatek\frameworks-ext\ex\chips\src\com\android\ex\chips)
中将
public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
    ......
    outAttrs.actionLabel = getContext().getString(R.string.done);//将此处的R.string.done替换为贵司需要的字符串，或者在mediate的 framework-res中搜索R.string.done的定义，修改为想要的字符串。
    return connection;
}
```

## [FAQ09620] 如何添加一个新的Latin输入法语言

```
在DMS上查找下面的文档，文档中详细的说明，请参考。
GB2：    Add new language support in LatinIME
ICS：SOP_add_new_language_for_android_keyboard_4.0
JB：SOP_add_new_language_for_android_keyboard_4.1
KK之后参考：
SOP_add_new_language_for_android_keyboard_JB_KK_L.pptx
 
如果要知道MTK目前有支持哪些输入语言，请参考FAQ。
ID: FAQ08121 
输入法语言支持状态
```

## [FAQ08767] 修改Android 自带输入法(LatinIME)空格键的显示

```
JB版本修改方式：
1:修改MainKeyboardView.java (alps\packages\inputmethods\latinime\java\src\com\android\inputmethod\keyboard)
中drawSpacebar函数,将绘制语言text的部分注释掉.
    //canvas.drawText(language, width / 2, baseline - descent - 1, paint);
    paint.setColor(mSpacebarTextColor);
    paint.setAlpha(mLanguageOnSpacebarAnimAlpha);
    //canvas.drawText(language, width / 2, baseline - descent, paint);
2:修改
Key_styles_common.xml 
(alps\packages\inputmethods\latinime\java\res\xml) 
中spaceKeyStyle的实现为
<key-style
    latin:styleName="spaceKeyStyle"
    latin:keyIcon="!icon/space_key"
    latin:code="!code/key_space"
    latin:keyActionFlags="noKeyPreview|enableLongPress" />
3:修改Keyboard-icons-ics.xml (alps\packages\inputmethods\latinime\java\res\values)
中 iconSpaceKey的实现为
<item name="iconSpaceKey">@drawable/sym_keyboard_space_holo</item>
重新编译LatinIME后并push到手机替换验证.
 
L版本和M版本修改方式：
1:修改MainKeyboardView.java (alps\packages\inputmethods\latinime\java\src\com\android\inputmethod\keyboard) 
中函数drawLanguageOnSpacebar函数，将绘制语言text的部分注释掉。
paint.setColor(mLanguageOnSpacebarTextColor);
paint.setAlpha(mLanguageOnSpacebarAnimAlpha);
//canvas.drawText(language, width / 2, baseline - descent, paint);
paint.clearShadowLayer();
paint.setTextScaleX(1.0f); 
2、重新编译LatinIME后并push到手机替换验证.
```

## [FAQ06663] 切换系统语言后默认输入法会自动切换到latin输入法

```
JB解决方案：
可以在文件inputmethodmanagerservice.java中
在构造函数InputMethodManagerService中的最后面，将接收语言改变广播的事件注释掉：

final IntentFilter filter = new IntentFilter();
filter.addAction(Intent.ACTION_LOCALE_CHANGED);
mContext.registerReceiver(new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        synchronized(mMethodMap) {
            //checkCurrentLocaleChangedLocked(); //将此行注释掉
        }
    }
}, filter);

这样就可以了。

KK、L、M 的解决方案：
可以在文件inputmethodmanagerservice.java中
在构造函数InputMethodManagerService中的最后面，将接收语言改变广播的事件注释掉：
final IntentFilter filter = new IntentFilter();
filter.addAction(Intent.ACTION_LOCALE_CHANGED);
mContext.registerReceiver(new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        synchronized(mMethodMap) {
            //resetStateIfCurrentLocaleChangedLocked();//将此行注释掉
        }
    }
}, filter);
这样就可以了。
```

## [FAQ18354] [Legacy Wi-Fi]非root权限下通过abd命令获取手机的MAC地址

```
adb shell wpa_cli -iwlan0 -g@android:wpa_wlan0 IFNAME=wlan0 DRIVER MACADDR
```

## [FAQ14493] [Speech][L version] 通话无声问题需要抓取哪些log

```
有时测试人员会低概率测试到通话无声的问题，
然而仅仅有vmlog+mobile log还比较难定位问题，需要抓取更多信息，具体请参考此FAQ
[SOLUTION]
1. 清空mtklog文件夹
2. 打开vmlog即进入工模->Hardware Testing->Audio->Speech Logger->勾选Enable speech log
    打开vmlog后每打一通电话便会在mtklog\audio_dump中生成一个*.vm文件，其以通话开始时间命名
3. start mobile log
4. 去复现无声问题
5. 当复现到无声后，请不要切换device(即不要切换成免提或者听筒，保持之前的就好)，也不要挂断电话
    进入工模->Hardware Testing->Audio->Audio Logger按下Dump Audio Debug Info
    [Expected result]: 前5s本端会听到tone音，后5s对方会听到tone音，请记录2边实际情况
6. 挂断电话后请不要再打电话
7. stop mobile log
8. 上传整个mtklog文件夹
注意：请严格按照如上步骤抓取，如果某项没有做，就麻烦测试人员重新复现，谢谢
```

## [FAQ14788] 如何用命令设置开发者选项中Enable OpenGL trace的各个选项？

```
在手机的Settings->Developer options->Enable OpenGL traces这个选项中的值，可以直接进入手机界面去做设定。
但有时候需要使用命令行来设置，那么可以使用如下方法来做。
 
[SOLUTION]
Enable OpenGL trace这个选项可以设定的值有3个：Logcat,Systrace(Graphics),Call stack on glGetError，
还有一个是默认选项：None(这个选项对应到property里面是没有值的，所以不可以通过setprop的方式去设置)
 
手机须先获取root权限后才可以设置，设置方法如下：
设定Logcat：adb shell setprop debug.egl.trace  1
设定Systrace：adb shell setprop debug.egl.trace systrace
设定glGetError：adb shell setprop debug.egl.trace  error
上述命令设置以后，接着需要如下两个命令来使得上述设置生效
adb shell  "stop;start"
 
注意：上述属性值设置完以后，永久生效(手机关机再开机依然保持不变)，若要恢复到默认值"None"，必须通过手机图形化界面去选择
 
通过如下命令check，做完上述设置以后是否生效：
adb shell getprop debug.egl.trace
```

## [FAQ18314] MountService对关机时间的影响

```
关机的时候，MountService需要对卡进行卸载，卸载卡有时候需要花费比较长的时间，进而影响到关机时间。
卸载卡即把卡的状态从Mouted切换到unmounted，状态切换的快慢跟是否有process访问卡上资源有很大关系。
卸载卡的时候，如果有process访问卡上资源，vold会每隔5秒retry 3次，如果到了timeout时间，还是有process访问卡上资源，vold会调用Process Killer暴利砍掉对应的process。
目前的循环等待时间是5s，如果要修改这个时间，建议不要修改太多，因为这是一个经验值，改太小的话，正常的unmount做不完就可能被kill，如果是SystemServer占用着卡上资源，暴利砍掉SystemServer就会导致系统重启，因此不要过分追求unmount时间短，因为这大大增加了SystemServer被kill的风险。
相关的code在：/system/vold/Utils.cpp的ForceUnmount()中，修改等待时间即修改这里面的sleep()时间。
 
另外，log中search "vold : Failed to unmount"可以知道具体是哪个路径被占用着，如果有FileSystem相关的监控工具，可以监控下这个路径在被谁操作，从而找到对应的Process。

简单的排查可以关掉MTKLoger(特别是modem log)，看关掉之后关机时间是否会变短。
```

## [FAQ18292] Omacp Apn信息替换原有APN

```
1. 在OmacpApnReceiverService.java文件中新增replaceApn,实现查找替换APN的功能
public long replaceApn(Context context, Uri uri, String apn, String apnId, String name, String types ,ContentValues values, String numeric) {
....
while (!cursor.isAfterLast()) {
…… 
//modify begin 
else if( (name.equals(cursor.getString(2))||apn.equals(cursor.getString(3))) && types.equals(cursor.getString(4)) )
{
numReplaced = cursor.getString(0);
break;
}
//modify end
cursor.moveToNext();
}
.....
}
注:标红的if语句中的内容可根据需求进行调整
 修改OmacpApnReceiverService.java的updateApn函数
private void updateApn(Context context, Uri uri, String apn, String apnId,
String name, ContentValues values, String numeric, Uri peferredUri) {
//modify 调用1中添加的方法
long replaceNum = replaceApn(context, uri, apn, apnId,name, mType , values, numeric);
.................
if (replaceNum == APN_NO_UPDATE) {
…..
}
// modify add 更新添加后的APN
} else if (replaceNum > 0) {
Uri url = ContentUris.withAppendedId(Telephony.Carriers.CONTENT_URI, Integer.parseInt(replaceNum));
getContentResolver().update(url, values, null, null);
}
// modify end
```

## [FAQ18313] [SMS]使用16bit 或7bit 编码，都需要替换特殊字符去掉帽子

```
如果只是针对7bit编码方式需要替换，请参考FAQ08878.
如果是不管使用什么编码方式都要替换，请参考以下改法：

case 1:要求发送方显示特殊字符，接收方显示去掉帽子：
如果发送方不要显示替换后的字符，就要在数据插入database后再替换字符。
/vendor/mediatek/proprietary/packages/apps/Mms/src/com/android/mms/transaction/SmsReceiverService.java
public synchronized void sendFirstQueuedMessage() {
    int msgId = c.getInt(SEND_COLUMN_ID);
    Uri msgUri = ContentUris.withAppendedId(Sms.CONTENT_URI, msgId);
    // 此处增加对 msgText中特殊字串的替换逻辑
    msgText.replaceAlll("\\u005e", "xxxx"); 
    ...
    SmsMessageSender sender = new SmsSingleRecipientSender(this,
    address, msgText, threadId, status == Sms.STATUS_PENDING, msgUri, subId);

case 2:要求发送方与接收方显示一致，都去掉帽子：
/packages/apps/Mms/src/com/android/mms/transaction/SmsMessageSender.java 
1. protected final String mMessageText;将 mMessageText final属性去掉；
2. private boolean queueMessage(long token) throws MmsException {
…
MmsLog.d(MmsApp.TXN_TAG, "SMS DR request=" + requestDeliveryReport);
/// @}
// 此处增加对 mMessageText 中特殊字串的替换逻辑
mMessageText = mMessageText.replaceAll("\\u005e", "xxxx"); 
```

## [FAQ18019] 如何把main log中的信息在kernel log中输出

```
#include <cutils/klog.h>

#define ERROR(x...)   KLOG_ERROR("module_name", x)
#define NOTICE(x...)  KLOG_NOTICE("module_name", x)
#define INFO(x...)    KLOG_INFO("module_name", x)

NOTICE("%s: val=%d \n", __FUNCTION__, value);
```

## [FAQ14351] L版本12小时制状态栏时间不显示AM/PM

```
Andoid L版本把时间格式设置为12小时制，状态栏时间不显示AM/PM的，这是google的默认设计。下拉状态栏，左上角的时间是带有AM，PM的，如果想要显示AM/PM怎么办呢？
[SOLUTION]
把mAmPmStyle的初始值改为AM_PM_STYLE_NORMAL
Clock.java alps\frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar\policy 
public Clock(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
    TypedArray a = context.getTheme().obtainStyledAttributes(
        attrs,
        R.styleable.Clock,
        0, 0);
    try {
        ///修改此处
        //mAmPmStyle = a.getInt(R.styleable.Clock_amPmStyle, AM_PM_STYLE_GONE);
        mAmPmStyle = AM_PM_STYLE_NORMAL
    } finally {
        a.recycle();
    }
}
```

## [FAQ18279] 开机时间慢分析

```
(1)若能抓取mobilelog，则可以在APLog_xxxx文件夹中找到bootprof文件。或者直接cat /proc/bootprof

----------------------------------------
0 BOOT PROF (unit:msec)
----------------------------------------
1077 : preloader         // 这里会记录preloader和lk的执行时间，单位为毫秒。
3667 : lk
----------------------------------------
47.188307 : ON
95.973922 : of_init 16992539 ns
124.732076 : ramoops_init 27976001 ns
155.463384 : init_mtk_governor 28810077 ns
208.009307 : arm64_device_init 40170846 ns
245.649461 : pm_sysrq_init 28632231 ns
305.320923 : event_trace_init 25269538 ns
328.487538 : pmic_mt_init 18462461 ns
398.533231 : populate_rootfs 67385539 ns
481.464077 : mtkfb_init 16279692 ns
631.410616 : modem_cd_init 128015693 ns
817.579693 : md_ccif_init 186129616 ns
894.852462 : gf_init 40584231 ns
940.017616 : mt_i2c_init 45137231 ns
1013.895463 : eem_init 23476462 ns
1059.026771 : acc_init 32313847 ns
1116.455540 : gyro_init 57412308 ns
2363.018851 : fpc1022_init 1232834464 ns
2382.414158 : battery_init 18354616 ns
2417.481312 : clk_debug_init 33775692 ns
2450.348466 : mt_soc_snd_init 32818538 ns
2451.768543 : Kernel_init_done
2875.773313 : INIT: on init start
2881.017236 : INIT:Mount_START
3546.686469 : INIT:Mount_END
3550.746930 : start mobicore (on fs)
3553.768623 : start mobicore end (on fs)
3675.040623 : post-fs-data: on modem start
5971.898167 : BOOT_Animation:START             // 这里表明已经进入上层。
6684.275630 : Zygote:Preload Start
7112.275554 : Zygote:Preload Start
8761.911327 : Zygote:Preload 3831 classes in 1319ms
8847.152943 : Zygote:Preload 3831 classes in 1424ms
9055.208867 : Zygote:Preload 342 obtain resources in 206ms
9059.303559 : Zygote:Preload 41 resources in 2ms
9076.121251 : Zygote:Preload 342 obtain resources in 313ms
9081.294482 : Zygote:Preload 41 resources in 3ms
9323.764175 : Zygote:Preload End
9481.360175 : Zygote:Preload End
9550.741483 : Android:SysServerInit_START
10059.694100 : Android:PackageManagerService_Start
10326.429639 : Android:PMS_scan_START
10516.254332 : Android:PMS_scan_data_done:/system/framework
11297.080180 : Android:PMS_scan_data_done:/system/priv-app
12650.057491 : Android:PMS_scan_data_done:/system/app
12736.916952 : Android:PMS_scan_data_done:/system/vendor/operator/app
12768.057183 : Android:PMS_scan_data_done:/system/plugin
12771.374414 : Android:PMS_scan_data_done:/data/app
12780.415645 : Android:PMS_scan_END
12952.868184 : Android:PMS_READY
22793.776438 : Android:SysServerInit_END
24645.384365 : BOOT_Animation:END                     // 这里表示已经开进home界面。
24646.324673 : OFF
----------------------------------------
================ END of FILE ===============

(2) 若不能抓取mobielog，可以直接用uart log抓取，时间的分析可以参考FAQ14851 进入kernel前开机时间分析方法。
```

## [FAQ17418] [Recovery][Build] 预置资源（如apk）到userdata，otapackage之后的userdata.img没有此资源

```
随着FLASH空间的使用率被广泛专注，MTK_SHARED_SDCARD的使用逐渐成为主流。
MTK_SHARED_SDCARD enable的前提下，phone storage和internal storage共享userdata分区，其中phone storage的目录变成了/data/media。
MTK_SHARED_SDCARD enable时的内置资源预置方式，可以参见FAQ：
[FAQ14735]【sdcard-FAT filesystem】MTK_SHARED_SDCARD打开时L上如何预置资源

[Issue]
按照FAQ14735预置资源以后，new之后的userdata.img是包含新内置资源，此时再执行otapackage，out目录下的userdata.img并不包含此资源。

[Solution]
经分析，主要原因如下所示：
/build/core/Makefile 中otapackage的主要flow --
otapackage: $(INTERNAL_OTA_PACKAGE_TARGET)
-> $(INTERNAL_OTA_PACKAGE_TARGET): $(BUILT_TARGET_FILES_PACKAGE) $(DISTTOOLS)
-> $(BUILT_TARGET_FILES_PACKAGE)
$(hide) ./build/tools/releasetools/add_img_to_target_files -p $(HOST_OUT) $@
$(hide) ./build/tools/releasetools/replace_img_from_target_files.py $@ $(PRODUCT_OUT)
Add_img_to_target_files对各个image的处理 --
/build/tools/releasetools/add_img_to_target_files
main
-> AddImagesToTargetFiles(args[0])
-> AddSystem(output_zip, recovery_img=recovery_image, boot_img=boot_image)
-> AddUserdata(output_zip)
-> AddCache(output_zip)

上面flow的目的是以out/obj/的中间包为source重新生成image，放入中间包。
def AddUserdata(output_zip, prefix="IMAGES/"):
"""Create an empty userdata image and store it in output_zip."""
其中， AddUserdata与其他接口的实现不同，主要是生成一个空的目录，google要求otapackage release出去的dataimage是空的（升级本身也是不包含userdata的）。
-> $(hide) ./build/tools/releasetools/replace_img_from_target_files.py $@ $(PRODUCT_OUT)
这段的目的是从中间包将image copy出来替换out目录。
所以，otapackage最终out/obj目录下的/DATA目录是有apk的，但是最后生成的out目录和中间包里的userdata.img都是空的。
如果一定要预置apk，可以尝试将new后的userdata.img保留下来。Otapackage之后，再用new后的userdata.img替换out目录下的userdata.img。
或是直接修改/build/tools/releasetools/replace_img_from_target_files.py 
将
if img.find(".img") != -1:
修改为
if img.find(".img") != -1 and img.find("userdata") == -1 :
```

## [FAQ11961] KK之后的版本状态栏电池图标问题

```
KK之后的版本电池图标由之前的蓝色改成白色，充电状态背景色也不会动。
这是因为KK之后的版本电池图标不再使用之前的图片方式，而是通过代码绘制而成，具体文件如下
BatteryMeterView.java(frameworks\base\packages\SystemUI\src\com\android\systemui)
```

## [FAQ11708] 如何去掉状态栏G、3G图标

```
去掉方法很简单，就是把这个View隐藏就行了，具体修改文件如下
SignalClusterView.java(frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar)

如果是KK之前的版本可能会有单卡、双卡之分，双卡文件是：

SignalClusterViewGemini.java(frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar)

KK及之前版本：
apply()
……
//hide network icon begin
/* int state = SIMHelper.getSimIndicatorStateGemini(i);//hide network icon
    if (!mIsAirplaneMode
            && SIMHelper.isSimInserted(i)
            && PhoneConstants.SIM_INDICATOR_LOCKED != state
            && PhoneConstants.SIM_INDICATOR_SEARCHING != state
            && PhoneConstants.SIM_INDICATOR_INVALID != state
            && PhoneConstants.SIM_INDICATOR_RADIOOFF != state) {
        ……
    } else {*/
        mSignalNetworkType[i].setImageDrawable(null);
        mSignalNetworkType[i].setVisibility(View.GONE);
    //}
//hide network icon end
……

L版本：
修改apply函数中的如下代码：
/*if (!mIsAirplaneMode && mNetworkType != null) {
    int id = TelephonyIcons.getNetworkTypeIcon(mNetworkType);
    Xlog.d(TAG, "apply(), mNetworkType= " + mNetworkType + " resId= " + id);
    mSignalNetworkType.setImageResource(id);
    mSignalNetworkType.setVisibility(View.VISIBLE);
} else {*/
    mSignalNetworkType.setImageDrawable(null);
    mSignalNetworkType.setVisibility(View.GONE);
//}

M版本：

目前默认的如果是非CTA的项目，网络图标默认就是不显示的，对于CTA项目如果不要显示，那么可以修改函数：
setNetworkIcon中如下代码：
// if (mNetworkIcon == 0) {
    mNetworkType.setVisibility(View.GONE);
/*       } else {
   mNetworkType.setImageResource(mNetworkIcon);
   mNetworkType.setVisibility(View.VISIBLE);
}*/

相反的对于非CTA项目如果需要将网络图标显示出来，可以将：
setNetworkIcon中如下代码屏蔽掉：
/*if (!FeatureOptions.MTK_CTA_SET) {
  return;
}*/
```

## [FAQ11620] 透明的状态栏有渐变的阴影效果

```
这是google default设计，如果桌面壁纸是白色的时候比较明显，这个渐进的效果是通过背景图来设置的，在frameworks/base/packages/systemui/res/ 里面drawable-hdpi（如果是其他density，请找对应的资源）中status_background.9.png替换这个图片；
或者修改代码绘制图片的地方：
BarTransitions.java文件最后draw的方法mGradient.draw(canvas); //注释掉这一行即不绘制这个图片就可以了
```

## [FAQ04788] 如何关闭Navigation Bar

```
KK及之前版本：
默认Navigation Bar的控制在 alps/frameworks/base/core/res/res/values/config.xml文件中<bool name=“config_showNavigationBar”>true</bool>， 但是在6589项目以及6572等项目上修改为false不起作用，或者默认已经是false，但是还是会显示navigation Bar。

MT6589 和MT6572：
1. 在6589项目和6572项目上，MTK内部Demo Project有Navigation Bar的需求，因此通过Resource Overlay机制默认打开了Navigation Bar，如果要关闭，需要确认resource overlay部分是否也有定义，具体如下：
alps/mediatek/custom/project_name/resource_overlay/generic/frameworks/base/core/res/res/values/config.xml
<bool name=“config_showNavigationBar”>true</bool>
将这个配置信息修改为false即可。

2. MT6572：
如果上面的xml文件定义都是false，请再确认下mediatek/config/工程名字的目录/system.prop 是否有qemu.hw.mainkeys=0
如果有，请去掉qemu.hw.mainkeys=0的定义
3. JB3 MP之后所有版本统一如下路径修改
\mediatek\custom\common\resource_overlay\navbar\frameworks\base\core\res\res\values\config.xml 
<bool name=“config_showNavigationBar”>true</bool>
将这个配置信息修改为false即可。 

4. 其他平台或者branch都可以类似查找，以上都找不到，请全局搜索config_showNavigationBar

L和M版本：

这个两个版本的修改方式与之前的版本也是类似：

（1）先查看config_showNavigationBar值的定义，默认定义在：alps/frameworks/base/core/res/res/values/config.xml，如果没有请全局搜索。

（2）再检查qemu.hw.mainkeys值的设置。

（3）是否显示Navigation Bar，判断的值在PhoneWindowManager.java文件中的setInitialDisplaySize 函数中被设置，检查mHasNavigationBar的值是如何被设置的。如果mHasNavigationBar为true，Navigation Bar会显示，否则不显示。
```

## [FAQ04504] 如何修改navigation bar为半透明？

```
Navigation bar是google 从4.0版本开始支持的feature，默认情况下这个feature对应的option是关闭的，需要通过修改config 文件来开启。开启navigation bar的方法和注意事项，请参考FAQ:如何开启navigation bar。
如果想要做到，在开启navigation bar的情况下，可以透过navigation bar的背景看到navigation bar后面的内容（也就是修改navigation bar为半透明），应该如何修改？
[SOLUTION]
1,alps\frameworks\base\packages\SystemUI\res\layout\navigation_bar.xml,
    把background修改成statusbar_background的背景图：
    android:background="@drawable/statusbar_background"
2,制作一张半透明的9.png图片，名字叫statusbar_background.9.png,放到
    alps\frameworks\base\packages\SystemUI\res\drawable-hdpi下
3,alps\frameworks\base\packages\SystemUI\src\com\android\
    systemui\statusbar\phone\PhoneStatusBar.java
    修改方法getNavigationBarLayoutParams，如下：
    private WindowManager.LayoutParams getNavigationBarLayoutParams() {
        WindowManager.LayoutParams lp = new WindowManager.LayoutParams(
        . . .
        /*PixelFormat.OPAQUE*/ PixelFormat.TRANSLUCENT);    //mtk added
        . . .
4,WindowManagerService.java中
    修改方法updateWallpaperOffsetLock，如下：
    boolean updateWallpaperOffsetLocked(WindowState wallpaperWin, int dw, int dh,boolean sync)  {
        if (wallpaperWin.mYOffset != offset) {
            if (DEBUG_WALLPAPER) Slog.v(TAG, "Update wallpaper " + wallpaperWin + " y: " + offset);
                changed = true;
                wallpaperWin.mYOffset = offset;   // 修改成wallpaperWin.mYOffset = 0;
            }

对于JB的版本，还需要修改：
5, WindowManagerService.java
修改方法performLayoutLockedInner，如下：
private final void performLayoutLockedInner(boolean initial, boolean updateInputWindows) {
    if (!mLayoutNeeded) {
        …
        for (i = N-1; i >= 0; i--) {
            final WindowState win = mWindows.get(i);
            //mtk added
            if (win.mIsWallpaper)
                mSystemDecorRect.bootom = 屏幕高度;    //以480*800分辨率来说，这里的屏幕高度就是800
            //mtk added
        …
}

对于JB2之后的版本，google对WMS的架构进行调整，暂不支持navigation bar透明，请在JB2之后的版本不做做此修改

注意：
修改navigation bar半透明后存在的限制：
从那些以wallpaper作为背景的画面(画面对应的window具备属性：FLAG_SHOW_WALLPAPER)切换到不显示wallpaper的画面，会在navigation bar的背景上先闪一下wallpaper，然后navigation bar的背景才变成黑色。
如果希望某些特定的window才可以让navigation bar半透明，其他window上navigation bar仍然不透明，例如：只在launcher画面做到navigation bar半透明，其他画面navigation bar仍然保持原来的风格，目前不做支持。
WVGA上开启navigation bar本身就有很多问题，建议不要在WVGA分辨率下开启navigation bar功能。
Navigation bar半透明的功能只针对当前的wallpaper是ImageWallpaper的情况，对Live Wallpaper不生效，后续也不做更多支持。
```

## [FAQ18278] 关闭wfi&&scan always 关闭的情况下依然显示wifi 耗电

```
关闭wfi&&scan always 关闭的情况下，电池计算耗电，依然显示wifi 耗电；
root casue:
BatteryStats 會去等Wifi framework的SupplicantStateTracker的noteWifiSupplicantStateChanged()
由此得知Wifi Supplicant的狀態，
但是關wifi時，可能正在ScaningState，SupplicantStateTracker沒有先送出WIFI_SUPPL_STATE_DISCONNECTED，就已經回到UninitializedState，不再聽Supplicant state change了，
所以造成BatteryStats與Wifi Framework/Supplicant state 不一致，
這個是Google default issue，
[SOLUTION]
diff --git a/service/java/com/android/server/wifi/SupplicantStateTracker.java b/service/java/com/android/server/wifi/SupplicantStateTracker.java
index a4c029d..7d35c61 100644
--- a/service/java/com/android/server/wifi/SupplicantStateTracker.java
+++ b/service/java/com/android/server/wifi/SupplicantStateTracker.java
@@ -249,6 +249,8 @@ class SupplicantStateTracker extends StateMachine {
                     transitionOnSupplicantStateChange(stateChangeResult);
                     break;
                 case WifiStateMachine.CMD_RESET_SUPPLICANT_STATE:
+                    ///M: for sync supplicant state with settings
+                    sendSupplicantStateChangedBroadcast(SupplicantState.DISCONNECTED, false);
                     transitionTo(mUninitializedState);
                     break;
                 case WifiManager.CONNECT_NETWORK:
```

## [FAQ18274] L版本之后，灭屏依然保证framework发起scan

```
灭屏之后离开AP 范围，断线，重新回到AP 范围，不会自动连接；
root cause：
因为L版本之后，为了省电考虑，framework不会触发scan ，从而导致断线后无法自动连接，需要等到亮屏才会重新连接； 
[SOLUTION]
如果需要客制化这一功能，请按照如下修改方案测试；
在WifiStateMachine.java文件中；
改两个地方：
1， 
PendingIntent getPrivateBroadcast(String action, int requestCode) {
    Intent intent = new Intent(action, null);
    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
    //intent.setPackage(this.getClass().getPackage().getName());    注解掉这行
    return PendingIntent.getBroadcast(mContext, requestCode, intent, 0);
}

2，setScanAlarm內，set那句code 改为setRepeating：
mAlarmManager.setRepeating(AlarmManager.RTC_WAKEUP,
System.currentTimeMillis() + 1000, mDefaultFrameworkScanIntervalMs, mScanIntent);

这里的修改保证一点：当wifi 断线之后，我们会1s 后触发一次scan ，之后每间隔5分钟触发一次scan；
mDefaultFrameworkScanIntervalMs 定义的值如下：
<integer translatable="false" name="config_wifi_framework_scan_interval">300000</integer>
```

## [FAQ18293] DRM FL文件没有小锁图标

```
1.进入浏览器->链接到下载网址
2.选择DRM文件->选择Forward Lock文件，下载一张图片->下载完成，从通知栏里进入downloads，发现下载的DRM文件没有小锁图标
这个是正常现象，只有CD和SD的文件才会有锁，因为只有这两类DRM文件需要check权限，而FL是没有权限限制的，只是不能转发，所以FL类型不会有锁显示。

什么是 DRM FL 文件？？
```

## [FAQ18294] 安装应用提示不能安装，报INSTALL_FAILED_DUPLICATE_PERMISSION错误

```
安装应用提示不能安装，报 INSTALL_FAILED_DUPLICATE_PERMISSION 错误
[SOLUTION]
Android 5.0上新增加的 permission 的判断，INSTALL_FAILED_DUPLICATE_PERMISSION这个简单讲就是如果两个apk声明了相同的permission，但是如果这两个apk的签名不一样的话，后安装的apk会fail。
http://tieba.baidu.com/p/3237226241?see_lz=1 可以参考一下。
```

## [FAQ17743] 如何修改35/35m/53平台DDR的工作频率

```
DDR工作频率的修改仅限debug使用，不能用于量产
[SOLUTION]
For MT6753/MT6735
[fix dram to low freq]
adb shell "echo ddr_dfs 1 > /sys/power/vcorefs/vcore_debug"
adb shell "echo KIR_SYSFS 0 > /sys/power/vcorefs/vcore_debug"
adb shell "echo KIR_SYSFS 1 > /sys/power/vcorefs/vcore_debug"
adb shell "echo feature_en 1 > /sys/power/vcorefs/vcore_debug"
adb shell "cat /sys/bus/platform/drivers/emi_clk_test/read_dram_data_rate"
DRAM data rate = 1313

[fix dram to highfreq]
adb shell "echo ddr_dfs 1 > /sys/power/vcorefs/vcore_debug"
adb shell "echo KIR_SYSFS 1 > /sys/power/vcorefs/vcore_debug"
adb shell "echo KIR_SYSFS 0 > /sys/power/vcorefs/vcore_debug"
adb shell "echo feature_en 1 > /sys/power/vcorefs/vcore_debug"
adb shell "cat /sys/bus/platform/drivers/emi_clk_test/read_dram_data_rate"
DRAM data rate = 1466 or 1600

For MT6735M

//DDR 1066
echo KIR_SYSFSX 1 > /sys/power/vcorefs/vcore_debug

//DDR 800
echo KIR_SYSFSX 2 > /sys/power/vcorefs/vcore_debug
```

## [FAQ18283] Android M+Mediatek _Camera Code Path （不含Kernel）

```
Camera App Package
MTK Camera：/vendor/mediatek/proprietary/packages/apps/Camera/
AOSP Camera：
(out/target/product/<project>/system/app/Camera2.apk)
/packages/apps/Camera2/

Application Framework（out/target/product/<project>/system/framework/framework.jar)
/frameworks/base/core/java/android/hardware/ （非Camera2下的为api1）
/frameworks/base/core/java/android/hardware/camera2/
/frameworks/base/media/java/android/media/ 
CamcorderProfile.java、CameraProfile.java、ExifInterface.java、Image.java、ImageReader.java、ImageUtils.java、ImageWriter.java等等
注：FaceDetector.java并非Camera FaceDetection，而是android原生一个开源人脸识别算法接口，可从一个bitmap获取到人脸信息

JNI (out/target/product/<project>/system/lib/libandroid_runtime.so)
/frameworks/base/core/jni/
android_hardware_Camera.cpp
android_hardware_camera2_CameraMetadata.cpp
android_hardware_camera2_DngCreator.cpp
android_hardware_camera2_legacy_LegacyCameraDevice.cpp
android_hardware_camera2_legacy_PerfMeasurement.cpp

Android Camera Native Framework
/frameworks/av/camera/
/frameworks/av/include/camera/
/frameworks/av/services/camera/libcameraservice/
/frameworks/av/media/mediaserver/
/frameworks/av/media/img_utils/src/DngUtils.cpp

Android Camera Hal
core header files：
(/system/core/include/system/) camera.h、graphics.h 、window.h
camera metadata：
/system/media/camera/

AOSP Hal：
/hardware/libhardware/include/hardware/
/hardware/libhardware/modules/camera/
/hardware/libhardware/modules/usbcamera/
/hardware/libhardware/modules/gralloc/

MediaTek Camera Hal (ISP3.0平台)
/vendor/mediatek/proprietary/hardware/mtkcam/legacy/
/vendor/mediatek/proprietary/hardware/mtkcam/ext/
/vendor/mediatek/proprietary/hardware/mtkcam/feature/
/vendor/mediatek/proprietary/custom/common/hal/inc/
/vendor/mediatek/proprietary/custom/mtxxxx/hal/ 
/vendor/mediatek/proprietary/custom/{ProjectName}/hal/imgsensor/

如下为非Camera但和Camera强相关的Hal模块
/vendor/mediatek/proprietary/hardware/gralloc_extra/
/vendor/mediatek/proprietary/hardware/dpframework/
/vendor/mediatek/proprietary/hardware/bwc/
/vendor/mediatek/proprietary/hardware/jpeg/
/vendor/mediatek/proprietary/hardware/m4u/
/vendor/mediatek/proprietary/hardware/mmsdk/
/vendor/mediatek/proprietary/hardware/mmutils/
/vendor/mediatek/proprietary/hardware/perfservice/

MediaTek Camera Hal (ISP4.0平台)
/vendor/mediatek/proprietary/hardware/mtkcam/（除legacy的folder外）
/vendor/mediatek/proprietary/custom/common/hal/inc/
/vendor/mediatek/proprietary/custom/mtxxxx/hal/ 
/vendor/mediatek/proprietary/custom/{ProjectName}/hal/imgsensor/

如下为非Camera但和Camera强相关的Hal模块
/vendor/mediatek/proprietary/hardware/gralloc_extra/
/vendor/mediatek/proprietary/hardware/dpframework/
/vendor/mediatek/proprietary/hardware/bwc/
/vendor/mediatek/proprietary/hardware/jpeg/
/vendor/mediatek/proprietary/hardware/m4u/
/vendor/mediatek/proprietary/hardware/mmsdk/
/vendor/mediatek/proprietary/hardware/mmutils/
/vendor/mediatek/proprietary/hardware/perfservice/

CTS
/cts/tests/tests/hardware/src/android/hardware/camera2/
/cts/tests/tests/hardware/src/android/hardware/cts/
/cts/apps/CameraITS/
/cts/apps/CtsVerifier/src/com/android/cts/verifier/camera/

Portability Camera
/frameworks/ex/camera2/
(主要应该是这个folder /frameworks/ex/camera2/portability/src/com/android/ex/camera2/portability/)
```

## [FAQ18281] 如何修改长按LatinIME键盘中某个字母时弹出框的内容

```
弹出框的字符定义在donottranslate-more-keys.xml这支文件中，根据修改语言的不同，可以在
packages\inputmethods\LatinIME\tools\make-keyboard-text\res\values-xxx这个路径中找到对应语言使用的donottranslate-more-keys.xml文件，在文件中找到要修改的字符对其字串定义进行修改即可。
 
修改完成之后需要按照如下步骤进行编译才能生效： 
（1）执行指令：mmm packages/inputmethods/LatinIME/tools/make-keyboard-text/
生成新的make-keyboard-text.jar放在alps\out\host\linux-x86\framework路径下。

（2）使用（1）步生成的make-keyboard-text.jar来生成新的KeyboardTextsTable.java文件，执行指令如下：
java -jar out/host/linux-x86/framework/make-keyboard-text.jar -java packages/inputmethods/LatinIME/java/src/
该指令完成后，会在packages\inputmethods\LatinIME\java\src\src\com\android\inputmethod\keyboard\internal路径下生成新的KeyboardTextsTable.java，将这个新的KeyboardTextsTable.java剪切到之前packages\inputmethods\LatinIME\java\src\com\android\inputmethod\keyboard\internal目录下，将旧的替换掉。

（3）执行mmma packages/inputmethods/LatinIME/，生成新的LatinIME.apk，将新的apk push到手机中验证即可。
```

## [FAQ03087] 如何在状态栏上增加一个icon

```
1. 首先需要在alps/frameworks/base/res/res/values/config.xml中定义需要显示的icon的配置信息。以添加headset(耳机图标)为例：
2. 其次在 alps/frameworks/packages/SystemUI/src/com/android/systemui/statusbar/PhoneStatusBarPolicy.java 中进行初始化
3. 然后在 alps/frameworks/packages/SystemUI/src/com/android/systemui/statusbar/PhoneStatusBarPolicy.java 中注册相应的receiver来接收Intent
同时在updateHeadSet方法中调用StatusBarManager提供的setIcon/setIconVisibility方法 来显示或隐藏head set icon.
```

## [FAQ03089] 如何调整状态栏icon之间的显示顺序

```
需要在alps/frameworks/base/res/res/values/config.xml 中的config_statusBarIcons调整相应的顺序，其中从上倒下，对应的状态栏的顺序为从左到右。
```

## [FAQ07781] user版本时，设置里，如何将“开发者选项”选项显示出来

```
如果要always显示“开发者选项”菜单，请修改
Settings.java (alps\packages\apps\settings\src\com\android\settings)
中 
private void updateHeaderList(List<Header> target) {
final boolean showDev =  true; //修改为一直显示开发者选项.
```

## [FAQ06277] 账户自动同步默认关闭

```
Q:设置--账户与同步---自动同步
如何使得自动同步默认关闭。
A:修改 SyncStorageEngine.java (alps\frameworks\base\core\java\android\content)中的
private boolean mMasterSyncAutomatically = true;
修改为
private boolean mMasterSyncAutomatically = false;
既可将自动同步的默认值设置成不勾选。 
```

## [FAQ10772] 在窗口小部件里快速设置如何默认同步关闭

```
在JB版本是由 SyncStorageEngine.java (alps\frameworks\base\core\java\android\content)
中
public boolean getMasterSyncAutomatically(int userId) {
    synchronized (mAuthorities) {
        Boolean auto = mMasterSyncAutomatically.get(userId);
        Log.d(TAG,"userId="+userId+" auto="+auto+" mExt="+mExt);
        if(mExt != null && mExt.getCurrentOPIndex() == 1){
            ///M: add for cmccc when there is no account default auto sync is off
            Log.d(TAG,"mExt.getCurrentOPIndex()="+mExt.getCurrentOPIndex());
            return auto == null ? false : auto;
        } else {
            return auto == null ? true : auto;
        }
        //return auto == null ? mDefaultMasterSyncAutomatically : auto;
    }
}
决定的, 如果是CMCC的项目,默认就会是false.这是CMCC需求。
如果不是CMCC定制,可以修改
return auto == null ? true: auto; 
为
return auto == null ? false: auto;
这样就默认是关闭了。
只适用JB版本
```

## [FAQ06166] 怎么在某种语言下添加baidu搜索引擎,BING 显示为中文，并将系统默认的搜索引擎修改成百度？

```
1：去掉google搜索引擎修改方法：
在alps\mediatek\source\frameworks\res\res\values\donottranslate-search-engines.xml 中
有一个name为search_engines的array,将其中的google item删除掉即可删除中文下的google搜索引擎。
其他语言下方法类似，在该res包中搜索search_engines的关键字找到其它语言的google搜索引擎，同样将
google的ITEM删除掉，即可删除其它语言下的google 搜索引擎。
2：如何设置BAIDU为默认引擎：
在quickSearhBox的源码中，有个SearchEngineItemControl.java的文件，修改其中的
DEFAULT_SEARCH_ENGINE的定义为baidu即可。
3：如何修改BING 显示为中文必应：
修改
alps\mediatek\source\frameworks\res\res\values\donottranslate-all_search_engines.xml 中
string-array name="bing_zh_CN" 内<item>的值为下面的内容即可
<string-array name="bing_zh_CN" translatable="false">
    ...
    <item>&#x5fc5;&#x5e94;</item>
    ...
</string-array>
如果只要验证baidu是否被添加进去,只需编译mediatek-res.apk, framework.jar,secondary-framewor.jar 并push 到手机重启即可验证.
如果要验证baidu是否有设为默认引擎,则需整个项目new下才能验证,我这边实验过恢复出厂设置不行,恢复后,还是上次
选中的搜索引擎.
```

## [FAQ10763] 在中文简体状态下无法修改默认引擎，默认引擎一直都是百度

```
项目在中文简体状态下无法修改默认引擎，默认引擎一直都是百度。如何改为Google?
[SOLUTION]
如果是OP01项目：
修改
KK和KK以前的版本：OP01DefaultSearchEngine.java (alps\mediatek\operator\op01\packages\apps\plugins\src\com\mediatek\qsb\plugin)
L和L以后的版本：OP01DefaultSearchEngine.java /vendor/mediatek/proprietary/operator/OP01/packages/apps/Plugins/src/com/mediatek/qsb/plugin/
中
public static final String SERCH_ENGIN_GOOGLE = "google";//BrowserSetting
public String getSearchEngine(SharedPreferences mPrefs) {
    Xlog.i(TAG, "Enter: " + "getSearchEngine" + " --OP01 implement");
    return mPrefs.getString(PREF_SEARCH_ENGINE, SERCH_ENGIN_GOOGLE);
}
同时为保证 quickSearchBox那边的一致, quickSearchBox部分也要修改
OP01DefaultSearchEngine.java (alps\mediatek\operator\op01\packages\apps\plugins\src\com\mediatek\qsb\plugin) 
中改为google
public static final String DEFAULT_SEARCH_ENGINE = "google";
 
如果不是OP01的项目应该修改
1：KK和KK以前的版本：Donottranslate-new-search_engines.xml (alps\mediatek\frameworks\base\res\res\values)
L和L以后的版本： /vendor/mediatek/proprietary/frameworks/base/res/res/values/
values-zh-rtw
values-zh-rcn 这三个目录，将google作为第一个搜索引擎。
```

## [FAQ06192] 设置 > 个人 > 安全 > 凭据存储 的作用

```
使用证书 您可以使用数字证书标识设备，以实现多种目的，包括 VPN 或 Wi-Fi 网络访问，以及“电子邮件”或 Chrome 浏览器等应用对服务器的身份验证。在您的系统管理员的帮助下进行使用；并将其安装在设备的受信任凭据存储上。
Android 支持以 .crt 或 .cer 扩展名的文件形式保存的 DER 编码 X.509 证书。如果您的证书文件带有 .der 或其他扩展名，则必须将其更改为 .crt 或 .cer，否则无法安装。
Android 也支持以 .p12 或 .pfx 扩展名的 PKCS#12 密钥库文件形式保存的 X.509 证书。如果您的密钥库文件带有其他扩展名，则必须将其更改为 .p12 或 .pfx，否则无法安装。通过 PKCS#12 密钥库安装证书时，Android 会同时安装所有随附的私有密钥或证书授权中心的证书。
安装客户端证书和 CA 证书
要从平板电脑的内存设备安装证书，请按以下步骤操作：
将证书或密钥库从计算机复制到设备的内存设备的根目录下（也就是说，不要复制到某个文件夹中）。 
依次转到设置  > 个人 > 安全 > 凭据存储 > 从存储设备安装。 
触摸证书或密钥库的文件名即可安装。系统只显示您尚未安装的证书。 
根据系统提示输入密钥库的密码，然后触摸确定。 
为该证书输入一个名称，然后触摸确定。 
通常，系统会同时安装客户端证书随附的 CA 证书。您也可以通过相同步骤安装单独的 CA 证书。
如果您尚未设置设备的图案、PIN 或密码，则系统会提示您设置一个。您的系统管理员可能会预先确定可接受的锁定类型。
现在，您可以在连接到安全网络时使用安装的证书，或将该证书用于“电子邮件”、“浏览器”和第三方应用的客户端身份验证。证书成功安装后，系统会删除存储设备中的副本。
重要提示：对于“电子邮件”和“浏览器”等支持证书的应用，可直接从应用内部安装证书。有关详情，请参阅各应用随附的帮助信息或其他说明。
使用 CA 证书
依次触摸设置 > 个人 > 安全 > 凭据存储 > 受信任的凭据。“受信任的凭据”屏幕有以下两个标签： 
系统显示永久安装在手机 ROM 中的证书授权中心 (CA) 的证书。
用户显示您自行安装的所有 CA 证书，例如安装客户端证书过程中安装的 CA 证书。
要查看 CA 证书的详情，请触摸其名称。相应详情会显示在滚动屏幕中。 
要删除或停用 CA 证书，请向下滚动到详情屏幕的底部，然后触摸停用（适用于系统证书）或删除（适用于用户证书）。 
当您停用系统 CA 证书后，其详情屏幕底部的按钮会变成启用，以便您在需要时重新启用该证书。当您删除用户安装的 CA 证书后，该证书会永久消失，必须重新安装才能再次获得该证书。
在出现的确认对话框中，点击确定。
```

## [FAQ12169] 点击进入quick search box，搜索不到通话记录

```
1:在quick search box中,进入设置->可搜索项->勾选通话记录。
2：在quick search box中选择全部，搜索，搜索不到通话记录。

搜索不到通话记录的原因是因为call log不是default enabled 的corpus， 
目前google  default的搜索规则在搜索全部时很怪，搜索全部时， 不是
真正的去搜索全部的，而是去搜索default enabled的，但是当default
enabled的(例如网络)不被勾选时，它又可以多去搜索一个非default的。
所以去掉网络就可以搜索到calllog.
如果想要保证搜索全部时可以搜索到calllog，需要把calllog设置成default 搜索项，
同时因为添加了一个default可搜索项目，需要
将QuickSearchBox 代码中
Config.java内的NUM_PROMOTED_SOURCE 的值加一，即修改为4.
同时修改QuicksearchBox中的config.xml
将default_corpora中添加callLog的项目
<string-array name="default_corpora" translatable="false">
    <item>web</item>
    <item>apps</item>
    <item>com.android.dialer/.com.mediatek.dialer.activities.CallLogSearchResultActivity</item>
    <item>com.android.providers.applications/.ApplicationLauncher</item>
</string-array>
或者将calllog的uri添加到default_corpora_suggest_uris中去
<string-array name="default_corpora_suggest_uris" translatable="false">
    <item>content://com.android.contacts/search_suggest_query</item>
    <item>content://call_log/search_suggest_query</item>
</string-array>
```

## [FAQ10764] 快速搜索(QuickSearchbox)怎么关联应用(apk)

```
快速搜索(QuickSearchbox)怎么关联应用（apk）
[SOLUTION]
要实现一个自己的contentProvider,并在searchable.xml中的searchSuggestAuthority 
配置上这个provider,同时provider返回的数据也有格式要求，返回的列应该是
_ID  TEXT_1  TEXT_2  ICON_1  ICON_2  INTENT_ACTION INTENT_DATA INTENT_DATA_ID NTENT_EXTRA_DATA QUERY SHORTCUT_ID SPINNER_WHILE_REFRESHING 
你的provider要响应的URI是
content://your.authority/optional.suggest.path/SUGGEST_URI_PATH_QUERY
其中optional.suggest.path是可选的，一般可以为空，所以贵司可以要handle的 uri是
content://your.authority/SUGGEST_URI_PATH_QUERY
而SUGGEST_URI_PATH_QUERY是SearchManager的一个常量，为"search_suggest_query"
所以要handler的URI是
content://your.authority/search_suggest_query
其中your.authority就是你在provider中定义的authority，也是searchable中的searchSuggestAuthority
 
如果要在选中全部时，输入就有搜索结果，必须在searchable.xml中设置android:queryAfterZeroResults="true"
如果在searchable.xml中没有设置，默认值就是false。

google官方可以参考的文档有
http://developer.android.com/guide/topics/search/index.html
http://developer.android.com/guide/topics/search/search-dialog.html
http://developer.android.com/guide/topics/search/adding-recent-query-suggestions.html
http://developer.android.com/guide/topics/search/adding-custom-suggestions.html
http://developer.android.com/guide/topics/search/searchable-config.html
```

## [FAQ18286] 设置里面App notification里面，短信应用选择Block all,但是在短信编辑界面自发自收短信，仍有提示音

```
进入系统设置，Sound&notification--->Notification---->App notification--->Messaging--->Block all,
勾选Block all选项。
在短信应用里面，当前会话界面自发自收，如果停留在编辑界面，收到新信息会有提示音。（这一点非常重点，一定是要当前正在收发信息的会话才会有提示音。如果是其它号码发过来的，而没有停留在那个会话，那么收到信息不会有提示音）

[SOLUTION]
block的if判断请参考如下修改方法，Thanks！
import android.app.AppOpsManager;
在 MessagingNotification.java 的 playInConversationNotificationSound 方法中：

AppOpsManager appOps = (AppOpsManager)context.getSystemService(Context.APP_OPS_SERVICE);
boolean isNotificationEnabled = appOps.checkOpNoThrow(AppOpsManager.OP_POST_NOTIFICATION,
context.getApplicationInfo().uid, context.getPackageName()) == AppOpsManager.MODE_ALLOWED;
if (!isNotificationEnabled || notiProf.needMute() || TextUtils.isEmpty(ringtoneStr)) {
// Nothing to play
return;
}
```

## [FAQ08624] 搜索设置为全部时无法搜索到短信，音乐

```
搜索设置中选择了音乐和短信，音乐中此时有一首名为全城热恋的歌曲，但是在搜索时，如果输入"全"或者"全城"，都搜不到，只有输入"全城热"才可以搜到,

music两个字符搜索不到是正常现象,因为在
Searchable.xml (alps\packages\apps\music\res\xml) 
中有默认定义最小搜索需要3个字符.
<searchable xmlns:android="http://schemas.android.com/apk/res/android"
    android:label="@string/search_title"
    android:hint="@string/search_hint"
    android:includeInGlobalSearch="true"
    android:searchSuggestAuthority="media"
    android:searchSuggestPath="external/audio/search"
    android:searchSuggestThreshold="3"             ##这里有默认定义最少3个,如果需要,可以修改这个值.
    android:searchSuggestIntentAction="android.intent.action.VIEW"
    android:searchSettingsDescription="@string/search_settings_description" />

[FAQ13588] [Audio APP]在音乐中搜索歌曲, 至少需要输入三个字符才会启动搜索
```

## [FAQ18254] 开启TurboDownload后下载速度会比纯4G更慢吗？

```
这种情况是存在的。
我们在下载前会根据之前wifi和mobile的速率设置比例，例如wifi为0.6，mobile为0.4，然后建立TCP connection进行下载。一旦建立起来之后，如果wifi速率变慢了，那么Turbo download就会比纯4G下载更慢。
目前无法做到动态配置速率比。
在网络状况良好的情况下是会加速的。不保证一定会比纯4G快

当下载的文件超过5M，并且wifi是connected状态，就会用两种方式进行下载。
涡轮下载不会看当前wifi的信号以及mobile data的信号值，而是根据当前统计的wifi速率及mobile速度设定一个ratio下去，例如wifi为0.5，mobile为0.5，如果之前并没有wifi或者mobile的统计信息，则会使用初始值0.5，0.5。
涡轮下载的时候，会根据当前的wifi和mobile速度动态调整ratio，在下一次再启用涡轮下载时，就会使用新的调整值。
```

## [FAQ17877] [Image]L/M版本上修改gif/bmp的限制

```
考虑到memory的问题，对较大的BMP，GIF图片都做了一些限制；
当前code中设置的值能够满足市面上大部分图片的尺寸要求；如需客制化，需要多测试是否会造成Low Memory问题.
如下地方修改:

/packages/apps/Gallery2/src/com/mediatek/gallery3d/util/DecodeSpecLimitor.java中：
// GIF: None LCA:20MB, LCA:10MB
private final static int MAX_GIF_FILE_SIZE = FeatureConfig.sIsLowRamDevice ? (10 * 1024 * 1024) : (20 * 1024 * 1024);
private final static long MAX_GIF_FRAME_PIXEL_SIZE = (long) (1.5f * 1024 * 1024); // 1.5MB
private final static String MIME_GIF = "image/gif";

// BMP & WBMP: NONE-LCA file size < 52MB, LCA file size < 6MB
private final static int MAX_BMP_FILE_SIZE = FeatureConfig.sIsLowRamDevice ? (6 * 1024 * 1024)
 : (52 * 1024 * 1024);
```

## [FAQ17755] 录制低画质的视频在WIN7上查看属性，发现高宽显示为空。

```
有客户反馈手机上录制低画质视频，把视频放到WIN7系统的电脑上，点右键查看视频的属性，视频高宽栏显示为空。 
 
这个是由于低画质录制的视频采用了H263编码，而Win7对H.263 支持不完善。可以看到，所有H263视频的高宽在WIN7上显示都是空的。
所以如果要避免此问题，可以修改视频录制的编码，比如H264。
```

## [FAQ04247] [Storage]如何解压编译生成的system/data等带ext4文件系统的image

```
在ubuntu系统下：
1.cd alps/out/host/linux-x86/bin/
2../simg2img <source_path>/data.img <target_path>/data_ext4.img
3.生成的data_ext4.img 即被解压出来的带有ext4 文件系统的image文件。
4.使用mount 命令把ext4 image挂载到某目录(temp_dir )
    sudo mount  -t ext4 <target_path>/data_ext4.img ~/<temp_dir>
5.这样就可以直接查看/修改文件系统内的类容。
注意 
如果调用./simg2img出现了错误，就将前面三个步骤省略，直接采用第四个步骤，将得到的回读img通过mout命令挂载。
```

## [FAQ04137] 【sdcard-common】如何将emmc上的内置sdcard拿掉

```
拿掉emmc上的内置T卡，将内置T卡空间分配给userdata区域使用。
[SOLUTION]
for ICS(android 4.0)
   可在DCC上下载参考文档《Disable Internal fat partition_customer_4.0》进行修改。
for JB(android 4.1)
   可在DCC上下载参考文档《Disable Internal fat partition_customer_4.1》进行修改。
```

## [FAQ12295] [VR]录像的视频如何在画面中实时加上时间戳

```
方法一（L之前版本）：
可以在下面这个地方同，即MDP输出这个画面，但是Encode之前，使用SW的方式来Overlay即可，至于具体如何实现Overlay的话，网上搜索一下，很多示例代码的。如下的参考代码是在录像的画面上画一条彩色条的测试代码，你们可以将添加timestamp的功能的代码替换掉memset之后即可实现timestamp的功能。这个Buffer的格式是YUV420 Planer格式，即先放Y，再放U，最后放V。
frameworks/av/media/libstagefright/CameraSource.cpp
 void CameraSource::dataCallbackTimestamp()
{
    ... ...
    CHECK(data != NULL && data->size() > 0);

    // Brand the timestamp start 2014-07-29
    {
        int _stride = mVideoSize.width;
        int height = mVideoSize.height;
        uint8_t *_ptr = (uint8_t *)data->pointer();
        int offset = 240;
        int bar_width = 80;
        ALOGE("!!! draw line, ptr: %p, offset: %d, stride: %d, height: %d", _ptr, offset, _stride,height);
        if (NULL != _ptr) {
            // Overlay the timestamp here.
            memset(_ptr + offset*_stride , 0x80, _stride * bar_width); //Clear Y
            memset(_ptr + (height*_stride) + offset*_stride/4 , 0x40, _stride*bar_width/4); // Clear U
            memset(_ptr + (height*_stride + height*_stride/4) + offset*_stride/4, 0x40, _stride*bar_width/4); // Clear V
        }
    }
    // Brand the timestamp end 2014-07-29

    mFramesReceived.push_back(data);
    int64_t timeUs = mStartTimeUs + (timestampUs - mFirstFrameTimeUs);
    mFrameTimes.push_back(timeUs);
    ... ...
}
方法二(适用所有版本，不包括MT6735平台的M版本):   
PreviewCmdQueThread.cpp(/vendor/mediatek/proprietary/platform/mt6735/hardware/mtkcam/D2/v1/hal/adapter/MtkDefault/Preview/PreviewCmdQueThread.cpp) 的
updateOne()方法中修改。将丢给encoder的yuv数据进行处理，这里的demo是将部分内容给涂黑，您可以使用这段buffer来处理timestamp，其中buffer地址为vidoNode.getImgBuf()->getVirAddr()。
1）录像video中显示时间：
if(flag&eID_Pass2VIDO)
{
 //Add timestamp
 MUINT8*p=(MUINT8*)vidoNode.getImgBuf()->getVirAddr();  
 MUINT8*end_p=(MUINT8*)vidoNode.getImgBuf()->getVirAddr()+ vidoNode.getImgBuf()->getImgWidth()*3*100/2;
 while((p<(end_p)))//add the addTimeStamp() function for yourself
 {
  *p=0;
   p++;
 }  
 //Add timestamp end
 vidoNode.getImgBuf()->setTimestamp(pass1LatestTimeStamp);
 mspPreviewBufHandler->enqueBuffer(vidoNode);
}
    2）录像preview的时候也显示时间:
if (flag&eID_Pass2DISPO)
{
 //Add timestamp
 MUINT8*p=(MUINT8*)dispNode.getImgBuf()->getVirAddr();    
 MUINT8*end_p=(MUINT8*)dispNode.getImgBuf()->getVirAddr()+ dispNode.getImgBuf()->getImgWidth()*3*100/2; 
 while((p<(end_p)) )//add the addTimeStamp() function for yourself
 {
  *p=0; 
   p++;
 }   
 //Add timestamp
 dispNode.getImgBuf()->setTimestamp(pass1LatestTimeStamp);  
 mspPreviewBufHandler->enqueBuffer(dispNode);
}   
方法三(适用所有版本，包括MT6735平台的M版本):
ExtImgProcImp.cpp：
M版本=>/vendor/mediatek/proprietary/hardware/mtkcam/legacy/v1/common/ExtImgProc/ExtImgProcImp.cpp
L版本=>/vendor/mediatek/proprietary/hardware/mtkcam/v1/common/ExtImgProc/ExtImgProcImp.cpp
KK版本=>/mediatek/hardware/mtkcam/v1/common/ExtImgProc/ExtImgProcImp.cpp
这里的demo是对ImageBufferQueue的yuv数据进行处理，将部分内容给涂黑，您可以使用这段buffer来处理timestamp，其中buffer地址为img.virtAddr。
1）设置需要处理的Image buffer type：
ExtImgProcImp::
ExtImgProcImp()
{
 FUNCTION_NAME;
 //Set which img buf you want to process.
 //For example: mImgMask = BufType_Display|BufType_Record;
 mImgMask = BufType_Display|BufType_Record;//录像Preview和video中都显示时间
 mUser = 0;
} 
2）添加时间戳
MBOOL
ExtImgProcImp::
doImgProc(ImgInfo& img)
{
...
 //Add image process code
 switch(img.bufType)
 {
  case BufType_Display:
  {
  //[BEGIN]

  //Add timestamp
  MUINT8 *p = (MUINT8*)img.virtAddr;
  MUINT8 *end_p = (MUINT8*)img.virtAddr + img.width*3*100/2;
  while((p<(end_p)))
  {
   *p=0;
   p++;
  }
  //Add timestamp end

  //[END]
  break;
  }
  ...
  case BufType_Record:
  {
  //[BEGIN]

  //Add timestamp
  MUINT8 *p = (MUINT8*)img.virtAddr;
  MUINT8 *end_p = (MUINT8*)img.virtAddr + img.width*3*100/2;
  while((p<(end_p)))
  {
   *p=0;
   p++;
  }
  //Add timestamp end

  //[END]
  break;
  }
  ...
 }
}
```

## [FAQ18241] 如何从Log里面判断EIS是否有生效

```
为了准确快捷的确定EIS是否生效，最好的方法就是main log里面去判断

[SOLUTION] 
1. 一般来说，EIS防抖主要录像功能，因此先看是否有startrecording之后才发生,关键词"CameraClient: startRecordingMode"
43648 01-01 22:17:18.968700   292  5565 D CameraClient: startRecording (pid 1591)
43653 01-01 22:17:18.968846   292  5565 D CameraClient: startRecordingMode
43672 01-01 22:17:18.971104   292  5565 I MtkCam/Cam1Device: (5565)(Default:0)[Cam1DeviceBase::startRecording] +

2. 直接看是EIS计算出来的结果,可以看cmvx和cmvy的值。关键词"[PrepareEisResult]"
43814 01-01 22:17:19.000351   292  5532 D EisHal  : [PrepareEisResult]cmvX(44738),cmvY(66588)
43816 01-01 22:17:19.000409   292  5532 D EisHal  : [PrepareEisResult]X(349,1107296256),Y(260,234881024)
44026 01-01 22:17:19.034379   292  5532 D EisHal  : [PrepareEisResult]cmvX(44749),cmvY(66463)
44028 01-01 22:17:19.034734   292  5532 D EisHal  : [PrepareEisResult]X(349,1291845632),Y(259,1333788672)
44310 01-01 22:17:19.068951   292  5532 D EisHal  : [PrepareEisResult]cmvX(44754),cmvY(66472)

3. MDP为EIS出来的input size, 关键词"{MdpMgr} [_startMdp]"
44437 01-01 22:17:19.082214   292  5545 I MdpMgr  : {MdpMgr} [_startMdp] QQ idx[0]_src_crop(1/1) : X(0),FloatX(0),Y(0),FloatY(0),W(2304),H(1296)

4. 供给EIS做处理的SIZE, 关键词"[DoEis]EisIn"
44503 01-01 22:17:19.100225   292  5532 D EisHal  : [DoEis]EisIn(2100,3116),P1T(1750,2596)
```

## [FAQ18243] MTK平台HAL3支持情况

```
目前我司平台有支援HAL3，默认开的是HAL1.如果ap有特别的需求，需要使用API2，可以通过修改一些配置文件开HAL3.
每个平台的支援情况请参考DCC上：M Camera Plan.pptx
如何从HAL1.0切换到HAL3请参考DCC上：
HAL1 switch to HAL3.2.pptx
Programming Guide to switch Camera HAL 1.0 and Camera HAL3.2.docx
```

## [FAQ03434] [Recovery]恢复出厂设置之后如何将时间变为初始值

```
Recovery.c (bootable\recovery):
#include <linux/rtc.h>
#include <sys/ioctl.h>
void set_rtc(void) {
    struct tm tm;
    int fd;
    tm.tm_sec = 0;
    tm.tm_min = 0;
    tm.tm_hour = 0;
    tm.tm_mday = 1;
    tm.tm_mon = 0;
    tm.tm_year = 2012-1900;
    fd = open("/dev/rtc0", O_WRONLY);
    if (fd != -1) {
        ioctl(fd, RTC_SET_TIME, &tm);
        close(fd);
    }
}
int
main(int argc, char **argv) {
...
中的
    } else if (wipe_data) {
....
 //
/*该else if代码最后 新增代码如下*/
set_rtc();
}
```

## [FAQ03431] [Recovery]OTA升级在recovery mode下无法返回normal mode

```
请确认一下 mediatek/custom/<project>/uboot/inc/mt65xx_partition.h
里面的 NAND_WRITE_SIZE是设定为多少.如果您使用的nand flash，请确认NAND_WRITE_SIZE此值是否与nand flash的page size一致。
```

## [FAQ18223] consys-reserve-memory use for which module

```
reviewing the consys-reserve-memory of device，customer finds thare are different in different device;
so customer want to know those memory used for which module?
 
adb shell cat proc/mtk_memcfg/memory_layout
Lavender M: [PHY layout]consys-reserve-memory : 0xa9e00000 - 0xa9ffffff (0x200000) => 2MB
SM30: [PHY layout]consys-reserve-memory : 0x5fe00000 - 0x5fefffff (0x100000) => 1MB

[Answer]
the 2M memory space is devided into three parts(512k for connectivity system, 512k for coredump space and 1M for GPS) in android M.
```

## [FAQ18224] 关于快拍实现的一个思路

```
很多客户有快拍的需求，如在灭屏或锁屏状态下能长按某个物理按键（多是音量键）来唤起Camera应用或者直接拍照并显示出照片预览。
这个需求的基本功能为灭屏或锁屏状态下能响应长按事件并唤起Camera进行拍照，可在PhoneWindowManager.java中来做这件事情。
 
PhoneWindowManager.java的interceptKeyBeforeQueueing会截取到keycode的down和up事件，可以在音量键按下(down)时给handler发送一个延迟启动的消息，在这个消息处理中做唤起Camera应用拍照的动作。在音量键抬起(up)时去remove这个消息.延迟时长可设200ms，表示长按的时间。这样，短按的话会在down时发送这个消息，up时马上又remove掉了，所以什么事情没有发生。长按时，在down时发送了消息，并长按时间超过200ms时就会真正去执行对Camera的操作。 
```

## [FAQ10434] Home key 点亮屏幕后, 如何使手机不自动回到 launcher 界面

```
有些项目会把 home key 配置成 wake key
这样, 按 home key 的时候就可以唤醒手机
但同时,home key 又会把当前的界面切到 launcher
如果只想让 home key 在黑屏时起到唤醒功能, 而不自动切换到 launcher
需要怎么做?
 
[SOLUTION]
注意: 黄色背景部分代码为所添加的代码
L、M
修改phonewindowmanager.java 中 interceptKeyBeforeQueueing 方法的下面这段 code:

// Basic policy based on interactive state.
int result; //参考行
//add  begin
if ( keyCode == KeyEvent.KEYCODE_HOME && !isScreenOn()) {
       policyFlags |= WindowManagerPolicy.FLAG_WAKE;
}
//add end
boolean isWakeKey = (policyFlags & WindowManagerPolicy.FLAG_WAKE) != 0
|| event.isWakeKey(); //参考行

KK
1: 修改 phonewindowmanager.java 中 interceptKeyBeforeQueueing 方法的下面这段 code:
if (keyCode == KeyEvent.KEYCODE_POWER) {
    policyFlags |= WindowManagerPolicy.FLAG_WAKE;
}
改为:
if (keyCode == KeyEvent.KEYCODE_POWER || (keyCode == KeyEvent.KEYCODE_HOME && !isScreenOn)) {
    policyFlags |= WindowManagerPolicy.FLAG_WAKE;
}

2: 仍然是此方法,对应部分修改为如下:
int result; //参考行

if (((isScreenOn && !mHeadless) || (isInjected && !isWakeKey))) {//参考行
    // When the screen is on or if the key is injected pass the key to the application.
    Log.d(TAG,"oldScreenOn = "+oldScreenOn); 
    if(!oldScreenOn && (keyCode == KeyEvent.KEYCODE_HOME)){
        Log.d(TAG,"eat the home up because home down has dropped");
        result |= ACTION_WAKE_UP;
    }else{
        result = ACTION_PASS_TO_USER;
    }
} else {
    // When the screen is off and the key is not injected, determine whether
    // to wake the device but don't pass the key to the application.
    result = 0;
    if (down && isWakeKey && isWakeKeyWhenScreenOff(keyCode)) {
           ...... 
    }
}
oldScreenOn = isScreenOn;

其中的 oldScreenOn 请定义在 phoneWindowManager 这个 class 中, 定义如下:
boolean oldScreenOn = true;
```

## [FAQ15186] Launcher3如何调整滑动灵敏度？

```
请修改Launcher3的PagedView.java中的变量：
private static final float SIGNIFICANT_MOVE_THRESHOLD = 0.4f;
请将这个变量变小。
Note：此修改L上会同时影响桌面和主菜单，M上只会影响桌面的滑动速度。
```

## [FAQ13295] 手机插SIM卡启动，Launcher会闪一下，如何避免？

```
手机插SIM卡启动，Launcher会闪一下，如何避免？
[SOLUTION]
KK/L0/L1/M0:
1. 在AndroidManifest.xml中修改Launcher这个Activity的属性，加上android:configChanges="mcc|mnc"。
2. 在Launcher.java中增加如下方法：
@Override
public void onConfigurationChanged(Configuration newConfig) {
    Log.d(TAG, "onConfigurationChanged() called.");
    super.onConfigurationChanged(newConfig);
}
KK/L0/L1:
3. 在LauncherModel.java的onReceive方法中，找到action等于Intent.ACTION_CONFIGURATION_CHANGED的分支，注释掉mcc/mnc变化时调用的forcereload()这行代码。
```

## [FAQ18182] 更改WiFi加密方式后，在WLAN列表中重复显示WIFI热点名称

```
测试机连接搭建的WiFi热点--路由器更换加密方式--进入设置--WALN列表，在WLAN列表中重复显示WIFI热点名称。
这种现象是正常行为，因为config的定义是，SSID + key management，只要有一者不一样，就是不同config。
如果要修改这个行为，请修改如下：
/frameworks/base/packages/SettingsLib/src/com/android/settingslib/wifi/AccessPoint.java
public void clearConfig() {
    mConfig = null;
    networkId = WifiConfiguration.INVALID_NETWORK_ID;
+ /// M: set AP rssi as default value when updateAccessPoints
+ mRssi = Integer.MAX_VALUE;
}
```

## [FAQ18237] [Legacy Wi-Fi]Adb如何获取所连接AP的RSSI

```
下载eng load，adb如何获取所连接AP的RSSI
adb shell wpa_cli -iwlan0 -g@android:wpa_wlan0 IFNAME=wlan0 SIGNAL_POLL
```

## [FAQ18187] 切换飞行模式SIM联系人是否应该显示?

```
这个与项目配置中的 MTK_FLIGHT_MODE_POWER_OFF_MD 有关系：默认设置是true，是为了省电；
如果期望打开飞行模式，SIM联系人继续显示，可以设置此项为false即可。
详细您可以参考 [FAQ08682][SIM]开关飞行模式引起modem关闭和打开这个与项目
```

## [FAQ17655] SIM卡联系人无法收藏

```
1. SIM卡联系人界面没有收藏功能选项；
2. 需要在收藏联系人界面和快速拨号界面显示收藏后的SIM卡联系人。  
 
[SOLUTION]
 
敝司设计时，故意屏蔽掉了SIM卡联系人。

[原因] SIM卡联系人在重开机/开关飞行模式/热插拨操作后，都会执行删除之前导入的并重新导入操作，
这样会导致您之前设定的 收藏 / 快速拨号 丢失，所以敝司专门屏蔽掉SIM联系人，

----------------------------------------------------------------------------------------------------------------------
如果不介意重开机/开关飞行模式/热插拨操作后设置的信息又丢失的Case，可以尝试如下修改对SIM卡联系人进行收藏。
----------------------------------------------------------------------------------------------------------------------
修改1. SIM卡联系人可以收藏
FILE: /packages/apps/Contacts/src/com/android/contacts/quickcontact/QuickContactActivity.java
public boolean onPrepareOptionsMenu(Menu menu) {
    if (mContactData != null) {
        final MenuItem starredMenuItem = menu.findItem(R.id.menu_star);
        ContactDisplayUtils.configureStarredMenuItem(starredMenuItem, 
        mContactData.isDirectoryEntry(), mContactData.isUserProfile(),
        mContactData.getStarred());
        
        // 下面这个地方就是您需要修改的地方，拿掉即可。 
        /// M: Disable sim contact star menu.
        if (mContactData.getIndicate() > 0) {
            starredMenuItem.setVisible(false);
        }
        ... ...
修改2. 收藏的SIM卡联系人在收藏列表和快速拨号列表显示
FILE: /packages/apps/Contacts/src/com/android/contacts/quickcontact/ContactTileLoaderFactory.java
public static CursorLoader createStrequentLoader(Context context) {
    /** M: Bug Fix for CR ALPS00319593 @{ */
    CursorLoader cursorLoader = new CursorLoader(context,
    Contacts.CONTENT_STREQUENT_URI, COLUMNS,
    Contacts.INDICATE_PHONE_SIM + "=-1 ", null, null);
    ContactsPreferencesUtils.fixSortOrderByPreference(cursorLoader, DISPLAY_NAME, context);
    return cursorLoader;
    /** @} */
}

public static CursorLoader createStrequentPhoneOnlyLoader(Context context) {
    Uri uri = Contacts.CONTENT_STREQUENT_URI.buildUpon().appendQueryParameter(ContactsContract.STREQUENT_PHONE_ONLY, "true").build();
    
    /** M: Bug Fix for CR ALPS00319593 @{ */
    CursorLoader cursorLoader = new CursorLoader(context, uri, COLUMNS_PHONE_ONLY, Contacts.INDICATE_PHONE_SIM + "=-1 ", null, null);
    ContactsPreferencesUtils.fixSortOrderByPreference(cursorLoader, DISPLAY_NAME, context);
    return cursorLoader;
    /** @} */
}
将以上两个方法中的 Contacts.INDICATE_PHONE_SIM + "=-1 " 修改为 NULL。
例如：
将
CursorLoader cursorLoader = new CursorLoader(context, uri, COLUMNS_PHONE_ONLY, Contacts.INDICATE_PHONE_SIM + "=-1 ", null, null);
修改为：
CursorLoader cursorLoader = new CursorLoader(context, uri, COLUMNS_PHONE_ONLY, null, null, null);
```

## [FAQ18203] [Camera_Tuning]CCT工具调试AE_PLine_table

```
CCT 页面上，导入device info ，到AE pline 页面tune AE pline table, 点save to nvraw 后，开机进不了camera
6755 之后的平台才可以通过CCT 页面tune AE Pline table 并且实时生效。。在此之前的平台如6735/6753 是不行的，建议通过CCT offline 的方式先gen AE Pline table ，把它导出来，通过build code 的方式验证
```

## [FAQ17922] 微信，登陆闪退，无法登陆

```
下载最新微信并登陆，下载最新微信并登陆。
1.提供对应的APK ,请确认测试机是否有写入IMEI ,WIFI MAC 地址，手机时间是否为当前网络时间
2.是否有先進行ATTK provisioning
$ adb shell soter_attk_provision
 
根據SOTER spec v2.3.1 SOTER方案OEM厂商微信接入指引 1.0.1.pdf
廠商必須在產線生產的時候同時燒入ATTK到RPMB
我司有提供一個provision command出來，可以透過adb進行attk provision動作
如下：
$ adb shell soter_attk_provision
```

## [FAQ17911] 开启节电助手，终端收到来电时不振动

```
来电震动的代码在alps\packages\services\telecomm\src\com\android\server\telecom\Ringer.java
private void startRingingOrCallWaiting方法中，修改其中的代码逻辑即可。
```

## [FAQ18063] [Others]当camera预览大小为4:3时，从camer里进图片旋转图片会比较慢

```
1.手机先拍几张照片
2.进camera\设置\相机\预览大小\4:3.
3.点右下角的缩略图图标进入Gallery打开一张图片
4.旋转图片，比较直接从Gallery中打开一张图片来旋转时的时间
Result:当camera预览界面比例为4:3时从camera里进图库旋转图片会比较慢,性能差
[SOLUTION]
可以做如下修改来解决
在Camera package下面
PreviewSurfaceView.java 中onMeasure方法中
找到 setMeasuredDimension(previewWidth, previewHeight);
在这一句code之前添加如下部分
if (mIsNeedLockSizeChange) {
    previewWidth = resolveSizeAndState(previewWidth, widthMeasureSpec, 0);
    previewHeight = resolveSizeAndState(previewHeight, heightMeasureSpec, 0);
}
```

## [FAQ18232] 如何打开MDP debug Log

```
当MDP出问题后，需要打开dpframework的开关才能在userdebug版本抓到完整的log.

为了使得在user版本上也能够打印出mdp和dpframework的log可以进行以下动作:
直接修改代码，然后复现问题后把整包mtklog传给mtk.
DpConfig.h (vendor\mediatek\proprietary\hardware\dpframework\include)
#define CONFIG_FOR_TPIPE_FINFO      0      // enable tile setting per tile
#define CONFIG_FOR_DUMP_COMMAND     0      // dump command.bin
#define CONFIG_FOR_SYSTRACE         0      // enable systrace
```

## [FAQ18233] 如何dump mdp(DpBlitStream mode) buffer

```
当图片出现异常后，为了理清问题，经常需要dump mdp buffer来理清是否为mdp 出错

[SOLUTION]
dump buffer的过程有以下两种方法.
(1)方法1：dump到默认的path: Dump folder : /sdcard/mdp/
adb shell setprop dpframework.dumpbuffer.enable 1

(2) 方法2: dump到制定的path: Change Dump folder : /data/mdp/
The dump folder is defined in DpPortAdapt.h

Command: 
1. adb shell setenforce 0 
2. adb shell mkdir /data/mdp
3. adb shell chmod 777 /data/mdp
4. adb shell setprop dpframework.dumpbuffer.enable 1
```

## [FAQ18189] Camera setting中添加拍照音选项

```
在DMS系统上下载以下文档, 参考修改即可
Camera_add_shuttersound_setting_item_L_platform,

DMS链接如下:
https://dcc.mediatek.com/Docs/Default.aspx
```

## [FAQ14500] [Audio Common] OTA升级音频参数后如果不恢复工厂设置也能生效

```
OTA升级默认只更新：boot.img, recovery.img, system.img
不会更新data区，但由于NVRAM存在于data区，所以OTA升级音频参数后需要恢复工厂设置才能生效，
但是恢复工厂设置导致data区user的其他数据也被擦除，不符合需求 
[SOLUTION]
Custom_NvRam_LID.h中每个data都对应一个VERNO即version number
/* audio file version */
#define AP_CFG_RDCL_FILE_AUDIO_LID_VERNO   "001" 
reboot时，当检测到VERNO有变化会重新生成新的NVRAM
所以只需要将对应项的VERNO如"001"改成不一样如"002"就可以了!
 
建议OTA时把此.h中所有的#define AP_CFG_***_LID_VERNO后面的number都改下！
```

## [FAQ15504] [Audio Profile]设置->情景模式->音效改善下面BesAudEnh、BesLoudness、BesSurround和无损蓝牙模式四个选项的默认值

```
设置->情景模式->音效改善下面BesAudEnh、BesLoudness、BesSurround和无损蓝牙模式四个选项的默认值
[SOLUTION]
1. 关于BesAudEnh，
默认值是在 vendor\mediatek\proprietary\custom\common\cgen\cfgdefault\audio_audenh_control_option.h
#define DEFAULT_AUDIO_AUDENH_CONTROL_OPTION_Coeff (0x00000002) //Bit0: Audenh default (Default off for Low Power) , Bit1: BesLoudness default
0x00000000 表示BesAudEnh关闭
0x00000001 表示BesAudEnh打开
2. BesLoudness
同上
0x00000002 表示 BesAudEnh关闭，BesLoudness打开
0x00000003 表示 BesAudEnh打开，BesLoudness打开
3. BesSurround
这个直接修改AudioProfileService.java里的mIsBesSurroundEnable
4. 无损蓝牙模式
/frameworks/av/services/audioflinger/AudioLosslessBTBroadcast.cpp 中，
将
mIsLosslessBTOn = (property_get(LOSSLESS_BT_PROP_NAME, value, "0") > 0) && (atoi(value) == 1);
改为：
mIsLosslessBTOn = (property_get(LOSSLESS_BT_PROP_NAME, value, "1") > 0) && (atoi(value) == 1);
```

## [FAQ15498] 【AudioProfile】如何判断当前文件是否存在？（system无权限读取SD card问题feature的规避）

```
在AudioProfile这边，是用isRingtoneExist()这个API来判断文件是否存在，但是Android5.1上google对system访问SD卡做了权限，而导致该API失效。 后来增加了validRingtoneUri这个API来去判断database里的URI存不存在，。 validRingtoneUri的缺点是一旦遇到文件已经不存在，但是database没有更新，就会有问题。 现提供新的判断方法。

[SOLUTION]
1. alps\vendor\mediatek\proprietary\frameworks\common\src\com\mediatek\common\audioprofile\IAudioProfileService.aidl
增加
boolean isRingtoneCanOpen(String UriData);

2. AudioProfileManager.java
增加
public boolean isRingtoneCanOpen(String UriData){
IAudioProfileService service = getService();
    try {
        return service.isRingtoneCanOpen(UriData);
    } catch (RemoteException e) {
        Log.e(TAG, "Dead object in isRingtoneCanOpen", e);
        return false;
    }
}

3. AudioProfileService.java
增加定义
private static final String GET_FILE_IS_EXIST = "GetFileIsExist: ";
增加API
public boolean isRingtoneCanOpen(String UriData){
    Log.d(TAG, "isRingtoneCanOpen() UriData= "+UriData);
    boolean ret=false;
    String validUri=null;
    // handle non-file sources
    String path= GET_FILE_IS_EXIST + UriData;
    validUri = mAudioManager.getParameters(path);
    Log.d(TAG, "isRingtoneCanOpen() validUri = "+validUri +", path= "+path);
    ret = validUri.equals("-1") ? false : true;
    return ret;
}

3. AudioFlinger.cpp

开头增加定义

char GET_FILE_IS_EXIST[] = "GetFileIsExist: "; // ddd file open



在 getParameters()的开头部分增加如下：

ALOGD("+%s(): %s", __FUNCTION__, keys.string());

//start ddd file open

String8 result;

char* strTag;

int lenKey = keys.length();

int lenTag = strlen(GET_FILE_IS_EXIST);

ALOGD("ddd getParameters(): lenKey=%d", lenKey);

 

strTag = strstr(keys, GET_FILE_IS_EXIST);

ALOGD("getParameters(): strTag=%s", strTag);

 

if(lenKey > lenTag && strTag!=NULL){

char* url = strTag + lenTag;

ALOGD("getParameters(): url=%s", url);

 

FILE *m_pInputFile;

m_pInputFile = fopen(url, "r");

if(m_pInputFile == NULL)

{

ALOGE("ddd Couldn't open fd for %s", url);

result = "-1";

}else {

ALOGE("ddd can open fd for %s", url);

result = "9";

fclose(m_pInputFile);

}

return result;

}

//end modify ddd file open

 

4. ringer.java

在startRingingOrCallWaiting()里调用 ValidRingtoneUri 的地方，增加如下，并且将ValidRingtoneUri 改用 isRingtoneCanOpen

String dataKey = audioProfileMgr.getDataKey(audioProfileMgr.getStreamUriKey(audioProfileMgr.getActiveProfileKey(), AudioProfileManager.TYPE_RINGTONE, slotId));

String uriData = Settings.System.getString(mContext.getContentResolver(), dataKey);

Log.d(this, " uriData: "+uriData);

 

if( false==audioProfileMgr.isRingtoneCanOpen(uriData)){

// if( -1==RingtoneManager.validRingtoneUri(mContext, ringtoneUri)){

Log.d(this, "default ");

ringtoneUri = audioProfileMgr.getDefaultRingtone(AudioProfileManager.TYPE_RINGTONE);

}

5. RingtoneManager.java

将getRingtone()里用到ValidRingtoneUri的地方，可以添加判断条件，将其屏蔽掉，因为在ringer.java里面已经有判断当前文件是否存在
```

## [FAQ10873] LatinIME输入法回车的图标如何替换成“Enter"字符

```
LatinIME输入法回车的图标如何替换成“Enter"字符？
[SOLUTION]
Enter图标在不同的style下有不同的定义，ICS和JB默认都采用的是IceCreaemSandWich风格。
在LatinIME的源码中搜索iconEnterKey,可以看到iconEnterKey有下面三个style定义：
KeyboardIcons.Black：
iconEnterKey = @drawable/sym_bkeyboard_return
KeyboardIcons.IceCreaemSandWich：
iconEnterKey = @drawable/sym_keyboard_return_holo
KeyboardIcons：
iconEnterKey = @drawable/sym_keyboard_return
默认情况下，将LatinIME中各个dpi下的资源中的sym_keyboard_return_holo.png
替换成带有Enter字符的图标即可。
如果用的是其它style ，请替换对应style的xxx.png图片为带Enter字符的图标即可。
 
其他版本也可以使用类似的搜索方式搜索iconEnterKey，然后修改它的定义即可。
```

## [FAQ08849] 乌克兰输入法长按Ь会弹出Ъ，去掉弹出Ъ

```
设置输入法为乌克兰输入法,长按长按Ь会弹出Ъ ,要求显示Ь而非Ъ .
因为乌克兰输入法中不应该有字符Ъ.
 
[SOLUTION]
修改
Donottranslate-more-keys.xml (alps\packages\inputmethods\latinime\tools\maketext\res\values-uk) 
中more_keys_for_cyrillic_soft_sign的定义为
 <!-- U+044A: "ÑŠ" CYRILLIC SMALL LETTER HARD SIGN -->
    <string name="more_keys_for_cyrillic_soft_sign"></string>
这里就去掉了长按Ь会弹出Ъ,
不过要使修改生效,先编译maketext,
编译完maketext后,请在alps
目录下使用
java -jar out/host/linux-x86/framework/maketext.jar  -java packages/inputmethods/LatinIME/java/src
然后再rebuild LatinIME.apk
将 LatinIME.apk push到手机中就可以验证了.
 
L和M版本修改类似只是string的名字有修改为：morekeys_cyrillic_soft_sign
```

## [FAQ08884] Latin输入法如何添加删除某些语言的输入法

```
android keyboard支持的keyboard请参考
Method.xml (alps\packages\inputmethods\latinime\java\res\xml) 
的开头说明中查看到输入所支持的语言。
开关这写支持的语言.
该文件有定义很多下面类似的subtype
<subtype android:icon="@drawable/ic_subtype_keyboard"
    android:label="@string/subtype_generic"
    android:subtypeId="1872175968"
    android:imeSubtypeLocale="af"
    android:imeSubtypeMode="keyboard"
    android:imeSubtypeExtraValue="KeyboardLayoutSet=qwerty,AsciiCapable"
/>
想关掉某种语言,直接注释掉即可.
想打开,请取消掉注释.
但是，某些语言无法删除，是因为有两种语言的输入法被定义在
predefined-subtypes.xml (alps\packages\inputmethods\latinime\java\res\values) 中
如果要删除预定义的语言de和fr，请在这里删除。
<string-array name="predefined_subtypes" translatable="false">
    <item>de:qwerty:AsciiCapable</item>
    <item>fr:qwertz:AsciiCapable</item>
</string-array>
因为latin输入法只支持latin语系,所以中日韩语言android keyboard是没有支持的.
对于这些语系,只能通过装第三方输入法解决(所以我司会预制sogou输入法).
```

## [FAQ10435] 如何让 app 自行处理 power key

```
Power key 通常都是由 framework 自行的
app 无法拿到这个 key 值
 
如果想让某个 app 自行处理 power key
应该要怎么做呢?
 
[SOLUTION]
L、M 
修改PhoneWindowManager的interceptKeyBeforeQueueing方法：
     ....
case KeyEvent.KEYCODE_POWER: {
result &= ~ACTION_PASS_TO_USER;
isWakeKey = false; // wake-up will be handled separately
 
//com.example.adc为要处理power key的包名
if(win != null && win.getAttrs() != null&&win.getOwningPackage().equals("com.example.adc")){
return 1;// return 1事件就传给app处理
}
if (down) {
interceptPowerKeyDown(event, interactive);
} else {
interceptPowerKeyUp(event, interactive, canceled);
}
break;
}
 
如果只想让power键让某个Activity处理，将以上的if条件改为：
if(win != null && win.getAttrs() != null&&win.getAttrs().getTitle().equals("xxx.xxx.xxx.xxxActivity")){
return 1;// return 1 就会传给 xxx.xxx.xxx.xxxActivity处理
}
 
KK、JB
1: 修改 phoneWindowManager.java 的 interceptKeyBeforeQueueing 方法,在 reference line 后加入下面这段代码
case KeyEvent.KEYCODE_POWER: { //reference line
 result &= ~ACTION_PASS_TO_USER; //reference line
  // add begin
 ActivityManager activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
 try{
  if (activityManager.getRunningTasks(1).get(0).topActivity.getPackageName().equals("your_special_package_name")){ 
   //Please reset the special package name.
   result |= ACTION_PASS_TO_USER;
   Xlog.d(TAG,"detect power key in special package, pass to user!")
  }
 }catch(NullPointerException e){
  Xlog.d(TAG,"ingore a NullPointerException ..");
 }
 //add end
 
2: 同样在此分支内, 找到 else 语句段, 并找到如下位置加入
if (interceptPowerKeyUp(canceled || mPendingPowerKeyUpCanceled)) { //参考行
      if(!((result & ACTION_PASS_TO_USER) == ACTION_PASS_TO_USER)){ //加入行
          result = (result & ~ACTION_WAKE_UP) | ACTION_GO_TO_SLEEP; //原有代码
      } //加入行
}

注意: 以上蓝色背景部分的内容需要替换为您预期要处理 power key 的 app 对应的 package name.
```

## [FAQ18170] 录像的时候添加Previewcallback

```
客户希望在录像的时候，能够在AP获取Previewcallback的数据进行处理。
  
[SOLUTION]
 
由于Record和Previewcallback在Pass2是公用同一输出，所以在录像的时候Previewcallback正常情况下是没有数据的。很多客户希望获取Previewcallback的数据，那么就需要从display输出中copy数据给Previewcallback，再callback给AP。所有的数据格式都是yv12的，如果AP设置NV12或者NV21的格式，可能会出现彩色条纹，所以请客户自行在copy的时候进行格式的转换。
具体的修改方式如下：

一.K2以上平台的修改方法如下：

修改文件路径：/vendor/mediatek/proprietary/hardware/mtkcam/legacy/platform/<ProjectName>/v1/adapter/CamNode/DefaultBufHandler.cpp

          1. private内添加变量

            MBOOL                       misVideo;//Add by mtk

2.函数enqueBuffer(MUINT32 const data, IImageBuffer const * pImageBuffer)内

            case eBuf_Rec:

            {

                 bufProvider = mspImgBufProvidersMgr->getRecCBPvdr();

                misVideo = MTRUE;//Add by mtk

                break;

            }

            case eBuf_AP:

            {

                                misVideo = MFALSE;//Add by mtk

             bufProvider = mspImgBufProvidersMgr->getPrvCBPvdr();

                const_cast<ImgBufQueNode*>(&keepImgBufQueNode)->setCookieDE(0); // 0 for preview

                break;

            }

         3.bufProvider->enqueProvider(keepImgBufQueNode);后添加

// Add by mtk start

if(misVideo){

            sp<IImgBufProvider> PreviewBufProvider;

            PreviewBufProvider = mspImgBufProvidersMgr->getPrvCBPvdr();

            ImgBufQueNode Previewnode;

            if (PreviewBufProvider != 0 && PreviewBufProvider->dequeProvider(Previewnode))

            {

                    MY_LOGD("APCallback size:%d, APClient size:%d", Previewnode.getImgBuf()->getBufSize() ,                                                   keepImgBufQueNode.getImgBuf()->getBufSize());

                    if ( Previewnode.getImgBuf()->getBufSize() >= keepImgBufQueNode.getImgBuf()->getBufSize())

                                               {

                             MY_LOGD("APCallback addr:0x%x, APClient addr:0x%x", Previewnode.getImgBuf()->getVirAddr(),                                             keepImgBufQueNode.getImgBuf()->getVirAddr());

                             memcpy(Previewnode.getImgBuf()->getVirAddr(),

                             keepImgBufQueNode.getImgBuf()->getVirAddr(),

                             keepImgBufQueNode.getImgBuf()->getBufSize());

                             const_cast<ImgBufQueNode*>(&Previewnode)->setStatus(ImgBufQueNode::eSTATUS_DONE);

                     }

                     else

                     {

                             MY_LOGE("APClient buffer size < Record buffer size");

                             const_cast<ImgBufQueNode*>(&Previewnode)->setStatus(ImgBufQueNode::eSTATUS_CANCEL);

                     }

                     PreviewBufProvider->enqueProvider(Previewnode);

            }

}

       //Add by mtk end

二.MT6580,MT6735M的修改如下

修改的文件路径：

/vendor/mediatek/proprietary/hardware/mtkcam/legacy/platform/<ProjectName>/v1/hal/adapter/MtkDefault/Preview/PreviewBufMgr.cpp

          1.添加private变量

MBOOL                         mIsVideo;//Add by mtk

          2.函数enqueBuffer(ImgBufQueNode const& node)内添加

         1）case eBuf_Disp:

        {

            sp<IImgBufProvider> bufProvider = mspImgBufProvidersMgr->getDisplayPvdr();

            if (bufProvider != 0)

            {

                bufProvider->enqueProvider(node);

            }

             //Add by mtk start

               if(mIsVideo)

            {

                 // If preview cb exists, copy to it

                  bufProvider = mspImgBufProvidersMgr->getDisplayPvdr();

                  ImgBufQueNode PrvCBnode;

                  if (bufProvider != 0 && bufProvider->dequeProvider(PrvCBnode))

                   {

                          if ( PrvCBnode.getImgBuf()->getBufSize() >= node.getImgBuf()->getBufSize())

                         {

                               memcpy(PrvCBnode.getImgBuf()->getVirAddr(),

                               node.getImgBuf()->getVirAddr(),

                               node.getImgBuf()->getBufSize());

                               const_cast<ImgBufQueNode*>(&PrvCBnode)->setStatus(ImgBufQueNode::eSTATUS_DONE);

                            }

                            else

                            {

                                 MY_LOGE("preview cb buffer size < ap buffer size");

                                const_cast<ImgBufQueNode*>(&PrvCBnode)->setStatus(ImgBufQueNode::eSTATUS_CANCEL);

                               }

                             //

                               bufProvider->enqueProvider(PrvCBnode);

                                  }                                                                                              

                              }

//Add by mtk end

        2）case eBuf_AP:

        {

                mIsVideo = MFALSE;//Add by mtk

       3）case eBuf_Rec:

        {

                mIsVideo = MTRUE;//Add by mtk

      3.析构函数中添加

PreviewBufMgr::

PreviewBufMgr(sp<ImgBufProvidersManager> &rImgBufProvidersMgr)

    : mspImgBufProvidersMgr(rImgBufProvidersMgr)

    , mspHwBufPvdr(new HwBuffProvider())

{

    mIsVideo = MFALSE;//Add by mtk

    }
```

## [FAQ11603] 如何在发生java层的out of memory时自动抓取对应进程的hprof

```
在Monkey等自动化测试时，需要在出现java的out of memory问题时自动抓取hprof文件(hprof会自动打包到aee_exp的db文件中)

1. 需要先从mainlog确认是否有合入DVM和AEE两部分的Patch.
   mainlog中有出现如下log, 代表有合入DVM部分的patch
   01-01 15:42:20.636  1310  1310 D dalvikvm: not gen hprof when oome
   mainlog中有出现如下log, 代表AEE部分的patch有合入
   01-01 15:42:21.407 12001 12001 E AEE/DUMPSTATE: copy_file: Copy /data/anr/1310.hprof to PROCESS_OOME_HPROF failed(2), No such file or directory 

2. 对应不同软件版本上的Patch ID：
   ALPS.JB2.MP：ALPS00692776
   ALPS.JB3.MP ALPS.JB3.TDD.MP: ALPS00828917 
   ALPS.JB5.MP: ALPS01210674+ ALPS00870675
   JB9.MP以及KK之后的版本已经包含所需patch

3. 再保证有合入patch的前提下，还请按照如下方法在ENG版本上测试：
    3.1. 连上adb执行如下命令（会自动重启，把电池开机后属性会无效，需要重新输入）：
          adb shell setprop dalvik.vm.oome-hprof-path  /data/anr
          adb shell chmod 0777 /data/anr/
          adb shell stop
          adb shell start
    3.2. 开完机后清除mtklog文件夹，再开启mobilelog.
    3.3. 然后复制问题，出现问题后等几分分钟，然后将mtklog发过来。

 

4.针对L版本需要做如下的修改

/art/runtime/Android.mk

334ifeq ($(TARGET_ARCH), $(filter $(TARGET_ARCH), arm arm64))
335  ifeq ($(TARGET_BUILD_VARIANT), eng)
336    # MTK add dump hprof when OOME
337    #LIBART_CFLAGS += -DMTK_DUMP_HPROF_WHEN_OOME
338    ifneq ($(strip $(MTK_EMULATOR_SUPPORT)), yes)
339      # MTK add dump reference table usage when table overflow
340      #LIBART_CFLAGS += -DMTK_DEBUG_REF_TABLE
341    endif
342  endif
343endif
344endif #MTK_EMULATOR_SUPPORT
345
LIBART_CFLAGS += -DMTK_DUMP_HPROF_WHEN_OOME     #打开宏开关

M 版本目前不支持。
```

## [FAQ18172] Andorid M版本上手电筒不亮

```
在Android M版本上，如果我们使用的闪光灯是透过LED2 的driver去实际控制打闪的，在下拉菜单中
点击手电筒会不亮。
 
[SOLUTION]
M版本的手电筒是透过flash_hal.cpp 来控制的，默认的source code中只会下command去控制LED1。如果闪光灯实际上是通过LED2的driver去控制，那么我们需要添加对LED2的控制，如下code中所示。（add for led2是需要添加的内容）
 
setTorchOnOff(MINT32 i4SensorOpenIndex, MBOOL en) {
    MINT32 i4SensorDevId = (!m_pHalSensorList)? 0: m_pHalSensorList->querySensorDevIdx(i4SensorOpenIndex);
    if(i4SensorDevId==2 && cust_isSubFlashSupport()==0)
        return 1;
    StrobeDrv* pStrobe = StrobeDrv::getInstance(i4SensorDevId);
    StrobeDrv* pStrobe2 = StrobeDrv::getInstance(i4SensorDevId,2);//add for led2
    if(en==1){
        pStrobe->init();
        pStrobe->setDuty(0);
        pStrobe->setTimeOutTime(0);
        //add for led2
        pStrobe2->init();
        pStrobe2->setDuty(0);
        pStrobe2->setTimeOutTime(0);
        //add end
        pStrobe->setOnOff(1);
        pStrobe2->setOnOff(1);//add for led2
        m_status = 1;
    }else{
        pStrobe->setOnOff(0);
        pStrobe->uninit();
        //add for led2 
        pStrobe2->setOnOff(0);
        pStrobe2->uninit();
        //add end
        m_status = 0;
    }
    return 0;
}
```

## [FAQ18149] Antutu跑分低排查建议

```
建议参考下述步骤排查：
1、请与贵司Power、Thermal相关同仁确认是否因为功耗、温升等问题修改过可能影响performance的代码及配置，比如CPU限核、限频等。如有，请还原为Mediatek原始状态进行测试。
2、请参考下面FAQ重新测试：
     FAQ12284  Benchmark Tool 跑分测试注意事项
3、请在冰箱环境中测试，统计并对比常温、冰箱中测试数据。
     Note*: 冰箱环境中，并非温度越低越好，比如电池在冰冻环境中比较容易打到低电量导致的CPU限核及限频。建议选取在-10℃、-5℃、0℃分别测试看看。
4、请关闭thermal throttle后，分别在冰箱、常温下进行测试，统计并对比相关测试数据。关闭方法参考下面FAQ:
     FAQ14794  How to disable thermal throttling
5、请测试CPU performance mode（全核全频率）下跑分，分别在冰箱、常温下进行测试，统计并对比相关测试数据。方法可以咨询贵司Power同仁。 
6、请使用Driver Only版本测试，统计并对比相关测试数据。
7、如果1~6排查下来仍有疑问，请提eservice处理，同时提供下面数据（统计到Excel表格中），格式如下：
```

## 安兔兔跑分中断[FAQ21495]

```
是因为 antutu 的应用占用内存太大被lmkd杀死了

/system/core/lmkd/lmkd.c
(1)
/* Kill one process specified by procp.  Returns the size of the process killed */
static int kill_one_process(struct proc* procp, int min_score_adj, bool is_critical) {
    int pid = procp->pid;
    uid_t uid = procp->uid;
    char *taskname;
    int tasksize;
    int r;

    taskname = proc_get_name(pid);

    // add 
    char packageName[30] = {""};
    strncpy(packageName, taskname, sizeof("com.antutu.ABenchMark:push"));
    
    if(!strcmp(packageName,"com.antutu.ABenchMark:push")){
    return -1000;
    }
    strncpy(packageName, taskname, sizeof("com.antutu.ABenchMark"));
    
    if(!strcmp(packageName,"com.antutu.ABenchMark")){
    return -1000;
    }
    strncpy(packageName, taskname, sizeof("com.antutu.ABenchMark:refinery"));
    
    if(!strcmp(packageName,"com.antutu.ABenchMark:refinery")){
    return -1000;
    }
    
    // add end


(2)
retry:
        procp = proc_adj_lru(i);

        if (procp) {
            killed_size = kill_one_process(procp, min_score_adj, is_critical);
       /* MTK add */
       if(killed_size == -1000){
                ALOGE("MTK_killed_size == -1000 and jump kill_one_process");
            }
       /* mtk add end 


3.18/drivers/staging/android/lowmemorykiller.c
(3)

rcu_read_lock();
for_each_process(tsk) {
    struct task_struct *p;
    /* mtk begin */
    if(tsk->comm){
    if((strstr(tsk->comm,"tutu.ABenchMark")!=NULL)
        ||(strstr(tsk->comm,"ABenc  hMark:push")!=NULL)
        ||(strstr(tsk->comm,"benchmark:full")!=NULL))
        ||(strstr(tsk->comm,"chMark:refinery")!=NULL)){
            lowmem_print(1,"mtk_lowmemorykiller_2\ jump kill 'tutu.ABenchMark' 'ABenchMark:push' 'benchmark:full' 'myapplication'\n");
            continue;
        }
    }
    /* mtk end */

Thanks
```

## [FAQ21508] framework 内存管理优化

## [FAQ21495] lmk (lowmemorykiller) and lmkd 白名单

```
lowmemorykiller 可能误杀一些进程，比如 测试测序，特别重要但占用内存比较大的程序等
 
可能使用到添加白名单的方法，避免被误杀
 
[SOLUTION]
 
 
（一）首先看是lowmemroy 还是  lmkd

查看方法看: 两种

（1）

▪/sys/module/lowmemorykiller/parameters/adj  里面的值

0,0,0,0,0,0 → lmkd  //o版本是没有这个值的

0,100,200,300,900,906  → lowmemorykiller 

 

（2）看“lowmemroykiller” 出现的位置

kernel log→ lowmemorykill

main log → lmkd 

 

(二)

判断好了后根据两种方式加入白名单，也可以都加入：

注意更改方法是 o 版本的更改方法，其他版本稍有变化

LMKD

1.

\system\core\lmkd\lmkd.c

/* Kill one process specified by procp.  Returns the size of the process killed */
static int kill_one_process(struct proc* procp, int min_score_adj, bool is_critical) {
    int pid = procp->pid;
    uid_t uid = procp->uid;
    char *taskname;
    int tasksize;
    int r;

    taskname = proc_get_name(pid);
    /* MTK begin */

    char packageName[20] = {""};
    strncpy(packageName, taskname, sizeof("com.antutu"));
    ALOGE("MTK_packageName=%s,taskname=%s,strcmp=%d",packageName,taskname,strcmp(packageName,"com.antutu"));
    if(!strcmp(packageName,"com.antutu")){
        return -1000;
    }
    /* MTK end */

2.

o版本
\system\core\lmkd\lmkd.c

static int find_and_kill_process(bool is_critical) {
    int i;
    int killed_size = 0;
    int min_score_adj = is_critical ? critical_oomadj : medium_oomadj;

    for (i = OOM_SCORE_ADJ_MAX; i >= min_score_adj; i--) {
        struct proc *procp;

retry:
        procp = proc_adj_lru(i);

        if (procp) {
            killed_size = kill_one_process(procp, min_score_adj, is_critical);

            /* MTK begin*/
    if(killed_size == -1000){
                ALOGE("MTK_killed_size == -1000 and jump kill_one_process");
            }else if (killed_size < 0) {
    /* MTK end */
                goto retry;
            } else {
                return killed_size;
            }
        }
    }

 

p版本

由于p版本这个地方google进行了更新，可能部分版本可以参照上面的的方法，如果发现有更改则使用下面的更改方法

\system\core\lmkd\lmkd.c

static int find_and_kill_process(bool is_critical) {

..

break;

killed_size = kill_one_process(procp, min_score_adj, level);
/* MTK begin*/
if(killed_size == -1000){
ALOGE("MTK_killed_size == -1000 and jump kill_one_process");
continue;
}
/* MTK end*/
if (killed_size >= 0) {
#ifdef LMKD_LOG_STATS
if (enable_stats_log && !lmk_state_change_start) {
lmk_state_change_start = true;
stats_write_lmk_state_changed(log_ctx, LMK_STATE_CHANGED,
LMK_STATE_CHANGE_START);
}

 
lowmemroykiller

3.18/drivers/staging/android/lowmemorykiller.c
(3)

rcu_read_lock();
for_each_process(tsk) {
struct task_struct *p;
short oom_score_adj; 

    //lowmem_print(1,"mtk jump lowmemorykiller_1 tsk->comm=%s",tsk->comm);
/* mtk begin */
    if(tsk->comm){
    if((strstr(tsk->comm,"tutu.ABenchMark")!=NULL)
        ||(strstr(tsk->comm,"ABenchMark:push")!=NULL)
        ||(strstr(tsk->comm,"benchmark:full")!=NULL))
        ||(strstr(tsk->comm,"chMark:refinery")!=NULL)){
         lowmem_print(1,"mtk_lowmemorykiller jump kill 'tutu.ABenchMark' 'ABenchMark:push' 'benchmark:full' \n");
         continue;
         }
    }
      /* mtk end */

添加白名单的名字是如何确定的？

搜索关键字lowmemorykiller ，  killing 的 apk  name 就添加到上面的代码中就可以了

11-30 11:08:03.668 <6>[10425.252789] (3)[92:kswapd0]lowmemorykiller: Killing 'android.vending' (23456) (tgid 23456), adj 100,
11-30 11:08:03.839 <6>[10425.423820] (2)[92:kswapd0]lowmemorykiller: Killing 'magazineservice' (9338) (tgid 9338), adj 100,
11-30 11:08:03.868 <6>[10425.452692] (1)[92:kswapd0]lowmemorykiller: Killing 'dboxed_process0' (16792) (tgid 16792), adj 100,
11-30 11:08:03.904 <6>[10425.488277] (1)[92:kswapd0]lowmemorykiller: Killing 'hbox:interactor' (9455) (tgid 9455), adj 100,
11-30 11:08:04.112 <6>[10425.696791] (3)[92:kswapd0]lowmemorykiller: Killing 'ssion.appupdate' (9323) (tgid 9323), adj 100,
11-30 11:08:04.222 <6>[10425.807027] (3)[92:kswapd0]lowmemorykiller: Killing 'android.smspush' (9561) (tgid 9561), adj 100,
11-30 11:08:04.370 <6>[10425.955053] (1)[92:kswapd0]lowmemorykiller: Killing 'MainThread-UE4' (18741) (tgid 18741), adj 0,

LMKD 不是这样添加的
```

## [FAQ12284] Benchmark Tool 跑分测试注意事项

```
1.使用Benchmark Tool，例如Antutu等对手机进行跑分测试时，建议使用user build + driver only测试；若没有driver only load，请务必使用user 版本(关掉log)来run benchmark tool

2.Run Benchmark Tool时建议:
    手机恢复出厂设置，再安装Benchmark APK;
    测试APK前重启手机，等待一分钟，等手机稳定后再进行测试，每测完一次，等待一分钟，再进行测试,测四次，取后三次平均值;

3.测试机与参考机分值差在10%以内，我们认为是正常的。

4.附上内部常用benchmark Tool apk list供您参考

CaffeineMark 
Linpack for Android
Nbench 
CoreMark(AndEBench)
Quadrant Advanced
Antutu benchmark 
Smartbench 2012
CF-Bench 
FPS2D 
Benchmark
0xBench
NenaMark2
An3DBenchXL 
Electopia 
3DRating Benchmark
Vellamo 
BrowserMark
Sunspider 
AndroBench
RL Benchmark:SQLite
```

## [lmkd][lowmemorykiller]80Go512M项目出现大量apk闪退，报错及CTS/CTSV测试不起来问题

```
修改 build/target/product/go_defaults_512.mk
PRODUCT_PROPERTY_OVERRIDES += \
    ro.lmk.medium=700

将这里的700修改为750，再测试看看
```

## [FAQ18152] [AudioProfile]第一次开机，来电话没有来电铃声

```
第一次开机的时候，没有来电铃声，甚至drive only版本也是如此。 正常情况下，第一次开机的时候，是要响默认铃声。
同样的版本，在客户端没有问题，而在客户的客户端却有问题。
[SOLUTION]
问题原因：
有第三方将ringtone_set的值初始化为1
解决办法：
以work around 的方法解决：
private boolean doesSettingEmpty(String settingName) {
    String existingSettingValue = Settings.System.getString(mContext.getContentResolver(), settingName);
    /*   删掉如下
    if (TextUtils.isEmpty(existingSettingValue)) {
        return true;
    }
    return false;
    */

//改为如下：
Log.d(TAG, "Mits doesSettingEmpty settingName:" + settingName + " existingSettingValue:"+existingSettingValue);
if (TextUtils.isEmpty(existingSettingValue)) {
    return true;
}else if(existingSettingValue.equals("yes")){
    return false;
}else
    return true;
}

也就是说，我们避开去判断第三方设置为1这个值，在初始化时，只有为"yes"，才认定为已经设置来电铃声的默认值，否则，就认为没有设定默认值。
```

## [FAQ14482] [Recovery][Others]如何在recovery mode下单独关闭selinux 而不影响normal mode

```
参考 FAQ11484[SELinux] 如何设置确认selinux 模式，
可以在开机一启动就设置selinux模式，  但这是针对所有模式。 
如果只想在recovery mode下关闭而不影响normal mode，以下提供方法。 

[SOLUTION]
修改  /bootable/bootloader/lk/app/mt_boot/mt_boot.c

+if(g_boot_mode == RECOVERY_BOOT){ //<----添加这行
+sprintf(commanline, "%s androidboot.selinux=permissive", commanline); //<----添加这行
+}else{ //<----添加这行
#ifdef SELINUX_STATUS
#if SELINUX_STATUS == 1
sprintf(commanline, "%s androidboot.selinux=disabled", commanline);
#elif SELINUX_STATUS == 2
sprintf(commanline, "%s androidboot.selinux=permissive", commanline);
#endif
#endif
+}//<----添加这行
 
在L版本上，因user版本默认无法关闭selinux, 如果要对user 版本有效,
同样需要修改 system/core/init/Android.mk ，新增
LOCAL_CFLAGS += -DALLOW_DISABLE_SELINUX=1
```

## [FAQ12491] [Recovery mode][Common] 选择"apply update from sdcard"直接进入data/目录是否正常？

```
Recovery mode 选择"apply update from sdcard"直接进入data/目录，说明您开了MTK_SHARED_SDCARD宏；请检查下贵司project下的projectconfig.mk文件，谢谢！
至于开了share sd功能后的升级方案：请参考：
ID: FAQ12477
关于打开MTK_SHARED_SDCARD宏后MTK目前升级方案
KK 版本默认是支持在打开MTK_SHARED_SDCARD宏后从内卡升级，即从/data/media/下面选取升级包升级；但这种情况有些Limitation；详情见FAQ12477。
[SOLUTION]
这种现象是正常的！ 谢谢！
```

## [FAQ12477] [Recovery][Common]关于打开MTK_SHARED_SDCARD宏后MTK目前升级方案

```
如果设置宏MTK_SHARED_SDCARD=yes；默认是把升级包放到外置SD卡才能升级成功。即这种情况下不支持内卡升级。
因为此时只有data/ 目录，sdcard0 其实变成了/data/media/；如果支持从内卡升级，有如下Limitation：
1、因為android 有對 /data 加密的功能, 在加密的情況下OTA 就無法將升級包下載至 /data recovery 也無法從 /data 下取得升級包升級.
2、除了加密的限制, 另外的 limitation 是, 如果 /data 分区的起始地址有更動我們升級時會擋下, 因為/data的資料無法 backup 和 restore. 所以客戶需確認兩版的 /data 起始地址也不能改變.
```

## [FAQ12478] [Recovery][Common]关于打开MTK_SDCARD_SWAP 宏后MTK目前升级方案

```
如果设置宏MTK_SDCARD_SWAP=yes；默认是优先从外卡获取升级包，外卡没有包，才会去内卡获取！
1. 插入外卡，升级包update.zip放入外卡，升级可以成功！
2. 插入外卡，升级包update.zip放入内卡，升级失败，提示：找不到升级包！
3. 未插入外卡，升级包update.zip放入内卡，升级成功！
```

## [FAQ18188] [Recovery][Common]Android M 版本如何升级logo等rawdata分区方法？

```
参考FAQ17441[Recovery][Common]Android M 版本如何升级lk 、preloader ？可以升级lk和preloader，那如何升级logo等其他的rawdata分区呢？
根据MTXXXX_Android_scatter.txt文件是否存在is_upgradable分成两种情况
 
一.存在is_upgradable关键字
修改方法
修改partition table中的OTA_Update，将需要升级的分区的N改成Y。

二.不存在is_upgradable关键字
修改方法：
在FAQ17441的基础上，另外加入下面的修改
 
修改/device/mediatek/build/releasetools/mt_ota_preprocess.py

if os.getenv("MTK_LOADER_UPDATE") is not None and os.getenv("MTK_LOADER_UPDATE") == "yes":
if "lk" not in upgrade_list_include:
upgrade_list_include.append("lk")
if "preloader" not in upgrade_list_include:
upgrade_list_include.append("preloader")
加入
+ if "logo" not in upgrade_list_include:
+ upgrade_list_include.append("logo")
其他的rawdata分区，可以参考加入。
```

## [FAQ14091] 如何在Recent App不显示某个应用

```
长按HOME键或者Navigation bar的recent key在最近应用程序列表中会显示最近访问过的应用，如何做到不显示某应用以达到隐藏进程的目的呢？
 
[SOLUTION]
 
为该应用AndroidManifest xml文件中主activity设置属性：android:excludeFromRecents=“true”
例如：
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="com.mingli.test"
      android:versionCode="1"
      android:versionName="1.0">
    <application android:icon="@drawable/icon" android:label="@string/app_name">
        <activity android:name=".HttpTest"
                  android:excludeFromRecents="true"
                  android:label="@string/app_name">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>        
    <uses-sdk android:minSdkVersion="3" />
</manifest>
```

## [FAQ13927] 如何取消Heads-Up Notification方式

```
1. 从Android 5.0开始，如果notification  priority设置为HIGH, MAX, 或者fullscreenIntent不为空，在非锁屏界面收到notification时屏幕上方会显示一个小悬浮窗口提醒用户，方便用户在不退出当前浏览界面的前提下快速响应该notification，即Heads-Up Notification(简称HUN)。如下图：

2. 如需禁止某个应用notification以HUN方式显示，又不想降低notification priority或者拿掉fullscreenIntent，毕竟这两种方式会改变notification其他行为。
work around方法是在baseStatusbar.java中根据需求客制化interrupt值。
例如，要禁止来电以Heads-Up Notification方式显示，可修改如下：
```

## [FAQ13742] 添加“一键删除最近应用列表”功能

```
在RecentActivity界面添加“一键删除最近应用列表”按钮，其实现分两个部分：
1. 在RecentActivity界面添加一个button，点击该button触发一键删除功能，请您根据需求添加在合适位置。
2. 在button的onclick()方法中，通过调用AMS接口来删除AMS记录的recent list。请通过如下方式来实现：
final ActivityManager am = (ActivityManager)mContext.getSystemService(Context.ACTIVITY_SERVICE);
final List<ActivityManager.RecentTaskInfo> recentTasks = am.getRecentTasks(MAX_TASKS, ActivityManager.RECENT_IGNORE_UNAVAILABLE);
for(ActivityManager.RecentTaskInfo rt:recentTasks ) {
    if (am != null) am.removeTask(rt.persistentId, ActivityManager.REMOVE_TASK_KILL_PROCESS);
}
```

## [FAQ12395] Notification列表中的日期格式和Setting的不一致

```
这个是google设计的默认问题，按照如下修改可以解决，
DateTimeView.java（frameworks/base/core/java/android/widget）
private DateFormat getDateFormat() {
    String format = Settings.System.getString(getContext().getContentResolver(), Settings.System.DATE_FORMAT);
    if (format == null || "".equals(format)) {
        return DateFormat.getDateInstance(DateFormat.SHORT);
    } else {
        try {
            //return new SimpleDateFormat(format);///注释此行，使用下面的替代
            return android.text.format.DateFormat.getDateFormat(getContext());
        } catch (IllegalArgumentException e) {
            // If we tried to use a bad format string, fall back to a default.
            return DateFormat.getDateInstance(DateFormat.SHORT);
        }
    }
}
```

## [FAQ10475] 切换系统语言，拉下状态栏发现状态栏内容没有同步更新

```
切换系统语言，拉下状态栏发现状态栏内容没有同步更新
例如：
1、手机插入USB，切换系统语言之后，下状态栏发现，USB相关的状态栏通知内容没有同步更新，还是切换前的语言文字内容。

[SOLUTION]
这是Google default design，google原生对比机nexus是一样的行为现象。因为：
1. Statusbar 无法控制是否改语言，只负责显示App发送的通知中所携带的字串和图片内容。
2. 如果需要翻译由各个app决定。
3. 到底变不变对于end users来说都是可以接受的，因为改变语言是主动行为，user是可以接受某条临时notification没有变化的情况的
请知悉，谢谢！
```

## [FAQ12130] [Recovery][Common]如何通过adb command 完成自动SD卡升级？

```
通过adb 命令的方式，免去了按powerkey+volumeup进入menu select以及recovery mode的不便。可以把命令放到.bat档。只要包的路径设置正确，可以实现在PC端一键升级。
1. Insert SD card with  OTA package，下面以OTA包放到内卡为例；
[Step]
1、正常开机模式下：手机连接usb成功。
2、输入adb cmd： adb shell "echo \"--update_package=/sdcard/update.zip\" > /cache/recovery/command"
3、输入：adb reboot recovery
```

## [FAQ08109] [Recovery][Common]在recovery mode下同时挂载内置T卡和外置T卡

```
目前recovery mode下只支持挂载内置T卡或者外置T卡一种，如果想同时挂载内置T卡和外置T卡，请参考以下方法
[SOLUTION]
1，
Add -DSUPPORT_SDCARD2 in bootable/recovery/Android.mk
ifeq ($(WITH_BACKUP_RESTORE),true)
LOCAL_CFLAGS += -DSUPPORT_DATA_BACKUP_RESTORE -DSUPPORT_SDCARD2
Endif
 
2，
recovery.fstab的优先级是project > platform > common，还请根据项目的具体情况来修改recovery.fstab。比如，project的fstab需要修改alps/mediatek/config/<project>/recovery_xxx.fstab。
具体修改，还请仿照以下方法新增加一行
a) KK前的版本
emmc为：
/sdcard2  vfat  /dev/block/mmcblk1p1 /dev/block/mmcblk1
nand为：
/sdcard2  vfat  /dev/block/mmcblk0p1 /dev/block/mmcblk0
 
b) KK版本
emmc为：
/dev/block/mmcblk1p1 /sdcard2 vfat  defaults defaults
nand为：
/dev/block/mmcblk0p1 /sdcard2 vfat defaults defaults
 
3，
重新编译整个工程
```

## [FAQ04559] [Recovery][Common]从JB版本开始支持adb sideload命令

```
从JB版本开始支持adb sideload命令,adb sideload命令的优势在于我们不必将制作好的升级包拷贝到SD卡或T上上！adb sideload是支持将升级包存于电脑上然后通过abd sideload命令进行直接对手机进行升级！

[Solution]

具体的操作过程如下：
1，同时按下手机power和音量上键进入recovery mode，
2，然后选择“apply update from ADB"这一项并确定
3，用usb线连上手机和电脑，（确保usb转串口驱动安装完好）
4，在电脑端点击 开始——运行，在里面输入 adb sideload $path,(其中$path 代表的是升级包在电脑上的具体路径）
```

## [FAQ07941] [HFP]蓝牙车载和蓝牙耳机的区别

```
蓝牙耳机：市面上，双声道蓝牙耳机大多数支持HFP(手机音频) 和 A2dp(媒体音频) 和AVRCP(音/视频控制)这三个Profile；
             单声道蓝牙耳机大多数只支持HFP，部分会同时支持HFP 和 A2dp。
 
蓝牙车载：分为外置式和内置式，外置式是一台可携带的蓝牙设备，内置式是集成在车辆上的，随原车一起购买。车载
             大多数都支持HFP、A2dp、AVRCP 这三个Profile，有显示屏的车载还会支持PBAP(电话本访问协议)，这样可以
             从车载上直接进行拨打电话操作。
 
所以从蓝牙系统应用(Profile) 角度看，蓝牙车载和蓝牙耳机本质上没有区别，只是车载的功能会多一些。
```

## [FAQ07939] [Debug]如何抓取蓝牙空中数据包(Air Sniffer)

```
1、抓取 Sniffer Log 需要专门的蓝牙Sniffer工具才能抓取，可以截取蓝牙通信双方的空中数据包，分析交互双方的行为等，目前敝司使用的 Frontline  公司和Ellisys 公司生产的蓝牙Sniffer 工具，抓取方式可以参考该工具的官方帮助文档。
 
2、抓取蓝牙Air Sniffer时，需要输入配对后产生的Link Key，目前敝司在JB 和 JB2 版本上获取Link key 的方法
如下：
 
1、手机连接ADB
2、输入 adb shell btconfig 6，即会打印出Link Key 和 对方设备蓝牙地址。

Sniffer工具哪里下载？？？？怎么用？？？
```

## [FAQ18155] factory mode/meta mode如何抓log

```
factory mode/meta mode如何抓log？
factory mode/meta mode下会将log存到外卡中。将外置SD卡插入手机，即可抓取log至外卡。
 
factory mode/meta mode抓不到log怎么办？
1.先确认，有插入外置SD卡
2.确认外卡能正常识别
adb shell进/storage下看是否有外卡
3.mobile_log_d这个抓log的daemon有在运行
查看手机 factory_init.rc 里是否有以下code：
service mobile_log_d /system/bin/mobile_log_d
class main
或adb shell ps | grep mobile_log_d查看daemon是否运行
4.M版本还需检查一下selinux权限
/device/mediatek/common/sepolicy/mobile_log_d.te中若无需添加下面两句：
allow mobile_log_d mnt_media_rw_file:dir {search create_file_perms};
allow mobile_log_d mnt_media_rw_file:file create_file_perms;
```

## [FAQ18077] Android L之后，状态栏图标资源的编辑

```
Android L之后，google逐渐采用VectorDrawable这种矢量图代替传统的png应用到状态栏上。
矢量图的优点是与像素无关，systemUI的矢量图统一放在frameworks\base\packages\SystemUI\res\drawable
路径下，可以将它缩放到任意大小和以任意分辨率在输出设备上打印出来，都不会影响清晰度。
最新版本的Android Studio支持解析xml文件描述的矢量图所输出的图片样式。
 
客户如果想客制化状态栏上的矢量图，有以下方法：
1. 用png代替。 谨记需提供不同分辨率设备所需的png资源，放在对应density的的res\drawable_xxx 路径下。
2. 制作xml矢量图。google未提供制作工具，目前市面上有收费软件Adobe Illustrator (AI) CS6可以制作，如果有兴趣可以向mtk提交e-service申请该工具参考文档。标题注明SystemUI 关键字。敝司只提供该工具指导文档，具体制作需客户自行研究实现。

Adobe Illustrator (AI) CS6 工具怎么用？？
```

## [FAQ08566] 如何修改默认的searchable items.

```
在QuickSearchBox中有个config.xml文件
里面有定义个default_corpora的数组。
修改这个数组的内容就可以更改默认的search-able的值。
例如：
将
<string-array name="default_corpora" translatable="false">
    <item>web</item>
    <item>apps</item>
    <item>com.android.providers.applications/.ApplicationLauncher</item>
</string-array>
修改为
<string-array name="default_corpora" translatable="false">
    <item>web</item>
    <item>apps</item>
    <item>com.android.providers.applications/.ApplicationLauncher</item>
    <item>com.android.mms/.ui.SearchActivity</item>
    <item>com.android.contacts/com.mediatek.contacts.activities.CallLogSearchResultActivity</item>
</string-array>
上面就添加了mms和calllog.
修改后，重新编译QuickSearchBox.apk ，再push进手机后恢复出厂设置验证.
```

## [FAQ18139] 如何dump连拍时的YUV数据

```
1. adb command 方式：
    手机连接PC
    adb shell setprop debug.MShot.dump 1
    adb shell setprop debug.camnode.dump.44 1
    然后进入camera 开始连拍，连拍后在sdcard/camera_dump 文件夹检查连拍dump YUV图片。

2. 修改code方式：
原理同上述方法1一样。
/vendor/mediatek/proprietary/platform/mt6735/hardware/mtkcam/D1/core/camnode/ICamGraphNode.cpp

ICamGraphImpl::
start()
{
Mutex::Autolock _l(mLock);
MY_LOGD("Start +");
MY_ASSERT_STATE( mState == State_Initiated, mState );

{ //update dump enable
char value[PROPERTY_VALUE_MAX] = {'\0'};
char key[PROPERTY_KEY_MAX];
snprintf( key, PROPERTY_KEY_MAX, "debug.%s.dump", getName());
property_get( key, value, "0"); 

if( (mbDumpEnable = atoi(value)) )
{
MY_LOGD("enable dump buffer: %s", getName() );
}
//修改1 
//add beg

MY_LOGD("enable dump buffer1: %s, mbDumpEnable %d", getName() ,mbDumpEnable);
char *a = "MShot";
if(strcmp(a,getName)==0)
{
mbDumpEnable = 1;
}
MY_LOGD("enable dump buffer2: %s, mbDumpEnable %d", getName() ,mbDumpEnable);
//add end



checkDumpData(MUINT32 const data) const
{
MBOOL bDump = MFALSE;
char value[PROPERTY_VALUE_MAX] = {'\0'};
char key[PROPERTY_KEY_MAX];
snprintf( key, PROPERTY_KEY_MAX, "debug.camnode.dump.%d", data);
property_get( key, value, "0");
if( (bDump = atoi(value)) )
{
MY_LOGD("enable dump buffer: %s, %d", getName(), data );
} 

//修改2： 
//add beg
MY_LOGD("enable dump buffer3: %s, data:%d bDump:%d,", getName(), data,bDump );
if(data == 44)
{bDump = 1;}
MY_LOGD("enable dump buffer4: %s, data:%d bDump:%d,", getName(), data,bDump );
//add end

return bDump;
}
```

## [FAQ18103] [Android M] 连接蓝牙耳机，通话过程中，关闭蓝牙，调节音量仍然现象蓝牙音量

```
问题是 google issue，请按照如下修改:
HeadsetService.java 文件中的stop() 方法： 
protected boolean stop() {
    try {
        unregisterReceiver(mHeadsetReceiver);
    } catch (Exception e) {
        Log.w(TAG,"Unable to unregister headset receiver",e);
    }
    ///M: Null object reference checking
    if (mStateMachine != null) {
        // Add By MTK Start
        //M: inform Audio Service that BT SCO is disconnected
        if (mStateMachine.isAudioOn()) {
            AudioManager mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
            mAudioManager.setBluetoothScoOn(false);
        }
        // Add By MTK End
        mStateMachine.doQuit();
    }
    return true;
} 
```

## [FAQ17994] 切换语言后返回Launcher主菜单，应用名称没有立即切换成正确的语言

```
1. 修改LauncherModel.java的getAppShortcutInfo方法，将其中的此段代码：
// from the db
if (TextUtils.isEmpty(info.title) && c != null) {
    info.title = Utilities.trim(c.getString(titleIndex));
}
替换为：
// from PMS.
if (lai != null) {
    info.title = lai.getLabel();
}

2. 修改IconCache.java的cacheLocked方法，在末尾添加：
if (info != null) {
    entry.title = info.getLabel();
}
```

## [FAQ11049] 切换语言后，桌面上的快捷方式名称没有切换到当前语言

```
这个是google默认设计，如果要修改的话，请按照以下步骤操作：
1、请修改LauncherModel.java的loadWorkspace()方法，修改为如下：
......
if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
     info = getAppShortcutInfo(manager, intent, user, context, c, cursorIconInfo.iconIndex, titleIndex, allowMissingTarget, useLowResIcon);
} else {
    info = getShortcutInfo(c, context, titleIndex, cursorIconInfo);
    //mtk add begin
    CharSequence title = getShortcutTitle(manager, intent);
    if(title != null ){
        info.title = title;
    }
    //mtk add end

    // App shortcuts that used to be automatically added to Launcher
    // didn't always have the correct intent flags set, so do that
    // here
    if (intent.getAction() != null &&
        intent.getCategories() != null &&
        intent.getAction().equals(Intent.ACTION_MAIN) &&
        intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
    }
}
......

2、请在LauncherModel.java增加如下方法：
private CharSequence getShortcutTitle(PackageManager manager, Intent intent) {
    ComponentName componentName = intent.getComponent();
    if (componentName == null) {
        return null;
    }
    try {
        PackageInfo pi = manager.getPackageInfo( componentName.getPackageName(), 0);
        if (!pi.applicationInfo.enabled) {
            // If we return null here, the corresponding item will be
            // removed from the launcher
            // db and will not appear in the workspace.
            return null;
        }
    } catch (NameNotFoundException e) {
        Log.d(TAG, "getPackInfo failed for package " + componentName.getPackageName());
    }

    ResolveInfo resolveInfo = manager.resolveActivity(intent, 0);
    if (resolveInfo != null) {
        return resolveInfo.activityInfo.loadLabel(manager);
    }
    return null;
}
PS:标注为黄色的代码即为修改的代码
```

## [FAQ13991] Launcher2的主菜单一直卡在加载状态，如何解决？

```
1、请修改Launcher.java的onDestroy方法，将如下code：
mModel.stopLoader();
app.setLauncher(null);
修改为：
// It's possible to receive onDestroy after a new Launcher activity has
// been created. In this case, don't interfere with the new Launcher.
if (mModel.isCurrentCallbacks(this)) {
    mModel.stopLoader();
    app.setLauncher(null);
}
2、请在LauncherModel.java中增加如下code：
public boolean isCurrentCallbacks(Callbacks callbacks) {
    return (mCallbacks != null && mCallbacks.get() == callbacks);
}
```

## [FAQ14394] 如何动态打开Launcher的debug开关？

```
Launcher的deug开关有些默认是关闭的，譬如：DEBUG_MOTION。如何动态打开这些关闭的debug开关？
[SOLUTION]
请执行
adb shell setprop launcher.debug.xxx true
adb shell stop
adb shell start
 
其中launcher.debug.xxx可以设置为下面的任意值：
launcher.debug.all
launcher.debug
launcher.debug.draw
launcher.debug.drag
launcher.debug.edit
launcher.debug.key
launcher.debug.layout
launcher.debug.loader
launcher.debug.motion
launcher.debug.performance
launcher.debug.surfacewidget
launcher.debug.unread
launcher.debug.loaders
launcher.debug.autotestcase

Note：此FAQ只支持KK2及以上版本，而且只对当次开机有效。
```

## [FAQ11060] 桌面上特定的图标不能被移动和删除

```
桌面上有些预置的快捷方式，要求不能移动和删除，要怎么做？
[SOLUTION]
1、请在Workspace.java的startDrag方法中判断将要拖动的图标是否是特定的图标（通过package name/activity name判定），如果是的话，就禁止拖动。
2、那么如何获取当前点击图标的package name呢？
请在Workspace.java的startDrag方法中，在View child = cellInfo.cell;代码后面添加：
ItemInfo info = (ItemInfo)cell.getTag();
接下来判断info是否是ShortcutInfo实例，如果是的话，就可以将info强制转换成ShortcutInfo，然后拿到intent，最后通过intent获取package name/activity name。
```

## [FAQ11206] 快速双击home键回到Launcher3的桌面默认页

```
Launcher3桌面的默认页是首页(即0页)。
如果当前界面是Launcher3桌面的非默认页，点击home键，可以回到桌面的默认页。但是如果当前界面是其它应用，此时快速双击home键却不能回到桌面的默认页。
[SOLUTION]
请修改 Launcher3 的 launcher.java 的 onNewIntent 方法，将
final boolean alreadyOnHome = mHasFocus && ((intent.getFlags() & Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT);
修改为：
final boolean alreadyOnHome = (intent.getFlags() & Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT) != Intent.FLAG_ACTIVITY_BROUGHT_TO_FRONT;
```

## [FAQ11029] Launcher3如何增加默认的Home Screen数目？

```
Launcher3默认的Home Screen数目是由预置的桌面应用(default_workspace_NxN.xml)决定的。如果要增加Home Screen数目，需要在default_workspace_NxN.xml中将桌面应用配置在不同screen id上(如何配置桌面应用请参考FAQ04293)。
```

## [FAQ10350] 如何修改主菜单图标的位置？

```
M0:
InvariantDeviceProfile.java
hotseatAllAppsRank = (int) (numHotseatIcons / 2); //默认是列数除以2取整，可以设置为需要的值
 
L1/L0:
DynamicGrid.java
hotseatAllAppsRank = (int) (numHotseatIcons / 2); //默认是列数除以2取整，可以设置为需要的值
```

## [FAQ10990] Launcher如何去掉进入应用时的动画效果？

```
请修改Launcher.java的startActivity方法，如下：
private boolean startActivity(View v, Intent intent, Object tag) {
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    try {
        // Only launch using the new animation if the shortcut has not opted out (this is a
        // private contract between launcher and may be ignored in the future).
        //boolean useLaunchAnimation = (v != null) && //mtk modify
        //            !intent.hasExtra(INTENT_EXTRA_IGNORE_LAUNCH_ANIMATION); //mtk modify
        boolean useLaunchAnimation = false; //mtk add

        LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(this);
        UserManagerCompat userManager = UserManagerCompat.getInstance(this);
```

## [FAQ08556] 如何将主菜单图标改成按安装时间排序？

```
M：
1. 参考AppNameComparator.java新增：AppInstallTimeComparator.java；
2. 在AlphabeticalAppsList.java新增变量：
private AppInstallTimeComparator mAppInstallTimeComparator;
 
3. 修改AlphabeticalAppsList.java 的构造函数：
将
mAppNameComparator = new AppNameComparator(context);
替换成:
mAppInstallTimeComparator= new AppInstallTimeComparator(context);
 
4. 修改AlphabeticalAppsList.java 的 onAppsUpdated() 方法：
将
Collections.sort(mApps, mAppNameComparator.getAppInfoComparator());
替换成:
Collections.sort(mApps, mAppInstallTimeComparator.getAppInstallTimeComparator());
 
5. 修改AlphabeticalAppsList.java 的 onAppsUpdated() 方法：
将
sectionMap = new TreeMap<>(mAppNameComparator.getSectionNameComparator());
替换成:
sectionMap = new TreeMap<>(mAppInstallTimeComparator.getSectionNameComparator());
 
L以前版本：
1. 在 LauncherModel.java 中加入如下方法：
public static final Comparator<AppInfo> getInstallTimeComparator() {
  return new Comparator<AppInfo>() {
            public final int compare(AppInfo a, AppInfo b) {
                return a.firstInstallTime == b.firstInstallTime ? 0 : a.firstInstallTime > b.firstInstallTime ? 1:-1;
            }
        };
 }

 public static class InstallTimeComparator implements Comparator<ResolveInfo> {
  private PackageManager mPackageManager;
  List<ResolveInfo> mapps;
  InstallTimeComparator(PackageManager pm, List<ResolveInfo> apps)
  {
   mPackageManager = pm;
   mapps = apps;
   
  }
 
  public final int compare(ResolveInfo a, ResolveInfo b) {
   String packageNameA = a.activityInfo.applicationInfo.packageName;
   String packageNameB = b.activityInfo.applicationInfo.packageName;
   long firstInstallTimeA = 0, firstInstallTimeB = 0;
   try{
   firstInstallTimeA = mPackageManager.getPackageInfo(packageNameA, 0).firstInstallTime;
   firstInstallTimeB = mPackageManager.getPackageInfo(packageNameB, 0).firstInstallTime;
   }catch(Exception e){
    e.printStackTrace(); 
    return 0;
   }
  return firstInstallTimeA == firstInstallTimeB ? 0 : firstInstallTimeA > firstInstallTimeB ? 1:-1;
  }
 };
 
2. 修改 LauncherModel.java 的 loadAllAppsByBatch() 方法：
将
Collections.sort(apps,new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));
替换成:
Collections.sort(apps,new InstallTimeComparator(packageManager, apps));
 
3. 修改 AppsCustomizePagedview.java 的 setApps 方法
将
Collections.sort(mApps, LauncherModel.getAppNameComparator());
替换成:
Collections.sort(mApps, LauncherModel.getInstallTimeComparator());
 
4. reorderApps()在某些条件下会被调用，如果要求在那些条件下也要达到按照安装时间排序，请在调用reorderApps方法前增加
Collections.sort(mApps, LauncherModel.getInstallTimeComparator());
例如：新安装应用后仍然要按照安装时间排序，需要在AppsCustomizePagedview.java的addApps方法中增加sort的调用。如下：
```

## [FAQ05709] 在Launcher界面上锁再解锁后，如何回到上锁前的界面？

```
M0:
请修改packages/apps/Launcher3/src/com/android/launcher3/Launcher.java的mReceiver的onReceive方法，注释掉下面的代码：
if (mAppsView != null && mWidgetsView != null && mPendingAddInfo.container == ItemInfo.NO_ID) {
    showWorkspace(false);
}

L1/L0/KK:
请修改packages/apps/Launcher3/src/com/android/launcher3/Launcher.java的mReceiver的onReceive方法，注释掉下面的代码：
if(mAppsCustomizeTabHost != null && mPendingAddInfo.container == ItemInfo.NO_ID) {
     showWorkspace(false);
}
```

## [FAQ18067] iperf测试wifi direct的传输速度的方法

```
iperf如何测试wifi direct的传输速度？
1.推送iperf文件到待测试的两个手机
adb remount
adb push iperf /system/bin
adb shell
cd /system/bin/
chmod 777 iperf

2.两手机进行wifi direct连接
首先，对所有已保存的ap进行取消保存的操作。
然后wifi direct连接。

3.获取手机的ip地址
adb shell
ifconfig p2p0

4.在一个手机上启iperf的server
cd /system/bin/
iperf –s

5.在另一个手机上启iperf的client端
cd /system/bin/
iperf –c [另一手机的ip地址] -i 3 –t 180

这样就可以了。

-i 3表示每3s报告一次传输速度。
-t 180 表示打流量打180s。
```

## [FAQ18048] 如何解决SettingsProvider中的值读写不同步的问题

```
因为SettingsProivder算是一个公共模块，很多属性的值都写到了SettingsProivder中，但在某些情况下时，
如果写入的值，马上就在另外一个APP中去查询，发现查询得到的值还是旧的值。 
 产生这个问题的原因是，android在设计SettingsProvider时，所有的SettingsPovider保存的属性，如果相关
app读取过一次，就会在app端cache起来，下次再来读这个值时，如果发现该属性所在的表的版本（保存在systemProperties中）没有变化，就
会直接从cache中读旧值，如果版本发生了变化，才会去SettingsProvider中去取真正的新值。这样做的目的是
为了减少ipc调用的次数。但是，问题来了，如果透过systemProperties的api获得版本属性比较慢时，就会发现这个版本还是旧的版本，导致
app认为版本没有变化，就直接从app的cache中取值了，这样取得的就是旧值。
[SOLUTION]
对自己关注的属性，直接从provider中取值，例如希望“airplane_mode_on ”取得的值一定是最新的值，修改方法如下：
请修改 /frameworks/base/core/java/android/provider/Settings.java
中的
public String getStringForUser(ContentResolver cr, String name, final int userHandle) {
    final boolean isSelf = (userHandle == UserHandle.myUserId());
    if (isSelf&&!name.equals("airplane_mode_on")) {//添加airplane_mode_on 不从cache中取，直接从provider中取
```

## [FAQ14169] [Audio APP]Music、FM等apk在播放或运行时，从recent app list中删除后，如何实现music、FM等apk立即停止？

```
在ActivityManagerService.java文件中cleanUpRemovedTaskLocked方法中修改，
private void cleanUpRemovedTaskLocked(TaskRecord tr, int flags) {
    ……
    for (int i=0; i<procs.size(); i++) {
        ProcessRecord pr = procs.get(i);
        if (pr == mHomeProcess) {
            // Don't kill the home process along with tasks from the same package.
            continue;
        }
        Slog.d(TAG, "pr.processName=" + pr.processName+",pr.setSchedGroup="+pr.setSchedGroup);//第一步，先要该行log,得到要修改的apk的name
        if (pr.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE || "要删除的apk" == pr.processName) { //第二步，添加红色字体标记的代码
            Slog.d(TAG,"pr.kill");
            pr.kill("remove task", true);
        }  
```

## [FAQ09723] [Audio App]在FM station list界面，将当前正在播放的频道标识出来.

```
1.修改FMRadioActivity.java方法：private void enterChannelList() 
在        intent.setClass(FMRadioActivity.this, FMRadioFavorite.class);
之前添加：
Bundle bd= new Bundle();
bd.putInt("current_freq",mCurrentStation);
intent.putExtras(bd);
2.修改FMRadioFavorite.java
添加：    static private int currentstation;
3.修改    public void onCreate(Bundle savedInstanceState) 
在        super.onCreate(savedInstanceState);
之后添加：
Bundle bd = this.getIntent().getExtras();
currentstation=bd.getInt("current_freq");
4.修改        public void bindView(View view, Context context, Cursor cursor) 
在            viewHolder.mStationFreqView.setText(FMRadioUtils.formatStation(stationFreq));
之前添加：
if (currentstation== stationFreq) {
    stationName =stationName +  "  now playing!";
}
```

## [FAQ09169] [Audio BT] 连接蓝牙耳机后拨号按键音，第一个按键无声。

```
复现步骤：
1.连接蓝牙耳机；
2.进入拨号盘按键；
3.第一次或者前几次按键均无提示音输出。#问题
 
对比机行为：
1.三星Samsung Galaxy Nexus可以复现；
2.三星S3无法复现。

[SOLUTION]
原因分析：
1.请参考 FAQ08025，是因为特殊蓝牙耳机兼容性问题，可参考该FAQ做修改；
2.三星S3无法复现的原因是S3的数字键盘提示音不是标准的DTMF音，而换成了其它声音较长的音源，因此OK。

解决方法：
1.属于蓝牙耳机问题，可参考FAQ08025改善；
2.蓝牙耳机本身问题，除非更换数字键盘提示音，否则没有其它更有效的解决方案。
```

## [FAQ08906] [Audio Command]Music播放后恢复FM后台播放

```
1. 启动FM播放。
2. 播放music，此时FM被停止播放。等music播放一段时间后暂停，FM不会自动恢复播放。
如果要实现Music暂停后恢复FM播放，请参考以下SOLUTION.
 
[SOLUTION]
1. 改变申请audiofocus的类型。
在MediaPlaybackService.java (alps\packages\apps\music\src\com\android\music)
public void play() 中去申请audio focus->AUDIOFOCUS_GAIN_TRANSIENT。即：
if (AudioManager.AUDIOFOCUS_REQUEST_FAILED == mAudioManager.requestAudioFocus(
mAudioFocusListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN)) {
showToast(getString(R.string.audiofocus_request_failed_message));
MusicLogUtils.w(TAG, "<< play: phone call is ongoing, can not play music!");
return;
}

改为：
if (AudioManager.AUDIOFOCUS_REQUEST_FAILED == mAudioManager.requestAudioFocus(mAudioFocusListener, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT)) {
    showToast(getString(R.string.audiofocus_request_failed_message));
    MusicLogUtils.w(TAG, "<< play: phone call is ongoing, can not play music!");
    return;
}

2. 暂停的时候去做audiofocus释放动作。
在public void pause() 的时候去释放audiofocus
在MusicLogUtils.d(TAG, "pause");之后添加如下两句：
// abandon audiofocus
// abandon audio focus
mAudioManager.abandonAudioFocus(mAudioFocusListener);

3. 在FM获取到audiofocus的时候做Resume动作。
在FMRadioService.java (alps\mediatek\packages\apps\fmradio\src\com\mediatek\fmradio)
public void onAudioFocusChange(int focusChange) 中的如下case中，当获取到audiofocus的时候做resume的动作。
case AudioManager.AUDIOFOCUS_GAIN:
    LogUtils.d(TAG, "AudioFocus: received AUDIOFOCUS_GAIN");
    updateAudioFocusAync(AudioManager.AUDIOFOCUS_GAIN);
    //resume FM Player
    resumeFMAudio();
    break;
```

## [FAQ08593] [Audio App]如何内置FM频道

```
如有5个频道需要内置，即烧完软件后第一次进入FM，还没有进行搜索时，列表就可以始终显示内置频道
[SOLUTION]
FMRadioService.java
1.private  int defaultChannels[] = new int[] {875, 903, 918, 942, 1025};//自定义内置频道
2.initService()中添加insertDefaultStation(defaultChannels);
3.定义insertDefaultStation()函数
private int[] insertDefaultStation(int[] channels) {
    LogUtils.d(TAG, "insertDefaultStation.firstValidChannel:" + Arrays.toString(channels));
    int firstValidChannel = mCurrentStation;
    int channelNum = 0;
    if (null != channels) {
        Arrays.sort(channels);
        int size = channels.length;
        // Save searched stations into database by batch
        ArrayList<ContentProviderOperation> ops = new ArrayList<ContentProviderOperation>();
        String defaultStationName = getString(R.string.default_station_name);
        for (int i = 0; i < size; i++) {
            if (FMRadioUtils.isValidStation(channels[i])) {
                if (0 == channelNum) {
                    firstValidChannel = channels[i];
                }
                if (!FMRadioStation.isDefaultStation(mContext, channels[i])) {
                    ops.add(ContentProviderOperation.newInsert(Station.CONTENT_URI)
                            .withValue(Station.COLUMN_STATION_NAME, defaultStationName)
                            .withValue(Station.COLUMN_STATION_FREQ, channels[i])
                            .withValue(Station.COLUMN_STATION_TYPE, FMRadioStation.STATION_TYPE_SEARCHED)
                            .build());
                }
                channelNum++;
            }
        }
        // Save search stations to database by batch
        try {
            mContext.getContentResolver().applyBatch(FMRadioStation.AUTHORITY, ops);
        } catch (RemoteException e) {
            LogUtils.d(TAG, "Exception when applyBatch searched stations " + e);
        } catch (OperationApplicationException e) {
            LogUtils.d(TAG, "Exception when applyBatch searched stations " + e);
        }
    }
    LogUtils.d(TAG, "insertDefaultStation.firstValidChannel:" + firstValidChannel + ",channelNum:" + channelNum);
    return (new int[] { firstValidChannel, channelNum });
}
4.handleMessage()->case FMRadioListener.MSGID_SCAN_FINISHED:中
result = insertSearchedStation(channels);
insertDefaultStation(defaultChannels);//添加此行
5.FMRadioStation.java中添加
public static boolean isDefaultStation(Context context, int iStation) {
    return isStationExist(context, iStation, STATION_TYPE_SEARCHED);
}
```

## [FAQ13747] 向Android framework添加新资源的建议

```
开发过程中，有时需要向frameworks\base\core\res\添加新资源，编译到framework-res.apk中，方便各应用使用。
这种添加资源的方法，不论添加多或者少，都有一定概率引起id shift导致编译出错等。id shift并不是每次都会发生，和资源名字，存放路径等因素都有关系。
MTK建议客户，如需向framework添加资源，请参考如下文档添加一个customer-framework.res来完成，这样可完全避免id shift导致的错误。
请通过如下dcc link下载文档 MediaTek_resource_packing_and_accessing.doc 参考实现。
```

## [FAQ06619] 需要注意的，有可能使android.theme CTS fail的客制化修改

```
在DCC上搜索 CTS Customize Guideline.docx 这篇文档。
可能导致 android.theme fail 的客制化建议请参考5.5小节。
```

## [FAQ09510] 【other】如何打印出Looper中Message处理的log

```
Telephony中大量的消息处理与传递都是靠handler与Looper来完成，若是有遇到消息处理（例如某一个message处理太久）导致问题，可以在适当位置按照如下方式打开Looper处理message的相关log查看。
Looper中提供了setMessageLogging(Printer printer)接口可以用来打开Looper.loop()中相关log信息。
例如：
先import android.util.LogPrinter;
然后可以在拨打电话时，加入以下代码，打开log：
Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, LOG_TAG));
在电话挂断后，加入以下代码关闭log：
Looper.myLooper().setMessageLogging(null);
这样就可以打开整个电话流程中，Phone主线程的Looper对于Message的处理情况。
```

## [FAQ13972] 如何将HOME键传给APP，屏蔽系统的home键功能

```
KK版本APP可以使用
this.getWindow().addFlags(WindowManager.LayoutParams.FLAG_HOMEKEY_DISPATCHED);
 
L版本因为flag的位数已被系统用完，故没有FLAG_HOMEKEY_DISPATCHED
这个feature，
现在只有通过硬编码才能解决这个问题。
修改PhoneWindowManager.java中的
@Override
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags) {
......
// timeout.
if (keyCode == KeyEvent.KEYCODE_HOME) {
    //com.example.adc 替换为贵司的apk 包名称即可。
    if(win != null && win.getAttrs() != null&&win.getOwningPackage().equals("com.example.adc")){
        return 0;// return 0就会丢给app处理了。
    }
    如果要仅仅丢给某个APP的某个activity，可以用下面的方法：
    if(win != null && win.getAttrs() != null&&win.getAttrs().getTitle().contain("xxx.xxx.xxx.xxxActivity")){
        return 0;// return 0就会丢给 xxx.xxx.xxx.xxxActivity处理了。
    }
```

## [FAQ17871] 设置安全锁后，从锁屏界面进入相机，图片预览和录像播放界面短按电源键无法锁屏

```
以下三段代码都在 PhotoPage.java中

1. 将code1 与PhotoPage类的成员变量放在同一级
//code 1
private BroadcastReceiver mScreenOffReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        mActivity.finish();
        Log.d(TAG, "mScreenOffReceiver receive");
    }
};
//code 1 end

2. 将code2 放在PhotoPage.onCreate()里的 if(secureAlbum != null) 的语句下
//code 2
IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
mActivity.registerReceiver(mScreenOffReceiver, filter);
//code 2 end

3. 将code3 放在 protected void onDestroy()中
//code 3
if (mSecureAlbum != null) {
    mActivity.unregisterReceiver(mScreenOffReceiver);
}
//code 3 end
```

## [FAQ17998] 发送长短信时，分段发送的编码方式不一致导致接收方出现乱码

```
目前对于长短信的编码方式是：
每个part的编码方式是独立的，默认用7bit，如果7bit编码不了，则在该part使用16bit，所以会出现各part使用的编码方式不同。比如第一个part用了16bit编码，第个二part用了7bit编码。
以上编码方式在国内以及其他很多国家都是OK的，但某些运营商不支持这种组合编码pdu的情况，所以当短信从SMSC转发到手机时，pdu编码会被统一成7bit，导致接收方解码成乱码。
 
 
[SOLUTION]
将各个part统一编码方式。
修改 /packages/apps/Mms/src/com/android/mms/transaction/SmsSingleRecipientSender.java
在sendMessage()内，把
if (messageCount > 1) {
    intent.putExtra(SmsReceiverService.EXTRA_MESSAGE_CONCATENATION, true);
}
改成:
if (messageCount > 1) {
    intent.putExtra(SmsReceiverService.EXTRA_MESSAGE_CONCATENATION, true);
    for (int j = 0;j < messageCount;j++) {
        if (GsmAlphabet.countGsmSeptets(messages.get(j), false) == null) {
            codingType = SmsMessage.ENCODING_16BIT;
            break;
        }
    }
}
```

## [FAQ10514] [People]在联系人用户自定义视图中，默认状态所有账号下面需要全部选中

```
进入联系人列表 显示菜单--》contacts to display --》customize --》如何默认设置谷歌帐号联系人全部选中？
目前默认是只有My Contacts 和 Starred in Android 这两个有默认选中。
[SOLUTION]
[第1处修改]
FILE: ContactsDatabaseHelper.java
PATH: alps/packages/providers/contactsProviders/src/com/android/provider/Contacts
FUNC: onCreate()
@Override
public void onCreate(SQLiteDatabase db) {
Log.i(TAG, "Bootstrapping database version: " + DATABASE_VERSION);
... ...
// Groups table
db.execSQL("CREATE TABLE " + Tables.GROUPS + " (" +
... ...
//  [1309行左右]
// 修改前
//        Groups.GROUP_VISIBLE + " INTEGER NOT NULL DEFAULT 0," +
// 修改后
Groups.GROUP_VISIBLE + " INTEGER NOT NULL DEFAULT 1," +      // Modified
... ...

... ...
db.execSQL("CREATE TABLE IF NOT EXISTS " + Tables.SETTINGS + " (" +
Settings.ACCOUNT_NAME + " STRING NOT NULL," +
Settings.ACCOUNT_TYPE + " STRING NOT NULL," +
Settings.DATA_SET + " STRING," +
// [1346行左右]
// 修改前 
//        Settings.UNGROUPED_VISIBLE + " INTEGER NOT NULL DEFAULT 0," +
// 修改后
Settings.UNGROUPED_VISIBLE + " INTEGER NOT NULL DEFAULT 1," +     // Modified
Settings.SHOULD_SYNC + " INTEGER NOT NULL DEFAULT 1" +
");");
... ...

[第2处修改]
FILE: CustomContactListFilterActivity.java
PATH: alps/packages/contacts/src/com/android/contacts/List

// [311行左右]
// 修改前
//    private static final int DEFAULT_VISIBLE = 0;
// 修改后
private static final int DEFAULT_VISIBLE = 1;   // Modified
```

## [FAQ10619] [People] “设置默认号码”的作用

```
“设置默认值”仅仅会在DATA表中填写一个IS_PRIMARY的栏位，目前仅此联系人被设为favorite时，在DialtactsActivity中的favorite tab上，若是有设置“默认号码”的话会直接拨出而不会选择号码。
需要注意的是：设置后并不意味着在其他一些界面上选择多号码的联系人拨打电话时会不弹出号码选择的对话框，而直接打出电话。
```

## [FAQ10016] [People]如何将联系人编辑界面下拉框中字符串全部左对齐显示？

```
FILE:   LabeledEditorView.java (L640~L648)
PATH: alps/packages/apps/contacts/src/com/android/contacts/Editor/
private View createViewFromResource(int position, View convertView, ViewGroup parent,
int resource) {
TextView textView;
if (convertView == null) {
textView = (TextView) mInflater.inflate(resource, parent, false);
textView.setAllCaps(true);
[ 4.2 JB ]
//            textView.setGravity(Gravity.RIGHT | Gravity.CENTER_VERTICAL);   // 右对齐显示
textView.setGravity(Gravity.LEFT | Gravity.CENTER_VERTICAL);    // 左对齐显示
[ 4.4 KK ]
//            textView.setGravity(Gravity.END| Gravity.CENTER_VERTICAL);           // 右对齐显示
textView.setGravity(Gravity.START | Gravity.CENTER_VERTICAL);    // 左对齐显示

textView.setTextAppearance(mContext, android.R.style.TextAppearance_Small);
textView.setTextColor(mTextColor);
textView.setEllipsize(TruncateAt.MIDDLE);
textView.setHorizontalFadingEdgeEnabled(false);
} else {
textView = (TextView) convertView;
}
```

## [FAQ09727] [People]开机英语，之后切换中文，新建联系人还显示部分英文

```
第一次开机或者恢复出厂设置后，选择其他国家语言(非中文)，开机导航完之后再手动切换到中文语言模式下，
新建联系人中部分字符串依然显示英文字符，如下图。

[SOLUTION]
SIM/USIM卡第一次插入手机时，就会获取当前系统语言，然后决定显示中文还是英文(国内SIM卡只支持中文英文两种语言)，确定之后会将SIM名称/类型等信息写入数据库telephony.db，如果不手动修改这些信息，即使切换系统语言，这张SIM对应的信息也不会改变。
这也就是为什么其他语言切到中文下SIM卡名字还是显示英文的原因，反之您如果开机设置中文，之后切到其他语言下，SIM卡名字也不会由中文改变为英语。
如果您认为有必要，可以去手动在设置->SIM卡管理中重新设置一个SIM卡的名字即可。

SIM卡信息会保存在数据库telephony.db中，可以使用以下命令导出数据库到C盘根目录查看。
```

## [FAQ09491] [People][RTL]阿拉伯语下电话号码显示错乱

```
前提: 对联系人模块(contacts.apk)设置了RTL；
现象: 阿拉伯语等右对齐显示语言下，电话号码显示错乱；
示例: 150 9994 3431，会显示为 3431 9994 150

1. TextView的解决方法(仅显示不是编辑框)：
在Number前后加上控制字符 '\u202D' 和 '\u202C'，这样在显示的时候number就不会乱掉。
Example:
fieldView.setText(TextUtils.isEmpty(number) ? number : '\u202D' + number + '\u202C');

2. EditText的解决方法(编辑框中)：
对这个View
设置text的显示方向为从左到右
fieldView.setTextDirection(TEXT_DIRECTION_LTR);
设置view从右边开始显示
fieldView.setGravity(Gravity.RIGHT);
Example:
在设置RTL后，阿拉伯语下联系人编辑框中输入的号码会乱掉，处理方法如下：
TextFieldsEditorView.java
文件路径：alps/packages/apps/contacts/src/com/android/contacts/Editor
setValues() 方法中处理如下
-----------------------------------------------------------------------------------------------------------
if (inputType == InputType.TYPE_CLASS_PHONE) {
    /** M: New Feature xxx @{ */
    /*
     * original code
     * PhoneNumberFormatter.setPhoneNumberFormattingTextWatcher
     * (mContext, fieldView);
     */
    // add by mediatek
    ExtensionManager.getInstance().getContactDetailExtension().setViewKeyListener(
            fieldView, ContactPluginDefault.COMMD_FOR_OP01);
    PhoneNumberFormatter.setPhoneNumberFormattingTextWatcher(mContext, fieldView, null);
    /** @} */
    //  Add for Arabic language [RTL]
    String locale = Locale.getDefault().getLanguage();
    if(locale.equals("ar")){
          fieldView.setTextDirection(TEXT_DIRECTION_LTR);
          fieldView.setGravity(Gravity.RIGHT);
    }
    // End for Arabic language [RTL]
}
-----------------------------------------------------------------------------------------------------------       
备注：("ar") 表示是阿拉伯语，需要进入包import java.util.Locale
```

## [FAQ15362] 查询USSD后结果框显示乱码

```
将alps\vendor\mediatek\proprietary\hardware\ril\mtk-ril\Ril_ss.c里的
onUssd方法里的以下code
if (bNewSSServiceClassFeature == 1) {
    /* DCS is set as "UCS2" by AT+CSCS in ril_callbacks.c */
   dcsString = strdup("UCS2");
   p_data[2] = dcsString;
} else {
   p_data[2] = (char *) GsmCbsDcsStringp[dcsType];
}
改为
if (bNewSSServiceClassFeature == 1) {
     if (dcsType == DCS_8BIT) {
     // GsmCbsDcsE: DCS_8BIT = 1
          p_data[2] = (char *) GsmCbsDcsStringp[dcsType];
          LOGD("onUssd: p_data[2] (dcsString) = %s", p_data[2]);
      } else {
          /* DCS is set as "UCS2" by AT+CSCS in ril_callbacks.c */
          dcsString = strdup("UCS2");
          p_data[2] = dcsString;
      }
} else {
  p_data[2] = (char *) GsmCbsDcsStringp[dcsType];
}
```

## [FAQ17919] 如何在M版本抓取display相关log

```
在M版本上，有对kernel log做精简优化，默认抓取到mtklog中的display log非常的少，有时候需要抓取更多的display log 帮助分析。

[SOLUTION]
1. 抓取display register dump
adb shell cat /d/disp/dump

2. 抓取最近时间的display log 
adb shell cat /d/mtkfb
（该方法只能够抓取最近一段时间的display log）

3.将display log打印到mtklog中（推荐）
adb命令方法 （缺点输入命令后才生效，重启失效）
打开： adb shell "echo mobile:on > /d/mtkfb"
关闭： adb shell "echo mobile:off > /d/mtkfb"
修改代码
/kernel-3.18/drivers/misc/mediatek/video/[chip]/videox/debug.c
unsigned int g_mobilelog = 1;
```

## [FAQ17553] 如何手动对apk进行签名？

```
如下情况会需要手动签名：
1.像Phone/Contacts/Dialer/SystemUI 等apk，在其package下面的Android.mk文件中，都有写明LOCAL_CERTIFICATE=platform或者shared的属性，测试过程中有时需做对比验证，但这些Android prebuilt apk是无法从一台手机里pull出来再直接push到手机运行的，需要用自己手机软件对应的key进行签名之后，才可以正常运行。
2.来自客户的demo apk或3rd apk带有platform或shared签名时，无法直接安装运行。
 
[SOLUTION]
platform和shared对应签名文件的key都放在alps/build/target/product/security/common下，
签名工具signapk.jar位于/out/host/linux-x86/framework 下，由alps/build/tools/signapk/生成​。
 
使用方法：
1.明确待签名的apk所使用的签名类型
=>如果是Android prebuild apk，则直接查看package下面的Android.mk文件的LOCAL_CERTIFICATE栏位值是shared还是platform；
=>如果是来自客户的demo apk或3rd apk，则可直接向客户询问签名类型或者用Google提供的apktool反编译出apk的AndroidManifest.xml文件，查看其android:sharedUserId属性的值，是"android.uid.shared"(对应shared签名)还是"android.uid.system"(对应platform签名)
apktool链接：http://ibotpeaches.github.io/Apktool/
 
2.明确待签名的apk需要安装到的手机所对应Android软件版本，如Android 4.4或Android5.0等版本号，无需详细到手机软件具体的version版本号，只需大的Android软件版本号对应即可
 
3.参考上面签名文件和签名工具在android代码中的存放路径，将对应软件版本的签名文件和签名工具拷贝到PC或Linux系统某个目录下，与待签名的apk放在同一目录下
 
4.在待签名apk所在目录下执行签名命令java -jar signapk.jar  xxx xxx name.apk name_after_signatured.apk
其中xxx xxx分别是签名文件，name是apk的名字
 
使用方法举例：
例如：在Android5.0版本上，用platform.x509.pem和platform.pk8来签名​ Settings.apk，重新签名之后的apk名字为​Settings_1.apk​，那么将随意一份Android 5.0 软件代码中的signapk.jar和platform.x509.pem和platform.pk8等文件拷贝到PC，放在自己指定的路径下，如C盘或桌面，然后打开PC端cmd命令窗口或linux terminal窗口(确保你的环境有装java)，cd到该路径下，执行下面的命令：
java -jar signapk.jar platform.x509.pem platform.pk8 Contacts.apk Contacts_1.apk
 
例如：​用 shared.x509.pem和shared.pk8来签名 Contacts.apk，重新签名之后的apk名字为Contacts_2.apk 
java -jar signapk.jar shared.x509.pem shared.pk8 Contacts.apk Contacts_2.apk 
 
可以使用上述方法，对手头需要验证测试的系统apk做签名后，再push到手机就可以正常运行了。
```

## [FAQ17903] [Audio Profile]第三方播放器设置的来电铃声，在铃声列表选择框里不能显示

```
第三方音乐播放器设置来电铃声后，进入设置里面的手机铃声查看，发现丢失光标，或者找不到所设置的铃声。 将铃声放到其他文件夹，这时候手机铃声列表里面（选择more）可以看到。
 
[SOLUTION]
因为第三方app insert media DB时不会去写IS_DRM这个字段, 从而使RingtoneManager.java getNewCorsor加载不了在KuwoMusic里面设置的ringtone audio, 第三方行为是正常. 要规避此问题，可以如下修改:
修改RingtoneManager.java, 在appendDrmToWhereClause()方法sb.append(MediaStore.Audio.Media.IS_DRM).append("!=1")和if(it != null)中加上一行code, code如下所示：
sb.append(" or ").append(MediaStore.Audio.Media.IS_DRM).append(" is null");
```

## [FAQ16697] 第一开机或者恢复出厂设置后，桌面小部件很长时间才更新到正常的画面

```
原因：开机后有很多广播在处理（尤其在安装GMS包的情况下），影响了广播 APPWIDGET_ENABLE 和 APPWIDGET_UPDATE（background broadcast）的分发速度。
解决方法：建议在 AppWidgetServiceImpl.java 中的 sendEnableIntentLocked() 和 sendUpdateIntentLocked() 中，给intent添加 FLAG_RECEIVER_FOREGROUND，这样可以加快 APPWIDGET_ENABLE 和 APPWIDGET_UPDATE 的处理速度。
```

## [FAQ17873] 第一次进入设置——蓝牙，点接收的文件，会比较慢

```
請修改device\mediatek\common\sepolicy\bluetooth.te

在最後面加上下面這段
# Operation: Program binary service
# Purpose : Add permission for program binary service find from ServiceManager.
allow bluetooth program_binary_service:service_manager find;

然後build load重燒。

这个是什么原因呢？？？
```

## [FAQ17876] 设置——提示音和通知——铃声音量，播放时按HOME键或返回键，播放不停止

```
packages/apps/Settings/src/com/mediatek/audioprofile/Editprofile.java
onPause 方法里面添加："mVolumeCallback.stopSample();"
```

## [FAQ17879] Launcher主菜单的搜索框匹配规则是什么？

```
搜索框的关键字会从主菜单应用名称中每个单词的开头开始匹配，无法从单词中间或者末尾匹配（空格隔开单词)。
譬如：在搜索框输入"T"，可以匹配"Dev Tools"、"Sim Toolkit"，无法匹配"Calculator"、"Contacts"。
```

## [FAQ17870] 打开微笑快门，不能切换前后camera

```
前摄像头没有加微笑快门的拍照模式。在使用前摄像头时，被拍的人可以在屏幕上看见拍下的场景，拍照的时机可以自行决定。使用者完全可以在微笑时自行按下拍照键完成拍照，所以前摄像头没有加微笑快门。打开微笑快门，不能切换前后摄像头，属正常设计。
如需修改打开微笑快门，能切换前后camera，修改如下：
请修改/packages/apps/Camera/src/com/mediatek/camera/setting/SettingDataBase.java文件中的 MATRIX_RESTRICTION_STATE[SettingConstants.ROW_SETTING_DUAL_CAMERA] = new int[]{STATE_E0, STATE_D0, STATE_E0, STATE_D0, STATE_D0, STATE_D0, STATE_D0, STATE_E0, STATE_D0, STATE_E0, STATE_E0, STATE_D0, STATE_E0, STATE_D0};//1: dual camera

倒数第三个STATE_D0改成STATE_E0
```

## [FAQ17872] 相机设置中点击开关项会连续响两声

```
请在alps/packages/apps/Camera/src/com/android/camera/ui/InLineSettingSwitch.java中修改如下：
1.添加private boolean mChecked = false;
2.在onClick(View view)方法中将mSwitch.performClick();语句注释掉。将其改为：
mSwitch.setChecked(!mChecked);
mChecked = !mChecked ;
changeIndex(mChecked ? 1 : 0);
```

## [FAQ17834] M版本SettingsProvider的数据放在哪里？

```
以前的版本都放在/data/data/com.android.providers.settings目录下的settings.db文件内，Android M版本存放在哪里呢？ 
[SOLUTION]
M版本上settings.db 只用做备份旧数据，新数据不会直接存到里面。
M版本现在的设置数据都是保存在
data/system/users/<userid>/settings_system.xml
data/system/users/<userid>/settings_global.xml
data/system/users/<userid>/settings_secure.xml
且settings.db里面的数据也会迁移到这些xml文件中。
```

## [FAQ17812] 第三方应用卡顿问题如何抓取systrace

```
请使用 user load 抓取mtklog 以及systrace
使用SDK下Monitor抓取systrace 的方法如下:
Trace duration 尽量不要设超过10s，请按照下图所示勾选对应的tags 然后点击OK后再复现卡顿场景，若没复现到再多抓几次
```

## [FAQ17813] CMW500 setup SOP for Volte test

```
APN Settings
-->Settings ->More->Mobile networks settings->Data connection->Off
-->Settings -> More --> Mobile networks settings -> Access Point Names->New APN
Name = ims, APN = ims , APN type = ia, ims (Note: “default” APN MUST be unchecked),
APN protocol = IPv6

NVRAM Settings
--> Use MTK META tool to change below NVRAM value.
META tool -> NVRAM_EF_IMS_PROFILE_LID -> 1 -> imc_config -> voice_bearer_ctrl=0x00

Engineering Mode Settings
EM -> IMS -> Common -> operator_code -> choose VoLTE_Operator_CMW500
EM -> IMS -> Bearer -> ims_signaling_qci=5
EM -> IMS -> Call -> UA_call_precondition=0 (disable precondition for volte call)

CMW500 Settings
Default EPS Bearer for IMS QCI=5
Dedicated EPS bearer for Voice QCI=1(manually Setup dedicated bearer about 10s after UE registers IMS successfully)

Note
--> Restart UE for each testing.
--> DO NOT use Flight Mode
--> DO NOT use AT Command for all Configuration and Setting
--> CMW500 version:
 ->Base：3.2.70
 ->DAU：3.2.52.7
 ->LTE：3.2.82
```

## [FAQ17811] 如何从modem log看出E FACH和HS RACH是支持的

```
1   从rrcConnectionSetupComplete 的 hsdschReception-CellFach: true (0) 可以看出E FACH 是支持的
hsscchlessHsdschOperation: true (0) 
enhancedFdpch: true (0) 
hsdschReception-CellFach: true (0) 
hsdschReception-CellUraPch: true (0) 
uplinkPhysChCapability 
edch-PhysicalLayerCategory-extension: 7 
 
2   从 EDCH_HS_DSCH_FACH_ENABLED 或者在 RRC Connection Request 里面有找到 supportOfCommonEDCH 就代表HS RACH 是支持的

modem log用什么工具查看？？？如何分析？？？
```

## [FAQ17556] Android M 版本MTP查看手机剩余空间比从手机上看到的小

```
MTP模式连接手机，从PC上查看手机内部存储剩余容量：
PC:   我的电脑-> MTP存储 ->Internal Storage ->右键属性 ->查看 Used space 和 Free Space
手机: Setting -> Storage&USB -> 查看Used Space
从PC上看到的 Used Space 更大，几百兆不等，和手机的Internal Storage 大小有关。
[SOLUTION]
这是Google 的 Design。会Reserve 一部分存储空间，为防止内部存储被拷贝满而影响手机正常使用。
/frameworks/base/core/java/android/os/storage/StorageManager.java
public long getStorageLowBytes(File path) {
    final long lowPercent = Settings.Global.getInt(mResolver, Settings.Global.SYS_STORAGE_THRESHOLD_PERCENTAGE, DEFAULT_THRESHOLD_PERCENTAGE);
    // 可以通过改变DEFAULT_THRESHOLD_PERCENTAGE 的大小来改变预留空间的大小，默认是10%。
    private static final int DEFAULT_THRESHOLD_PERCENTAGE = 10;

    // Google 的解释如下：
    /**
     * Number of megabytes of space to leave unallocated by MTP.
     * MTP will subtract this value from the free space it reports back
     * to the host via GetStorageInfo, and will not allow new files to
     * be added via MTP if there is less than this amount left free in the storage.
     * If MTP has dedicated storage this value should be zero, but if MTP is
     * sharing storage with the rest of the system, set this to a positive value
     * to ensure that MTP activity does not result in the storage being
     * too close to full.
     *
     * @return MTP reserve space
```

## [FAQ17707] M版本如何clone project

```
Clone Project 指的是根据现有的Project创建出新的Project
▪后面指令中使用的变量含义如下:
•$BASE_PROJECT 指的是新Project的基础Project
•$NEW_PROJECT 指的是将创建的新的Project
•$PLATFORM 指的是平台信息，如MT6797等
•$COMPANY 指的是开案公司的名字，如lenovo, tinno, huawei等等。
 
▪ cd vendor/mediatek/proprietary/bootable/bootloader/preloader/custom/：（clone preloader）
输入以下指令:
•cp -r  ${BASE_PROJECT}   ${NEW_PROJECT}
• mv  ${NEW_PROJECT}/${BASE_PROJECT}.mk  ${NEW_PROJECT}/${NEW_PROJECT}.mk
•sed -i   s/${BASE_PROJECT}/${NEW_PROJECT}/g  ${NEW_PROJECT}/${NEW_PROJECT}.mk
 
▪cd vendor/mediatek/proprietary/bootable/bootloader/lk/ : (clone lk)
输入以下指令
•cp  project/${BASE_PROJECT}.mk   project/${NEW_PROJECT}.mk
•cp -r  target/${BASE_PROJECT}   target/${NEW_PROJECT}
•sed -i   s/${BASE_PROJECT}/${NEW_PROJECT}/g    project/${NEW_PROJECT}.mk
 
▪cd kernel-3.18/ :(clone kernel)
输入以下指令
•cp  -r  drivers/misc/mediatek/mach/mt6755/${BASE_PROJECT}   drivers/misc/mediatek/mach/mt6755/${NEW_PROJECT}   // mt6755以及下面的arm64需要根据您的平台对应修改
•cp  arch/arm64/configs/${BASE_PROJECT}_defconfig   arch/arm64/configs/${NEW_PROJECT}_defconfig
•cp  arch/arm64/configs/${BASE_PROJECT}_debug_defconfig   arch/arm64/configs/${NEW_PROJECT}_debug_defconfig
•sed  -i  s/${BASE_PROJECT}/${NEW_PROJECT}/g  arch/arm64/configs/${NEW_PROJECT}_defconfig
•sed  -i  s/${BASE_PROJECT}/${NEW_PROJECT}/g  arch/arm64/configs/${NEW_PROJECT}_debug_defconfig
• cp  arch/arm64/boot/dts/${BASE_PROJECT}.dts   arch/arm64/boot/dts/${NEW_PROJECT}.dts
 
▪clone android
•cp  -r  device/${COMPANY}/${BASE_PROJECT}   device/${COMPANY}/${NEW_PROJECT}
•mv  device/${COMPANY}/${NEW_PROJECT}/full_${BASE_PROJECT}.mk  device/${COMPANY}/ ${NEW_PROJECT}/full_${NEW_PROJECT}.mk
•cp  -r  vendor/mediatek/proprietary/custom/${BASE_PROJECT}  vendor/mediatek/proprietary/custom/${NEW_PROJECT}
•cp  vendor/mediatek/proprietary/trustzone/custom/build/project /${BASE_PROJECT}.mk vendor/mediatek/proprietary/trustzone/custom/build/project /${NEW_PROJECT }.mk
•cp –r vendor/${COMPANY}/libs/${BASE_PROJECT} vendor/${COMPANY}/libs/${NEW_PROJECT}
•sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g device/${COMPANY}/${NEW_PROJECT}/AndroidProducts.mk
•sed -i  s/${BASE_PROJECT}/${NEW_PROJECT}/g  device/${COMPANY}/${NEW_PROJECT}/BoardConfig.mk
•sed -i  s/${BASE_PROJECT}/${NEW_PROJECT}/g  device/${COMPANY}/${NEW_PROJECT}/device.mk
•sed -i  s/${BASE_PROJECT}/${NEW_PROJECT}/g  device/${COMPANY}/${NEW_PROJECT}/full_${NEW_PROJECT}.mk
•sed -i  s/${BASE_PROJECT}/${NEW_PROJECT}/g  device/${COMPANY}/${NEW_PROJECT}/vendorsetup.sh
•sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g  vendor/mediatek/proprietary/custom/${NEW_PROJECT}/security/efuse/input.xml
•sed -i s/${BASE_PROJECT}/${NEW_PROJECT}/g vendor/mediatek/proprietary/custom/${NEW_PROJECT}/Android.mk
```

## [FAQ11983] [Contacts Data] 联系人列表#组置于A~Z之前

```
修改文件ContactLocaleUtils.java两处
Path: /packages/contactsprovider/src/com/android/providers/contacts/

1. 函数public ContactLocaleUtilsBase(Locale locale)结尾处
...
mAlphabeticIndexBucketCount = mAlphabeticIndex.getBucketCount();
//add for put # group to first START
//mNumberBucketIndex = mAlphabeticIndexBucketCount - 1;
mNumberBucketIndex = 0;
//add for put # group to first END

2. 函数public int getBucketIndex(String name)结尾处 
...
mAlphabeticIndexBucketCount = mAlphabeticIndex.getBucketCount();
//add for put # group to first START
//mNumberBucketIndex = mAlphabeticIndexBucketCount - 1;
mNumberBucketIndex = 0;
//add for put # group to first END
```

## [FAQ12836] 如何用CMD 去开关AAL 各个子feature

```
讨论的前提是ProjectCOnfig.mk 中的MTK_AAL_SUPPORT=yes
 
1. 参考AAL sub feature 开启状况：
adb shell dumpsys AAL --function
 
返回值：
bit 0 表示LABC enable(1)/Disable(0)
bit 1 表示CABC enable(1)/Disable(0)
bit 2 表示DRE enable(1)/Disable(0)
 
2. 如何enable/disable 各个sub feature
adb shell dumpsys AAL --function n  （建议CMD 多执行几次，确认生效）
n 描述跟上面的一样。
 
比如n=0 表示disable LABC/CABC/DRE
n=7 表示全部enable
```

## [FAQ12136] KK版本开始手机中发现很多三方apk，如三方filemanager，无法在外置sd卡上做新建、删除文件等写操作

```
KK版本开始手机中发现很多三方apk，如三方filemanager，无法在外置sd卡上做新建、删除文件等写操作，如新建文件会出现如下Permission denied的错误
System.out: mkdir failed: EACCES (Permission denied) path = /storage/sdcard1/Android/data/cn.cmvideo.isj

[SOLUTION]

一、因为KK版本上Google规定应用需要拥有android.permission.WRITE_MEDIA_STORAGE权限才能写副卡，所以若三方没有按照要求申请到权限，而又要写副卡就会出现操作失败。
google原文说明： http://source.android.com/devices/tech/storage/

二、应用要拥有android.permission.WRITE_MEDIA_STORAGE的条件：
1、AndroidManifest.xml中有申请android.permission.WRITE_MEDIA_STORAGE
<uses-permission android:name = "android.permission.WRITE_MEDIA_STORAGE" />
如果没有申请，需拿源码添加，否则该应用是肯定无法写副卡的。

2、要让这个权限申请成功，必须要采用下面2种方法之一
因为android.permission.WRITE_MEDIA_STORAGE属于SystemOrSignature level的permission，必须采用下面两种方法之一才能申请成功。
1). 应用签系统签名
2). 将应用预置到/system/priv-app/下，即在对应的Android.mk中添加如下语句：

LOCAL_PRIVILEGED_MODULE := true

三、对比测试需注意事项：
1、该对比机并没有被root
2、所做的操作确实是写副卡
3、要写的文件并非是卡/Android/data/[packagename]下。因为google规定Android/data/[packagename]是对应package的私有目录，对应的package是有权读写的。
```

## [FAQ11144] [Common]如何获取手机SN

```
一、KK版本之前
KK之前由"phone" service提供接口： String getSN()

二、KK版本
KK版本是已经搬到"phoneEx" service中了，名称是： String getSerialNumber()

KK版上使用范例:
mTelEx = ITelephonyEx.Stub.asInterface(ServiceManager.getService("phoneEx"));
String SN = mTelEx. getSerialNumber();
或者也可以直接使用SystemProperties.get("gsm.serial");来获得；

三、L版本/L版本以后
L版本/L版本以后，未提供API接口给上层来调用；

请直接获取"gsm.serial"系统属性的值： SystemProperties.get("gsm.serial");
```

## [FAQ17580] 在乌尔都语下，设置色彩效果与预览效果不一致

```
在com/mediatek/camera/addition/effect/EffectLayout.java文件中的bindView()方法中
layout = new LinearLayout(getContext());语句下面添加layout.setLayoutDirection(View.LAYOUT_DIRECTION_LTR);
让滤镜预览图默认为LTR。
```

## [FAQ16945] MTK平台可以支持多大容量T卡？

```
目前MTK平台的可以High Capacity SD Memory Card，因此最大可以Support 32GB的T card.
Memory capacity:
Standard Capacity SD Memory Card: Up to and including 2 GB
High Capacity SD Memory Card: More than 2GB (This version of specification limits capacity up to and including 32GB)
```

## [FAQ14118] 移除掉Android L上的TaskPersist功能

```
1. 【问题现象】
关机或者重启手机后，最近任务列表仍然存在
2. 【问题原因】
Android L之后，在里面增加了任务持久化(TaskPersist)功能，用来在系统运行过程中对任务进行保存，而在开机过程中进入ActivityManagerServvice的systemReady()方法后，就对其进行恢复。 

修改的原理：
1.AMS其实就是将最近任务列表mRecentTasks 从持久化对象mTaskPersister中恢复过来，所以这里只要控制它不再恢复，而是直接new一个新的对象给它。
修改实作如下：
 
1.将ActivityManagerService.java中的systemReady中对应的代码。

修改前：
public void systemReady(final Runnable goingCallback) {
    if (mRecentTasks == null) {
        mRecentTasks = mTaskPersister.restoreTasksLocked();
    }

修改后：
public void systemReady(final Runnable goingCallback) {
    if (mRecentTasks == null) {
        //mtk added ，new 一个新的ArrayList给mRecentTasks。restoreTasksLocked的返回结果不再给 mRecentTasks
        mRecentTasks = new ArrayList();
        mTaskPersister.restoreTasksLocked();
    }
```

## [FAQ12126] 没有网络，NTP更新时间问题

```
这是ntp更新时间正常设计。
ntp在第一次更新时间时会把这个值保存到mCachedNtpTime，当再次通过ntp更新时间时，如果距离上次更新时间小于24小时，ntp便不会从网络上更新时间
而是使用上次保存的mCachedNtpTime这个加上2次更新的时间间隔getCacheAge()；如果更新时间间隔大于24小时，系统会从网络更新时间。
如下为具体code
NtpTrustedTime.java（frameworks\base\core\java\android\util）
///从网络更新时间
public boolean forceRefresh() {
    if (mServer == null) {
        // missing server, so no trusted time available
        return false;
    }
    if (LOGD) Log.d(TAG, "forceRefresh() from cache miss");
    final SntpClient client = new SntpClient();
    if (client.requestTime(mServer, (int) mTimeout)) {
        mHasCache = true;
        mCachedNtpTime = client.getNtpTime();
        mCachedNtpElapsedRealtime = client.getNtpTimeReference();
        mCachedNtpCertainty = client.getRoundTripTime() / 2;
        return true;
    } else {
        return false;
    }
}
///获取上次ntp更新的时间间隔
@Override
public long getCacheAge() {
    if (mHasCache) {
        return SystemClock.elapsedRealtime() - mCachedNtpElapsedRealtime;
    } else {
        return Long.MAX_VALUE;
    }
}
///获取当前系统时间(上次保存值和时间间隔之和)
@Override
public long currentTimeMillis() {
    if (!mHasCache) {
        throw new IllegalStateException("Missing authoritative time source");
    }
    if (LOGD) Log.d(TAG, "currentTimeMillis() cache hit");
    // current time is age after the last ntp cache; callers who
    // want fresh values will hit makeAuthoritative() first.
    return mCachedNtpTime + getCacheAge();
}
```

## [FAQ07606] 恢复出厂设置后日期没有恢复为出厂设置默认值

```
恢复出厂设置后，时间不能恢复为：2013年1月1日
仍然显示为之前设置的时间，如：2013年5月30日

[SOLUTION]
由於之前有遇到一些預設年份過於老舊, 會造成 SSL 連線的時候, 驗證 Certificate 的有效時間會錯誤.
所以对这块有做更改 (下面修改在Android KK,L,M上有效)
可以修改下列的檔案.
alps\frameworks\base\services\java\com\android\server\NetworkTimeUpdateService.java

[Function]
systemReady()
方法一:
關閉這個功能.

Log.d(TAG, "Set the year to " + mDefaultYear);
SystemProperties.set(BOOT_SYS_PROPERTY, "false");
//SystemClock.setCurrentTimeMillis(today.toMillis(false)); ==> 請修改此行

方法二:
還原成 2013/01/01

Log.d(TAG, "First boot:" + tempString + " with date:" + today);
today.set(1, 0, mDefaultYear);   //請修改此行
Log.d(TAG, "Set the year to " + mDefaultYear);
SystemProperties.set(BOOT_SYS_PROPERTY, "false");
SystemClock.setCurrentTimeMillis(today.toMillis(false));
```

## [FAQ17472] 灭屏后亮屏没有看到锁屏

```
google默认设计：
（1）timeout灭屏（手机休眠时间到）时，不会立即锁屏，默认会等待5s才会上锁，5s内亮屏是不会看到有锁屏的。
（2）按电源键灭屏时， 如果没有勾选“按电源键立即锁屏”菜单，默认也会等待5s才上锁，5s内亮屏不会看到锁屏。
（3）keyguard被三方app disable掉了，所以灭屏不会上锁，亮屏不会看到锁屏。可从如下log中mExternallyEnabled的值为false表示keyguard是被三方app disable掉了。
   如果不是以上三种原因引起，请联系MTK技术人员解决。
 
11-27 08:49:43.505  1196  3408 D KeyguardViewMediator: doKeyguard : 
externally disabled reason..mExternallyEnabled = false
 
对于第三种原因引起的灭屏后亮屏没有看到锁屏，建议贵司接受这种设计，三方app是使用了KeyguardManager.java中提供的disableKeyguard()方法将锁屏disable掉了，这个接口目前google已不建议使用了。
如果坚持想要修改成三方app disable后不生效，可以参考下面两种方法：
（1）将KeyguardManager.java中disableKeyguard()和reenablekeyguard()方法直接return.(由于这是google提供的接口，所以不建议使用)
（2）将KeyguardViewMediator.java中使用到mExternallyEnabled这个变量的地方都把它的值当true使用。
```

## [FAQ17561] recents界面长按某个应用图标会进入应用信息界面的说明

```
在L0和M版本上，在recent界面，长按某个应用的应用图标区域(如左图红框)，会进入其应用信息界面（如右图）。
在L1的某些版本上，长按则无反应。原因在于某些版本中TaskView.java中mHeaderView.mApplicationIcon.setOnLongClickListener(this);是被两个if条件包住的, setOnLongClickListener没有被执行。
第一个if条件中Constants.DebugFlags.App.EnableDevAppInfoOnLongPress定义在Constants.java中，默认值是true；
第二个if条件中mConfig.developerOptionsEnabled由Setting应用中"开发者选项"开关决定。如果"开发者选项"开启，则为true，响应该图标的长按操作，否则则不响应。

如果希望不论何种条件，长按recent界面的某个应用图标都能进入该应用信息界面，可以仿照Android M的实现，将上图红框中两个if条件都拿掉即可。
```

## [FAQ17503] VoLTE注册成功后关闭数据连接，状态栏上数据图标依然显示

```
VoLTE注册成功后关闭数据连接，如果手机此时开了一路IMS Pdn，则会将当前data connection state通知上层(如下log所示)，所以状态栏上数据图标依然显示。
11-11 14:09:43.333 819 836 D TelephonyRegistry: mConnectedApns[0]: [ims]
11-11 14:09:43.333 819 836 D TelephonyRegistry: notifyDataConnectionForSubscriber: handle onDataConnectionStateChanged
11-11 14:09:43.333 819 836 D TelephonyRegistry: onDataConnectionStateChanged(0, 13)
11-11 14:09:43.335 968 968 D NetworkController.MobileSignalController(1): onDataConnectionStateChanged: state=0 type=13
11-11 14:09:43.335 968 968 D NetworkController.MobileSignalController(1): updateNetworkType: DataState= 0, getDataNetworkType= 13
这在OM版本上是google default设计。
 
[SOLUTION]
如果希望此时状态栏上不显示数据连接图标。
1. NetworkControllerImpl.java MobileSignalController中新增：
String mApnType = "unknown";
public void onPreciseDataConnectionStateChanged(PreciseDataConnectionState state) {
    /// M: Support onPreciseDataConnectionStateChanged. @{
    if((mDataState==state.getDataConnectionState())&&(mDataNetType == state.getDataConnectionNetworkType())){
        mApnType = state.getDataConnectionApnType();
    }
    if (PluginFactory.getStatusBarPlugin(mContext).customizeBehaviorSet() == BehaviorSet.OP01_BS) {
        mSvLteController.onPreciseDataConnectionStateChanged(state);
        mCurrentState.mShowDataActivityIcon = mSvLteController.isShowDataActivityIcon();
        notifyListenersIfNecessary();
    }
}

2. MobileSignalController.notifyListeners()中 showDataIcon变量加上mApnType 的判断即可。
```

## [FAQ14865] Android L上EmergencyButton不显示初步分析方法

```
在mainlog中搜索EmergencyButton关键字，看其中的如下log．
下面log中，　变量show的值表示紧急拨号显示或不显示，　为true表示显示EmergencyButton，　false表示不显示EmergencyButton．
antiTheftLocked的值表示当前是否防盗锁，为true表示当前是防盗锁，　false表示当前不是防盗锁．
mEmergencyButtonExt.showEccInNonSecureUnlock()的值表示是否在非安全锁上显示，　为false表示不在非安全锁上显示．
eccShouldShow的值表示是否允许EmergencyButton显示．
enabled的值稍稍复杂一点，可对着代码看，　根据EmergencyButton.java中函数private void updateEmergencyCallButton()去了解．
它们之间的关系是这样：　 show = (enabled || antiTheftLocked || mEmergencyButtonExt.showEccInNonSecureUnlock()) && eccShouldShow;

紧急拨号不显示多数情况是eccShouldShow的值的影响．eccShouldShow的值是在函数private boolean eccButtonShouldShow()函数返回的，
对于默认版本，　eccShouldShow为true的条件是ServiceState为STATE_IN_SERVICE或者ServiceState.isEmergencyOnly()的值为true. 对于联通版本，　它还要求sim卡处于ready状态．
可按照如上方法先确定问题时间点，如不能解决问题，请联系MTK技术人员，　并将分析结果贴入note中，以上分析结果能让MTK更精准的将问题分配给对应owner处理．


05-28 17:30:58.912  1139  1139 I EmergencyButton: show = true --> enabled= true, antiTheftLocked=false, mEmergencyButtonExt.showEccInNonSecureUnlock() =false, eccShouldShow=true
```

## [FAQ10256] 【Contacts Data】 RCS/AAS/SNE/SNS分别代表什么含义?

```
RCS 是为国外一些运营商（如OP03），提供的一种类似于QQ、飞信的服务。这个东西会作为plug-in嵌入到Contacts中，提供一些即使通信、语音视频的服务。
AAS 是USIM卡的附属号码，这个附属号码会支持自定义Label。这个Feature是作为plug-in嵌入到Contacts中的，提供UI、db上支持这个功能的code。OP03上有这个feature。
SNE 是USIM卡的“NickName”功能，支持给一个USIM联系人起别名。部分USIM卡支持这个功能，OP06上有这个plug-in。
SNS 是之前开发的对Facebook等社交网络的整合支持，但这个Feature后来被拿掉掉了，没有MP过。这部分代码只存在于Host中，没有对应的plugin apk。

AAS和SNE在SPEC上的解释如下：

4.4.2.7 EFAAS (Additional number Alpha String)

This file contains the alpha strings that are associated with the user defined naming tags for additional numbers referenced in EFANR.

4.4.2.10 EFSNE (Second Name Entry)

The phone book also contains the option of a second name entry. The amount of second name entries may be less than or equal to the amount of records in EFADN. Each record contains a second name entry. This record cannot be shared between several phonebook entries.
```

## [FAQ09775] 【Contacts Data】 短信选择收件人时，号码搜索联系人修改成任意位置开始中间匹配

```
ContactsProvider2.java 中的queryLocal函数，修改方法如下：
case PHONES_FILTER:
case CALLABLES_FILTER: 
......
if (searchPhoneNumber) {
    ......
    sb.append(Data._ID +
            " IN (SELECT DISTINCT " + PhoneLookupColumns.DATA_ID
            + " FROM " + Tables.PHONE_LOOKUP
            + " WHERE " + PhoneLookupColumns.NORMALIZED_NUMBER + " LIKE '");
    //add here 
    sb.append("%");
    sb.append(number);
    sb.append("%')");
    hasCondition = true;
}
```

## [FAQ08959] 【Contacts Data】 Contacts/Acore进程经常被Kill，导致联系人开机后丢失怎么办？

```
Contacts/Acore进程，在内存较少和开机进程过多的情况下会经常被 ActivityManager Kill 掉，
导致Sim卡联系人开机后未导入或者只导入一部分，造成联系人丢失的现象，但是重新开机后可以恢复正常。
[SOLUTION]
遇到这样的问题可以采用以下方法提供Contacts/Acore进程的优先级，降低被ActivityManager 杀掉的概率。
 
找到这个进程对应的AndroidMannifest.xml文件，在其中添加属性『android:persistent="true"』，
这样可以将该进程设置为常驻内存进程，就可以降低被Kill的概率。
以Acore进程为例，
在 /package/providers/ContactsProvider/AndroidMannifest.xml 文件中增加一行『android:persistent="true"』
具体修改示例如下：
<application android:process="android.process.acore"
     android:label="@string/app_label"
     android:icon="@drawable/app_icon"
     android:allowBackup="false"
     android:persistent="true" <!--新增加代码，保证acore进程不被ActivityManager杀死-->
>
NOTICE:
这个方法可以将对应AP的ADJ临时提高到2。

解决发生JE问题（必须合入）：
CallLogProvider.java  (Line1000)

public static final void notifyNewCallsCount(SQLiteDatabase db, Context context) {
    Log.i(TAG, "[notifyNewCallsCount] newCallsCount = " + newCallsCount);
    //send count=0 to clear the unread icon
    if (newCallsCount >= 0) {
        Intent newIntent = new Intent(Intent.MTK_ACTION_UNREAD_CHANGED);
        newIntent.putExtra(Intent.MTK_EXTRA_UNREAD_NUMBER, newCallsCount);
        newIntent.putExtra(Intent.MTK_EXTRA_UNREAD_COMPONENT, new ComponentName(Constants.CONTACTS_PACKAGE, Constants.CONTACTS_DIALTACTS_ACTIVITY));
        // New add for fixed JE
        newIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);
        // End
        context.sendBroadcast(newIntent);
```

## [FAQ10264] 【Contacts Data】sim卡姓名长度最大为14字节可以输入11个相同汉字

```
SIM卡记录名字的最大长度是14 ，可以输入14个字符，输入中文是可以输入6个，但是如果是相同的汉字 ，可以输入11个。如，可以保存"天天天天天天天天天天天" ,但只能保存"天天天天天气”
[SOLUTION]
sim联系人的中文编码采用UCS2 0x81编码. 编码格式为，14个字节，前两个字节表示编码方式和长度.一个汉字占用两个字节.
当输入全部相同的汉字时，将采用基址偏移的方式，第三个字节为基址, 后面11个字节则是通过基址偏移对应的unicode编码. 所以，当输入相同的汉字，最多可以存储11个汉字.
 
例如,  杜杜杜
UNICODE编码为:675C675C675C
用UCS2的81方案表示是:81 03 CE DCDCDC
81：为标记
03：表示整个字符串为3个字符
CE：一个字节为基址。解析的方法为：将基址（CE）左移七位，并将最高位置为0，最低位再补一个0.此时基址变为0x6700，然后再判断后面的数据字节。
DCDCDC：3个数据字节 DC， DC， DC 。如果数据字节的最高位为0，则认为此字节是一个ASCII字符。如果数据字节的最高位为1，则低7位为基址的一个偏移，实际的UCS2字符为基址加上这个偏移值。由于此处三个数据字节最高位都为1，则实际的3个字符的偏移值为：5C， 5C， 5C。实际的UCS2编码为： 0x675C 0x675C 0x675C
```

## [FAQ10397] 【Contacts Data】 SDN/FDN/BDN MTK平台是否支持？

```
SIM卡的SDN/FDN/BDN MTK SmartPhone平台是否支持？
[SOLUTION]
EF_SDN (Service Dialling Numbers)  [业务拨号号码]
--> 默认支持
     联系人列表最上面会显示所有SDN
EF_FDN (Fixed Dialling Numbers)  [固定拨号号码]
--> 默认支持
     Dialpad -> Settings -> Other Settings -> Fixed Dialing Number -> Enable FDN -> FDN List
EF_BDN (Barred Dialling Numbers)  [禁止拨号号码] 
--> 目前不支持
 
NOTE:
您可以通过在拨号盘输入 *#*#4636#*#* 来进入Phone information
  --> Menu
  --> View SIM address book           [ADN]
  --> View Fixed Dialing Numbers      [FDN]
  --> View Service Dialing Numbers   [SDN]

SDN/FDN/BDN 有什么用？？
```

## 如何导出国内手机号码归属地的数据库？

```
adb pull /system/etc/geocoding.db ./
```

## [FAQ13184] 【Contacts Data】 如何修改最小匹配位数MIN_MATCH?

```
如何修改最小匹配位数MIN_MATCH? 
[SOLUTION]
调整MIN_MATCH涉及三支文件：
1. PhoneNumberUtils.java   MIN_MATCH
    （alps\frameworks\base\telephony\java\android\Telephony\）
2. OldPhoneNumberUtils.cpp   getMinMatch()
    （alps\external\sqlite\Android\）
3. PhoneNumberExt.java getMinMatch() （After KK 4.4）
    L:（alps\vendor\mediatek\proprietary\frameworks\base\packages\fwkplugin\src\com\mediatek\op\Telephony\） 
    KK:（alps\mediatek\frameworks\common\src\com\mediatek\common\Telephony\）
```

## [FAQ17576] [Storage]如何在android M版本的storage有关界面里不显示sdcard品牌名称？

```
android M版本当插入sdcard的后，在storage有关界面里面会显示sdcard厂商。下图示例是一张sandisk的sdcard插入到M版本的手机中作为Portable storage在setting->Storage&USB显示情况：
详细修改方案：
/system/vold/Disk.cpp
需要对status_t Disk::readMetadata() 函数中如下语句进行修改，将蓝色code修改为红色code
 
notifyEvent(ResponseCode::DiskLabelChanged, mLabel);
修改为：
notifyEvent(ResponseCode::DiskLabelChanged, “”);
```

## [FAQ17558] 如何用adb shell am命令启动MTKLogger?

```
adb shell am 命令手动叫起mobile log这个apk：
adb shell am start -n com.mediatek.mtklogger/com.mediatek.mtklogger.MainActivity

备注：
adb shell am 命令是一个通用的命令，在知道activity的包名和类名的情况下，可以手动启动activity。
特别是主菜单中应该显示某应用图标，而遇到不显示图标的时候，可以用这个命令做临时测试用。

命令格式如下：
adb shell am start -n packagename/packagename.ClassName
```

## [FAQ17577] omacp的browser xml文件样本

```
<wap-provisioningdoc>
<characteristic type="BOOTSTRAP">
<parm name="NAME" value="settings" /> 
</characteristic>
<characteristic type="APPLICATION">
<parm name="APPID" value="w2"/>
<parm name="NAME" value="bookmark folder name"/>
<parm name="TO-PROXY" value="PROXY"/>
<parm name="TO-NAPID" value="INTERNET"/>
<characteristic type="RESOURCE">
<parm name="AAUTHNAME" value="username"/>
<parm name="AAUTHTYPE" value="HTTP-BASIC"/>
<parm name="AAUTHSECRET" value="password"/>
<parm name="URI" value="www.qq.com/index.wml"/>
<parm name="NAME" value="QQ"/>
<parm name="STARTPAGE"/>
</characteristic>
</characteristic>
</wap-provisioningdoc>
```

## [FAQ13612] Mms Apn的omacp xml文件样本

```
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE wap-provisioningdoc PUBLIC "-//WAPFORUM//DTD PROV 1.0//EN" "http://www.wapforum.org/DTD/prov.dtd">
<wap-provisioningdoc version="1.1">
  <characteristic type="BOOTSTRAP">
       <parm name="NAME" value="WAP y MMS"/>
       <!parm name="PROVURL" value="http://www.mediatek.com/"/>
       <parm name="CONTEXT-ALLOW" value="0"/>
       <parm name="PROXY-ID" value=""/>
  </characteristic>
  <characteristic type="PXLOGICAL">
       <parm name="PROXY-ID" value="id4"/>
       <parm name="NAME" value="MMS"/>
         <characteristic type="PXPHYSICAL">
              <parm name="PHYSICAL-PROXY-ID" value="id4"/>
              <parm name="PXADDR" value="10.0.0.172"/>
              <parm name="PXADDRTYPE" value="IPV4"/>
              <parm name="TO-NAPID" value="ap4"/>
                <characteristic type="PORT">
                     <parm name="PORTNBR" value="80"/>
                </characteristic>
         </characteristic>
  </characteristic>
  <characteristic type="NAPDEF">
       <parm name="NAPID" value="ap4"/>
       <parm name="BEARER" value="GSM-GPRS"/>
       <parm name="NAME" value="mediatek彩信 (China Mobile)"/>
       <parm name="NAP-ADDRESS" value="mediatekcmwap"/>
       <parm name="NAP-ADDRTYPE" value="APN"/>
  </characteristic>
  <characteristic type="APPLICATION">
       <parm name="APPID" value="w4"/>
       <parm name="NAME" value="mms"/>
       <parm name="ADDR" value="http://mmsc.monternet.com"/>
       <parm name="TO-PROXY" value="id4"/>
         <parm name="CM" value="R"/>
  </characteristic>
</wap-provisioningdoc>
```

## [FAQ12286] [Dialer][KK]进入Dialer显示最新一条的通话记录不变，不随calllog的切换tab操作改变

```
通过下面的修改确保Dialer界面的最新通话记录不会随着Calllog切换tab页面的操作而改变.
请修改PhoneFavoriteFragment.java, fetchCalls, 注释下面两行代码. 其余不变.

//int typeFilter = prefs.getInt(Constants.TYPE_FILTER_PREF, Constants.FILTER_TYPE_DEFAULT);
int typeFilter = Constants.FILTER_TYPE_ALL;
```

## [FAQ17512] 开机通过SIM卡更新时间出错

```
开机的时候通过SIM卡更新时间出问题
从LOG中看到 MccTable: timezone set to ××时区
如果××时区和SIM卡的MCC号对应不上就会出现此问题。 

frameworks\opt\telephony\src\java\com\android\internal\telephony\gsm GsmServiceStateTracker.java
private String[][] mTimeZoneIdByMcc = {{"460", "Asia/Shanghai"}这个数组中添加上自己需要的时区和SIM卡MCC号码
```

## [FAQ08125] [Audio App]观看优酷视频或者youtube时如何将music,FM等后台播放停掉

```
优酷视频或者youtube使用HTML5Video进行播放
修改方法如下：
修改HTML5VideoView.java中方法start()
在   mPlayer.start();  之前添加
Intent i = new Intent("com.android.music.musicservicecommand");
i.putExtra("command", "pause"); 
mProxy.getContext().sendBroadcast(i);

在开始播放时broadcast此消息，FM，music app中会接收此消息并停止
```

## [FAQ08112] [Audio Speech] 不同制式下语音加密算法及密钥长度

```
有客户在过运营测试时运营商要求提供不同制式下语音加密算法及密钥长度
目前支持情况如下：
加密算法             密钥长度              制式
A5_1/A5_3         64 bits               GSM
UEA-0/UEA-1     128 bits;             UMTS
```

## [FAQ12562] [Audio App]如何关闭com.mediatek.voicecommand进程

```
请在ProjectConfig.mk中进行配置：
MTK_VOICE_CONTACT_SEARCH_SUPPORT=no
MTK_VOICE_UI_SUPPORT=no
MTK_VOICE_UNLOCK_SUPPORT=no
```

## [FAQ10792] [Audio App]如何在手机中不显示某类后缀名的多媒体文件

```
请在frameworks\base\media\java\android\media\mediafile.java中，找到不显示的某类后缀名
addFileType(后缀名,...) //直接拿掉
```

## [FAQ10972] 如何在ap获取拍照的yuv数据

```
通过实现ap的RawPictureCallback接口来实现，主要包括ap层以及中间层的修改：
一、AP层的修改：
PhotoActor.java（alps/packages/apps/Camera/src/com/android/camera/actor/）
1、添加import android.hardware.Camera.Size;
2、public boolean capture() 函数中
将
if (!mCameraCategory.applySpecialCapture()) {
    mContext.getCameraDevice().takePicture(getShutterCallback(), mRawPictureCallback,
    mPostViewPictureCallback, mCameraCategory.getJpegPictureCallback());
}
改为
if (!mCameraCategory.applySpecialCapture()) {
    if(!mContinuousShotPerformed){
        Size curPictureSize = mCamera.getParameters().getPictureSize();
        byte []uRawDataBuffer = new byte [curPictureSize.width*curPictureSize.height*2];
        mContext.getCameraDevice().addRawImageCallbackBuffer(uRawDataBuffer);
    }
    mContext.getCameraDevice().takePicture(getShutterCallback(), mRawPictureCallback,
    mPostViewPictureCallback, mCameraCategory.getJpegPictureCallback());
}

二、中间层的修改：
NormalShot.cpp（alps/mediatek/platform/mt65XX/hardware/camera/hal/adatper/scenarioshot/normalshot/）
1，onCmd_capture（）函数中需要注册YUV的callback message：
pSingleShot->enableDataMsg(NSCamShot::ECamShot_DATA_MSG_YUV);
2，fgCamShotDataCb（）函数中需要添加yuv callback的处理机制：
依照postview的处理方式，添加else if语句
else if(NSCamShot::ECamShot_DATA_MSG_YUV==msg.msyType)
{
pNormalShot->handleYUVData(msg.puData,msg.u4Size)；
}
3，第二步中调用的handleYUVData是新添加的函数，首先在NormalShot.h文件中仿照handlePostViewData()添加函数声明：
MBOOL handleYUVData(MUINT8* const puBuf,MUINT32 const u4Size);
然后在NormalShot.cpp文件中添加其实现：
MBOOL
NormalShot::
handleYUVData（MUINTE8 * const puBuf,MUINT32 const u4Size）
{
MY_LOGD("+ (puBuf, size)=(%p,%d)",puBuf,u4Size);
mpShotCallback->onCB_RawImage(0,u4Size,reinterpret_cast<uint8_t const*>(puBuf));
return MTRUE;
}
4，在handleJpegData（）函数中，将原来的dummy raw callback注释掉
//mpShotCallback->onCB_RawImage(0,0,NULL);
```

## [FAQ17430] 如何让某个APK里面的图片能够作为壁纸使用

```
1.在APK中需要申明Action为“com.android.launcher3.action.PARTNER_CUSTOMIZATION”的receiver
<receiver
android:name="com.example.partner_wallpaper.WallpaperReceiver"
android:exported="true">
<intent-filter>
<action android:name="com.android.launcher3.action.PARTNER_CUSTOMIZATION" />
</intent-filter>
</receiver> 
2.编写Receiver的类，重写onRecive方法
public class WallpaperReceiver extends BroadcastReceiver{
    @Override
    public void onReceive(Context arg0, Intent arg1) {
    }
}
3.将想要作为壁纸的图片放到apk代码的res/drawable-xxx目录下，并将其重名为 xxx, 还要提供对应的缩略图（小图）放在相同的目录下并命名为xxx_small.

xxx_small显示在壁纸选择列表，xxx是作为壁纸使用。

4.在APK代码的res/value/arrays.xml中增加partner_wallpapers字符串数组资源
<?xml version="1.0" encoding="utf-8"?> 
<resources>
    <!-- name 必须固定为partner_wallpapers-->
    <string-array name="partner_wallpapers">
        <!-- item 与第3步中图片名对应-->
        <item>a</item>
        <item>b</item>
        <item>c</item>
    </string-array>
</resources>

此时如果将此APK预置为系统APK，则这些图片就能出现在Launcher的WallPapaer Picker中，可以作为壁纸使用。
如果不想把APK预置为系统的APK，让其安装上去就能实现此功能，则需要按以下方法修改Launcher的代码。

5.修改 Launcher的Utilities.java文件中的findSystemApk方法
```

## [FAQ16260] [video][common]video play/record issue standard operation

```
[DESCRIPTION]
遇到视频播放/录制问题，请先判断你的问题属于哪一类，大致可以分为以下类；

然后分类别找寻对应解决方案；

最后找寻不到对应类别或者仍未能解决，请贵司将所需的资讯附上来，以加快我司协助速度。

类别一：Video Spec问题，即BB chip支持播放/录制能力咨询问题，提示视频无法播放错误或者只有声音没有视频等问题；播放/录制flexible机制，即希望通过加大memory等代价支持一定限度内超spec的视频播放/录制，当然performance问题无法保证；

类别二：播放视频performance问题，即播放不流畅或者马赛克严重等问题

类别三：播放视频花屏问题

类别四：录制视频performance问题，即录制视频帧率低，录制视频分辨率低等问题

类别五：录制视频花屏问题，即录制中预览花屏，录制后保存视频花屏或者是录制后回放视频花屏等等

类别六：播放/录制视频死机问题以及其他异常情况
 
 
[SOLUTION]
具体处理方法如下：

类别一：video spec问题

1)了解video基础知识

参见FAQ02573 [Video][Common] video常见名称简介

2) 查询贵司项目所用BB chip的video spec，即平台支持的播放录制视频格式，最大支持播放录制的分辨率，帧率等具体参数

参见FAQ02580 [Video][Spec] MTK Chip Video Spec 相关说明

3)  了解贵司工程支持的视频spec配置

参见FAQ09285 [video][common]project video spec详解

通过以上三步，基本上可以确认贵司所需要的video资讯

4)  查看贵司无法播放或者无画面视频的具体参数

参见FAQ02596 [Video][Common]常用Video 辅助工具的说明

通过此步骤基本可以确认播放失败的视频是由于codec不支持还是resolution超过vidoe spec；


若是超过chip video spec，抱歉平台能力有限无法支持；若是希望通过希望通过加大memory等代价支持一定限度内超spec的视频播放/录制，可尝试利用flexible机制实现视频播放/录制

参见FAQ02587[Video Performance][Common] MT6252，MT6253，MT6236等 Chip Video Flexible Architecture 简介

若是未超过chip video spec，只超过project video spec，贵司memory有富余的话，请修改工程.mak看是否能够编译通过，若未通过请告知贵司project版本号，提交patch申请；

若是未超过project video spec，请提供对应的工程.mak,log文件以及sample视频文件。

参见FAQ09284[video][common]video播放录制问题cather log抓取以及memory dump详解

 

类别二：播放视频performance问题

1)请根据类别一方法，确认视频是否已经超过chip/project video spec.若已超过，抱歉chip cpu处理速度有限，无法保证超spec视频的播放效果；若是未超spec，请提供相关log文件。

2)若是播放高码率mpeg4 codec视频，可以尝试将默认丢块的解码方式改为丢帧，改善播放画质；当然若码率超很多的话，改善效果有限。

参见FAQ05081[video][Common] 高品质MPEG4视频播放模糊，马赛克严重，改善播放质量

 

类别三：播放视频花屏问题

1)请帮忙验证时播放特殊视频会花屏还是所有视频都花屏；特殊视频在PC上播放是否正常；

2)请提供memory dump帮忙分析

参见FAQ09284[video][common]video播放录制问题cather log抓取以及memory dump详解

 

类别四：录制视频performance问题

1)通过类别一确认贵司录制视频需求是否有超过spec

2)录制的四种品质fine/good/normal/low时的视频，查看录制的视频参数，告知我司录制具体参数信息或者直接上传视频；

参见FAQ02596 [Video][Common]常用Video 辅助工具的说明

3)录制参数是通过底层帧率表配置的，具体配置位置在

hal\video\custom\custom_video_enc_setting_mjpg.h\_rMjpegFrameRateTable

hal\video\custom\custom_video_enc_setting_mpeg4.h\_rMpeg4FrameRateTable

hal\video\custom\custom_video_enc_setting_h264.h\_rH264FrameRateTable

请根据贵司录制品质及采用的编码方式，告知我司选用的4个帧率表信息

4）请提供录制时的cather log帮忙分析

参见FAQ09284[video][common]video播放录制问题cather log抓取以及memory dump详解

 

类别五：录制视频花屏问题

1)  请查看贵司工程.mak,检查配置是否正确。

我司提供方案设置如下：

a.sensor竖装方案：HORIZONTAL_CAMERA = FALSE, SENSOR_ROTATE = SENSOR_ROTATE_0；

b.sensor横装方案：HORIZONTAL_CAMERA = TURE, SENSOR_ROTATE = SENSOR_ROTATE_90。

也就是sensor若是横装的话，UI必须要横过来，这样录制的视频才符合常规视频宽>高，拍的影像才是比较被用户接受的。且我们底层编码数据时会参考UI rotate的角度，强行将HORIZONTAL_CAMERA = FALSE会导致encode角度计算出错，这样录制出来是视频就会花。

2）配置没有错误的话，请上传此视频文件，并提供录制过程以及播放花屏时的memory dump文件帮忙分析。

参见FAQ09284[video][common]video播放录制问题cather log抓取以及memory dump详解

 

类别六：播放/录制视频死机问题以及其他异常情况

1)  请详细描述复现步骤

2)  死机问题请提供memory dump,其他非死机异常请先提供cather log即可

参见FAQ09284[video][common]video播放录制问题cather log抓取以及memory dump详解
```

## [FAQ17443] [SLP Template] AGPS Supl Profile Configration

```
1.How to change default supl profile
In agps_profiles_conf2.xml,the default profile is google, whose format is：
          <cur_supl_profile name="GOOGLE"
              addr="supl.google.com"
              port="7275"
              tls="true"
          />
cur_supl_profile is refer to default profile. If we need change the default profile, we should change it as below:
          <cur_supl_profile name="nexteldata"
              addr="supl.iusacell.com"
              port="7275"
              tls="true"
          />
Now the default profile will be changed to nexteldata, which can be seen in SLP Template.
 
2.How to add supl profile
If we want to add supl profile in agps_profiles_conf2.xml, we only need to add supl_profile, according to google’s format as below:
  <!-- GOOGLE-->
  <supl_profile name="GOOGLE"
      addr="supl.google.com"
      port="7275"
      tls="true"
  />
  <!-- nexteldata-->
  <supl_profile name="nexteldata"
      addr=" supl.iusacell.com "
      port="7275"
      tls="true"
  />
  <!-- IUSACELL-->
  <supl_profile name="IUSACELL"
      addr="supl.iusacell.com"
      port="7275"
      tls="true"
  />
Now the nexteldata and IUSACELL are added to the SLP Template.

3.How to adaptive change supl profile
If we want to adaptive change supl profile along with SIM card, we should ensure auto_profile_enable=“true” in agps_profiles_conf2.xml , then add operator MCC and MNC in profile as below:
  <!-- GOOGLE-->
  <supl_profile name="GOOGLE"
      addr="supl.google.com"
      port="7275"
      tls="true"
  />
  <!-- nexteldata--> 
  <supl_profile name="nexteldata"
      addr="supl.iusacell.com"
      port="7275"
      tls="true“
      mcc_mnc="334050"
  />
  <!-- IUSACELL-->
  <supl_profile name="IUSACELL"
      addr="supl.iusacell.com"
      port="7275"
      tls="true“
      mcc_mnc="334090"
  />
Now if the inserted SIM card is mcc(334) mnc(050), the SLP Template will auto select nexteldata, else if the inserted SIM card is mcc(334) mnc(090), the SLP Template will auto select IUSACELL.
```

## [FAQ15090] [FM]open /dev/fm fail

```
L版本使用fm app时遇到open /dev/fm fail问题，从log来看/dev/fm这个设备节点打开失败，失败原因是节点的访问权限问题，如下红色字体内容： 
Line 14637: 01-02 09:06:19.878  3563  3592 I FMLIB_COM: COM_open_dev start
Line 14638: 01-02 09:06:19.880  3563  3592 E FMLIB_COM: Open /dev/fm failed, Permission denied
Line 14638: 01-02 09:06:19.880  3563  3592 E FMLIB_COM: Open /dev/fm failed, Permission denied
Line 14639: 01-02 09:06:19.880  3563  3592 I FMLIB_COM: int COM_open_dev(const char*, int*), [fd=-1] [ret=-1007]
Line 14640: 01-02 09:06:19.880  3563  3592 E FMLIB_CORE: int FMR_open_dev(int) failed, [fd=-1]
Line 14640: 01-02 09:06:19.880  3563  3592 E FMLIB_CORE: int FMR_open_dev(int) failed, [fd=-1]
Line 14641: 01-02 09:06:19.880  3563  3592 D FMLIB_JNI: jboolean openDev(JNIEnv*, jobject), [ret=-1007]
Line 14642: 01-02 09:06:19.880  3563  3592 E FM/FMRadioService: Error: opendev failed

1. 在alps\vendor\mediatek\proprietary\packages\apps\FmRadio\Android.mk
修改 LOCAL_CERTIFICATE := platform，原先是media。

2. 在alps\vendor\mediatek\proprietary\packages\apps\FmRadio\ AndroidManifest.xml中添加
<uses-permission android:name="android.permission.ACCESS_FM_RADIO" />

3. 在device/mediatek/common/sepolicy/system_app.te 里面添加下面这行
allow system_app fm_device:chr_file { read write ioctl open};
```

## [FAQ04171] 打开fm设备节点被拒绝

```
打开fm设备节点被拒绝，从mobile log中的main log发现是由于权限问题。
检查init.rc中加载fm驱动时，创建的fm设备节点权限为660，为何上层打开FM还是会失败。
[SOLUTION]
在alps/mediatek/source/packages/FMRadio里面的AndroidManifest.xml文件中加上<uses-permission android:name="android.permission.ACCESS_MTK_MMHW">
```

## [FAQ09547] FM搜不到104M频点

```
104M是一个desense频点，软件中作了特殊了处理是这个台不被搜到。但是比如在印度104M本身是一个有效频点，那么需要修改软件将这104作为正常的频点来处理。

要把104M台当做正常台的处理需要修改三处地方：

针对MT6628

1)修改alps/mediatek/source/external/fmradio/custom/fmlib_cust.h文件，从MT6620_FM_FAKE_CHANNEL中拿掉104M

2) 修改alps\mediatek\source\kernel\drivers\fmradio\mt6628\pub中的mt6628_fm_lib.c文件：

将数组mt6628_mcu_dese_list[]和mt6628_scan_dese_list[]中的104拿掉

针对mt6627：

1)修改alps/mediatek/source/external/fmradio/custom/fmlib_cust.h文件，从MT6620_FM_FAKE_CHANNEL中拿掉104M

2) 修改alps\mediatek\source\kernel\drivers\fmradio\mt6627\pub中的mt6627_fm_lib.c文件：

将数组mt6627_mcu_dese_list[]和mt6627_scan_dese_list[]中的104拿掉

对于L版本修改方法跟上面的相同，只是文件的路径有变化，说明如下：

1、mt6627_scan_dese_list和mt6627_mcu_dese_list对应的文件如下：

alps\kernel-3.10\drivers\misc\mediatek\fmradio\mt6627\pub\mt6627_fm_lib.c

2、 MT6627_FM_FAKE_CHANNEL对应的文件为：

alps\hardware\mediatek\fmradio\fmnative\custom\custom.cpp

需要注意我们这边的定义有用MTK_FM_50KHZ_SUPPORT包起来，要注意修改对位置。
```

## [FAQ14734] L版本上auto join 和auto save的配置开关

```
1，auto join
L版本上的一项auto join 的新功能，即每次scan 之后，会比较scan 到的ap 来决定是否要切换到其他ap 去
如果想关闭此功能测试，请修改如下位置：
/frameworks/base/core/res/res/values/config.xml
<bool translatable="false" name="config_wifi_framework_enable_associated_network_selection">true</bool>
将这里的true 改为false；
但是这里请注意side effect ：如果关闭了此auto join 功能，会出现如下现象：
A,B两个已保存ap ，连接A ，断开A 之后，不会自动去连接B ，还请特别注意！
 
2，auto save
连接ap1之后，断开ap1连接，自动去连接名字类似的ap2，但是ap 2开始并不是已保存的ap；
L版本上新功能，自动保存ssid 和bssid 类似的ap；
例如如下log中的两个ap；
Line 126703: 07-28 14:36:14.426 1099 1099 D wpa_supplicant: wlan0: selected BSS 50:17:ff:35:da:e0 ssid='SF-client'
Line 131516: 07-28 14:36:26.372 1099 1099 D wpa_supplicant: wlan0: selected BSS 50:17:ff:35:da:e1 ssid='SF-office'
 
如果需要关闭此功能，请提eservice，申请如下patch：ALPS02217759；
此patch在配置文件中做了一个option，用于对此功能的选择开关；
如果需要此功能，可以直接通过打开此option，
false:表示关掉auto save
```

## [FAQ04539] [Maui Meta]写IMEI或校准后如何正确保存参数

```
使用MauiMETA写IMEI或做RF校准，手机恢复出厂设置之后参数丢失问题
MauiMETA写IMEI、做RF校准后相关参数保存在USRDATA区，正常是需要备份到NVRAM Bin Region

[Solution]
1.确认在MauiMETA的"Options"菜单有选择"Backup to BackupPartition/SDS before disconnect"项
2.写完IMEI（或校准）后点"Disconnect"按钮正常退出META模式
3.待正常退出后在断电（手机会关机）
```

## [FAQ12399] [Common]spn 如何添加特殊‘&’符号

```
在\mediatek\frameworks\base\telephony\etc\spn-conf.xml中配置运营商名称，名称字符串包含‘&’时编译出错，该如何添加？

Xml文件里面配置‘&’需要使用‘&#038;’代替，例如：
对spn-conf.xml中需要配置运营商名称“AT&T”的位置使用：
“AT&#038;T”
```

## [FAQ02912] [Common]如何判断sim卡是4G、3G、2G卡

```
SIM卡是4G、3G卡还是2G卡是由网络来判断的；
例如若这张卡可以注册上4G网络，那这张卡就是4G卡，否则就是3G or2G卡。SIM卡本身是不携带4G、3G还是2G信息的，所以无法通过获得SIM卡的某些信息来做判断。
```

## [FAQ08549] 如何把"设置--安全--未知来源“默认打开

```
如果要修改该默认值,对op03来说,请修改
alps\mediatek\operator\op03\packages\apps\plugins\res\values\Defaults.xml
中
<bool name="def_install_non_market_apps_op03" translatable="false">false</bool>
为
<bool name="def_install_non_market_apps_op03" translatable="false">true</bool>
其它情况请修改
alps\frameworks\base\packages\settingsprovider\res\values\Defaults.xml
中
<bool name="def_install_non_market_apps">false</bool>
为
<bool name="def_install_non_market_apps">true</bool>
注意，修改后可能导致CTS无法通过，请酌情修改。
```

## [FAQ08629] 如何更改后台进程限制默认值

```
ActivityManagerService.java (alps\mediatek\custom\bsp_overlay\frameworks\base\services\java\com\android\server\am)  中
int mProcessLimitOverride 的值即可
```

## [FAQ08016] 关于Mouse and Trackpad/鼠标和触控板功能

```
1.在设置->语言和输入法->鼠标和触控板；
2.调节速度
【实际结果】
不知道变化在哪里

[SOLUTION]
1、当您的手机外接OTG线的方式连接USB鼠标后，手机上会出现一个鼠标指针，那么调节这个Pointer speed，可以改变鼠标指针的速度的；
2、当您的手机外接无线蓝牙键盘（带Trackpad功能的）后，手机上会出现一个鼠标指针，这一点类似笔记本电脑上的触控板了；那么调节这个Pointer speed，可以改变鼠标指针的速度的；
```

## [FAQ12262] 如何默认关闭输入法设置中的“Auto correction”

```
默认关闭请修改SettingsProvider中的databaseHelper.java内的
loadSecureSettings函数，在函数尾部添加
loadBooleanSetting(stmt,Settings.Secure.SPELL_CHECKER_ENABLED,false);
```

## [FAQ08894] 如何将"设置->开发者选项"这个菜单的总开关默认设置为Off”

```
在进入“设置->开发者选项”这个菜单后，系统默认该菜单项的总开关为On，如果想改为Off，可以做如下修改，使得Switch开关默认为Off。
[SOLUTION]
在alps/packages/apps/settings/src/com/android/settings/DevelopmentSettings.java中的onResume()方法中
将如下代码注释掉：
/*
if (mHaveDebugSettings && !mLastEnabledState) {
    // Overall debugging is disabled, but there are some debug
    // settings that are enabled.  This is an invalid state.  Switch
    // to debug settings being enabled, so the user knows there is
    // stuff enabled and can turn it all off if they want.
    Settings.Global.putInt(getActivity().getContentResolver(), Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 1);
    mLastEnabledState = true;
    mEnabledSwitch.setChecked(mLastEnabledState);
    setPrefsEnabledState(mLastEnabledState);
}
*/
```

## [FAQ07782] 在法律信息中添加菜单

```
请在Device_info_settings.xml (alps\packages\apps\settings\res\xml)
中下面部分添加,其中JASONYYY是我添加的一个菜单项,贵司可以对照修改.
action部分为该菜单项对应的intent.
 <!-- Legal Information -->
<PreferenceScreen
        android:key="container"
        android:title="@string/legal_information">
    <!-- Note: The titles given here probably won't be used.  Instead, we programmatically
               fill the title with the label of the activity with the corresponding action.
               If there is not an activity for an action, the item will be removed from the
               list. -->
    <!-- Copyright information -->
    <PreferenceScreen
            android:key="copyright"
            android:title="@string/copyright_title">
        <intent android:action="android.settings.COPYRIGHT" />
    </PreferenceScreen>
    <!-- License information -->
    <PreferenceScreen
            android:key="license"
            android:title="@string/license_title">
        <intent android:action="android.settings.LICENSE" />
    </PreferenceScreen>
    <!-- Terms and conditions -->
    <PreferenceScreen
            android:key="terms"
            android:title="@string/terms_title">
        <intent android:action="android.settings.TERMS" />
    </PreferenceScreen>
    <!-- Terms and conditions -->
    <PreferenceScreen
            android:key="JASONYYY"
            android:title="JASONYYY">
        <intent android:action="android.settings.LICENSE" />
    </PreferenceScreen>
</PreferenceScreen>
```

## [FAQ04994] 如何去掉ListView/GridView等列表控件滑到顶部或底部时的模糊边缘效果？

```
修改如下文件：
alps/frameworks/base/core/java/android/view/View.java文件中的View的一个构造方法，
将其中这一行 setOverScrollMode(OVER_SCROLL_IF_CONTENT_SCROLLS);
修改为：setOverScrollMode(OVER_SCROLL_NEVER);

public View(Context context) {
    mContext = context;
    mResources = context != null ? context.getResources() : null;
    ......
    mTouchSlop = ViewConfiguration.get(context).getScaledTouchSlop();
    setOverScrollMode(OVER_SCROLL_NEVER);
    mUserPaddingStart = UNDEFINED_PADDING;
    mUserPaddingEnd = UNDEFINED_PADDING;
}
注意：上述的修改是将系统中所有使用列表控件的界面的这种顶部/底部边缘模糊效果都去掉了，而不是只针对单个控件的，
如果要消除某一个控件的顶部/底部边缘模糊效果的话，可以通过设定控件的xml属性android:overScrollMode 或者setOverScrollMode(int overScrollMode)这个方法去单独设置即可。
```

## [FAQ04905] 如何在任意界面按某个预设定的硬体按键进入某个Activity？

```
实现在任意非锁屏界面，按某个预设定好的按键进入某个Activity的功能

修改alps/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java文件中的如下方法：
public long interceptKeyBeforeDispatching(WindowState win, KeyEvent event, int policyFlags)
找到如下代码段：
else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
    if (......) {
        ......
    }
    return -1;
}
在这个else if后面增加相应代码：
else if (keyCode == KeyEvent.KEYCODE_APP_SWITCH) {
    if (......) {
        ......
    }
    return -1;
} //add begin
else if (keyCode == KeyEvent.KEYCODE_XXX) {
    if (down && repeatCount == 0 && !keyguardOn) {
        mContext.startActivity(new Intent("intent.xxx").addFlags(Intent.FLAG_ACTIVITY_NEW_TASK));
    }
    return -1;
}  // add end

注意:
1、上面写的KeyEvent.KEYCODE_XXX是预设定好的硬按键的键值，根据需要来设定即可；
2、startActivity(new Intent("intent.xxx")中的intent.xxx需要根据所启动的activity来写
```

## [FAQ11540] [Common]如何获取ICCID

```
如何获取(U)SIM卡的唯一标识ICCID (Integrate Circuit Card IDentification)
[SOLUTION]
 
ICCID保存在(U)SIM卡文件中，需要等到开机(U)SIM卡初始化后才能获取到；
方法1：通过SystemProperty获取：
由于开机在RILD会下AT CMD："AT+ICCID?" 去获取个卡的ICCID并保存在对应SystemPrority中，所以可以在上层直接到对应SystemPrority中获取：
(1) 在上层需要获取ICCID的java文件中 import android.os.SystemProperties;
(2)定义SystemProperty：
    private String[] PROPERTY_ICCID_SIM = {
        "ril.iccid.sim1",              //for SIM1
        "ril.iccid.sim2",
        "ril.iccid.sim3",              //if your project is triple SIMs project
        "ril.iccid.sim4",              //if your project is quad SIMs project
    };
(3)定义string来调用get方法接收ICCID
mIccId[simIdx]= SystemProperties.get(PROPERTY_ICCID_SIM[simIdx]);
方法2：IccRecords.java中有public方法 getIccId来获取
 
如果ICCID显示异常，可以参考如下FAQ
ID: FAQ11502[Common]iccid显示异常
```

## [FAQ10436] [Common]默认显示MM reject cause的通知

```
1.在alps/medatek/frameworks/base/op/java/com/mediatek/op/telephony/ServiceStateExt.java
中，更改方法needRejectCauseNotiication(),对特定的cuase返回true，这样在发生MM reject时，如果cause匹配上就会显示出通知。
 
如果想全部cause都显示通知，直接返回ture即可。
 
2.需要注意的是，需要check一下ServiceStateExtOPXX.java是否有重新改方法，如果有重写该方法，则需要到ServiceStateExtOPXX.java里面的needRejectCauseNotiication中去进行修改；
例如，
alps/medatek/frameworks/base/op07/java/com/mediatek/op/telephony/ServiceStateExtOP07.java
里面有去重写needRejectCauseNotiication方法；

什么是MM reject？？？
```

## [FAQ12269] 互动屏保无法使用google相册显示，将此菜单隐藏？

```
预置条件：
安装GMS包，已登录google帐户并存有图片；
测试步骤：
settings-->display-->daydream-->google photos-->start now；
预期结果：
能进入互动屏保界面；
实测结果：
终端不能进入屏保界面，终端闪退。
对比机也有该问题，能否将此菜单隐藏，该如何处理?

[SOLUTION]
修改 Settings 源码中的 DreamSettings.java 添加
import java.util.ArrayList;
......
修改refreshFromBackend的实现
private void refreshFromBackend() {
    logd("refreshFromBackend()");
    mRefreshing = true;
    boolean dreamsEnabled = mBackend.isEnabled();
    if (mSwitch.isChecked() != dreamsEnabled)
        mSwitch.setChecked(dreamsEnabled);
    mAdapter.clear();
    if (dreamsEnabled) {
        List<DreamInfo> dreamInfos = mBackend.getDreamInfos();
        List<DreamInfo>  filteredDreamInfo = new ArrayList<DreamInfo>(); // modify begin
        for(int i= 0;i< dreamInfos.size();i++){
         DreamInfo info = dreamInfos.get(i);
         if(info.componentName.toString().contains("com.google.android.apps.plus"))
          continue;
         filteredDreamInfo.add(info);
        }
        mAdapter.addAll(filteredDreamInfo);    //modify end
    }
    if (mMenuItemsWhenEnabled != null)
        for (MenuItem menuItem : mMenuItemsWhenEnabled)
            menuItem.setEnabled(dreamsEnabled);
    mRefreshing = false;
}
```

## [FAQ14728] [SP Multiport Download Tool]Download checksum分级机制

```
Checksum匹配是保证下载完整性的一种机制，了解Download tool的checksum机制，对我们分析下载不完整问题和提高产线效率是非常重要。

[SOLUTION]
从W1516版本的MDT（SP Multiport Download Tool）开始，MDT下载可以支持4个级别的DA checksum，如图：

4个级别的DA checksum分别如下：
Disable Checksum: 不做DA checksum，即下载时不做任何checksum，不保证下载的完整性。
Enable USB+Dram Checksum: 会在PC Ram和手机或者板子的Ram两边做checksum，并compare 这两个checksum是否一致，这个级别没有把Flash上的image读出来并计算checksum与下载前image checksum做比较，故只能保证USB通信两边的数据在Dram的完整性。
Enable Flash Checksum: download 到手机的flash之后，回读做checksum，然后与PC 侧image的check做比较检查是否一致。这个级别不会做Enable USB+Dram Checksum这个checksum检查。
Enable Checksum All: 这个是Enable USB+Dram Checksum和Enable Flash Checksum总和，即两种mode都会做。

参考FAQ: 
FAQ08732 [SP Multiport Download Tool]Flashtool checksum原理简单介绍
```

## [FAQ17415] 如何在factory mode下将modem log存放在内置SD

```
从6755 L1.MP10开始支持factory mode sd logging功能，mobile log仅可保存在外置SD。 modem log支持USB/SD方式。存放方式在正常开机MTKLogger页面中通过修改modem log mode进行设置。设置后需要将MTKLogger start起来。

如果选为是SD存放，factory mode默认是存放在外置SD（抓取方式参考FAQ15308），用户可根据需要修改为内置SD，以下介绍修改方法
[SOLUTION]
修改/data/mdlog/mdlog1_sd_config （modem1 sd log配置文件）及/data/mdlog/mdlog3_sd_config   （modem3 sd log配置文件）
用UE可打开修改   1è内置    2è外置
这个文件在factory mode中运行一次emdlogger1/3自动生成，默认是2，也可以修改后adb push到相应路径。如果功能不生效
请检查是否有上patch ALPS02412333

参考FAQ：
FAQ14184--Factory Mode下USB抓取modem log的方法
FAQ15308--FactoryMode下用SD卡抓取mobilelog及modemlog
```

## [FAQ09749] LCA项目，DayDream屏保功能默认关闭，如何打开？

```
LCA版本有很多feature或功能都没有打开，包括DayDream，可按如下方法打开开关，但有可能由此引发performance问题，请自行斟酌。
 
[SOLUTION]
修改alps\mediatek\custom\common\resource_overlay\LCA_ram\frameworks\base\core\res\res\values\config.xml，将
<bool name="config_dreamsSupported">false</bool>
修改为
<bool name="config_dreamsSupported">true</bool>
L版本上如果是512M 和1024M的项目，也会因为 ro.mtk_gmo_ram_optimize 为1或者
ro.mtk_lca_ram_optimize 为 1 导致在 DisplaySettingsEx.java
中 initPreference 函数内会 remove KEY_SCREEN_SAVER 的 Preference. 如果一定要开，
可以把该函数内的这一段逻辑删除。删除的影响是会吃掉一些memory，故对memory不算富余的项目，自行斟酌是否要开。
```

## [FAQ06645] [TimeZone]如何解决在欧洲城市自动更新时区错误

```
欧洲某些运营商的NITZ消息比正常的NITZ消息少一位，缺少的是夏令时参数，在这样的情况下，会造成手机获得的时区错误，通常显示为非洲某时区。

对于缺少dst参数的NITZ消息，我们需要通过其他方式来获取和补充这个参数。这里的修改方法是根据手机的TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC这个属性中的mcc信息，即目前所在国家来判断的。

step1:修改ServiceStateTracker.java(frameworks\base\telephony\java\com\android\internal\telephony)
在setTimeFromNITZString这个方法中，修改dst的申明和定义语句如下：
int dst = (nitzSubs.length >= 8 ) ? Integer.parseInt(nitzSubs[7]) : mccDst( getMcc() ,  c.getTimeInMillis());

step2:添加获取mcc参数的方法getMcc（）
//getMcc方法的定义如下（如果已经有这个函数，不用重复添加）：
private int getMcc(){
 int mccmnc = 0;
 int mcc=0;
    if (phone.getMySimId() == Phone.GEMINI_SIM_1) {
     mccmnc = SystemProperties.getInt(TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC, 0);
    } else {
     mccmnc= SystemProperties.getInt(TelephonyProperties.PROPERTY_ICC_OPERATOR_NUMERIC_2, 0);
    } 
   try {
    mcc = mccmnc/100;
   } catch (NumberFormatException e) {
    Log.e(LOG_TAG, "Error parsing IMSI");
   }
   return mcc;
   }
 
step3:添加根据mcc参数获取dst参数的方法mccDst()
//mccDst方法的定义如下
private int mccDst(int mcc, long when) {
  String tz = MccTable.defaultTimeZoneForMcc(mcc);
  if(tz==null)
    return 0;
  TimeZone timezone = TimeZone.getTimeZone(tz);
  if(timezone==null)
  return 0;
  Date d = new Date(when);
  return timezone.inDaylightTime(d)==true?1:0;
 }
```

## [FAQ09004] 【TimeZone】俄罗斯插MTS卡测试，时区自动同步到错误时区

```
在俄罗斯进行测试，插当地SIM卡，勾选“自动确定时间”和“自动确定时区选项”，发现时区更新到"GMT+4:00,Samara Time"，预期显示为"GMT+04:00,Moscow Standard Time"。

原因：

俄罗斯在2010年和2011做过2次时区调整，2010年，将原本的11个时区合并到9个时区；2011年，永久使用夏令时。在调整之前，俄罗斯是属于+3时区，使用夏令时的；调整之后，俄罗斯属于+4时区，没有夏令时。

由于俄罗斯的时区调整，可能会出现下面两个问题：

1.将手机时间调到2013年1月1日，时区调整到Moscow，Moscow的时区是GMT+3时区，正确应该是GMT+4。这个问题原因是android在2010或2011年之前的版本，zoneinfo.dat文件版本较旧，没有包含俄罗斯时区调整后的规则。所以如果出现Moscow时区是GMT+3的问题，请参考FAQ05710更新dat文件。(Android中的时区数据文件zoneinfo.dat编译好之后只读的，所以download到手机之后，该文件不能自动更新)

FAQ05710	【Zone】如何更新时区data文件

2.勾选“自动更新时区”，时区变成"GMT+4:00,Samara Time"。这个问题是因为虽然zoneinfo.dat更新了，但是time_zones_by_country.xml文件没有更新。在这个xml文件中同时有Samara和Moscow，目前Samara时区和Moscow时区都是GMT+4时区，而Samara在该文件中排序靠前，所以查找时会优先返回。参考本FAQ可以修正这种错误。

解决方法：
修改time_zones_by_country.xml(framework/base/core/res/res/xml/)，把含有Samara的那行删除。
```

## [FAQ05703] 手机加密前后，时间显示不一致

```
此现象是正常的。
 
在加密后，手机的data区域都经过加密了，而手机的时区信息也存储在这里，在未解密之前不能获取到该区域的数据，所以输入密码界面显示的时间会是通过默认时区计算而来的时间。
```

## [FAQ14883] google 开机设置时区界面 找不到对应时区

```
安装了setup wizard  ，在开机向导中的时区选择列表中找不到对应的时区，
如（希望在开机向导中找到上海时区，而开机向导中只有北京时区）；

而在设置--时区能够找到该时区如（在设置中可以找到上海时区）。
[SOLUTION]
由于开机向导中的时区列表是GOOGLE自行定义的并非是系统定义的,
而设置--时区中的时区列表是在setting中定义的。

同时在开机向导显示默认时区会分为两种情况：

1.插入sim卡，根据sim卡获取对应的时区，如果开机向导列表中没有对应时区,
setup wizard 会选择其他时区。
2.没插sim卡，根据系统默认时区，如果开机向导列表中没有对应时区,
setup wizard 会选择其他时区。

由于GOOGLE setupwizard 是GOOGLE直接释放的APK,没有源码可以修改，建议接受这种现象。
```

## [FAQ04790] 不勾选从网络自动更新时间，时间仍然会从网络获取时间更新？

```
不勾选：从网络自动更新时间，时间仍然会从网络获取时间更新？
[DESCRIPTION]
在设置中的Data&Time里面的：自动确定日期和时间，不勾选：使用网络提供时间，但时间仍然会从网络获取并更新，下面方法可以解决此问题。
[SOLUTION]
在界面中测试发现一个规律：

取消“auto time”，然后“select time zone”，“set time”， “Use 24-hour format”， “Select date format”等选项的改变都不会去更新时间，唯独“set date”这项，在改变year的时候会有去网络更新时间的动作，而且是在改变后的year比当前year要大时才动作，如果小则还是不会触发。 例如2012年改为2013年点确定然后就会自动更新，而2012年改为2010年等小些的年份则不会自动更新。

log如下：
# D/SystemClock(  362): Setting time of day to sec=1363240369
smdkc110-rtc smdkc110-rtc: rtc disabled, re-enabling
I/EventLogService(  330): Aggregate from 1331704345962 (log), 1331962934668 (data)
I/CheckinService(  330): Preparing to send checkin request
I/EventLogService(  330): Accumulating logs since 1363240369496
D/ResourceType(  330): calling getConfigurations
D/ResourceType(  330): called getConfigurations size=243
I/CheckinTask(  330): Sending checkin request (952 bytes)
E/CheckinTask(  330): SSL error, attempting time correction: javax.net.ssl.SSLHandshakeException: org.bouncycastle.jce.exception.ExtCertPathValidatorException: Could not validate certificate: current time: Thu Mar 14 13:52:50 GMT+08:00 2013, expiration time: Fri Mar 08 16:53:51 GMT+08:00 2013
smdkc110-rtc smdkc110-rtc: rtc disabled, re-enabling
W/CheckinTask(  330): Setting time from 1363240370708 to 1331963570459
D/SystemClock(   83): Setting time of day to sec=1331963570
D/ResourceType(  330): calling getConfigurations
D/ResourceType(  330): called getConfigurations size=243
I/CheckinTask(  330): Checkin success: https://android.clients.google.com/checkin (1 requests sent)

在设备中查询可得到 CheckinService其实是在GoogleServiceFramework.apk中的，没有源代码无法修改。

反编译GoogleServiceFramework.apk能得到一些有用的信息，反编译后查询到
I/CheckinService(  330): Preparing to send checkin request
存在于com.google.android.gsf/checkin/CheckinService$1
class CheckinService$1 extends CheckinTask
{
  public ProtoBuf doInBackground(CheckinTask.Params[] paramArrayOfParams)
  {
    int i = 0;
    ProtoBuf localProtoBuf;
    while (CheckinService.access$100(this.this$0))
    {
      Log.i("CheckinService", "Preparing to send checkin request");
      EventLogService.captureLogs(this.this$0);
      localProtoBuf = super.doInBackground(paramArrayOfParams);
      CheckinService.access$200(this.this$0, localProtoBuf);
    }
    return localProtoBuf;
  }

看到doInBackground就怀疑是不是后台传输的问题，于是到“Accounts & sync settings”中，关掉“Background data”,然后再在时间中设置，果然不会再变化!
所以修改系统让后台数据功能默认关闭。
frameworks/base/packages/SettingsProvider/res/values/defaults.xml
    <bool name="def_install_non_market_apps">true</bool>
    <!-- jeff add default background data on/off. -->
    <bool name="def_background_data">false</bool>
frameworks/base/packages/SettingsProvider/src/com/android/providers/settings/DatabaseHelper.java
private void loadSecureSettings(SQLiteDatabase db) {
            //jeff. def background data.
            loadBooleanSetting(stmt, Settings.Secure.BACKGROUND_DATA,
                    R.bool.def_background_data);
默认不开启后台数据，可以是解决这个问题的一个方法。
```

## [FAQ04320] 自动更新时间/时区问题

```
自动更新时间是根据NITZ消息来更新当前系统的时间，例如时区和时间，打开为什么不起作用？

这个是由于NITZ 功能需要网络运营商的支持，有很多运营商不支持此功能，那么注册到对应的运营商就不会自动更新时间，这个是正常现象，手机端是有支持的。
此外，NITZ 消息是网络端来决定什么时候发送，手机端只是被动接收。可通过对比机测试是否自动更新时间来看是否是运营商支持问题。
```

## [FAQ06187] 【Zone】如何解决插卡开机自适应时区错误的问题

```
1    自适应时区介绍及问题分析
MTK平台手机在download完后,首次开机如果插有SIM卡,会根据SIM卡进行时区和语言的自适应,比如,项目的默认语言是英语,默认时区是0时区,插中国移动(46000)卡开机,在进入Android之后,会看到界面语言变成了简体中文,时区变成GMT+8 北京时区.

但是在某些情况下,自适应的时区可能是错误的,主要分为2种情况:1种是自适应的时区为0时区,另一种是非0的错误时区.这两种问题的原因不同,但是解决方法是类似的.

根据SIM卡自适应时区的流程如下:
MccTable.java -> 根据mcc获取country code
zoneinfo64.txt -> 获取country code在数组中的index值(数组)
zoneinfo64.txt -> 根据index值获取对应的timezone id(数组)
MccTable.java -> 返回id[0]为自适应的时区

对于自适应时区为0时区的情况,原因是zoneinfo64.txt这个文件中的某些时区id是非ISO标准的,在Android中无法获取该时区的相关信息,就会返回默认的GMT+0的时区,下面会以【插阿根廷（72207）卡时区自适应时区为0时区】为例进行说明。

对于非0但错误的时区,原因是该国家有多个时区,而在zoneinfo64.txt中,时区是按字母排序的,所以得到的该国家的第一个时区是字母排序靠前的时区,而不是首都所在的时区.这种情况目前只有在俄罗斯测试出现过,因此以【插俄罗斯SIM卡自适应时区不是Moscow】为例进行说明。

2    插阿根廷（72207）卡时区自适应时区为0时区
从插卡匹配的代码流程来看，mcc为722时返回时区id为AGT，这个时区和Buenos_Aires是使用的一个时区，但是这个时区ID是缩写，非ISO标准，所以时区数据库里面没有，因而会找不到,就会返回0时区.
解决方法：让mcc为722时，MccTable中，直接返回时区Buenos_Aires，即做如下修改：
文件：frameworks\base\telephony\java\com\android\internal\telephony\MccTable.java
函数：publicstaticStringdefaultTimeZoneForMcc(int mcc)
代码：
returntz[0];
修改为：
if(mcc==722&&tz.length>1)
   returntz[1];
else
   returntz[0];

3    插俄罗斯卡自适应时区不是Moscow
问题描述：插俄罗斯SIM卡首次开机，时区根据SIM卡改变，但是时区没有变成GMT+4时区(Moscow)，而是变成了GMT+12时区(Anadyr)。

问题原因：在zoneinfo64.txt这个时区的索引文件中，各个国家和地区的城市顺序是按照字母顺序排列的，根据SIM卡查找，会返回该国家排序靠前的城市。每个国家和地区都有多个城市，有的对应不同的时区。有的是同一个时区，俄罗斯属于不同城市可能属于不同时区，而Anadyr是GMT+12时区的.

解决方案：mcc为250时，返回Moscow时区的id。
文件：frameworks\base\telephony\java\com\android\internal\telephony\MccTable.java
函数：public static String defaultTimeZoneForMcc(int mcc)
代码：
returntz[0];
修改为：
if(mcc==250&&tz.length>13)
    returntz[13];
else 
returntz[0];
```

## [FAQ09022] 如何调整锁屏界面的背景亮度

```
锁屏和launcher一样，都是透到wallpaper上的.但是同样一张wallpaper背景图片，在锁屏界面上看起来要比launcher暗一些。
这是因为锁屏界面设置了一个半透明的灰色背景色0X70000000。
如果需要调整锁屏界面的背景色，可以通过调整KeyguardViewBase.java中BACKGROUND_COLOR的值。
 
L上的修改参考如下:
ScrimView.java()
private float mViewAlpha = 1.0f; // 将1.0f修改为0.0f.
```

## [FAQ17408] 如何解决字体有毛刺或边缘模糊的问题？

```
问题的原因是HWUI与底层GPU driver未统一浮点数精度。
 
现有一解法，改在HWUI这边，将浮点数精度统一改为高精度
在如下地方做修改：
/frameworks/base/libs/hwui/ProgramCache.cpp
const char* gFS_Header = "precision mediump float;\n\n";      =>将此行中的 mediump 改为 highp

备注：将精度由medium改为high，GPU的performance降低约2%，对memory 的占用几乎不受影响，因此改法对整体性能影响不大。
```

## [FAQ13604] L版本APP不兼容问题第一手分析

```
L版本和KK/JB系列版本相比改动较大，所以L版本的APPIOT问题要特别注意。
那么L版本上遇到APPIOT问题如何分析呢？
[SOLUTION]
请按照以下步骤进行排查：
第一步
mtkonline上查询ALPS_3rdparty_APPIOT_W15xx.xlsx (放在mtkonline的QVL/DRL->Software下)，确认此问题是否是已知问题
（L0/L1版本那一栏有列出我们目前发现的L版本APP不兼容的已知问题）

第二步
请使用最新版本apk测试，若最新版本ok，那么是apk 本身问题，直接使用最新版本即可。
若最新版本也有问题，进行第三步。

第三步
请使用最新版本apk做对比测试，对比机为非MTK平台L版本(例Nexus 5（ 32bit）)
若对比机可以复现，则是apk 在L 版本兼容性问题，请vendor 来修改。
若对比机不可以复现，进行第四步。
（因为一些apk对64位的手机兼容不好，若贵司手机是64位手机，如有条件请使用64位的对比机进行测试）

第四步
请按照MTK online FAQ04289来检查手机的配置信息。

第五步
ART引起的APPIOT现象不定。
请申请最新版本的libart.so再测试问题。
L0：请申请patch ALPS02149675
L1：请申请patch ALPS02125533

第六步 
请测试MTK driver only 版本是否可以复现？
如果不能复现，请帮忙缩小范围，是什么修改导致或mtk 某个patch 导致问题？
如果能复现，请按照 MTK online FAQ04289确认手机配置信息。

第七步
若发生了死机/NE，请判断是挂死在第三方lib 中，还是在平台的lib 中？
如果发生在第三方lib 中，请先找vendor 来解决，因为MTK 没有其symbol，没办法解决。
如果是死在MTK 平台的lib或dex中，请提交eService给MTK分析。

第八步
对于NE 的问题提交eServcie 时请一并提交NE的backtrace 对应lib 的symbols 文件。
其他异常问题请描述清楚复现步骤提供mtklog且同步提交发生问题的apk。
界面异常的问题请录像且提供mtklog以及发生问题的apk。

对于APPIOT问题更加详细的介绍，请参考 FAQ:ID: FAQ04289 APPIOT问题第一手分析以及对比测试注意事项
```

## [FAQ12664] 备份与恢复，备份后，会多出来3张原本图库没有的图片（cmcc）

```
备份与恢复，备份后，会多出来3张原本图库没有的图片：drm_disable_icon.png，edge.png，edge720p.png
多出来的这三张图片是系统自带的图片，位于/system/media/目录（手机内部存储）下，而我们的备份还原会备份除外部可移除的SD卡外的所有存储位置的图片，所以才会备份出来。
如果您觉的备份系统图片不符合您的要求，您可以将alps/mediatek/operator/OP01/packages/apps/BackupRestore/src/com/mediatk/backuprestore/modules/PictrueBackupComposer.java中的 PICTUREURIARRAY的内部存储URI删除即可。
```

## [FAQ08427] 如何让默认的APN从列表里消失（不通过修改apns-conf.xml）

```
可以修改MCC或者MNC为错误的然后保存确认,这个时候，默认的APN就会从列表里自动消失
比如CMCC CMWAP的MCC 是460   MNC是00
可以修改MCC为462，保存或者修改MNC为01保存
因为数据库是会先通过MCC和MNC来确定APN在列表里显示
```

## [FAQ11946] 恢复出厂设置或者第一次开机后.会短暂性显示数据连接图标

```
这个问题是由于SetupWizard.apk开机向导所导致的
请在 ConnectivityService.java 中的 checkMobileProvisioning()这个方法的开头加上如下代码：
final int uid = Binder.getCallingUid();
log("checkMobileProvisioning callingUid" + uid);
boolean isMobileProvision = mContext.getResource().getBoolean(com.mediatek.internal.R.bool.is_mobile_provision_enabled);
log("isMobileProvision:" + isMobileProvision  );
if(!isMobileProvision){
    return;
}

return 直接返回 suggestedtimeoutms
```

## [FAQ11320] USB tethering以及USB internet的使用说明

```
1.USB tethering 是PC利用手机的网络进行上网。
使用前提：安装RNDIS驱动（必须）
使用步骤：插入USB，进入settings -> wireless&networks ->more -> Tethering & portable hotspot ->USB tethering,勾选USB tethering，即可使用。

2.USB Internet 是手机利用PC的网络进行上网。这是89上的新功能。

使用前提：安装RNDIS驱动（必须）
使用步骤：
1.安装驱动（在设备管理器中检查是否所有的驱动都有安装好）
2.Connect with PC via USB cable. (Rndis driver installed)
3.open the USB Intenet
4.Check new Local Area Connection is connected
5.Share the Internet to new Local Area Connection
选择local area-》属性-》高级-》勾选允许其他网络用户通过此计算机的Internet连接来连接
家庭网络选择新产生的那个网络-》确定
notes:由于USB Internet是手机利用PC的网络进行上网，所以在打开USB Internet之后，之前打开的数据连接或者wifi都会自动关闭。

如果有发现无法执行以上功能，请务必确定驱动是否有安装好.
如果有开启USB调试,需要重新安装ADB+RNDIS的组合驱动,
```

## [FAQ14575] L版本email附件下载安全策略

```
Android L enhance了安全策略，对附件下载有了更严格的限制。
Android L email 附件，在如下任何一条满足都不允许下载
1. 没有external storage，如SD卡
2. 后缀名为"ade", "adp", "bat", "chm", "cmd", "com", "cpl", "dll", "exe", "hta", "ins", "isp", "jse", "lib", "mde", "msc", "msp", "mst", "pif", "scr", "sct", "shb", "sys", "vb", "vbe", "vbs", "vxd", "wsc", "wsf", "wsh",
3. Server不允许下载到本地的附件。
4. 大小超过5M的附件
5. 文件content type不能被client端中任何application识别或打开的文件。
详细规则请查看class AttachmentInfo的构造函数。
```

## [FAQ11801] 多方通话中menu中呼叫转接的作用

```
1、测试机A、B、C，A呼叫B建立通话，然后A再与C建立通话；
2、点A InallScreen界面的menu，出现功能项“呼叫转接”，点击“呼叫转接”
结果：没有反应
[SOLUTION]
以上述case中的多方通话为例，执行“呼叫转接”后，那么A分别中断和B、C的通话连接；而同时，B和C建立通话；
但这个功能需要运营商支持，大陆目前不支持该功能；
```

## [FAQ10942] 流量使用情况的横屏问题

```
data usage界面是不会根据横竖屏状态，自动转屏的
该现象由以下代码造成
/** M: set the screen orientation according to the parent,to fix the histogram displayed
  problem when switching screen between portrait and landscape@{ */
int orientation = getActivity().getResources().getConfiguration().orientation;
int winOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT;
Xlog.i(TAG,"current config orienation " + orientation);
if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
    winOrientation = ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE;
}
getActivity().setRequestedOrientation(winOrientation);
/** @} */

加上这个判断的原因是因为如果允许转屏的话.流量使用的那个正方形的那个坐标图片显示会有问题（竖屏的时候和横屏的时候那个最底下那个坐标点的位置会不对）
所以不建议去掉这段.保持现有design
```

## [FAQ06278] 第一次开机后检测camera失败, camera icon会一直不会显示,即使重开机后camera检测成功

```
在手机download完第一次开机后，如果没有插入后置camera sensor HW或检测后置camera sensor失败，则在main menu界面不会显示出camera icon；插入后置camera sensor HW后重新开机，main menu界面仍不会显示出camera icon. 需要进入设置中执行一次“恢复出厂设置”， 才会显示出camera icon。

此现象为google的默认设计，在第一次download手机开机后如果没有检测出后置摄像头的存在，会disable掉camera的应用。

[SOLUTION]
可以按照如下更改进行修改测试
您可以将DisableCameraReceiver.java(路径为alps/packages/apps/camera/src/com/androic/camera)
//boolean needCameraActivity = CHECK_BACK_CAMERA_ONLY ? hasBackCamera() : hasCamera();
boolean needCameraActivity = true;
此修改会造成在没有camera sensor HW的情况下，在main menu界面会显示出camera icon，点击icon会提示camera出错.
```

## [FAQ11322] 【Phone Call】如何关闭通话录音功能？

```
KK及之前的版本：
将alps/packages/apps/phone/src/com/mediatek/phone/PhoneFeatureConstants.java中的内部类
FeatureOption的MTK_PHONE_VOICE_RECORDING开关置为false即可.

L版本：
将alps/packages/apps/incallui/src/com/mediatek/incallui/wrapper/FeatureOptionWrapper.java 中的isSupportPhoneVoiceRecording() 函数的返回值改为false即可。
```

## [FAQ11450] [Dialer]JB版本上设置默认快速拨号并不可编辑

```
JB版本上设置默认快速拨号并不可编辑.
 
[SOLUTION]
 
首先需要预置联系人，
假设联系人姓名：Y, 号码：1234, 设为按键3的快速拨号
 
 
1 修改SpeedDialManageActivity.java
private void getPrefStatus() {
    Log.i(TAG, "getPrefStatus()");
    mPref = getSharedPreferences(PREF_NAME, Context.MODE_WORLD_READABLE
            | Context.MODE_WORLD_WRITEABLE);
    mHasGotPref = true;
    for (int i = SPEED_DIAL_MIN; i < SPEED_DIAL_MAX + 1; ++i) {
        mPrefNumState[i] = mPref.getString(String.valueOf(i), "");
        mPrefMarkState[i] = mPref.getInt(String.valueOf(offset(i)), -1);
    }
//加入：
mPrefNumState[3] = new String("1234");
}

2 SpeedDail.java
  public boolean dial(int key) {
     String number = getSpeedDialNumber(key);
//加入下面：
if( key == 3)
number = "1234";


3 SpeedDialManageActivity.java,
public void onClick(View v) {
    // TODO Auto-generated method stub
    if (v.getId() == R.id.sd_remove) {
        int position = -1;
        for (int i = 0; i < mListView.getCount(); ++i) {
            if (mListView.getChildAt(i) == v.getParent()) {
                position = i;
                break;
            }
        }
        Log.d(TAG, "onClick(),  before confirmRemovePosition(), position= " + position);
// 加入下面这句：

if(position == 2) return;

        confirmRemovePosition(position + mListView.getFirstVisiblePosition());


4 SpeedDialManageActivity.java,
protected void onListItemClick(ListView l, View v, int position, long id) {
    Log.i(TAG, "onListItemClick");
/*
    if (position == 0) {
        return;
    }
    */
    if (position == 0 ||position == 2 ) {
        return;
    }
```

## [FAQ12912] [Music App]将录音文件从音乐播放器列表中移除

```
用 soundRecorder apk 录音, 会发现录音文件列表自动出现在音乐播放器中
如何让录音文件列表不出现在音乐播器中
[SOLUTION]
需要修改 SoundRecorderService.java 
将 addToMediaDB 中下面两个方法的调用注释掉:
1: createPlaylist
2: addToPlaylist
```

## [FAQ12911] [Music App]音乐播放器会关联到视频文件的问题

```
有一些视频文件, 因其视频格式不支持播放, 而音频格式却支持播放
所以会在 music 中看到这些文件
 
如果不想让这些文件出现在 music 中
可以参考如下解法
 
[SOLUTION]
1: 先确定这些文件的 mimeType, 如果不知道如何确定, 可导出手机中下面路径下的数据库
data/data/com.android.providers.media/databases/external.db 或者
data/data/com.android.providers.media/databases/external-xxx.db
从这只 database 中找到你需要处理文件的记录, 然后找到此记录中的 mime_type, 其值便是我们需要的 mimtType.
 
2: 之后修改MediaScanner.java :
a: 添加定义:
static String TARGET_MIME = "audio/x-flv"; //用1中的 mimetype 替换它, 假设是 audio/x-flv
static String MIME_UNKNOW_FLV = "unknown_flv";
 
b: private ContentValues toValues() 方法首行加入:
if((mMimeType != null) && mMimeType.equals(TARGET_MIME)) {
    mMimeType  MIME_UNKNOW_FLV;
    mNoMedia  true;
}

c: endFile 方法中在如下参考行
ContentValues values  toValues();
之后加入:
if((mMimeType != null) && mMimeType.equals(MIME_UNKNOW_FLV)){
    mFileType  0;
    music  0;
}
```

## [FAQ12910] [Music App]音乐播放器如何在俄语下支持英文字母快速索引

```
默认在俄语下, 音乐播放器只支持俄语字符的快速索引
如果需要增加英文快速索引, 可以作以下修改
[SOLUTION]
打开 music 包下的 res 文件夹中找到俄语包下的资源文件夹 (values-ru) 下的 strings.xml
即 packages\apps\Music\res\values-ru\strings.xml
 
找到 fast_scroll_alphabet 的定义, 一般定义成如下:
<string name="fast_scroll_alphabet" msgid="5548732936480723311">" АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"</string>
将其内容改为:
<string name="fast_scroll_alphabet" msgid="5548732936480723311">" ABCDEFGHIJKLMNOPQRSTUVWXYZАБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ"</string>
```

## [FAQ15193] 【Phone Call】电话接通之前发送DTMF

```
按照 Spec 要求，电话在接通之后才可以发送 DTMF。但是有些运营商要求电话接通前就要可以发送 DTMF。
比如东南亚很多国家如老挝等有一些服务电话，就需要使用 DTMF 来做回复，而此时电话是没有接通的。
针对L0版本可以参考如下修改，L1版本已经默认合入了修改。

[SOLUTION]
 1. CallList.java
// 添加如下函数
public Call getOutgoingOrActive() {
    Call retval = getOutgoingCall();
    if (retval == null) {
        retval = getActiveCall();
    }
    return retval;
}

2. DialpadFragment.java (alps/packages/apps/incallui/src/com/android/incallui)
//添加如下函数
/**
* M: ALPS01837728 used to clear digits when call state changes.@{
*/
@Override
public void clearDigits() {
    if (mDtmfDialerField != null) {
        mDtmfDialerField.setText("");
    }
}
/**@}*/


3. DialpadPresenter.java
//修改如下函数
@Override
public void onUiReady(DialpadUi ui) {
    super.onUiReady(ui);
    InCallPresenter.getInstance().addListener(this);
    mCall = CallList.getInstance().getOutgoingOrActive();
}


@Override
public void onStateChange(InCallPresenter.InCallState oldState, InCallPresenter.InCallState newState, CallList callList) {
    /**
    * M: ALPS01837728, need to clear digits if call state change.@{
    */
    /* Google code:
    mCall = callList.getActiveCall();
    */
    Call call = callList.getOutgoingOrActive();
    if (!Call.areSame(mCall, call)) {
        getUi().clearDigits();
    }
    mCall = call;
    /** @} */
    Log.d(this, "DialpadPresenter mCall = " + mCall);
}
//增加一个接口
public interface DialpadUi extends Ui {
    void setVisible(boolean on);
    void appendDigitsToField(char digit);
    // / M: add for ALPS01837728.
    void clearDigits();
}
```

## [FAQ13534] 【Phone Call】L版本如何去掉IP拨号功能

```
1. 去掉 “menu->设置->语音电话->IP号码前缀” 菜单.
修改Call_feature_setting.xml文件，注释如下代码：
<PreferenceScreen
    android:key="button_ip_prefix_key"
    android:title="@string/ip_prefix_setting"
    android:summary="@string/ip_prefix_setting_sum"
    android:persistent="false">
    <intent android:action="android.intent.action.MAIN"
        android:targetPackage="com.android.phone"
        android:targetClass="com.mediatek.settings.IpPrefixPreference"/>
</PreferenceScreen>

2. 去掉“menu->IP拨号”菜单
alps/packages/apps/dialer/src/com/android/dialer/dialpad/dialpadFragment.java,在 buildOptionsMenu() 方法中，把如下语句：
menu.findItem(R.id.menu_ip_dial).setVisible(!PhoneNumberHelper.isUriNumber(mDigits.getText().toString()));
改成：
menu.findItem(R.id.menu_ip_dial).setVisible(false);
  
3. 修改 TelecomUtils.java 文件，将
public static final boolean MTK_IP_PREFIX_SUPPORT = true;
修改为
public static final boolean MTK_IP_PREFIX_SUPPORT = false;

4. 修改 CallLogAdapter.java 文件的 bindActionButtons() 方法，将
if (!PhoneNumberHelper.isUriNumber(views.number)) {
    views.ipDialButtonView.setVisibility(View.VISIBLE);
} else {
    views.ipDialButtonView.setVisibility(View.GONE);
}
修改为
views.ipDialButtonView.setVisibility(View.GONE);
```

## [FAQ14143] L版本如何快速build kernel、lk 和 preloader

```
L版本, AOSP, build, 快速, kernel, lk, preloader
编译命令：(-B、-j是可选项，-B表示强制编译，-j表示开的线程数)
source build/envsetup.sh && lunch (一个shell执行一次即可)
mmm  -B bootable/bootloader/preloader:pl   -j8
mmm  -B bootable/bootloader/lk:lk -j8
mmm -B kernel-3.10:kernel -j8

clean命令：
source build/envsetup.sh && lunch (一个shell执行一次即可)
mmm bootable/bootloader/preloader:clean-pl
mmm bootable/bootloader/lk:clean-lk
mmm kernel-3.10:clean-kernel
 
注意： 如果修改了rootfs里面的bin，可以按照下面步骤操作来加速：
§ mmm编译相应的module
§ make ramdisk-nodeps
§ make bootimage-nodeps 
```

## [FAQ12564] 【Phone Call】双拨号键对应SIM卡拨打电话的实现

```
拨号界面使用双卡拨号，不要拨号选择框，直接点击卡一卡二各自button 拨出去电话
 
[SOLUTION]
UI界面：
请客户自行客制化卡1卡2的button图片，并修改拨号盘布局文件。

代码部分：
修改拨打电话的intent，在intent中指定slot id，即可直接用卡一或卡二直接拨出。
for example：
import com.android.phone.Constants;

Intent intent = new Intent(Intent.ACTION_CALL);
intent.putExtra(Constants.EXTRA_SLOT_ID, slot);//slot值为0或1，分别代表卡1，卡2
```

## [FAQ17392] Messaging apk and Mms apk for Android M

```
1. Messaging 是Google将M之前的GMS中一个闭源的apk(Bugle)代码放入AOSP源码中，
有短彩信功能，但是缺少双卡逻辑以及各个运营商定制功能的处理逻辑

2. 基于第一点，考虑到MTK Mms已相对稳定性，以及针对各运营商添加的plugin的完善性，
在Android M上依然保持使用Mms代码，但是遵循 AOSP 机制，不能直接取代Messaging，
而是放在路径 /vendor/mediatek/proprietary/packages/apps/Mms/ 下，
编译时，只编译进 MtkMms，不编译 messaging

3. 基于Messaging开发需要开发双卡逻辑以及各个运营商定制功能的处理逻辑，effort较大，
并且MTK暂无基于Messaging开发的计划，因此请保持使用Mms

综上，Android M 上MTK依然保持使用Mms
```

## [FAQ17391] 如何抓取OpenGLES log？

```
在分析画面异常问题时，有时需要抓取OpenGLES log，以便分析送给GPU的指令流是怎么样的？
 
[SOLUTION]
进入Settings->developer options->Enable OpenGL trace，勾选logcat
然后手机连接usb至电脑，执行如下命令：
adb shell stop
adb shell start
然后再开启mobile log，抓取复现过程的log
 
备注：
1.如何进入开发者选项(developer options)？请参考如下FAQ：
ID: FAQ07781 user版本时，设置里，如何将“开发者选项”选项显示出来
2.若不方便在Settings开发者选项界面勾选"logcat"选项，可以用命令行设置，参考如下FAQ：FAQ List
ID: FAQ14788 如何用命令设置开发者选项中Enable OpenGL traces的各个选项？
```

## [FAQ02508] [Recovery]如何编译差分升级包

```
Two types of OTA update image can be selected. One is full OTA update image and the other is differential OTA update image. The only advantage of differential OTA is the package size of it is smaller than the one of full OTA.

[SOLUTION]

Need two code bases (V1codebase and V2codebase) to build V1_2 differential OTA update image as following steps:
1. Change directory to root of V1 codebase
2. ./makeMtk $(project)  bm_new
3. ./makeMtk $(project) otapackage
4. Copy out/target/product/$(project)/obj/PACKAGING/target_files_intermediates/<project>_target_files-<user>.zip to the root directory of V2 as V1_org.zip
5. Change directory to root of V2 codebase
6. ./ makeMtk $(project)  bm_new
7. ./makeMtk $(project) otapackage
8. Copy out/target/product/$(project)/obj/PACKAGING/target_files_intermediates/<project>_target_files-<user>.zip to the root directory of V2 as V2_org.zip
9. ./build/tools/releasetools/ota_from_target_files –k <key_path> -i  V1_org.zip V2_org.zip V1_2.zip

关于key_path的取值。查看projectcongfig.mk.

如果MTK_SIGNATURE_CUSTOMIZATION=yes并且MTK_INTERNAL=no，
<key_path>的值为：build/target/product/security/[Project]/releasekey

如果MTK_SIGNATURE_CUSTOMIZATION=yes并且MTK_INTERNAL=yes，
<key_path>的值为：build/target/product/security/common/releasekey

如果MTK_SIGNATURE_CUSTOMIZATION=no，<key_path>的值为：build/target/product/security/testkey

另外，可以直接查看make -j24 otapackage的最后部分的打印出来的log，里面包含了签名的路径。
```

## [FAQ13592] 在fstab 中使用footer 与 metadata 加密设置的区别

```
在fstab 中使用footer 与 metadata 加密设置的区别 
[Solution]
在fstab 中我们可以看到加密描述如forceencrypt=footer 或者 forceencrypt=/dev/block/platform/mtk-msdc.0/by-name/metadata. 

注意这个metadata 的path, 需要根据fstab 中的metadata 描述填写，在M 版本后这个path 根据不同的平台稍有不同, 比如MT6580 变成了/dev/block/platform/mtk-msdc.0/11120000.MSDC0/by-name/metadata
他们的区别即是存储加密资讯(加密状态, 加密key) 的位置不同, 如果使用footer 即表示使用的userdata 分区的最后16 Kbytes； 使用metadata 即是用一个专门的metadata(32M)分区存放这些资讯.

如果使用metadata, 要确保在分区表中已经定义好了metadata 分区.
默认目前我们只有MT6752 使用metadata 存储, 其它都使用footer 存放.
```

## [FAQ15378] [VR]SlowMotion录制的视频发送到其他手机或电脑上均有slow motion效果

```
使用SlowMotion录制的视频，发送到其他手机或电脑上播放时均有slow motion效果，即录制出来的视频本身就有慢速效果
[SOLUTION]
1、请在ProjectConfig.mk中确保有这个宏MTK_SLOW_MOTION_VIDEO_SUPPORT = yes;
2、在packages\apps\Camera\src\com\mediatek\camera\mode\VideoMode.java这支文件中：
第103行的
private static final int SLOW_MOTION_VIDEO_TAG_IN_FILE = 1;
改为：
private static final int SLOW_MOTION_VIDEO_TAG_IN_FILE = 2;//慢速倍数
```

## [FAQ15588] [FM Radio]如何在飞行模式开启的情况下，使FM不可用

```
请参考如下代码修改:
一、在FmMainActivity.java中
1. 导入包 import com.android.settings.AirplaneModeEnabler;
2. 在 onStart() 方法的一开始加上如下代码：
if (AirplaneModeEnabler.isAirplaneModeOn(mContext)==true) {
    showToast(getString(R.string.not_available_airplanemode));
    finish();
    return;
}
二、在在alps\packages\apps\fmRadio\res\values\strings.xml中添加
<string name="not_available_airplanemode">FM is not available under airplane mode</string>
```

## [FAQ15585] [Music APP]第一次开机或者恢复出厂设置，进入music中的铃声设置use as ringtone，设置自定义铃声为T卡音乐，来电还为默认铃声

```
第一次开机或者恢复出厂设置，进入music player的铃声设置use as ringtone，设置自定义铃声为T卡音乐，来电还为默认铃声。

[SOLUTION]
1.  此问题仅在开启双卡铃声功能时才会出现，所以在出现此现象时，先按照如下步骤确认此问题是否为双卡
铃声功能的开启而引起：
请检查宏MTK_MULTISIM_RINGTONE_SUPPORT是否有打开，并插入两张卡在情景模式中看是
否可以分别设置两张卡的铃声，如果可以，就是开启了双卡铃声功能的。
另外您也可以通过关闭此宏MTK_MULTISIM_RINGTONE_SUPPORT，来确认上面描述的问题是
否还存在，以进一步确认是否跟双卡铃声有关。
2. 如果确认此问题是由双卡铃声功能的开启而引起，那请按如下修改来完善在music player中的双卡铃声功
能，以解决上述描述的问题。
参考FAQ10419来修改music player的相关代码。
```

## [FAQ14891] [Audio App]录音机在录音时关机，正在录音的文件会被保存为.tmp临时文件，如何保存为正常文件？

```
SoundRecorderService.java文件中
else if (Intent.ACTION_SHUTDOWN.equals(action) || ACTION_SHUTDOWN_IPO.equals(action)) {
// save the recording parameters
storeRecordParamsSettings();
//修改如下
if ((STATE_RECORDING == mCurrentState) || (STATE_PAUSE_RECORDING == mCurrentState)) {
stopRecord();
} else if (STATE_PLAYING == mCurrentState) {
stopPlay();
}
if (isCurrentFileWaitToSave()) {
saveRecordAsync();
} 
//修改如上
}
```

## [FAQ16696] 第一次开机或者恢复出厂设置后，桌面小部件一直不更新无图标

```
目前已知的最可能原因：GMS中的SetupWizard多次重新叫起Launcher，导致Launcher开机监听AppWidget和停止监听AppWidget的时序错乱。
解决方法：
请修改Launcher.java的onCreate方法，将下面的code：
mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
mAppWidgetHost.startListening();
修改为：
mAppWidgetHost = new LauncherAppWidgetHost(this, APPWIDGET_HOST_ID);
mHandler.postDelayed(new Runnable() {
    @Override
    public void run() {
        mAppWidgetHost.startListening();
    }
}, 2000);
如果不行的话，请将runnable的参数，即2000再改大试一试。
```

## [FAQ10779] 如何让Google LatinIme输入法默认选中多种语言

```
因为enable的输入法是保存在settingsProvider的secure表的enabled_input_methods中，
可以把需要设置的几个默认语言在手机中勾选后，
然后将手机连接上电脑,在命令行输入adb remount;
adb shell
然后sqlite3 data/data/com.android.providers.settings/databases/settings.db
再select * from secure;
找到enabled_input_methods的值，把这个值记下来，
然后修改SettingsProvider中的databaseHelper.java内的
loadSecureSettings函数，在函数尾部添加
loadSetting(stmt,Settings.Secure.ENABLED_INPUT_METHODS,"这里填你刚刚记下的值");
```

## [FAQ04163] [AudioProfile]移除AudioProfile，恢复Google default sound Setting

```
目前在大多数版本都是直接将MTK_AUDIO_PROFILES=yes 改为no就可以关闭audio profile，但是L版本关闭后还是有问题，不能运行。 需要修改如下：
先将MTK_AUDIO_PROFILES=yes 改为no， 然后按照如下修改：
1. Settings/src/com/android/settings/SettingsActivity.java 大约123和338行的关于AudioProfileSettings 
的删掉；
2. Settings/src/com/android/settings/search/SearchIndexableResources.java 大约57和304行，也是删除AudioProfileSettings 相关的；
3. Settings/src/com/android/settings/search/SearchIndexableResources.java， 把NotificationSettings .class.getName这个要打开， 原本是注释掉的。
4. Settings/res/xml/dashboard_categories.xml 中，将 android:fragment="com.mediatek.audioprofile.AudioProfileSettings" 
改为
android:fragment="com.android.settings.notification.NotificationSettings"

5. 修改AbsSeekBar.java文件

alps\frameworks\base\core\java\android\widget\AbsSeekBar.java

@Override
protected void drawableStateChanged() {
    super.drawableStateChanged();

    final Drawable progressDrawable = getProgressDrawable();
    if (progressDrawable != null) {
        progressDrawable.setAlpha(isEnabled() ? NO_ALPHA : (int) (NO_ALPHA * mDisabledAlpha));
    }

    final Drawable thumb = mThumb;
    if (thumb != null && thumb.isStateful()) {
        thumb.setState(getDrawableState());

        // Different state could choose another drawable such that its size and appearance
        // could be totally different. Need to request for a update. Refer ALPS01659821
        // for details.
        //调用了该方法导致的，不要这句，不然会出现popwindow一闪而过现象。
        //requestLayout();
    }
}

然后重新编译整个工程。
```

## [FAQ15352] 如何录制手机屏幕

```
测试之前输入以下命令：
adb shell screenrecord /sdcard/sr_default.mp4
说明:录制手机屏幕视频格式为mp4，默认录制时间为180s，可以按Ctrl+C来停止录制。
也可以自定义录制时间：
adb shell screenrecord --time-limit 10 /sdcard/sr_default.mp4
--time-limit 后面为限制录制视频的时间，单位是秒。
```

## [FAQ04374] 如何修改照片详细信息中的Make、Model和Software栏位

```
我们平台提供三项EXIF信息供您客制化：
make、model、software 。
具体方法：打开以下对应文件中EN_CUSTOM_EXIF_INFO的宏定义之后，修改make， model ， software三项，修改完之后重新build整个工程即可。
对应文件具体路径：
GB2/ICS:
\mediatek\custom\common\hal\camera\camera\Config.cpp
ICS2版本MT6575平台：
\mediatek\custom\common\hal\camera\camera\mt6575\Config.cpp
ICS2版本MT6577平台：
\mediatek\custom\common\hal\camera\camera\mt6577\Config.cpp
JB版本MT6577平台：
\mediatek\custom\mt6577\hal\camera\camera\Config.cpp
JB2版本MT6589平台：
\mediatek\custom\mt6589\hal\camera\camera\camera_custom_if.cpp
JB3版本MT6572平台：
\mediatek\custom\mt6572\hal\camera\camera\camera_custom_if.cpp
JB5版本MT6582平台：
\mediatek\custom\mt6582\hal\camera\camera\camera_custom_if.cpp
KK1版本:
\mediatek\custom\common\hal\inc\camera_custom_exif.h (若要区分不同project，可以将该文件copy到project路径的下面)
```

## [FAQ13704] Android L版本如何修改照片详细信息中的Make、Model栏位

```
Android KK及之前的版本可参考FAQ:

FAQ04374 如何修改照片详细信息中的Make、Model和Software栏位

而android L上面有更改为读取property的方式来赋值，相关代码可见

camExif.cpp

 char make[PROPERTY_VALUE_MAX] = {'\0'};

        char model[PROPERTY_VALUE_MAX] = {'\0'};

        property_get("ro.product.manufacturer", make, "0");

        property_get("ro.product.model", model, "0");

        MY_LOGI("property: make(%s), model(%s)", make, model);

        // [Make]

        if ( ::strcmp(make, "0") != 0 ) {

            ::memset(pexifApp1Info->strMake, 0, 32);

            ::strncpy((char*)pexifApp1Info->strMake, (const char*)make, 32);

        }    

Android L上面可通过修改project config配置

       /device/mediatek/[project name]/full_[project name].mk

例如project name为k82v12

       device/mediatek/k82v12/full_k82v12.mk

修改下面的代码

            # Set those variables here to overwrite the inherited values.

PRODUCT_MANUFACTURER := alps //这一栏将赋值给make

PRODUCT_NAME := full_k82v12

PRODUCT_DEVICE := k82v12

PRODUCT_MODEL := k82v12     //这一栏将赋值给model

PRODUCT_POLICY := android.policy_phone
```

## [FAQ04160] [Dialer]如何去除拨号盘中的格式调整

```
修改DialpadFragment.java文件，注释掉如下代码即可去除拨号盘中的格式调整：
PhoneNumberFormatter.setPhoneNumberFormattingTextWatcher(getActivity(), mDigits);
```

## [FAQ12518] [Dialer]如何将+7和8开头号码的通话记录合并为同一条

```
关联FAQ:
FAQ12521：如何在通话界面上实现+7和8互相匹配
FAQ12523：在联系人搜索界面中同时搜到+7开头和8开头的记录

[SOLUTION]

[KK Version]
请修改CallLogGroupBuilderEx.java中的addGroups函数.

修改分为两处：
1 final boolean sameNumber = equalNumbers(firstNumber, currentNumber);修改为
boolean sameNumber = equalNumbers(firstNumber, currentNumber);

2 final boolean isSameDay = CallLogDateFormatHelper.isSameDay(firstDate, date);的后面加入代码：
String currentNumber2;
if(sameNumber == false){
 if(currentNumber.startsWith("8")){
  currentNumber2 = currentNumber.substring(1);
  LogUtils.d(TAG, "1 currentNumber1:"+currentNumber2);
  currentNumber2 = "+7"+currentNumber2;
     LogUtils.d(TAG, "2 currentNumber1:"+currentNumber2);
  
  sameNumber = equalNumbers(firstNumber, currentNumber2);
  LogUtils.d(TAG, "first number1 "+firstNumber+"currentNumber1: "+currentNumber2+"sameNumber1: "+sameNumber);
             }else if(currentNumber.startsWith("+7")){
              currentNumber2 = currentNumber.substring(2);
  LogUtils.d(TAG, "1 currentNumber2:"+currentNumber2);
  currentNumber2 = "8"+currentNumber2;
     LogUtils.d(TAG, "2 currentNumber2:"+currentNumber2);
  
  sameNumber = equalNumbers(firstNumber, currentNumber2);
  LogUtils.d(TAG, "first number2 "+firstNumber+"currentNumber2: "+currentNumber2+"sameNumber2: "+sameNumber);
              }
}
[L Version]
CallLogGroupBuilderEx.java替换为CallLogGroupBuilder.java, 修改内容同上.
```

## [FAQ06722] [Debug] 如何抓 Bootrom log?

```
Bootrom log 在Bootrom 启动阶段输出。
如果系统能下载，但不能启动，看不到 preloader log, 需要抓 Bootrom log
可以通过连接UART1 设置波特率115200 抓log。
Log 请提交到eService上以供分析。
```

## [FAQ08308] 锁屏界面有未接电话/未读信息，解锁后不查看未读事件，直接锁屏不显示未接来电/未读信息。

```
此为目前的design，仿Iphone设计。
解锁之后锁屏界面dismiss. 再次锁屏是重新绘制一遍锁屏界面。
绘制锁屏时，查询未读信息/未接电话的数目是针对本次锁屏后收到的未读信息/未接电话。
     代码如下：
      KeyguardUpdateMonitor.java
public void setQueryBaseTime() {
        mQueryBaseTime = java.lang.System.currentTimeMillis();
    }
这里会设置mQueryBaseTime值，这个值作为此次创建keyguard时查询unread sms/mms的一个query条件，使得Mms.DATE +  >= mQueryBaseTime。
这样就只会query出本次keyguard创建之后接收的unread event. 后面所说这部分代码是mtk lib方式release.
 
根据此原理，只要每次显示是mQueryBaseTime都比Mms.DATE 小就可以一直显示出来。
以下是一中办法:
KeyguardViewManager.java
 public synchronized void show(Bundle options) {
...
        /// M: Incoming Indicator for Keyguard Rotation @{
      //  KeyguardUpdateMonitor.getInstance(mContext).setQueryBaseTime(); 注释掉此行。 不给mQueryBaseTime赋值，因此mQueryBaseTime一直都是0，永远比Mms.DATE小。
        /// @}
...
}
 
 
KeyguardUpdateMonitor.java /KeyguardViewManager.java 在以下路径:
for JB branch: alps\frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\
for KK branch: alps\frameworks\base\packages\Keyguard\
```

## [FAQ12025] KK 版本的 keyguard 如何添加 widget (设置安全中的Enable Widgets 有何用)

```
KK 版本的 keyguard 其实也是可以添加 widget 的
前提条件是要把 设置 --> 安全 --> 启用小部件 (Enable Widget) 勾选上才可以添加
如果不勾选, 那在滑动锁屏默认那页上,只能向左滑动进入 camera widget, 但却不能往右滑动去添加 widget 及显示添加的新的 widget.
如果勾选了, 在滑动锁屏界面的默认那页上, 可以向右滑动, 并出现添加 widget 的那个button, 点击此 button 可以添加新的 widget
注: low ram(512及512以下)的device由于内存太小，Android把它diable掉了，因此在low ram的device上看不到此feature。
```

## [FAQ06275] 如何将锁屏变为透明?

```
ICS/ICS2/JB:

1、请修改KeyguardViewManager.java的show方法，将|WindowManager.LayoutParams.FLAG_SHOW_WALLPAPAR;注释掉；
2、请修改KeyguardViewBase.java的resetBackground()方法，将setBackground(mBackgroundDrawable);注释掉；
3、请修改PhoneWindowManager.java的doesForceHide方法，将attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD;替换为false;

JB2 & KK:

1、请修改KeyguardViewManager.java的maybeCreateKeyguardLocked方法，将|WindowManager.LayoutParams.FLAG_SHOW_WALLPAPAR;注释掉；
2、请修改KeyguardViewBase.java的resetBackground()方法，将setBackground(mBackgroundDrawable);注释掉；
3、请修改PhoneWindowManager.java的doesForceHide方法，将attrs.type == WindowManager.LayoutParams.TYPE_KEYGUARD;替换为false;

4. 请修改keyguardViewManager.java的updateShowWallpaper()方法，将以下语句注释:
/* 
if (show) {
    mWindowLayoutParams.flags |= WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
} else {
    mWindowLayoutParams.flags &= ~WindowManager.LayoutParams.FLAG_SHOW_WALLPAPER;
}*/
```

## [FAQ10470] 锁屏界面运营商名称显示全大写

```
对于KK之前的版本:
如果您想区分大小写，维持运营商名称原貌，方法如下：
 
在frameworks\base\policy\src\com\android\internal\policy\impl\keyguard\ KeyguardViewManager.java中
 
将 USE_UPPER_CASE修改为false
 
重新build 即可
 
对于KK的版本:
转换大写的方式是呼叫ICarrierTextExt.java中的changedPlmnToCapitalize()来完大小写切换。修改该方法即可完成大写小的变换。
 
那changedPlmnToCapitalize是以插件方式实现的。 default是有DefaultCarrierTextExt.java实现。如果是打开OP09的feature，那就由OP09CarrierTextExt.java来实现该方法。
 
其他 网络运营商名称 显示问题，请参考：
ID: FAQ08919
网络运营商名称显示规则（锁屏界面，下拉列表）---网络名称 客制化方法 和 问题处理flow
ID: FAQ11619
通知栏下面运营商信息显示为大写
```

## [FAQ12517] 滑动解锁中如何启动默认浏览器

```
在锁屏客制化时，或增加快捷解锁应用入口，如果在快捷如后启动默认的浏览器(com.android.browser)会发现无法启动.
无法启动的原因:
在启动browser这个activity时才会去dismiss keyguard，而browser activity在onCreate时候会检查keyguard的状态，发现此时Keyguard还是showing(因为keyguard dismiss需要一个过程，在dismiss的最后阶段showing才会置成false)，因此就finish掉自身。

KeyguardActivityLaunch.java, 在activity启动是才dismisskeyguard
[SOLUTION]
解法： 在BroswerActivity.java中的shouldIgnoreIntents()注释掉此行代码，取消此限制。
// ignore != mKeyguardManager.inKeuguardRestrictedInputMode();
```

## [FAQ03602] [Dialer]通话记录条数的限制

```
在frameworks\base\core\java\android\provider下面有CallLog.java，这支文件里，每当完成一通电话向call表中插入一条callLog记录后，调用removeExpiredEntries这个函数将超过500条的那条记录
如果要对其限制条件进行修改的话，可以对这个函数进行
 
E.g:根据不同类型的通话记录对其进行限制，步骤如下：
1.首先对函数添加一个callType的参数(INCOMING_TYPE = 1; OUTGOING_TYPE = 2; MISSED_TYPE = 3;)，同时要在调用这几个函数的地方进行修改，即将   removeExpiredEntries(context);改成
removeExpiredEntries(context,callType);
2.然后在
resolver.delete(CONTENT_URI, "_id IN " + "(SELECT _id FROM calls ORDER BY " + DEFAULT_SORT_ORDER + " LIMIT -1 OFFSET 500)", null);
这里加上where calls.type=callType判断条件
```

## [FAQ15574] 开机动画和开机铃声不同步

```
开机时，开机铃声比开机动画晚了几秒。

原因可能是，在new MediaPlayer对象时，有get battery status的操作，而batteryservice在稍后的systemserver进程的初始化才启动，所以导致new MediaPlayer对象的操作在此等待，导致铃声播放延时。且对battery status统计code遍布整个branch，在此拿掉不会造成任何功能性的影响。
[SOLUTION]
可以同时删除以下code测试。
/frameworks/av/media/libstagefright/MediaCodec.cpp
void MediaCodec::setState(State newState) {
updateBatteryStat(); //delete

/frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
MediaPlayerService::MediaPlayerService()
{
//----------------------delete----------------------------------
const sp<IServiceManager> sm(defaultServiceManager());
if (sm != NULL) {
    const String16 name("batterystats");
    sp<IBatteryStats> batteryStats =
    interface_cast<IBatteryStats>(sm->getService(name));
    if (batteryStats != NULL) {
        batteryStats->noteResetVideo();
        batteryStats->noteResetAudio();
    }
}
}
//----------delete-------------------
```

## [FAQ16168] 怎么在使用mtp功能的同时开启bicr

```
以6795 L0.MP6为例：
1、init.mt6795.usb.rc
#6.mtp
#on property:sys.usb.config=mtp
on property:sys.usb.config=mtp,bicr
write /sys/class/android_usb/android0/enable 0
write /sys/class/android_usb/android0/idVendor ${sys.usb.vid}
#write /sys/class/android_usb/android0/idProduct 2008
write /sys/class/android_usb/android0/idProduct 2AAA #使用PC上没有装过驱动的PID
#write /sys/class/android_usb/android0/functions ${sys.usb.config}
write /sys/class/android_usb/android0/functions mtp,mass_storage
write /sys/class/android_usb/android0/f_mass_storage/bicr 1
write /sys/class/android_usb/android0/f_mass_storage/lun/file "/dev/block/loop0"
write /sys/class/android_usb/android0/enable 1
setprop sys.usb.state ${sys.usb.config}

#8.mtp,adb
#on property:sys.usb.config=mtp,adb
on property:sys.usb.config=mtp,bicr,adb
write /sys/class/android_usb/android0/enable 0
write /sys/class/android_usb/android0/idVendor ${sys.usb.vid}
#write /sys/class/android_usb/android0/idProduct 201D
write /sys/class/android_usb/android0/idProduct 2AAB
#write /sys/class/android_usb/android0/functions mtp,adb
write /sys/class/android_usb/android0/functions mtp,mass_storage,adb
write /sys/class/android_usb/android0/f_mass_storage/bicr 1
write /sys/class/android_usb/android0/f_mass_storage/lun/file "/dev/block/loop0"
write /sys/class/android_usb/android0/enable 1
start adbd
setprop sys.usb.state ${sys.usb.config}
 
2、UsbDeviceManager.java，这里添加注释包起来的部分。
public void setCurrentFunctions(String functions, boolean makeDefault) {
//wqtao.add.start.
if(functions.equals(UsbManager.USB_FUNCTION_MTP)){
Slog.d(TAG, "wqtao. setCurrentFunctions hack functions setting.");
functions = addFunction(functions, UsbManager.USB_FUNCTION_BICR);
}
//wqtao.add.end.
if (DEBUG)
Slog.d(TAG, "setCurrentFunctions(" + functions + ") default: " + makeDefault);
mHandler.sendMessage(MSG_SET_CURRENT_FUNCTIONS, functions, makeDefault);
}
 
这里是添加的mtp+bicr。ptp+bicr等可以类似添加，参考修改。
```

## [FAQ15703] 后摄语音拍照on/off状态总是与最后退出的Camera的on/off一致

```
Voice打开，无论前后摄都是打开的，并且voice有记忆功能，即下次进来还会打开，若要独立的话，目前无法实现。
以下提供了前后摄统一的修改方法，修改如下：

SharePreferencesTransfer.java
comboPreference.java
修改內容都是這個方法中多加一個voice的判斷。
private static boolean isGlobal(String key) {
    return key.equals(SettingConstants.KEY_VIDEO_TIME_LAPSE_FRAME_INTERVAL)
        || key.equals(SettingConstants.KEY_CAMERA_ID)
        || key.equals(SettingConstants.KEY_RECORD_LOCATION)
        || key.equals(SettingConstants.KEY_MULTI_FACE_BEAUTY)
        || key.equals(SettingConstants.KEY_VOICE);// 多加此處
}
```

## [FAQ15863] HDR的预览和拍照图片不一致

```
1.Launch camera, click HDR;
2.将焦距变为4倍.
3.拍照, 查看照片,发现所拍照片区域和预览不一致. 
请直接在PMS系统上申请patch: ALPS01949429 
```

## [FAQ15990] 开启零延迟拍照后无效

```
分析方法：
1.先确认是否是normal shot with strobe off拍照，如果不是这种情况，就不是走ZSD流程，属于正常现象。 
2.查看Log文件，分析开启了ZSD后是否走的ZSD流程。

1.开闪光灯和ZSD后，属Normalshot，Log如下：
111893 01-01 00:12:13.195 257 257 D CameraClient: takePicture (pid 5081): 0x302 拍照开始
111917 01-01 00:12:13.197 257 257 D MtkCam/CamAdapter: (257)(MtkZsd)[onHandlePreCapture] +
112086 01-01 00:12:13.214 257 5207 D MtkCam/ZSDPrvCQT: (5207)[precap] flash ON 闪光灯打开
113551 01-01 00:12:13.517 257 257 D MtkCam/CamAdapter: (257)(MtkZsd)[onHandleStopPreview] +
113783 01-01 00:12:13.568 257 257 D MtkCam/CamAdapter: (257)(StateIdle)[onCapture] +
115337 01-01 00:12:14.004 257 5208 D MtkCam/Shot: (5208)(NormalShot)[handleJpegData] + (puJpgBuf, jpgSize, puThumbBuf, thumbSize) = (0xeda79000, 2052806, 0xf1f21000, 9538) 
115510 01-01 00:12:14.025 257 5208 D MtkCam/Shot: (5208)(NormalShot)[~ImpShot] - 普通拍照完成
115564 01-01 00:12:14.042 5081 5081 I CameraFramework: handleMessage: 256

2.打开ZSD后，走ZSD流程，Log如下：
00953 01-01 23:34:33.798 253 816 D CameraClient: takePicture (pid 3569): 0x302 拍照开始
01987 01-01 23:34:34.198 253 3722 D MtkCam/ZSDShot: (3722)(ZSD)[handleJpegData] + 
02133 01-01 23:34:34.221 253 3722 D MtkCam/Shot: (3722)(ZSD)[~ImpShot] - ZSD拍照结束
02144 01-01 23:34:34.235 3569 3569 I CameraFramework: handleMessage: 256
```

## [FAQ15743] How to enable GEA4

```
Method 1. Use meta tool to modify NVRAM
NVRAM_EF_CLASSMARK_RACAP_L1D->Byte 11，Enable GEA4 and save NVRAM.

Method 2. Modify file nvram_data_items.c，under NVRAM_EF_CLASSMARK_RACAP_DEFAULT[]，
modify byte 11 to value 0xF1 which means GEA-1,2,3,4 and SM cap support.
```

## [FAQ15336] 土耳其语下邮件不能打开，其他语言下是正常的

```
1. Set system language as Turkish;
2. Create a email account and open an email;
3. can not open the mail
[SOLUTION]
mail的展现是通过展开几个html模板， 把信的内容以及一些javascript字符值赋到模板的变量中去(HtmlConversationTemplate.java)。 因此在显示mail前我们需要将一些预设值赋值给template_converstaion_lower.html里面的Js变量。 而在土耳其语状态下其中一个预设值<string name="forms_are_disabled" msgid="2876312737118986789">"Formlar Gmail \' de devre disi"</string>翻译的有点奇怪， 有\ ' 等字符， 这个变量会在render message时被JS脚本用到，可能会造成WebView在解析时出错， 导致邮件不能被render出来。

因此解决方法就是删除这些特殊字符，如\ '  ？等字符。该字符串位于Email/UnifiedEmail/res/values-tr/strings.xml文件中。
```

## [FAQ15592] 如何解决wifi 连接过程中，状态栏显示为0x

```
请修改如下位置code；

/frameworks/base/wifi/java/android/net/wifi/WifiSsid.java
141 public String getHexString() {
142 String out = "0x"; //这里的初始值，修改为贵司想要的string 显示
143 byte[] ssidbytes = getOctets();
144 for (int i = 0; i < octets.size(); i++) {
145 out += String.format(Locale.US, "%02x", ssidbytes[i]);
146 }
147 return out;
148 }
调用过程如下：

/frameworks/base/wifi/java/android/net/wifi/WifiInfo.java
303 public String getSSID() {
304 if (mWifiSsid != null) {
305 String unicode = mWifiSsid.toString();
306 if (!TextUtils.isEmpty(unicode)) {
307 return "\"" + unicode + "\"";
308 } else {
309 return mWifiSsid.getHexString();
310 }
311 }
312 return WifiSsid.NONE;
 
出现的原因一般是在wifi 连接or 漫游时，会有一个ssid 为null 的过程；
从而在状态栏中，如果此过程持续时间长一点，即会看到短暂的0x显示过程；
```

## [FAQ15573] 开机动画结束时增加振动提示

```
在进入launcher前增加振动功能solution：
振动500ms。

/frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
//-------------add--------------------
// length of vibration before boot up
private static final int BOOTUP_VIBRATE_MS = 500;
private static final AudioAttributes VIBRATION_ATTRIBUTES = new AudioAttributes.Builder()
.setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
.setUsage(AudioAttributes.USAGE_ASSISTANCE_SONIFICATION)
.build();
//-------------add--------------------

6424 public void performEnableScreen() {
...
6483 mDisplayEnabled = true;
6484 if (DEBUG_SCREEN_ON || DEBUG_BOOT) Slog.i(TAG, "******************** ENABLING SCREEN!");
//-------------add--------------------
1076 // vibrate before boot up
1077 Vibrator vibrator = new SystemVibrator();
1078 try {
1079 vibrator.vibrate(BOOTUP_VIBRATE_MS, VIBRATION_ATTRIBUTES);
1080 } catch (Exception e) {
1081 // Failure to vibrate shouldn't interrupt boot up. Just log it.
1082 Log.w(TAG, "Failed to vibrate during boot up.", e);
1083 }
//-------------add--------------------
6486 // Enable input dispatch.
6487 mInputMonitor.setEventDispatchingLw(mEventDispatchingEnabled);

/frameworks/base/services/core/java/com/android/server/VibratorService.java
391 private void startVibrationLocked(final Vibration vib) {
//将该部分注释掉
404 if (mode != AppOpsManager.MODE_ALLOWED) {
405 if (mode == AppOpsManager.MODE_ERRORED) {
406 Slog.w(TAG, "Would be an error: vibrate from uid " + vib.mUid);
407 }
408 //MTK Modify, do nothing with App related control in MTK solution
409 //mH.post(mVibrationRunnable);
410 return;
411 }
//将该部分注释掉
```

## [FAQ15376] L1上首选网络类型只有4G/3G/2G,没有auto选项.

```
这是google重新命名了 preferred network type选单的选项名字而已:
4G：即之前的4G/3G/2G auto
3G：即3G/2G auto
2G：即GSM only
如果客户强烈要求要改成与L0上一致，可在以下这支文件进行修改.
相关处理逻辑在packages\services\telephony\src\com\android\phone\MobileNetworkSettings.java中，请参考进行客制化
```

## [FAQ14847] L版本全屏显示来电界面

```
HeadsUp 是 google 在 L 版本上面 PhoneStatusBar 中新增的功能.
 
而在未锁屏时来电就是通过这种方式来显示的. 从而替代了全屏显示来电界面的方式.
 
如果客户还是倾向于全屏显示来电界面. 则可以通过如下方式来单独关闭通话的 HeadsUp 功能.

File: frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar\phone\PhoneStatusBar.java

/// M: turn off HeadsUp for dialer. @{ 
private final String PACKAGES_DIALER = "com.android.dialer";
/// @}

@Override
public void addNotification(StatusBarNotification notification, RankingMap ranking) {
    /// M: turn off HeadsUp for dialer. @{ 
    boolean belongsToDialer = PACKAGES_DIALER.equals(notification.getPackageName());
    if (DEBUG) {
        Log.d(TAG, "addNotification key=" + notification.getKey() +
            ", package=" + notification.getPackageName());
    }
    if (!belongsToDialer &&
    /// @}
        mUseHeadsUp && shouldInterrupt(notification)) {
        if (DEBUG) Log.d(TAG, "launching notification in heads up mode");
        Entry interruptionCandidate = new Entry(notification, null);
        ViewGroup holder = mHeadsUpNotificationView.getHolder();
        if (inflateViewsForHeadsUp(interruptionCandidate, holder)) {
            // 1. Populate mHeadsUpNotificationView
            mHeadsUpNotificationView.showNotification(interruptionCandidate);

            // do not show the notification in the shade, yet.
            return;
        }
    }

    .................................;
}
```

## [FAQ08873] 【Contacts Data】 特殊符号开头的联系人归并至“#”下

```
在PeopleActivity界面，联系人的显示位置是由其display name的第一个字符决定的。
数字开头的联系人会显示在“#”这个header下。
中英文联系人会显示在“A” 到“Z”下。
以符号开头的联系人则没有对应的header，显示在最顶部，如何修改已让它们显示在‘#’号下？
下面的方法可以将其显示在“#”下面（适用于一般ASCII编码内的符号）
 

[SOLUTION]
 JB版本：

ContactsProvider2.java (packages\providers\contactsprovider\src\com\android\providers\contacts)

getFastScrollingIndexExtras函数中如下语句：

          if (title == null) {

                    title = "";                             

                }

修改为：   if (title == null) {

                    title = "#";                                  

                }

 

KK及以后版本：

ContactLocaleUtils.java (alps\packages\providers\contactsprovider\src\com\android\providers\contacts)

修改

ContactLocaleUtilsBase内部类

 

 public int getBucketLabel(String name) {

修改以下代码

 

final int bucket = mAlphabeticIndex.getBucketIndex(name);
if (bucket < 0) {
return -1;
}

//mtk add 
if (bucket == 0) {
     return mNumberBucketIndex; // 返回mNumberBucketIndex是放在#里面，如果想放在#号后面，return mNumberBucketIndex+1
}

//mtk add end

if (bucket >= mNumberBucketIndex) {
return bucket + 1;
}
return bucket;
```

## [FAQ03603] 【Contacts Data】 SIM卡支持存储2000条联系人,MTK平台只能存储1000条

```
有以下两个原因考虑：
1.存储2000条联系人，其开机加载速度非常慢，用记体验不是很好
2.一般情况下，1000条联系人基本能满足用记需求
 
如果一定需要支持到2000条的话，因为是其modem层对这块有限制，需要对其进行修改。
 
对于有modem源码的用户，需要按以下方式对其进行修改：
   1)change modem makefile phb_sim_entry to 2000
   2)remove this limitation in the option.mak:
               ifeq ($(call gt,$(strip $(PHB_SIM_ENTRY)),1000),T)
      $(warning ERROR: PHB_SIM_ENTRY value ($(PHB_SIM_ENTRY)) of USIM projects should not be larger than 1000) 
        DEPENDENCY_CONFLICT = TRUE
    endif
 
对于没有modem源码的客户，需要提交patch request。
 
PS： 因为MTK这边只对SIM卡存储1000条联系人有过全面的测试，因此，如果打开了2000条的开关，需要自行多做测试。
```

## [FAQ03096] 【Contacts Data】 如何修改账户与同步设置下的默认设置

```
背景数据的默认值可以通过修改
ConnectivityService.java(alps\frameworks\base\services\java\com\android\server)
中的getBackgroundDataSetting函数的实现为如下：
public boolean getBackgroundDataSetting() {
    return Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.BACKGROUND_DATA, 0) == 1;
}
这样即可修改为默认背景数据不能同步发送和接收。

自动同步的默认值如何修改？
修改SyncStorageEngine.java (alps\frameworks\base\core\java\android\content)中的
private boolean mMasterSyncAutomatically = true;
修改为
private boolean mMasterSyncAutomatically = false;
既可将自动同步的默认值设置成不勾选。
```

## [FAQ15364] [Legacy Wi-Fi] WEP长度及MTK客制化

```
添加网络，当时输入SSID，把密码设置为WEP后，当输入的密码的字符串为5、10、13、16等，“Save”亮显可以保存；输入其他位，则灰显，无法保存。
[SOLUTION]
IEEE802.11 spec 下面這段：
11.2.2 Wired equivalent privacy (WEP)
11.2.2.1 WEP overview

WEP-40 was defined as a means of protecting (using a 40-bit key) the confidentialiy of data exchanged among authorized users of a WLAN from casual eavesdropping. Implementation of WEP is optional. The same algorithms have been widely used with a 104-bit key instead of a 40-bit key in fielded implementations; this is called WEP-104. The WEP cryptographic encapsulation and decapsulation mechanics are the same whether a 40-bit or a 104-bit key is used. The term WEP by itself refers to either WEP-40 or WEP-104.

--以上设计确实是敝司在谷歌original代码上面扩展的，是为了考虑到路由器设备等在密码长度也是这个限制，这样设计是为了提醒用户所输入的密码的长度的有效性。

关于16这个长度的解释如下：
在Wikipedia 有這類的描述,
https://zh.wikipedia.org/wiki/%E6%9C%89%E7%B7%9A%E7%AD%89%E6%95%88%E5%8A%A0%E5%AF%86

WEP是1999年9月通過的IEEE 802.11標準的一部分，使用RC4（Rivest Cipher）串流加密技術達到機密性，並使用CRC-32 驗和達到資料正確性。

標準的64比特WEP使用40位元的鑰匙接上24位元的初向量（initialization vector，IV）成為RC4用的鑰匙。在起草原始的WEP標準的時候，美國政府在加密技術的輸出限制中限制了鑰匙的長度，一旦這個限制放寬之後，所有的主要業者都用104位元的鑰匙實作了128位元的WEP延伸協定。用戶輸入128位元的WEP鑰匙的方法一般都是用含有26個十六進位數（0-9和A-F）的字串來表示，每個字元代表鑰匙中的4個位元，4 * 26 = 104位元，再加上24位元的IV就成了所謂的"128位元WEP鑰匙"。有些廠商還提供256位元的WEP系統，就像上面講的，24位元是IV，實際上剩下232位元作為保護之用，典型的作法是用58個十六進位數來輸入，（58 * 4 = 232位元）+ 24個IV位元 = 256個WEP位元。

鑰匙長度不是WEP安全性的主要因素，破解較長的鑰匙需要攔截較多的封包，但是有某些主動式的攻擊可以激發所需的流量。WEP還有其他的弱點，包括IV雷同的可能性和變造的封包，這些用長一點的鑰匙根本沒有用，見stream cipher attack一頁。
```

## [FAQ13689] L版本何时需要make clean操作

```
L版本make clean何时需要执行，如何执行该命令 
[SOLUTION]
L版本中，new = clean + remake ，
如果非第一次编译，先做make clean 再做make ，相当于new 整个project,否则就是remake的操作
在涉及到project level的configuration,以及kernel的*_defconfig ，修改后要做clean:

例如： 
device/mediatek/mtxxxx/device.mk ->可以添加一些property,变量,permission等等
device/mediatek/mtxxxx/boardconfig.mk ->宏观的是否支持某个feature
device/$company/ $project/ projectconfig.mk 的修改， 
kernel menuconfig 调整了*_defconfig 文件

make clean 是清除之前编译的可执行文件以及配置文件（例如:  *.o 文件以及可执行文件 ），以及out文件夹
在修改了上面的配置文件后，如果局部编译可能会不起做用，这时，先make clean然后再make，执行命令如下：

source build/envsetup.sh
lunch full_$project-eng/userdebug/user
make clean /-pl/-lk/-kernel

make -j24   或者 make -j24 pl/lk/kernel 重新编译project 或者preloader/lk/kernel

注：除了project level 的configuration ，当需要从PRODUCT_PACKAGES里面删除一个module，也需要make  clean ，或者使用make  -B  module_name,否则无法更新system 下的module
```

## [FAQ13305] [Vibrator]LK阶段如何实现开机震动

```
描述LK阶段实现开机震动

[SOLUTION]
1.若LK mt_pmic.c中有实现vibr_Enable_HW/vibr_Disable_HW函数，
请在LK platform.c中Show Logo 之前添加对其调用。
如在platform_init()里面mboot_common_load_logo()之前添加如下代码：
-----------------------------------------
vibr_Enable_HW();//开启震动
mdelay(80); //震动80ms
vibr_Disable_HW();//关闭启震动
-----------------------------------------

2.若LK mt_pmic.c中没有实现vibr_Enable_HW/vibr_Disable_HW函数，
请按如下说明实现vibr_Enable_HW/vibr_Disable_HW函数，
然后再按上面说明在适当位置添加代码对其进行调用。
a).在LK mt_pmic.h中添加vibr_Enable_HW/vibr_Disable_HW函数申明
extern void vibr_Enable_HW(void);
extern void vibr_Disable_HW(void);
b).在LK mt_pmic.c中实现vibr_Enable_HW/vibr_Disable_HW函数
-------------------------------------------------
void vibr_Enable_HW(void)
{
xxxx_upmu_set_rg_vibr_vosel(0x5); // 0x5: 2.8V, 0x6: 3V, 0x7: 3.3V
xxxx_upmu_set_rg_vibr_en(1);
}
void vibr_Disable_HW(void)
{
xxxx_upmu_set_rg_vibr_en(0);
}
-------------------------------------------------
或者
-------------------------------------------------
void vibr_Enable_HW(void)
{
pmic_set_register_value(PMIC_RG_VIBR_VOSEL,5);// 0x5: 2.8V, 0x6: 3V, 0x7: 3.3V
pmic_set_register_value(PMIC_RG_VIBR_EN,1);
}

void vibr_Disable_HW(void)
{
pmic_set_register_value(PMIC_RG_VIBR_EN,0);
}
-------------------------------------------------

其中xxxx_upmu_set_rg_vibr_*/pmic_set_register_value表示LK upmu_common.c中提供的相应API，
如upmu_set_rg_vibr_vosel/mt6325_upmu_set_rg_vibr_vosel/mt6331_upmu_set_rg_vibr_vosel等。
```

## [FAQ15337] Email物理按键弹出菜单字体看不清楚

```
1、进入email 收件箱；
2、点物理按键menu，弹出的菜单显示字体是白色，背景是灰色，无法看清内容，如下图：

这个问题是因为该Activity使用了Android support v7 的actionbar导致的。原因是support v7 的actionbar style与L风格不一致。
可以通过如下方法解决。
在/packages/apps/Email/UnifiedEmail/res/values/themes.xml，约41行，增加一行style 的 item，如下：
<style name="UnifiedEmailTheme.Appcompat.Toolbar" parent="@style/Theme.AppCompat.Light.NoActionBar">
    ......
    <item name="panelMenuListTheme">@style/ThemeOverlay.AppCompat.Light</item>
</style>
另外，Google 在Android 5.0之后，已经禁止设备使用硬件的Menu，不然会有很多UI显示问题。
```

## [FAQ15326] [VP]默认播放器播放视频添加快进快退功能

```
默认的视频播放器只有在op02(联通)的项目默认会有快进快退的功能，若在其他项目上也需要添加快进快退功能，请参考如下方法
[SOLUTION]

Step1：添加RewindAndForward.java到alps\packages\apps\Gallery2\src\com\mediatek\gallery3d\video目录下；每次快进快退的默认时间是：3S
RewindAndForward.java文件请从如下路径下拷贝：
alps\vendor\mediatek\proprietary\operator\op02\packages\apps\plugins\src\com\mediatek\gallery3d\plugin\，并需要把该文件的包名改一下：
package com.mediatek.gallery3d.plugin;
修改为：
package com.mediatek.gallery3d.video; 

Step2：添加drawable：
alps\packages\apps\Gallery2\res\drawable\下添加:  icn_media_forward,xml  ,  icn_media_stop.xml ,   icn_media_rewind.xml
文件来源路径：
alps/vendor/mediatek/proprietary/operator/OP02/packages/apps/Plugins/res/drawable
drawable-hdpi等资源文件下添加：ic_menu_disable_forward.png  ,  ic_menu_disable_rewind.png ,  ic_menu_disable_stop.png ,  ic_menu_rewind.png ,  ic_menu_forward.png,  ic_menu_stop.png

文件来源路径：
alps/vendor/mediatek/proprietary/operator/OP02/packages/apps/Plugins/res/drawable-hdpi
alps/vendor/mediatek/proprietary/operator/OP02/packages/apps/Plugins/res/drawable-mdpi
alps/vendor/mediatek/proprietary/operator/OP02/packages/apps/Plugins/res/drawable-xhdpi
alps/vendor/mediatek/proprietary/operator/OP02/packages/apps/Plugins/res/drawable-xxhdpi
alps/vendor/mediatek/proprietary/operator/OP02/packages/apps/Plugins/res/drawable-xxxhdpi

Step3：修改alps\packages\apps\Gallery2\ext\src\com\mediatek\gallery3d\ext\DefaultMovieExtension.java中的getRewindAndForwardExtension()方法如下： 

public IRewindAndForwardExtension getRewindAndForwardExtension(){
     //return new DefaultRewindAndForwardExtention();//default code
     MtkLog.d(TAG,”new RewindAndForward()”; //added by MTK
     return new RewindAndForawrd(mContext); //added by MTK
}
```

## [FAQ15297] [Audio FTM]如何用adb shell命令实现Loopback测试

```
如何用adb shell命令实现Loopback测试

请先看这些定义，后面的命令需要用到.
enum loopback_t {
    NO_LOOPBACK                                 = 0,
    // AFE Loopback
    AP_MAIN_MIC_AFE_LOOPBACK                    = 1,
    AP_HEADSET_MIC_AFE_LOOPBACK                 = 2,
    AP_REF_MIC_AFE_LOOPBACK                     = 3,
    AP_3RD_MIC_AFE_LOOPBACK                     = 4,
    // Acoustic Loopback
    MD_MAIN_MIC_ACOUSTIC_LOOPBACK               = 21,
    MD_HEADSET_MIC_ACOUSTIC_LOOPBACK            = 22,
    MD_DUAL_MIC_ACOUSTIC_LOOPBACK_WITHOUT_DMNR  = 23,
    MD_DUAL_MIC_ACOUSTIC_LOOPBACK_WITH_DMNR     = 24,
    MD_REF_MIC_ACOUSTIC_LOOPBACK                = 25,
    MD_3RD_MIC_ACOUSTIC_LOOPBACK                = 26,
};

enum loopback_output_device_t {
    LOOPBACK_OUTPUT_RECEIVER = 1,
    LOOPBACK_OUTPUT_EARPHONE = 2,
    LOOPBACK_OUTPUT_SPEAKER  = 3,
};

输入adb shell进入控制台，然后输入AudioSetParam进行loopback测试。
C:\Documents and Settings\mtk03996>adb shell 

root@demo95v2:/ # AudioSetParam

please enter command, ex: 'GET_XXX_ENABLE', 'SET_XXX_ENABLE=0', 'SET_XXX_ENABLE=1', and '0' for exit

SET_LOOPBACK_TYPE=1,3   //1,3表示从main mic -> Speaker的loopback测试。(1,3请参考第1点中的定义，这里可自由组合，这里只是举个例子)
SET_LOOPBACK_TYPE=1,3

please enter command, ex: 'GET_XXX_ENABLE', 'SET_XXX_ENABLE=0', 'SET_XXX_ENABLE=1', and '0' for exit
SET_LOOPBACK_TYPE=0
SET_LOOPBACK_TYPE=0

please enter command, ex: 'GET_XXX_ENABLE', 'SET_XXX_ENABLE=0', 'SET_XXX_ENABLE=1', and '0' for exit
0
0
root@demo95v2:/ #
```

## [FAQ15099] [BT]如何用meta工具修改蓝牙名称

```
1，连上meta
2，选择nvram editor
3，选择other LID -> NVRAM_EF_BT_SYS_INFO_LID
4，按下read from nvram
6，从第五个字节开始修改（nvram_ef_bt_sys_info[4]）
7，按下save to nvram保存就可以了。
 
再用其他设备搜索就可以看到蓝牙名称修改成功了。
```

## [FAQ15310] 睡眠后短按pwrkey偶现点亮不了屏幕（唤醒系统）

```
使用PMIC 6323的平台，诸如MT6582/72等，偶现深度睡眠后，短按pwrkey键无法点亮屏幕的情况。通过查看log可发现，短按pwrkeyu时，并没有上报key press。
[SOLUTION]
针对以上问题，可采用以下两种优化方法（可单独使用也可一起使用）：
1.上层修改
下面从Framework的角度给一个workaround的方法： 
在/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java中添加一个变量标记是否按下power key： 
Private Boolean isPressedPwrkey; 

然后在public int interceptKeyBeforeQueueing(KeyEvent event, int policyFlags)方法中添加以下代码： 
// Handle special keys. 
switch (keyCode) { 
    case KeyEvent.KEYCODE_POWER: {
        result &= ~ACTION_PASS_TO_USER;
        isWakeKey = false; // wake-up will be handled separately
        if (down) {
            isPressedPwrkey = true;
            interceptPowerKeyDown(event, interactive);
        } else {
            if(!isPressedPwrkey && !isScreenOn(){
               interceptPowerKeyDown(event, interactive);
               isPressedPwrkey = true;
            }
            interceptPowerKeyUp(event, interactive, canceled);
        }
        break;
} 

2.driver层修改 
在pmic_mt6323.c中创建一个全局变量keyispressed，在函数pwrkey_int_handler中作如下逻辑判断：如果按键未被按下的情况下，收到release，先上报press再上报release. 
if (upmu_get_pwrkey_deb()==1) {
    …… 
    if (keyispressed==false) { //add
        kpd_pwrkey_pmic_handler(0x1);  //add
    }
    kpd_pwrkey_pmic_handler(0x0);
    ……
    keyispressed=false;  //add
} else {
    ……
    keyispressed=true;   //add
}
```

## [FAQ15313] How to close the scan function started by framework

```
we can enter linux environment, and use adb cmd to stop scan function.

adb shell am broadcast -a com.mtk.stopscan.activated // stop scan
adb shell am broadcast -a com.mtk.stopscan.deactivated // start scan
ps: the method is onlu used to stop scan function started by framework.
```

## [FAQ15258] [Audio App] 如何将 soundrecorder 改为 wav 格式录音

```
soundrecorder 默认是录 3gpp 格式，如果需要改成 wav 格式录音

需要在录音的时候对 mediarecord 调用下面几个方法：
MediaRecorder mr = new MediaRecorder();
mr.setAudioEncoder(MediaRecorder.AudioEncoder.PCM); //设为 wav 编码
mr.setOutputFormat(MediaRecorder.OutputFormat.OUTPUT_FORMAT_WAV); //设为 wav 对应的 format

默认的录音是在 Recorder.java (soundrecorder 包里面) 的 
private boolean initAndStartMediaRecorder(Context context, RecordParams recordParams, int fileSizeLimit) 
方法里面设置的，请自行改一下

再改一下后缀名为 .wav 就好了, 在如下方法中修改，加入 "// add this line" 行
private boolean createRecordingFile(String extension) {
LogUtils.i(TAG, "<createRecordingFile> begin");
extension=".wav"; // add this line
String myExtension = extension + SAMPLE_SUFFIX;
```

## [FAQ14327] [Audio framework] L 及之后版本首次开机截屏无声音

```
1：status_t Sample::doLoad() 方法内 error 段改为：
error:
mState = ERROR;//add this line
mHeap.clear();
return status;

2: soundpool.h 中，加入 ERROR 态定义
enum sample_state { UNLOADED, LOADING, READY, UNLOADING, ERROR };
 
3: play 方法加入如下修改
int SoundPool::play(int sampleID, float leftVolume, float rightVolume,
int priority, int loop, float rate)
in /frameworks/av/media/libmedia/SoundPool.cpp

add lines wrapped in dismissed lines:

int SoundPool::play(int sampleID, float leftVolume, float rightVolume,
int priority, int loop, float rate)
{
ALOGV("play sampleID=%d, leftVolume=%f, rightVolume=%f, priority=%d, loop=%d, rate=%f",
sampleID, leftVolume, rightVolume, priority, loop, rate);
sp<Sample> sample;
SoundChannel* channel;
int channelID;

Mutex::Autolock lock(&mLock);

if (mQuit) {
return 0;
}
// is sample ready?
sample = findSample(sampleID);//reference line

//add begin
if(sample != 0){
int LoopCounter = 5;
while(LoopCounter-- > 0 && (sample->state() != Sample::READY) && (sample->state() != Sample::ERROR )){
ALOGD("wait for sample ready, sleep 100ms");
usleep(100 * 1000);
}
}//add end
```

## [FAQ15283] [Audio Driver] 手机放音乐时连接音箱, 将音箱音量调到最大时，音乐暂停

```
手机放音乐时连接音箱, 将音箱音量调到最大时，音乐会自动暂停
原因是：HPL上信号过大导致EINT拉高产生了耳机拨出讯号，所以音乐会自动暂停掉
```

## [FAQ15254] [Audio Driver] Audio 寄存器打印不完整怎么办

```
ALSA 架构 Audio 寄存器打印不完整怎么办?
[SOLUTION]
mt_soc_machine.c 中 mt_soc_debug_read函数
const int size=4096;
char buffer[size];
如果寄存器打印出来后面的不完整,那可能是buffer size越界了.
可以将size增大,如size=8192;
```

## [FAQ15286] 关闭EDGE以后 手机界面仍然显示E

```
手机界面显示的E是指示手机当前驻留的2G 小区 具备支持EDGE的能力， 不代表手机自身仍然支持EDGE
换句话说 手机界面显示E，也不应理解为手机的EDGE功能没有关闭

正确的确认手机自身是否支持EDGE 是需要从MTK MD log 中 空口信令 attach req中解析

观察是否携带 EGPRS multislot class:
若以下字段为0，则表示不支持EDGE
EGPRS multislot class: Bits are not available (0)

我司关闭edge的方法可以参考： [FAQ14048]如何关掉EDGE功能
```

## [FAQ05818] 如何默认打开或者关闭TagLog

```
Eng版本TagLog默认打开，user版本TagLog默认关闭。

1.可通过修改\alps\mediatek\external\xlog\tools\目录下的mtklog-config-eng.prop和mtklog-config-user.prop文件（分别对应eng和user load）设定
taglog是否默认开启，在文件的最后一段添加上以下描述：
com.mediatek.log.taglog.enabled = false/true

如果没有添加以上描述，则默认在eng load上开启，在user load上关闭。
注：L版本该文件路径为\alps\vendor\mediatek\proprietary\external\xlog\tools

2.Eng/User版本均可以进入工程模式手动打开/关闭Taglog，方法如下：
拨*#*#3646633#*#* -> EngineerMode -> TagLog -> Start TagLog，勾选时表示打开，否则表示关闭。

TagLog功能简述：FAQ03748
```

## [FAQ15156] Caused by: java.lang.ClassNotFoundException的解决办法

```
经常会发生三方apk出现ClassNotFoundException的异常，这个异常在android开发中无非就是告诉你类没有找到，那么什么原因导致没找到呢？这里会介绍几种发生场景供排除。

ClassNotFoundException形如：
Caused by: java.lang.ClassNotFoundException: Didn't find class "com.iflytek.inputmethod.FlyApp" on path: DexPathListlib

[SOLUTION]
一般分为以下几种情况：

1、(常见)L版本上打开WITH_DEXPREOPT := true之后，预置apk的android.mk的配置不准确，导致32bit和64bit的兼容性问题，找不到对应apk的odex，自然就发生ClassNotFoundException，属于配置问题。

log形如：
Caused by: java.io.IOException: Failed to open oat file from /system/priv-app/ShanYao_StaticTimeWallpaper/arm64/ShanYao_StaticTimeWallpaper.odex (error Failed to open oat filename for reading: No such file or directory) (no dalvik_cache availible) and relocation failed.

【Solution】: 参考“[FAQ14102]L版本开机提示“Android正在升级或启动””第一点进行配置。

2、(常见)启动activity的时候，在AndroidManifest.xml中虽然有注册activity但是code中并没有定义，或者说activity的包名或者名字写错了。属于apk方问题。

【Solution】: 检查AndroidManifest.xml和code对应的class。

3、odex文件损坏，这一般是由于系统硬件问题，比如emmc不稳定，导致类似framwork.jar包被破坏。属于硬件问题。

【Solution】: 从损坏角度出发考量，检查硬件是否稳定。

4、L版本上FOTA/OTA升级后或一些特殊场景下会发生一类特殊的ClassNotFoundException，属于系统方问题。

log形如：
Caused by: java.io.IOException: Failed to remove obsolete file from /data/dalvik-cache/arm/data@app@com.handsgo.jiakao.android-1@base.apk@classes.dex when searching for dex file /data/app/com.handsgo.jiakao.android-1/base.apk: Permission denied

【Solution】参考：“[FAQ14893]FOTA/OTA之後启动第三方APP出現APP Crash”


5、在项目中重新定义了init.rc，但没有加入/system/framework/**.jar，这样会将类似mediatek\config\mt6595\init.rc覆盖，因此找不到**.jar。属于配置问题。

6、使用的class，是一个外部的JAR包，当在工程中编译使用时，发布成APK并没有包含JAR文件，所以APK在执行的时候就找不到JAR文件，也会报错。属于apk方问题。

7、使用了重复的类库，且版本不一致，导致低版本的被优先使用。此时应删除重复的类库，只保留最新的。属于apk方新旧版本问题。
```

## [FAQ11919] 【缅甸语专项】设置--日期和时间--设置日期和时间，弹出的对话框里面，默认日期或者时间看不到

```
【缅甸语专项】设置--日期和时间--设置日期和时间，弹出的对话框里面，默认日期或者时间看不到，拖动下又出来了。
 
[SOLUTION]
 
请修改 NumberPicker.java (path: \frameworks\base\core\java\android\widget\NumberPicker.java).

修改如下:
修改NumberPicker.java裡面的 filter() method:
=== 將原本的 ===
    CharSequence filtered = super.filter(source, start, end, dest, dstart, dend);
    if (filtered == null) {
        filtered = source.subSequence(start, end);
    }
=== 修改為:(中間插入一段code) ===
    CharSequence filtered = super.filter(source, start, end, dest, dstart, dend);
    if (filtered != null) {
        int i;
        for (i = start; i < end; i++) {
            if (!Character.isDigit(source.charAt(i))) {
                break;
            }
        }
        if (i == end) {
            /// the characters in source are all digit.
            filtered = null;
        }
    }
    if (filtered == null) {
        filtered = source.subSequence(start, end);
    }
```

## [FAQ10820] 针对某个APK，需要做到wifi/gprs分别做到允许/禁止两种策略

```
JB5开始已经default有这部分代码，只需要参照该FAQ后面的使用说明和方法调用即可。
JB5之前的版本，可以按照下面完整的solution进行操作
[SOLUTION]
1.NetworkManagementService.java
    public void setFirewallUidChainRule(int uid, int networkType, boolean allow) {
        //enforceSystemUid();
        final String MOBILE = "mobile";
        final String WIFI = "wifi";

        final String rule = allow ? ALLOW : DENY;
        final String chain = (networkType == 1) ? WIFI : MOBILE;
        
        try {
            mConnector.execute("firewall", "set_uid_fw_rule", uid, chain, rule);
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        }
    }
    
    /**
     * @internal Configure firewall rule by uid and chain
     * @hide
     */
    public void clearFirewallChain(String chain) {
        //enforceSystemUid();
        try {
            mConnector.execute("firewall", "clear_fw_chain", chain);
        } catch (NativeDaemonConnectorException e) {
            throw e.rethrowAsParcelableException();
        }
    }    
}
2.CommandListener.cpp中
1)最后一个类FirewallCmd的runCommand方法的
    cli->sendMsg(ResponseCode::CommandSyntaxError, "Unknown command", false);
    return 0;
之前加上
    if (!strcmp(argv[1], "set_uid_fw_rule")) {
        if (argc != 5) {
            cli->sendMsg(ResponseCode::CommandSyntaxError,
                         "Usage: firewall set_uid_fw_rule <uid> <mobile|wifi> <allow|deny>",
                         false);
            return 0;
        }

        int uid = atoi(argv[2]);
        FirewallChinaRule chain = parseChain(argv[3]);
        FirewallRule rule = parseRule(argv[4]);

        int res = sFirewallCtrl->setUidFwRule(uid, chain, rule);
        return sendGenericOkFail(cli, res);
    }

    if (!strcmp(argv[1], "clear_fw_chain")) {
        if (argc != 3) {
            cli->sendMsg(ResponseCode::CommandSyntaxError,
                         "Usage: firewall clear_fw_chain <chain>",
                         false);
            return 0;
        }

        const char* chain = argv[2];
        
        int res = sFirewallCtrl->clearFwChain(chain);
        return sendGenericOkFail(cli, res);
    }   
2)以下两个数组改成如下;
static const char* FILTER_INPUT[] = {
        // Bandwidth should always be early in input chain, to make sure we
        // correctly count incoming traffic against data plan.
        BandwidthController::LOCAL_INPUT,
// mtk03594: Support enhanced firewall @{
        FirewallController::FIREWALL,
///@}
        FirewallController::LOCAL_INPUT,
        NULL,
};
static const char* FILTER_OUTPUT[] = {
        OEM_IPTABLES_FILTER_OUTPUT,
// mtk03594: Support enhanced firewall @{
        FirewallController::FIREWALL,
///@}
        FirewallController::LOCAL_OUTPUT,
        BandwidthController::LOCAL_OUTPUT,
        NULL,
};
3) 添加下面这个数组
static const char* FILTER_FIREWALL[] = {
        FirewallController::FIREWALL_MOBILE,
        FirewallController::FIREWALL_WIFI,
        NULL,
};

4) CommandListener.cpp的构造函数CommandListener::CommandListener() :的
    createChildChains(V4, "nat", "PREROUTING", NAT_PREROUTING);
    createChildChains(V4, "nat", "POSTROUTING", NAT_POSTROUTING);

    // Let each module setup their child chains
    setupOemIptablesHook();
后添加
createChildChains(V4V6, "filter", "firewall", FILTER_FIREWALL);


3.FirewallController.cpp里
1)加上以下两个函数
int FirewallController::setUidFwRule(int uid, FirewallChinaRule chain, FirewallRule rule) {
    char uidStr[16];
    char cmdStr[128];
    int res = 0;
    const char* op;
    const char* fwChain;

    sprintf(uidStr, "%d", uid);

    if (rule == ALLOW) {
        op = "-I";
    } else {
        op = "-D";
    }

    if(chain == MOBILE) {
        fwChain = "mobile";
    }else{
        fwChain = "wifi";
    }

    res |= execIptables(V4, op, fwChain, "-m", "owner", "--uid-owner", uidStr,
            "-j", "REJECT", "--reject-with", "icmp-net-prohibited", NULL);
    res |= execIptables(V6, op, fwChain, "-m", "owner", "--uid-owner", uidStr,
            "-j", "REJECT", "--reject-with", "icmp6-adm-prohibited", NULL);

    return res;    
}

int FirewallController::clearFwChain(const char* chain) {
    int res = 0;

    if(chain != NULL){
        if(strlen(chain) > 0){
            res |= execIptables(V4V6, "-F", chain, NULL);
        }else{
            ALOGD("Clear all chain");
            res |= execIptables(V4V6, "-F", NULL);
        }
    }else{
        ALOGE("Chain is NULL");
    }

    return res;
}
2).FirewallController.cpp文件里面添加
const char* FirewallController::FIREWALL = "firewall";
3).FirewallController.cpp文件下面这个方法改成如下;
int FirewallController::setupIptablesHooks(void) {

    // mtk03594: Support enhanced firewall @{
    int res = 0;
    res |= execIptables(V4V6, "-F", FIREWALL, NULL);
    res |= execIptables(V4V6, "-A", FIREWALL, "-o", "ppp+", "-j", FIREWALL_MOBILE, NULL);
    res |= execIptables(V4V6, "-A", FIREWALL, "-o", "ccmni+", "-j", FIREWALL_MOBILE, NULL);
    res |= execIptables(V4V6, "-A", FIREWALL, "-o", "ccemni+", "-j", FIREWALL_MOBILE, NULL);
    res |= execIptables(V4V6, "-A", FIREWALL, "-o", "usb+", "-j", FIREWALL_MOBILE, NULL);
    res |= execIptables(V4V6, "-A", FIREWALL, "-o", "cc2mni+", "-j", FIREWALL_MOBILE, NULL);
    res |= execIptables(V4V6, "-A", FIREWALL, "-o", "wlan+", "-j", FIREWALL_WIFI, NULL);
    //@}
    
    return 0;
}

4.FirewallController.h里
加上以下两个函数定义
    int setUidFwRule(int, FirewallChinaRule, FirewallRule);
    int clearFwChain(const char* chain);
JB5开始的版本可以从此开始进行修改：
完成以上代码添加后，可以在相应的APK里采用以下步骤使用添加的这些接口：
１．在相关的文件里import并且定义及获得NetworkManagementService
　　　　import android.os.INetworkManagementService;
　　　　private INetworkManagementService mNetworkService;
        mNetworkService = INetworkManagementService.Stub.asInterface(
                ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE));

2.调用mNetworkService.setFirewallUidChainRule　or mNetworkService.clearFirewallChain设置和清空相应的APP的限制即可．

PS:1.每次重新开机，其Iptable都会被清空，如果下次重新开机时，需要重新下一遍command
     2.setFirewallUidChainRule这个方法,针对同一个AP其allow和deny要成对出现
     如果是要禁止掉某个APP访问网络的话，应该是要下allow,而不是下deny，deny是不禁止，allow是允许禁止
     clearFirewallChain是重置规则,一般在APK reset的时候使用,它里面传的参数可以为wifi 或者mobile
```

## [FAQ04537] 如何修改Kernel Log Buffer的大小？

```
我们采用可以增大kernel log buffer的方法来避免ring buffer的循环覆盖发生。
 
1. 修改文件如下，其中${ARM}为arm或者arm64，根据架构不同选择不用的目录，${PROJECT}指代具体的项目名称。
ENG: alps/kernel/arch/${ARM}/configs/${PROJECT}_debug_defconfig
USER: alps/kernel/arch/${ARM}/configs/${PROJECT}_defconfig
 
修改位置如下：
CONFIG_LOG_BUF_SHIFT=17
将其中的数值17修改为19或者更大，如：
CONFIG_LOG_BUF_SHIFT=19
 
17表示2^17=128KB, 18表示2^18=256KB, 以此类推。但是最大支持的值为21，即2MB buffer。
 
2. 修改后需要重新build kernel并重新生成boot image
$source build/envsetup.sh && lunch
$mmm kernel-3.10:clean-kernel -j8
$mmm kernel-3.10:kernel -j8
$make bootimage-nodeps -j8
 
3. 重新download boot.img即可。
```

## [FAQ12271] [USB]如何修改内置光盘中的内容(BICR, CD-ROM, ISO)

```
BICR 内置光盘 CD-ROM ISO
 
在制作光盘ISO文件时设定需要的文件，然后将制作好的ISO文件放置于 alps/system/mobile_toolkit/ 下即可。
 
其他相关可能的客制化，也可以参考如下FAQ：
FAQ05690 [USB] How to add ISO files into BICR?
FAQ04856 [USB名称修改系列]第4项-如何修改BICR在PC"我的电脑"中显示的label名称
```

## [FAQ10612] 【USB名称修改系列】第15项-如何修改USB设备在控制面板中显示的名称

```
可以在 kernel\drivers\usb\gadget\Android.c 中修改如下红色字段为所需显示的字段
#define PRODUCT_STRING "MT65xx Android Phone"
```

## [FAQ05354] 如何在preloader、uboot、lk、kernel中预置obj文件

```
如何在preloader、uboot、lk、kernel中预置obj文件.docx 
```

## [FAQ02684] [SP FlashTool、SP Multiportdownload Tool]客制化实现下载完成后自动开机

```
一、flashtool:
BCB版本的FlashTool：
1. 修改version.cpp
static const bool          CUSTOMER_VER     = false;
 
2. 修改tboot_1.cpp
//---------------------------------------------------------------------------
int tboot_1::ArgFlashToolWatchDog(FlashTool_EnableWDT_Arg *p_wdt_arg) {
    assert(NULL != p_wdt_arg);
    memset(p_wdt_arg, 0, sizeof(FlashTool_EnableWDT_Arg));
    //timeout to reset bootRom
    p_wdt_arg->m_timeout_ms = 5000;
    p_wdt_arg->m_async = _FALSE;
    p_wdt_arg->m_reboot = _FALSE // _TRUE;=>_FALSE 
    return 0;
}
 
QT版本的Flashtool:
1. 修改version.cpp
static const bool          CUSTOMER_VER     = false;
 
2. 修改WatchDogCommand.cpp
//---------------------------------------------------------------------------
void WatchDogCommand::ArgFlashToolWatchDog(FlashTool_EnableWDT_Arg *p_wdt_arg) {
     memset(wdt_arg, 0, sizeof(FlashTool_EnableWDT_Arg));
     wdt_arg->m_timeout_ms = 3000;
     wdt_arg->m_async = _FALSE;
     wdt_arg->m_reboot = _FALSE;
}
二、SP Multiportdownload Tool:
1，将SPMultiPortFlashDownloadProject.ini中的ForceWatchdogReset改为yes。
2，工具界面的EnableAutoPulling不能勾选。
 
注意：
MTK official release的tool不会开启这个feature.
产线tool也请不要开启这个功能, 会导致重启usb 枚举可能会受影响.
```

## [FAQ04080] 如何消除Phone模块导入Eclipse后产生的错误

```
一般来说，alps工程中的系统应用导入Eclipse后一般都会有很多编译错误，下面我们会以Phone模块为例来说明如何消除这些编译错误，方面我们使用Eclipse进行开发与debug。
[SOLUTION]
1、 将alps中的系统应用取出，例如我们取出./alps/package/apps/Phone/，在Eclipse中新建一个Android Project，将之前取出的Phone模块导入，然后我们就会发现有很多编译错误：
2、 由于Google原生SDK中android.jar的限制，我们需要继续添加一些jar文件参与编译解决编译错误。在我们编译整个alps工程时，其实我们需要的jar文件已经产生，路径为：
a) alps/out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar
b) alps/out/target/common/obj/JAVA_LIBRARIES/core_intermediates/classes.jar
c) alps/out/target/common/obj/JAVA_LIBRARIES/ext_intermediates/classes.jar
将以上三个jar文件分别重命名为framework.jar\core.jar\ext.jar，然后导入之前Eclipse建立的工程中：

查看一下效果，看看是否还有编译错误。
这里建议将SDK自带的android.jar删除，因为它会被优先编译，导致编译错误。
3、如果还有错误，可能是还要依赖其他的.java，将这些 .java 文件（.aidl / .java）copy 过来一起编译即可，这里注意package name要用对。
4、若是有发现API level的的编译错误，可以尝试使用在工程上右键---Android Tools---Clear Lint Markers来尝试忽略。这样编译错误就基本清理完毕。

注意事项：
Android 4.1之后的版本，Google开始对framework做拆分，例如有可能还需要加入secondary-framework.jar/telephony-common.jar等。可以仿照以上方式将需要的jar档导入即可
```

## [FAQ11803] [USB]修改USB存储在PC"我的电脑"中显示的label名称，如何解决label中的小写字母全部变成大写字母的问题？

```
按照FAQ04906修改了USB存储在PC"我的电脑"中显示的label名称，代码中label名称由大小写字母组成，但是电脑端的显示全部变成了大写字母，比如新增的format()函数参数  -L  “AAbbCC"，但连接电脑显示的却是“AABBCC"。如何实现在电脑端的显示为实际的 “AAbbCC"？

[KEYWORD]
USB存储 PC"我的电脑" label名称 小写字母 大写字母

[SOLUTION]

请这样修改：
system/core/toolbox/newfs_msdos.c
static void
mklabel(u_int8_t *dest, const char *src) {
    int c, i;
    for (i = 0; i < 11; i++) {
    c = *src ? toupper(*src++) : ' '; //将此处toupper注释掉
    *dest++ = !i && c == '\xe5' ? 5 : c;
    }
}
```

## [FAQ12212] [USB名称修改系列] 如何修改USB MTP模式下，“设备与打印机”中Model项的显示？

```
修改kernel/drivers/usb/gadget/f_mtp.c
 
static struct usb_string mtp_string_defs[] = {
 /* Naming interface "MTP" so libmtp will recognize us */
 [INTERFACE_STRING_INDEX].s = "MTP", //修改此处
 {  }, /* end of list */
};
```

## [FAQ11787] [USB] KK user版本使用adb会提示error: device offline

```
KK user版本需要
1.检查adb版本是1.0.31
2.操作UI 点选弹出的框 OK
才可以使用。

原因是由于google升级SDK，将adb升级加入权限导致。您可以参考以下链接： 
The reason to appearing "device offline" in android 4.2.2 is that android has a security feature in 4.2.2 that create a whitelist of usb ports that can be used as debugging port.
After plugging deivce in usb and entering the command "adb devices" a popup window will be raised in your device and ask you to accept the connection:

After accepting RSA fingerprint of you usb you can now issue the "adb devices" again and see the device is no longer offline,
If you dont see the popup window, the reason is your adb version is old, your adb version must ne at least 1.0.31 (you can see the version using the command "adb version").

http://stackoverflow.com/questions/15079211/android-4-2-2-device-offline
```

## [FAQ04354] 一些查看内存状况的adb command

```
请参考下面的1)2)3)抓取对应的信息，若需要MTK协助，请提供下面的信息，并将mtklog文件夹也一并附上

1) Use adb shell cat /proc/meminfo to calculate the free memory, as usual the free memory is  MemFree + cached
taking the follow example, te free memory is 5616K + 158632K
cat proc/meminfo
MemTotal:         483724 kB
MemFree:            5616 kB
Buffers:            2732 kB
Cached:           158632 kB
SwapCached:            0 kB
Active:           277336 kB
Inactive:          83232 kB
Active(anon):     197452 kB
Attention，in the phone menu setting->apps->running app, the free memory is MemFree + cached + background running app memory - SECOND_SERVER_MEM，you can refer to the follwoing for details：the function void refreshUi(boolean dataChanged) in RunningProcessView.java(/alps/package/apps/settings/src/com/android/setting/applications) (Related FAQ09452How to calculate cached free memory?)

2) Use adb shell procrank (Just ENGload) to find which process consume most memory, please refer to PSS

adb shell procrank
PID      Vss      Rss      Pss      Uss  cmdline
476   65312K   65284K   38499K   35560K  com.android.launcher
268   54916K   54880K   30001K   27000K  system_server
110   32196K   28988K   18924K   12432K  /system/bin/surfaceflinger
347   42400K   42320K   15445K   10704K  com.android.systemui


3) For the process in 2) who consume most memory， use adb shell showmap [pid] (Just ENG load) to more details.  Take system_server for example， first get the pid by adb shell ps system_server:
adb shell ps system_server
USER     PID   PPID  VSIZE  RSS     WCHAN    PC         NAME
system    268   111   406736 54876 ffffffff 400e9c70 S system_server

Then  adb shell showmap 268 to find every .so and heap, stack memory consume.  Refer to the PSS
adb shell showmap 268
virtual                     shared   shared  private  private
size      RSS      PSS    clean    dirty    clean    dirty    # object
-------- -------- -------- -------- -------- -------- -------- ---- ------------------------------
72       20       20        0        0       20        0    1 /data/dalvik-cache/system@app@SettingsProvider.apk@classes.dex
352      148      103       32       16       48       52   18 /data/dalvik-cache/system@framework@android.policy.jar@classes.dex
1348       28        8       20        0        8        0    1 /data/dalvik-cache/system@framework@apache-xml.jar@classes.dex
956       60       13       52        0        8        0    1 /data/dalvik-cache/system@framework@bouncycastle.jar@classes.dex
24        8        0        8        0        0        0    1 /data/dalvik-cache/system@framework@core-junit.jar@classes.dex
3292     1056      126     1012        0       44        0    1 /data/dalvik-cache/system@framework@core.jar@classes.dex


其它内存相关FAQ，欢迎访问
FAQ04223如何查看Modem/Kernel/FrameBuffer的Footprint?
FAQ04354内存不足时查看内存使用情况的一些adb command
FAQ07759如何查看当前项目的physical memory layout
FAQ07760如何查看当前项目的virtual memory layout
FAQ09452手机cached free memory(剩余内存)计算方法
FAQ09454如何计算开机之后留给Linux Kernel可用的总内存
FAQ09456zram(内存压缩)介绍
FAQ10389如何关闭 zram/swap功能
```

## [FAQ09454] 如何计算开机之后留给Linux Kernel可用的总内存

```
众所周知，RAM的layout里面会包含modem 以及 framebuffer部分，那如何计算剩余留给Linux kernel的内存呢？

[SOLUTION]
请首先抓一份开机的uart log

1、搜索“available”，你会看到Memory:xxxxx/xxxxx available，这个xxxxx就是linux kernel可用总内存
[    0.000000]-(0)[0:swapper]Memory: 954092k/954092k available, 27924k reserved, 467968K highmem

2、如何计算的呢？
1) 搜索“PHY layout”，得到total ram size，modem size，以及framebuffer size
[    0.000000]-(0)[0:swapper][PHY layout]avaiable DRAM size = 0x40000000
[    0.000000]-(0)[0:swapper][PHY layout]FB       :   0xbfb00000 - 0xc0000000  (0x00500000)
[    0.000000]-(0)[0:swapper][PHY layout]MD       :   0xbc000000 - 0xbe000000  (0x02000000)
[    0.000000]-(0)[0:swapper][PHY layout]MD       :   0xba000000 - 0xbbc00000  (0x01c00000)
2) memory avaliable = total ram size - (modem size + framebuffer size + reserved)
        = 0x40000000 - (0x02000000 +0x01c00000 + 0x00500000 + 27924k  )
        //本例有两个modem
        = 954092k
其它内存相关FAQ，欢迎访问
FAQ04223如何查看Modem/Kernel/FrameBuffer的Footprint?
FAQ04354内存不足时查看内存使用情况的一些adb command
FAQ07759如何查看当前项目的physical memory layout
FAQ07760如何查看当前项目的virtual memory layout
FAQ09452手机cached free memory(剩余内存)计算方法
FAQ09456zram(内存压缩)介绍
```

## [FAQ09452] 手机cached free memory(剩余内存)计算方法

```
计算方法请参考：RunningProcessView.java(/alps/packages/apps/settings/src/com/android/setting/applications)里面的void refreshUi(boolean dataChanged)接口：
1、首先获取 /proc/meminfo信息
2、availMem = mMemInfoReader.getFreeSize() + mMemInfoReader.getCachedSize()
                - SECONDARY_SERVER_MEM; (因为不同平台，不同配置SECONDARY_SERVER_MEM会不同，如果想确定该值具体大小，建议您在这边自行加log打印该值)
3、 mLastAvailMemory = availMem;
      long freeMem = mLastAvailMemory + mLastBackgroundProcessMemory;
 
4、freeMem即为可用内存，已用内存即为meminfo.total - freeMem
 
所以，这里会包含background process占据的内存
 
其它内存相关FAQ，欢迎访问
FAQ04223 如何查看Modem/Kernel/FrameBuffer的Footprint?
FAQ04354 内存不足时查看内存使用情况的一些adb command
FAQ07759 如何查看当前项目的physical memory layout
FAQ07760 如何查看当前项目的virtual memory layout
FAQ09454 如何计算开机之后留给Linux Kernel可用的总内存
FAQ09456 zram(内存压缩)介绍
```

## [FAQ09456] zram(内存压缩)介绍

```
下面是对Zram(内存压缩)一个简单介绍:
1. zram 又称内存压缩，Linux kernel会把不常用的内存进行压缩，以换出更多的内存供系统使用
    -- 平时空闲时候会做压缩，以备不时之需
    -- kernel 申请不到内存，会触发压缩机制
 
2. 只有user process的内存可被压缩
 
3. 压缩是有成本的，会影响performance
    -- 通常，launch app的时候会受影响
    -- 代码执行中，突然要大量内存的时候也会受到影响
 
4. 在LCA/non-LCA的项目都有可能Enable，目前为止只有72&82&92项目上面支持，其它暂不支持
 
若有更细节问题，可提e-service与MTK讨论
 
 
其它内存相关FAQ，欢迎访问
FAQ04223如何查看Modem/Kernel/FrameBuffer的Footprint?
FAQ04354内存不足时查看内存使用情况的一些adb command
FAQ07759如何查看当前项目的physical memory layout
FAQ07760如何查看当前项目的virtual memory layout
FAQ09452手机cached free memory(剩余内存)计算方法
FAQ09454如何计算开机之后留给Linux Kernel可用的总内存
```

## [FAQ01934] [Others] 如何单独build factory bin？

```
[Key Words]
SW相关，Factory Mode，Factory bin
[Description]
当我们中修改factory的部分，则不需要在new整个工程，只需要重新make factory模块就好，然后使用ADB push到手机即可
[Solution]
1. 修改factory的source code（不然也不需要build bin）
2. 进到工程目录使用下面的命令编译：mk mm mediate/source/factory，注意查看factory的生成时间，如果发现没有重新生成，则随便打开一支文件，添加个空格或回车，保存再执行mk操作
3. 生成的bin会放在alps/out/target/product/[project]/system/bin/factory，注意，没有后缀
4. 接下来使用下面的adb命令push factory到手机：
adb remount
adb push d:\factory /system/bin/factory （d:\factory为factory在PC上的路径，/system/bin/factory为要push到手机中的位置）
adb shell chmod 777 /system/bin/factory
adb reboot（重新开机验证即可）
另外，第4个步骤也可以写成bat文件，每次只需要运行这个bat即可
```

## [FAQ11325] KitKat版本，keyguard上状态栏透明的实现

```
KitKat版本，android default实现了状态栏透明。
statusbar透明的属性是WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;
navigationbar透明的属性是WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION;

keyguard界面状态栏透明实现是在KeyguardViewManager.java中:
if (shouldEnableTranslucentDecor()) {
    mWindowLayoutParams.flags |= WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION;
}
如需要关闭/打开锁屏界面状态栏透明，修改frameworks/base/core/res/res/values/config.xml中config_enableLockScreenTranslucentDecor变量值即可。
PS: 以上只针对锁屏界面的状态栏透明。
```

## [FAQ14863] perfomance问题的基本信息确认

```
1:确认是否为eng版本？　adb shell getprop ro.build.type.  eng版本本身对perofamnce影响比大．
如果是eng版本出现的问题，请在user load确认是否有同样的问题．

2:　uart 是否有打开，adb shell cat /sys/module/printk/parameters/disable_uart
如果是Ｎ，表示你测试的版本是开uart的，很有可能你遇到perofamnce会跟这个相关．　
如果uart是开的，可以在有root权限下命令: echo 0 > /proc/sys/kernel/printk,然后再测试看看是否有问题.
```

## [FAQ14787] 前置默认设置为美颜模式

```
CameraActivity.java函数内做如下修改：

private PickerManager.PickerListener mPickerListener = new PickerManager.PickerListener() {
@Override

public boolean onCameraPicked(int cameraId) {

函数内的语句mCameraAppUi.setViewState(ViewState.VIEW_STATE_CAMERA_CLOSED);前添加如下语句：

if(cameraId==1)

{

mModePicker.setCurrentMode(ModePicker.MODE_FACE_BEAUTY);

Log.i(TAG,"setCurrentMode facebeauty");

}

else

{mModePicker.setCurrentMode(ModePicker.MODE_PHOTO);}

2.private SettingManager.SettingListener mSettingListener = new SettingManager.SettingListener() {

@Override

public void onRestorePreferencesClicked() {

函数内

将如下语句

if (ModePicker.MODE_PHOTO == mCameraActor.getMode() || !isNonePickIntent()

|| ModePicker.MODE_PHOTO_SGINLE_3D == mCameraActor.getMode()

|| ModePicker.MODE_PHOTO_3D == mCameraActor.getMode()) {

if (ModePicker.MODE_VIDEO == mCameraActor.getMode() && !isNonePickIntent()) {

mISettingCtrl.onSettingChanged(SettingConstants.KEY_VIDEO,"on");

}

mCameraDeviceCtrl.applyParameters(false);

} else {

mModePicker.setModePreference(null);

mModePicker.setCurrentMode(ModePicker.MODE_PHOTO);

}

修改为

if(getCameraId()==1){

mModePicker.setCurrentMode(ModePicker.MODE_FACE_BEAUTY);

}else if (ModePicker.MODE_PHOTO == mCameraActor.getMode() || !isNonePickIntent()

|| ModePicker.MODE_PHOTO_SGINLE_3D == mCameraActor.getMode()

|| ModePicker.MODE_PHOTO_3D == mCameraActor.getMode()) {

if (ModePicker.MODE_VIDEO == mCameraActor.getMode() && !isNonePickIntent()) {

mISettingCtrl.onSettingChanged(SettingConstants.KEY_VIDEO,"on");

}

mCameraDeviceCtrl.applyParameters(false);

} else {

mModePicker.setModePreference(null);

mModePicker.setCurrentMode(ModePicker.MODE_PHOTO);

}
```

## [FAQ12495] 如何用adb命令实现选择哪个麦克录音

```
adb shell setprop streamin.micchoose 0  //代表双麦克
adb shell setprop streamin.micchoose 1  //代表主麦克
adb shell setprop streamin.micchoose 2  //代表副麦克
```

## [FAQ12424] KK版本与JB版本拨号按键音的区别

```
部分客户反馈KK平台拨号音比JB时间较长
[SOLUTION]
kk版本拨号按键音时间长的原因是：
DialpadFragment.java里
private void keyPressed(int keyCode) {
      switch (keyCode) {
         case KeyEvent.KEYCODE_1:
            playTone(ToneGenerator.TONE_DTMF_1, TONE_LENGTH_INFINITE);//这个值TONE_LENGTH_INFINITE代表按下拨号按键会一直有声音，您按的时间长声音出来的声音就会长。如果将这个值TONE_LENGTH_INFINITE改为TONE_LENGTH_MS ，其他按键类似的修改，这样就是每个按键音都是一个固定时间TONE_LENGTH_MS
```

## [FAQ12382] 如何修改LatinIME输入法空格键的显示

```
我要修改LatinIME空格键的显示为自定义的图片,该如何做？
[SOLUTION]
1:修改 MainKeyboardView.java (alps\packages\inputmethods\latinime\java\src\com\android\inputmethod\keyboard)
中 drawSpacebar 函数,将绘制语言text的部分注释掉.
//canvas.drawText(language, width / 2, baseline - descent - 1, paint);
paint.setColor(mSpacebarTextColor);
paint.setAlpha(mLanguageOnSpacebarAnimAlpha);
//canvas.drawText(language, width / 2, baseline - descent, paint);
2:修改
Key_styles_common.xml (alps\packages\inputmethods\latinime\java\res\xml) 
中spaceKeyStyle的实现为
<key-style
    latin:styleName="spaceKeyStyle"
    latin:keyIcon="!icon/space_key"
    latin:code="!code/key_space"
    latin:keyActionFlags="noKeyPreview|enableLongPress" />
3:修改Keyboard-icons-ics.xml (alps\packages\inputmethods\latinime\java\res\values)
中 iconSpaceKey的实现为
<item name="iconSpaceKey">@drawable/sym_keyboard_space_holo</item>
这里将sym_keyboard_space_holo 定义为贵司希望修改成的图片。
```

## [FAQ12383] 如果选择Use system language，如何在键盘的空格上显示当前语言

```
方法1：直接在MainKeyboardView.java (alps\packages\inputmethods\latinime\java\src\com\android\inputmethod\keyboard)  的drawSpacebar函数中对mNeesToDisplayLanguage的判断去掉。
//if(mNeesToDisplayLanguage){
......
//}
方法2：修改SubTypesSwitcher.java中的
needsToDisplayLanguages函数的返回值直接为true.
```

## [FAQ15086] 如何客制化自己的开机向导

```
在开发过程中，可能需要客制化自己的开机向导，可以参考如下的方案。
[SOLUTION]
可以参考一下之前敝司KK版本上的OOBE的实现，其主要有两个核心思想：
1.需要将APK的主Activity的Category声明为"android.intent.category.HOME"，并且设置其优先级要高于默认的Launcher。基中的优先级，可以根据自己的需求灵活设置。因为可能其他的Activity也会有同样的需求。
例如

<activity 
    android:name=".MainActivity"
    android:label="@string/app_name" >
    <intent-filter android:priority="10"> 
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.HOME" /> 
    </intent-filter>
</activity>
 
2.在完成自己的开机向导之后，需要通过PMS的接口禁止掉自己的应用，这样才能在后面的home-key不再起来。

例如：

/mediatek/packages/apps/OOBE/src/com/mediatek/oobe/basic/MainActivity.java

private void finishOOBE() {
    //disable WizardActivity
    PackageManager pm = getPackageManager();
    ComponentName name = new ComponentName(this, WizardActivity.class);
    int state = pm.getComponentEnabledSetting(name);
    if (state != PackageManager.COMPONENT_ENABLED_STATE_DISABLED) {
        pm.setComponentEnabledSetting(name, PackageManager.COMPONENT_ENABLED_STATE_DISABLED,
        PackageManager.DONT_KILL_APP);
    }
}
```

## [FAQ15071] ListView边缘的button经常点不中

```
这是L1的新特性决定的，因为在L1版本的
/frameworks/base/core/java/android/widget/FastScroller.java
中，isPointInsideX的实现如下：
private boolean isPointInsideX(float x) {
    final float offset = mThumbImage.getTranslationX();
    final float left = mThumbImage.getLeft() + offset;
    final float right = mThumbImage.getRight() + offset;

    // Apply the minimum touch target size.
    final float targetSizeDiff = mMinimumTouchTarget - (right - left);
    final float adjust = targetSizeDiff > 0 ? targetSizeDiff : 0;

    if (mLayoutFromRight) {
        return x >= mThumbImage.getLeft() - adjust;
    } else {
        return x <= mThumbImage.getRight() + adjust;
    }
}
相对于L0的版本，会增加一个adjust的值，
而该函数又会影响listView是否会中断事件,导致事件传不到listItem上的button.
 
故该问题可以调小framework resource中，即
frameworks\base\core\res\res\values\dimens.xml
frameworks\base\core\res\res\values-xxx\dimens.xml中
R.dimen.fast_scroller_minimum_touch_target的值解决。
或者可以调整isPointInsideX的实现为L0.MP版本中的实现(即不adjust)，也
可以解决。
L0版本的实现如下：
private boolean isPointInsideX(float x) {
    if (mLayoutFromRight) {
        return x >= mThumbImage.getLeft();
    } else {
        return x <= mThumbImage.getRight();
    }
}
```

## [FAQ15089] Android L 版本后native process 无法使用am pm 等命令的说明

```
在android 5.0 后, 默认启用了Enforcing SELinux. Google 通过SELinux 严禁普通的native process 执行非system image 中的非exec类型的文件, 如data/dalvik-cache 下面的odex 文件, 从而native process 无法直接执行am, pm 等命令.
//external/sepolicy/domain.te
neverallow {
    domain
    -appdomain
    -dumpstate
    -shell
    userdebug_or_eng(`-su')
    -system_server
    -zygote
} { file_type -system_file -exec_type }:file execute;
neverallow {
    domain
    -appdomain # for oemfs
    -recovery # for /tmp/update_binary in tmpfs
} { fs_type -rootfs }:file execute;

通常我们解决的方式是，通过binder 直接使用 activity 等service接口, 直接向AMS 发送指令来规避这一条。 
注意这个同样要求你的process 有操作binder 的SELinux 权限，这个Google 不会限制。
在我们的代码中已经有很多类似的这样案例，大家可以参考：
frameworks/av/media/libmediaplayerservice/ActivityManager.cpp
/vendor/mediatek/proprietary/external/ds1_utility/ds1_utility.cpp
/vendor/mediatek/proprietary/external/batterywarning/batterywarning.cpp
/frameworks/av/services/audioflinger/AudioLosslessBTBroadcast.cpp
/vendor/mediatek/proprietary/packages/apps/MTKThermalManager/jni/thermald.cpp

通常首先：
#include <unistd.h>
#include <binder/IBinder.h>
#include <binder/IServiceManager.h>
#include <binder/Parcel.h>
#include <utils/String8.h>

(1). 获取am service 
sp<IServiceManager> sm = defaultServiceManager();
sp<IBinder> am = sm->getService(String16("activity"));

(2). 填充传送参数Parcel data, 准备好Parcel reply
data.writeInterfaceToken(String16("android.app.IActivityManager"));
.....

(3). 执行binder 
status_t ret = am->transact(XXXXXX_TRANSACTION, data, &reply); 
这些cmd 都定义在/frameworks/base/core/java/android/app/IActivityManager.java , 可选择查看.

(4). 解析返回的ret 和 reply.
比如：
if (ret == NO_ERROR) {
    int exceptionCode = reply.readExceptionCode();
    if (exceptionCode) {
        ALOGE("sendBroadcastMessage(%s) caught exception %d\n", action.string(), exceptionCode);
        return false;
    }
} else {
    return false;
}

Parcel 参数的填充过程可以参考：
/frameworks/base/core/java/android/app/ActivityManagerNative.java
CMD 参数列表可以参考：
/frameworks/base/core/java/android/app/IActivityManager.java
```

## [FAQ15081] eng版本make命令生成不了odex的说明

```
在eng版本上打开宏WITH_DEXPREOPT:=true后，采用make命令生成不了odex文件(预置apk)，而采用mm或mmm命令是可以生成odex文件。
 
[Reason]
 
Android.mk中定义了LOCAL_MODULE_TAGS := debug导致；
在full build下，如果是透過LOCAL_MODULE_TAGS為debug的方式安裝，在build system中會透過debug_MODULES此變數記錄安裝目錄下的目標，而目標只.apk並沒odex:
out/target/product/cci6735m_65u_nj_l1/system/priv-app/WiFiTest/WiFiTest.apk

然而透過PRODUCT_PACKAGES的方式安裝，比如将LOCAL_MODULE_TAGS改为optional,并在device/mediatek/common/device.mk中增加debug版本WiFiTest apk的安装，在build system中會透過product_FILES此變數記錄安裝目錄下的目標，這時目標除了.apk之外還多了.odex:
out/target/product/cci6735m_65u_nj_l1/system/priv-app/WiFiTest/WiFiTest.apk 
out/target/product/cci6735m_65u_nj_l1/system/priv-app/WiFiTest/arm64/WiFiTest.odex

因此透過debug tag安裝的module只會生成.apk，而透過PRODUCT_PACKAES安裝的才會產生.odex。
此設計與除錯會需要classes.dex關，因此帶debug tag的module才不做odex(因為會把.apk中的classes.dex刪除)。

[SOLUTION]
所以如果您需要在make 命令全编时产生WiFiTest.apk的odex,您需要将Android.mk中LOCAL_MODULE_TAGS改为：
LOCAL_MODULE_TAGS := optional

并在 device/mediatek/common/device.mk 中将如下设置增加eng时也需要安装此apk.(可以直接去掉判断)

ifeq ($(TARGET_BUILD_VARIANT), eng)
    PRODUCT_PACKAGES += WiFiTest
endif
```

## [FAQ15083] user版本无充电动画

```
user版本无充电动画，而eng版本无此问题。如果把uartlog打开，无此问题，关闭uartlog，会有问题。
[SOLUTION]
请在project的init.charging.rc中的mount ubifs后面都加上wait ：
mount ubifs ubi@system /system wait
mount ubifs ubi@system /system ro remount wait
mount ubifs ubi@userdata /data nosuid nodev wait
```

## [FAQ15079] L版本如何添加全局宏代码控制开关

```
L版本及之后，MTK采用google 编译架构，不再采用kk版本之前架构，android,kernel,lk,preloader各模块相互独立，
projectconfig.mk 中定义的宏将仅作用到 android 层
Version >= android 5.0
[SOLUTION]
由于Projectconfig.mk只作用于Android层,而kernel ，lk ，和preloader 是不起作用的，需要宏控制对应代码时，请分别在对应地方定义。具体可参考以下：

preloader部分：
如需宏控制pl这部分代码时，需在alps/bootable/bootloader/preloader/custom/$project/$(project).mk中增加需要的宏。

lk部分：
如需宏控制lk这部分代码时，需在alps/bootable/bootloader/lk/project/$(Project).mk文件中添加控制宏。

kernel部分：
如需宏控制kernel这部分代码时,参考以下步骤新增kernel config.
1.请在您的driver code所在目录中的Kconfig文件增加您的宏定义
具体怎么写可以参考Kconfig中的其他宏定义
举个例子:
config MTK_FB
bool "MediaTek Framebuffer Driver"
depends on FB
default y
select FB_SOFT_CURSOR
---help---
This selects the MediaTek(R) frame buffer driver.
If you want to use MediaTek(R) frame buffer diver, say Y.
2.在您对应的kernel defconfig配置文件中(如：kernel-3.10/arch/arm/configs/$(project)_defconfig(user及userdebug版本时需在此文件中配置)或$(project)_debug_defconfig(eng版本时需在此文件中配置))中设定您增加的宏的值,如 CONFIG_MTK_FB=y
3.在您的kernel代码中就可使用CONFIG_MTK_FB这个宏了

Android部分：
如需宏控制Android c,c++代码时,参考以下步骤
1.ProjectConfig.mk中定义您需要添加的宏CONFIG_XXX = yes
2.Android.mk中根据ProjectConfig.mk中添加的宏设定LOCAL_CFLAGS
ifeq ($(CONFIG_XXX),yes)
LOCAL_CFLAGS += -DCONFIG_XXX=yes
endif
3.接下来，您的code中就可以使用您定义的CONFIG_XXX宏了
务必注意，自L版本之后preloader/lk/kernel/android已经完全独立，代码不会有任何耦合，请参考以上方法设置控制宏。
```

## [FAQ14878] 如何打开binder的log

```
在分析perfromances问题时，常常会有些问题时卡在频繁的binder调用的地方，但binder调用如果时间小于500ms，是没有log出来的。
那如何将这些binder调用信息打印出来了？ 
[SOLUTION]
可以在我司DCC(http://dcc.mediatek.inc/)上搜索HowToOpenbinderLog.docx，该文档内有详细介绍。
```

## [FAQ15065] 如何用命令行强制开关HWUI

```
强制开HWUI：
adb shell setprop persist.sys.ui.hw true
adb shell setprop debug.viewroot.disableHW false
adb shell stop
adb shell start

强制关HWUI：
adb shell setprop debug.viewroot.disableHW true
adb shell setprop persist.sys.ui.hw false
adb shell stop
adb shell start
```

## [FAQ14814] 如何定义App的Max Adj

```
AMS 有一套完整的算法来调整进程的 ADJ. 比如当进程退出使用后, AMS 会将该进程的 ADJ 提高. 从而使得 Memory 不足时 Low Memory Killer 可以有依据杀死进程. 
但在产品层面, 总有一些进程是产品特别关心的. 对于这些进程, 不希望 ADJ 调整太高, 避免被 LMK 杀死. 可以有几种方法实现该需求. 比如:
1. 将进程设置为 Persistent. 使进程持续占据 Memory 不被杀死
2. 调整 ADJ 的最大许可值. 在 Memory 不是特别紧张时, 可以保证该进程不被杀死. 而当 Memory 特别紧张时, 又可以被 LMK 杀死, 从而释放出 Memory 给前台进程使用.
这里介绍方法 2.

[SOLUTION]

首先需要加入 Patch ALPS01995207.
然后修改 /vendor/mediatek/proprietary/frameworks/base/packages/FwkPlugin/src/com/mediatek/op/amsplus/DefaultCustomizedOomExt.java 中的函数 getCustomizedAdj(String processName). 如果传入的是需要重新定义 ADJ 的进程, 则返回期望的 ADJ.
需要注意的是, 这个修改对 AMS 的策略会产生影响. 必然会影响到其他进程. 所以请一定斟酌放入 getCustomizedAdj 中的进程, 以及期望的 ADJ.
如果需要 Check 修改结果, 需要打开 AMS 的 DEBUG_OOM_ADJ 开关. 当该进程的 ADJ 按照 getCustomizedAdj 的返回结果重新设定时, 会打印如下 trace:
getCustomized(XXXX) with adj = Y cur = Z
其中 Y 表示 getCustomized 给出的 ADJ, Z 表示 AMS 计算出的 ADJ.
```

## [FAQ14973] Adb sideload OTA升级失败报错："E: unknown volume for path [/sideload/pakage.zip]”

```
操作步骤：
1. Enter the recovery mode by pressing the buttons with Power + Volume
2. Select the "Recovery"
3. Pressing the button "Power" and soon after the button "Volume +"
4. Select the "Apply update from ADB"
5. On the PC running the command "adb sideload <filename>"
6. Check the behavior

实际结果：
Is not possible to carry out the recovery and is shown msg "Sideload aborted"
The log is shown:
E: unknown volume for path [/sideload/pakage.zip]
E: can`t mount /sideload/package.zip
I: GPT is supported!
[SOLUTION]
在bootable/recovery/ roots.cpp如下函数添加code：
1、ensure_path_mounted函数开始位置加上：
if (!strncmp(path, "/sideload", strlen("/sideload"))) {//add
   return 0；//add
}//add
Volume* v = volume_for_path(path);

2、同样ensure_path_unmounted函数开始位置加上：
if (!strncmp(path, "/sideload", strlen("/sideload"))) {//add
   return 0；//add
}//add
Volume* v = volume_for_path(path);
```

## [FAQ14889] [Gallery]移动定制机（OP01）三方apk保存图片后，在gallery中不能正常显示（含图）

```
问题确认：
Step 1. 首先确认database中图片插入数据库的宽高信息为0
方法一：
可通过mobile_log来确认（无width 和 height 信息，或赋值为0）：
08-24 16:33:29.582257   942   953 V MediaProvider: insertFile<<<: values=bucket_id=1606349962 media_type=1 storage_id=65537 date_modified=1440405209 parent=13 format=14337 file_name=Moji_20150824_1633.jpg bucket_display_name=Moji file_type=1 title=Moji_20150824_1633.jpg mime_type=image/jpeg date_added=1440405209 _display_name=1440405209520 _size=351585 datetaken=1440405209000 _data=/storage/sdcard0/DCIM/Moji/Moji_20150824_1633.jpg, rowId=608
 
方法二：
可通过导出手机中的database文件external.db，直接使用database工具查看；
database文件路径：/data/data/com.android.providers.media/databases/
 
Step 2. 确认调用了TileImageViewAdaptor.java文件的updateWidthAndHeight()方法更新宽和高为0
可通过mobile_log来确认：
08-24 16:33:53.416043 1944 1944 I Gallery2/TileImageViewAdapter: <updateWidthAndHeight> mImageWidth 0, mImageHeight 0
08-24 16:33:53.418353 1944 1944 I Gallery2/Op01ImageOptionsExt: <updateMediaType> mediaType [mediaType = NORMAL,width = 0,height = 0,orientation = 0,mimeType = image/jpeg,isDRM = 0,drmMethod = 0,groupID = 0,groupIndex = 0,groupCount = 0,bestShotMark = 0,filePath = /storage/sdcard0/DCIM/Moji/Moji_20150824_1633.jpg,uri = null,isVideo = false,isLivePhoto = false,isSlowMotion = false,bucketId = 1606349962,id = 608,fileSize = 351585,duration = 0,relateData = null, dateModifiedInSec = 1440405209, isRefocus = false]
 
修改方案：
方案一：
从根源上来解决：
push 第三方apk，修改其插入数据库时，对宽和高进行赋值；
 
方案二：
在gallery中针对这种database中保存图片宽和高为0的情况进行优化：
修改TileImageViewAdaptor.java文件的如下方法
public void updateWidthAndHeight(MediaItem item) {
    if (item != null) {
        // add by MTK begin
        if ((item.getWidth()==0) || (item.getHeight()==0)) {
            Log.d(TAG, " Item width and height are 0, return");
            return;
        }
        // add by MTK end
        mImageWidth = item.getWidth();
        mImageHeight = item.getHeight();
        Log.i(TAG, " mImageWidth " + mImageWidth + ", mImageHeight " + mImageHeight);
    }
}
```

## [FAQ14842] 如何支持自拍杆拍照功能

```
根据Log确定自拍杆按键对应的KeyCode是多少，进而根据这个KeyCode值来确认对应的按键是哪个。
一般常用的有：音量+、音量-、Enter
public static final int KEYCODE_VOLUME_UP       = 24;
public static final int KEYCODE_VOLUME_DOWN     = 25;
public static final int KEYCODE_ENTER           = 66;
这里以音量-键为例
在/packages/apps/Camera/src/com/android/camera/actor/PhotoActor.java文件中的onKeyDown方法和onKeyUp方法中添加对KEYCODE_VOLUME_DOWN 键的处理即可,

即在case KeyEvent.KEYCODE_CAMERA:之前添加：

case KeyEvent.KEYCODE_VOLUME_DOWN:
```

## [FAQ14937] [Storage]Download开机后恢复出厂设置userdata可用空间变小

```
在开启MTK_SHARED_SDCARD时，userdata分区会自适应emmc剩余空间的大小，您可能会注意到download bin档后开机，透过adb shell df或Setting -> Storage查询到的内部存储空间(/data)大小会比恢复出厂设置后稍大。
但是第二次再做恢复出厂设置，/data的空间大小就不会再发生变化，一直保持第一次恢复出厂后的大小。除非再次重新download，又会发生这样的现象。


[SOLUTION]
编译时分区表设定的userdata分区size较小（大概1GB多），build时生成的userdata.img是以这个较小的size生成的。从build log中会找到类似以下这段:
make_ext4fs -s -T -1 -S out/target/product/sisley2OTP/root/file_contexts -l 1237319680 -a data out/target/product/sisley2OTP/userdata.img out/target/product/sisley2OTP/data

Creating filesystem with parameters:
Size: 1237319680   //0x49c00000
Block size: 4096
Blocks per group: 32768
Inodes per group: 7552
Inode size: 256
Journal blocks: 4720
Label: 
Blocks: 302080
Block groups: 10
Reserved block group size: 79
Created filesystem with 33/75520 inodes and 10340/302080 blocks

可以看到这个例子中生成ext4 image时总的size为0x49c00000 (1180MB)。
而download后第一次开机后会执行ext4 resize操作，根据实际userdata分区的大小修改ext4 fs里面的相关参数，以达到文件系统自适应emmc实际大小的目的。 可以从kernel log中找到类似下面的log:

[    7.677582].(5)[180:resize_ext4]resize: Size for partition(/dev/block/platform/mtk-msdc.0/by-name/userdata) is 12064256K.  //0x2E0580000，userdata分区实际的size
[    7.678956].(5)[180:resize_ext4]resize: Size in superblock is 1208320K.  //0x49C000000, userdata在分区表中的size
[    7.679793].(5)[180:resize_ext4]resize: Size will (maybe) resize to(after adjust) is 12064256K.
[    7.681178].(5)[180:resize_ext4]resize: Running /system/bin/resize2fs on /dev/block/platform/mtk-msdc.0/by-name/userdata
[    8.169390].(0)[180:resize_ext4]resize: Resize ext4 return 0

在执行恢复出厂设置时，会擦除userdata分区，并重新利用make_ext4fs创建新的文件系统，这时候就是直接根据userdata分区的实际大小来创建ext4 fs。从factory reset recovery log中会找到类似以下这段:

Formatting /data...
format /data start=1420131485 
I:GPT is supported!
Creating filesystem with parameters:
Size: 12353798144     //0x2E0580000
Block size: 4096
Blocks per group: 32768
Inodes per group: 8112
Inode size: 256
Journal blocks: 32768
Label: 
Blocks: 3016064
Block groups: 93
Reserved block group size: 743
Created filesystem with 11/754416 inodes and 87558/3016064 blocks
format end=1420131494 duration=9

对比build时创建的userdata.img和factory reset时在userdata分区创建文件系统，由于userdata分区的size在这两种情况下不同，那么创建ext4时一些参数就会被自动调整，这里看到最重要的就是 Journal blocks差异较大，build时是 4720，recovery时是32768，差了110MB左右。inode per group也会有些差异，这些都是导致df出来的分区大小差异的原因。因为ext4 resize操作不会调整这些参数值，只会调整super block里面的参数，以及总的block和group数目。

一般手机只会在工厂产线上遇到这样的问题，手机在产线上一定会最后做factory reset，end user一般只会做OTA升级，不会再遇到这样的问题。
```

## [FAQ14881] 如何修改设置中语言显示的名称(如将"繁体中文（台湾）"修改为　　"中文（繁体）")

```
如何修改设置中语言显示的名称(如将　"繁体中文（台湾）"　修改为　"中文（繁体）")
语言名称的显示是在LocalePicker.java中(alps/framework/base/core/java/com/android/internal/app)函数getAllAssetLocales()中做的．如要修改可参考如下方案．
[SOLUTION]
可将LocalePicker.java中成员变量　
private static final boolean DEBUG = false；　将DEBUG的值置为true, 
然后抓一份log,　进设置－＞语言，停止抓log, 从log中会包含函数getAllAssetLocales(Context context, boolean isInDevelopeMode)打出的log，这个函数是把各语言加到一个list中，各语言显示的名称也有打出来，　可以对着log打印的地方修改这个显示的名称．
```

## [FAQ14938] [Storage]关于文件系统空间预留的说明

```
也许你在测试时无意中发现虽然把/data或/cache填满了，无法再写入数据，但是透过stat查看分区文件系统状态，free blocks并不等于0. 

[SOLUTION]
kernel-3.10 ext4模块本身会预留2%左右的分区存储空间做reserved空间，专门为ext4自己保留。在super.c (kernel-3.10\fs\ext4)的ext4_calculate_resv_clusters()这个函数中有以下这段code:
/*
* By default we reserve 2% or 4096 clusters, whichever is smaller.
* This should cover the situations where we can not afford to run
* out of space like for example punch hole, or converting
* uninitialized extents in delalloc path. In most cases such
* allocation would require 1, or 2 blocks, higher numbers are
* very rare.
*/
resv_clusters = ext4_blocks_count(EXT4_SB(sb)->s_es) >>
EXT4_SB(sb)->s_cluster_bits;

do_div(resv_clusters, 50);
resv_clusters = min_t(ext4_fsblk_t, resv_clusters, 4096);
这段code就是计算ext4预留空间大小的。EXT4_SB(sb)->s_cluster_bits的值一般为0，可以看到最终预留的空间是取分区空间的2%和4096的最小值，也就说最多会预留4096个block（4096bytes ），也就是16MB。

(1) system分区
执行busybox的stat -f /system会印出类似以下的信息:
# ./stat -f /system
File: "/system"
ID: d3609fe804970d6b Namelen: 255     Type: ext2/ext3
Block size: 4096
Blocks: Total: 380892     Free: 139835     Available: 135739
Inodes: Total: 98304      Free: 95634

这里Free - Available = 4096 blocks，即16MB，因为system分区一般size较大(大于1GB)，预留2%多半会超过16MB，因此会预留最多4096个block，即16MB。

(2)cache分区
cache分区一般size比较小，100~400MB之间，目前L版本常见的是400MB，以预留2%来计算的话，应该会预留的是8MB，以下的例子就是对应这种情况。
# ./stat -f /cache
File: "/cache"
ID: d3609fe804970d6b Namelen: 255     Type: ext2/ext3
Block size: 4096
Blocks: Total: 99186      Free: 99085      Available: 97037
Inodes: Total: 25600      Free: 25585
这里Free - Available = 2048 blocks，即8MB

(3) data分区
data分区一般size较大(大于1GB)，与system分区类似，按照理论分析应该也是要预留16MB才对，实际执行stat后的结果如下:
./stat -f /data
File: "/data"
ID: d3609fe804970d6b Namelen: 255     Type: ext2/ext3
Block size: 4096
Blocks: Total: 3232930    Free: 2911026    Available: 2902834
Inodes: Total: 827392     Free: 825699

Free - Available = 8192 blocks，即32MB
很奇怪，这里为什么变成了32MB呢？

为了防止data分区被普通的APP填满，MTK对/data分区额外做了空间预留，具体就是在init.mt6XXX.rc里面的以下这段:
on fs
write /proc/bootprof "INIT:Mount_START"
mount_all /fstab.mt6735
exec /system/bin/tune2fs -O has_journal -u 10010 -r 4096 /dev/block/platform/mtk-msdc.0/by-name/userdata

tune2fs会为uid <=10010的process再额外预留4096个blocks，即16MB。tune2fs这里会设置super block里面的s_r_blocks_count字段，这个字段在创建ext4 fs时默认值为0。

(4) Internal SD
在开启MTK_SHARED_SDCARD的情况下，Internal SD与/data会共享userdata的存储空间。但是/system/core/sdcard/sdcard.c中default会预留50MB，防止APP写internal sd时把/data填满。
#define DATA_FREE_SIZE_TH_DEFAULT (50UL*1024UL*1024UL)
如果有需求的话， 可以对这里预留的空间做客制化修改。

同样对internal sd执行stat
# ./stat -f /mnt/shell/emulated
File: "/mnt/shell/emulated"
ID: 0        Namelen: 255     Type: UNKNOWN
Block size: 4096
Blocks: Total: 3220130    Free: 2898219    Available: 2890027
Inodes: Total: 827392     Free: 825696
Free - Available = 8192 blocks，也是差32MB。

这是因为internal sd的Free和Available都是基于/data的Free和Available直接减去50MB得到的。

data Free - internal sd Free =  2911026 - 2898219 = 12807 blocks (50MB)
对于Internal SD来说，当Available为0时，这时候实际上还是可以写入数据的，直到Free为0为止。

因此建议APP call getFreeBlocks()来获取Internal SD的剩余空间，而不是getAvailableBlocks()。

而对于data来说，由于Linux Kernel会额外做限制，因此建议APP是call getAvailableBlocks()来获取/data的剩余可用空间，而不是getFreeBlocks()。 
```

## [FAQ14893] FOTA/OTA之後启动第三方APP出現APP Crash

```
用FOTA下载OTA包，下载完毕更新；
更新完毕后点击多个三方APP无法进入，提示报错（这些APK都是正常安装，非预置）。

报错信息类似：
Caused by: java.io.IOException: Failed to remove obsolete file from /data/dalvik-cache/arm/data@app@jp.naver.line.android-1@base.apk@classes.dex when searching for dex file /data/app/jp.naver.line.android-1/base.apk: Permission denied

[SOLUTION]
1. 如果apk之前有安装过，OTA升级后会检测到该apk的odex是旧的需要重新去提取，但是因为这个apk贵司长时间没有使用，L版本上默认PackageManagerService判断超过7天，则开机时不会做dexopt而报这种错误，此时一般重启之后这些apk会正常运行。

上述code中 mDexOptLRUThresholdInMills的值是7天，即若此apk上次使用时间(then=pkg.mLastPackageUsageTimeInMills)+7天还小于当前时间(now)，则此apk被判别为never不会被使用的apk，所以就不做dexopt了。那么异常时会出现上面的log。

2. 发生异常时如果点击了这几个apk且发现其无法使用（无法使用的原因可能是boot.oat有更新，此时apk的odex档是旧的，需要重新提取才可正常运行），即此时mLastPackageUsageTimeInMills会更新。
所以重新开机后这个条件if (then + mDexOptLRUThresholdInMills < now)就不会满足，即这几个apk会做dexopt，此时能够正确提取odex，这时apk能够正常运行。

3. 这是Google在L版本上的机制，不建议修改，如果需要规避，可以将i.remove();这行给注释掉，即超7天时仍可以正常提取odex.
```

## [FAQ13439] 添加低温警告

```
    修改
    alps\mediatek\packages\apps\BatteryWarning\src\com\mediatek\batterywarning\BatteryWarningActivity.java
    1.
    private static final int SAFETY_OVER_TIMEOUT_TYPE = 4;
    //添加低温类型5
    private static final int BATTERY_LOW_TEMPERATURE_TYPE = 5;
    
    2.
    static final int[] sWarningTitle = new int[] {
            R.string.title_charger_over_voltage,
            R.string.title_battery_over_temperature,
            R.string.title_over_current_protection,
            R.string.title_battery_over_voltage,
            R.string.title_safety_timer_timeout,
            /*添加低温字符串资源 */
            R.string.title_battery_low_temperature};
    3.
    private static final int[] sWarningMsg = new int[] {
            R.string.msg_charger_over_voltage,
            R.string.msg_battery_over_temperature,
            R.string.msg_over_current_protection,
            R.string.msg_battery_over_voltage,
            R.string.msg_safety_timer_timeout,
            /*添加低温字符串资源 */
            R.string.msg_battery_low_temperature };
    4.
    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
        @Override
        public void onReceive(Context context, Intent intent) {
            String action = intent.getAction();
            if (Intent.ACTION_POWER_DISCONNECTED.equals(action)) {
                if (mType == CHARGER_OVER_VOLTAGE_TYPE
                        || mType == SAFETY_OVER_TIMEOUT_TYPE || mType == BATTERY_LOW_TEMPERATURE_TYPE /*添加低温类型*/) {
                    Xlog.d(TAG, "receive ACTION_POWER_DISCONNECTED broadcast, finish");
                    finish();
                }
            }
        }
    };
    5.
    替换两个方法即可
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        Intent intent = getIntent();
        mType = intent.getIntExtra("type", -1);
        Xlog.d(TAG, "onCreate, mType is " + mType);
        if (mType >= CHARGER_OVER_VOLTAGE_TYPE  && mType <= BATTERY_LOW_TEMPERATURE_TYPE/*改为低温类型*/) {
            showWarningDialog(mType);
            registerReceiver(mReceiver, new IntentFilter(
                    Intent.ACTION_POWER_DISCONNECTED));
        } else {
            finish();
        }
    }
    protected void onDestroy() {
        super.onDestroy();
        if (mType >= CHARGER_OVER_VOLTAGE_TYPE  && mType <= BATTERY_LOW_TEMPERATURE_TYPE/*改为低温类型*/) {
            unregisterReceiver(mReceiver);
        }
    }
    6.字符串资源
    values/strings.xml
        <string name="title_battery_low_temperature">"Low Battery Temperature"</string>
        <string name="msg_battery_low_temperature">"Your battery temperature is too low, please disconnect the charger!"</string>
    values-zh_rCN/strings.xml
        <string name="title_battery_low_temperature">"电池温度过低"</string>
        <string name="msg_battery_low_temperature">"您的电池温度过低，请断开充电器!"</string>
```

## [FAQ14661] 设置中电池耗电量排名不准确、显示有误等问题

```
1.先按照 Power profile for Android.pptx 中的步骤对 framwork/base/core/res/res/xml/power_profile.xml 文件中的各个参数进行测量 
<item name="battery.capacity">1000</item>此处1000即可。
2.build新版本后再次进行测试
```

## [FAQ14785] L平台上频繁GC导致UI卡顿

```
在L平台上频繁GC导致UI发生卡顿，通过systrace和log来判断是否是GC导致的，如果是，则可以使用下面的解决方案
[SOLUTION]
请按照如下的修改测试：
/frameworks/base/core/jni/android_util_Binder.cpp
158static void incRefsCreated(JNIEnv* env)
159{
160    int old = android_atomic_inc(&gNumRefsCreated);
161    if (false) {  //
162        android_atomic_and(0, &gNumRefsCreated);
163        env->CallStaticVoidMethod(gBinderInternalOffsets.mClass,
164                gBinderInternalOffsets.mForceGc);
165    } else {
166        ALOGV("Now have %d binder ops", old);
167    }
168}
169
```

## [FAQ14778] 手机支持的Mobile Class

```
手机支持的Mobile Class有：
1. Class_CC --> CS ONLY
2. Class_CG --> PS ONLY
3. Class_B, GSM Prefer --> CS & PS, CS Prefer
4. Class_B, GPRS Prefer --> CS & PS, PS prefer
 
对于Mobile Class，手机的默认设置应该是Class_B, GSM Prefer.
 
Mobile Class也可以通过Nvram来修改设定：
```

## [FAQ14830] 【Build and Make】L版本常见编译问题汇总

```
目前MOL系统针对build and make的FAQ有很多但过于分散，本FAQ主要针对目前适应L版本（Version >= android 5.0）的已有FAQ进行汇总，同时也汇总了DCC上可以参考的相关文档。 
  
[SOLUTION]
 
注意以下汇总，适应于L版本：
(1)编译环境搭建
 
android环境搭建请到DCC搜索文档：
Android_Build_Environment_on_Ubuntu_12.04_64-bit_Installation_SOP.docx
 
modem环境搭建请到DCC搜索文档：
MTK_MOLY_MakeBuild_Design_Customer.docx
 
(2)系列FAQs
 
[FAQ14443]合入patch的注意事项
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ14443
 
[FAQ11888]Turnkey AOSP的软件包的编译命令
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ11888
 
[FAQ14143]AOSP如何快速build kernel、lk 和 preloader
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ14143
 
[FAQ13925]AOSP如何单独build Preloader
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13925
 
[FAQ13735]AOSP 如何单独build LK
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13735
 
[FAQ13428]AOSP如何单独build kernel
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13428
 
[FAQ10625]提升Android编译速度
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ10625 
 
[FAQ07275]如何在linux中添加新的kernel module
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ07275
 
[FAQ14175]AOSP如何menuconfig
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ14175
 
[FAQ13609]L版本如何编译android module
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13609
 
[FAQ13697]L 版本如何将第三方so库打包到apk
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13697
 
[FAQ13232]L 预置apk
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13232
 
[FAQ14513]L GMS预置
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ14513
 
[FAQ14131]L版本预编译提取apk的odex文件，如何修改？
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ14131
 
[FAQ13465]L版本How to clone project
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13465
 
[FAQ13658]L版本上传git服务器后编译出错
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13658
 
[FAQ11794]Preloader bin size过大编译报错怎么办
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ11794
 
[FAQ14456]system.img>2G导致编译otapackage时报错如何处理
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ14456
 
[FAQ13408]AOSP编译常见问题
http://online.mediatek.inc/Pages/FAQ.aspx?List=SW&FAQID=FAQ13408
```

## [FAQ09389] [AT]在双卡版本中，如何在PC端发送AT命令给SIM2

```
非SGLTE版本：
Example：
当前手机中插入两张SIM卡，3G protocol在卡槽1，如果要通过PC端对SIM2发送AT命令，需要先下：
AT+ESUO=5

同样，如果
当前手机中插入两张SIM卡，3G protocol在卡槽2，如果要通过PC端对SIM1发送AT命令，需要先下：
AT+ESUO=5

关于AT+ESUO的具体参数解释，请参考DCC上AT_DOCUMENT_Modem.docx文档中所描述。

SGLTE版本：
SGLTE比较特殊，SIM1占用了protocol1和protocol2，所以如果需要发送AT命令到protocol2的话，那么需要先下：
AT+ESPO=2

如果是SGLTE DSDS版本，想将AT命令发送给SIM2，那么需要先下：
AT+ESPO=3

关于AT+ESPO的具体参数解释，请参考DCC上AT_DOCUMENT_Modem.docx文档中所描述。

L版本：
使用AT+ESUO=4发送AT给SIM1

使用AT+ESUO=5发送AT给SIM2

在C2K项目上，如果要发送AT命令到C2K的modem，请先下：
AT+ESUO=9
```

## [FAQ14829] [Gallery]相册列表界面，屏幕截图在相册缩略图中的字迹模糊

```
Fancy 界面显示的是图片缩略图，那既然是缩略图就存在不清晰的情况，而当图片上有字迹的时候，这种不清晰的情况就会表现出来。
缩略图界面的功能是图片的预览，如果需要查看清晰的图片，可以点击进入大图。
如果需要修改，可按照如下方式做改动：
在decode时提高BitmapFactory.Options中的inSampleSize，使得decode出来的图片变清晰，然后在这个基础上进行resize。

LocalImage.java的onDecodeOriginal()函数中，在
int targetSize = MediaItem.getTargetSize(type);
这句话之后添加
if (type == MediaItem.TYPE_FANCYTHUMBNAIL)
    targetSize = (int)(targetSize * 1.5f);
```

## [FAQ14693] 如何将device version由HAL3.2改为HAL1.0

```
Android one版本默认底层配的device version为HAL3.2，如果想改为HAL1.0，可以按以下方法修改。
[SOLUTION]
在文件config_static_metadata_common.h中把
case 0:
     //======================================================================
    CONFIG_METADATA_BEGIN(MTK_HAL_VERSION)
        CONFIG_ENTRY_VALUE(MTK_HAL_VERSION_3_2, MINT32)
    CONFIG_METADATA_END()
    //======================================================================
    break;
case 1:
     //======================================================================
    CONFIG_METADATA_BEGIN(MTK_HAL_VERSION)
        CONFIG_ENTRY_VALUE(MTK_HAL_VERSION_3_2, MINT32)
    CONFIG_METADATA_END()
    //======================================================================
    break;
改为
case 0:
     //======================================================================
    CONFIG_METADATA_BEGIN(MTK_HAL_VERSION)
        CONFIG_ENTRY_VALUE(MTK_HAL_VERSION_1_0, MINT32)
    CONFIG_METADATA_END()
    //======================================================================
    break;
case 1:
     //======================================================================
    CONFIG_METADATA_BEGIN(MTK_HAL_VERSION)
        CONFIG_ENTRY_VALUE(MTK_HAL_VERSION_1_0, MINT32)
    CONFIG_METADATA_END()
    //======================================================================
    break;
```

## [FAQ14749] 在电源设置中出现红线

```
那个红线是因为debug开关为true导致的，把BatteryHistoryChart.java中的DEBUG开关设置为false就可以了。
```

## [FAQ14769] L版本OTA升级遇到error："system has been remounted R/W; reflash device to reenable OTA updates"

```
L版本；如果有在bootable/recovery/目录下code中添加ensure_path_mounted(“/system”);
或者是在recovery mode下执行root integrity check之后，导致OTA升级失败，而且last_log中有如下error：
 
script aborted: system has been remounted R/W; reflash device to reenable OTA updates
system has been remounted R/W; reflash device to reenable OTA updates
[SOLUTION]

可以尝试在 /bootable/recovery/roots.cpp中作如下修改：(蓝色为添加部分)
int ensure_path_mounted(const char* path) {
} else if (strcmp(v->fs_type, "ext4") == 0 ||
    strcmp(v->fs_type, "vfat") == 0) {
    if (strcmp(v->mount_point, "/system") == 0)//add
        result = mount(v->device, v->mount_point, v->fs_type, MS_NOATIME | MS_NODEV | MS_NODIRATIME | MS_RDONLY, "");//add
    else //add
        result = mount(v->device, v->mount_point, v->fs_type, MS_NOATIME | MS_NODEV | MS_NODIRATIME, "");
如果问题还是不能解决，请提eservice给Mediatek，谢谢！
```

## [FAQ08895] 如何抓取traceview？

```
1、手机用usb连接到电脑，打开Eclispe的DDMS界面或Android Debug Monitor，进入Device 标签页，在识别到Device并连接成功之后，用鼠标点击你要进行method profiling的process，选择之后，这个process处于深蓝色高亮状态。
2、在Device这个面板的最上方那一排button中，将鼠标悬停在button上方，有提示文字，找到"Start Method Profiling"的button，点击该button，进行profiling动作。
3、接下来你就开始操作手机，复现问题。
4、操作复现问题完了之后，还是点击刚才那个button，此时button的提示文字会变为"Stop Method Profiling"，点击之后就停止了profiling动作，也就停止了抓取traceview。
5、抓完之后会自动打开刚才所抓取的traceview文件，如果是用Eclipse，请通过Eclipse的File-> Save as 功能，将该traceview文件另存下来提供给我们分析；如果是Android Device Monitor，则将鼠标悬停在已经打开的traceview文件上，该文件的保存路径会悬浮显示在文件名上方，按照此路径将抓到的traceview文件发给我们分析即可。
```

## [FAQ03568] [Audio Driver] 录音最开始一段时间的数据是录不到的

```
drop 120ms record data due to hardware pluse
[SOLUTION]
AudioType.h中
#define CAPTURE_DROP_MS (120)
此宏规定了会drop 120ms的数据
```

## [FAQ03685] [Audio Common] 如何打开HD record

```
HD record即高质量录音
打开方法如下：修改ProjectConfig.mk中
MTK_AUDIO_HD_REC_SUPPORT=yes
MTK_DUAL_MIC_SUPPORT=yes  (双mic项目才能开此项)
```

## [FAQ03966] [Audio Common] 通话时如何播放声音给对方听

```
默认情况下：通话时播放声音只有本端能听到，对方听不到，如果希望对方也能听到请参考如下修改
[SOLUTION]
AudioALSAStreamManager::AudioALSAStreamManager()中可以看到
mBGSDlGain(0xFF),
mBGSUlGain(0),
其中mBGSDlGain表示下行gain值，影响的是本端听到的声音大小
mBGSUlGain表示上行gain值，影响的是对方听到的声音大小，默认值是0，所以对方听不到
只要将mBGSUlGain改为非0值即可，最大值0xFF
```

## [FAQ03686] [Audio App] 录音机菜单项意义

```
录音机菜单项意义
[SOLUTION]
音质:
High(3gpp): AAC, stereo
Mid(3gpp): AAC, stereo //虽然和High的音频编码同为AAC但是bitrate和samplerate略差
Low(amr): AMR, mono
录音模式:
Normal: 普通录音
Meeting: 会议（近距）录音
Lecture: 远距录音
```

## [FAQ14782] L版本开启MTK_SHARED_SDCARD 后OTA包放入内卡如何MOTA升级成功？

```
L版本开启MTK_SHARED_SDCARD=yes， 并且把OTA包放入内卡，即升级包路径为：/data/media/0/update.zip，在进行MOTA升级时，重启机器会遇到一直卡在黑屏、但不会进入recovery mode的现象，仔细检查mtklog发现有如下error：
 
uncrypt : update package is /data/media/0/update.zip
uncrypt : failed to convert /data/media/0/update.zip to absolute path: Permission denied
[SOLUTION]
解决方法：
修改\alps\device\mediatek\common\sepolicy\uncrypt.te 如下：(其中蓝色为新添加)
# ==============================================
# MTK Policy Rule
# ============
allow uncrypt misc_device:chr_file *;
allow uncrypt platformblk_device:dir *;
allow uncrypt platformblk_device:blk_file *;
allow uncrypt system_data_file:file { open read };
allow uncrypt media_rw_data_file:dir { search getattr };
allow uncrypt media_rw_data_file:file { open read getattr };
```

## [FAQ14753] 预置apk到vendor/operator/app下面，有时候会编译不过

```
这种情况一般是apk本身没有对齐导致的，可以先使用zipalign重新对齐apk后再预置，具体做法如下：
out/host/linux-x86/bin/zipalign -f 4 unalign.apk aligned.apk
其中，unalign.apk指当前source apk，aligned.apk指对齐后输出的apk。
```

## [FAQ14537] 下拉菜单中闪光灯打开时，mtk camera app也可以正常启动

```
当mtk camera app启动时会主动发送广播到下拉菜单，提示去关闭闪光灯，然后mtk camera app再去启动相机，这样就可以正常启动了。具体实现可参考如下文档：
MTK Camera ap-broadcast-SystemUI_mt6735.pdf
 
文档可以去下面DMS中下载：
https://dcc.mediatek.com/Docs/Default.aspx
```

## [FAQ10591] 怎样编译MTK的SDK?

```
请参考 FAQ03042 的编译命令，然后会生成相应的zip包，那只需要将其产生的out目录下的zip包给到三方开发即可，其中public 的api都放在这个zip包中的docs\mediatek-sdk\reference目录下.
```

## [FAQ03042] 如何编译MTK的模拟器

```
MTK的emulator是基于MTK平台的codeabse编译得到用来模拟真机的虚拟Device,以下是具体的操作步骤：

1. Build MTK SDK Packages
-对于mt6572以前的chip，用如下的命令编译: 
./makeMtk banyan_addon
-从mt6572开始的chip,由于mt6572之后CPU开始支持X86架构，其performace会更好，mt6572之后，建议编译x86的emulator来使用.
./makeMtk banyan_addon_x86

编译完成后会在out/host/linux-x86/sdk_addon下生成MTK的SDK包，比如mtk_sdk_api_addon-17.1.zip，(其中17是android api level)

2. 解压mtk_sdk_api_addon_17.1.zip
将解压后的mtk_sdk_api_addon-17.1整个文件夹放在android原本的sdk的add-ons目录下。

3. 拷贝emulator相关的执行文件到android sdk tool下：
- 对ICS 4.0之前的版本：
进入android-sdk-windows\add-ons\banyan_addon_ALPS.GB.FDD.MP.V1_eng\tools 目录下，将其中的 emulator.exe 或者 emulator（如果使用Linux的SDK的话）复制出来，覆盖android-sdk-windows\tools下的相应emulator.exe

- 对ICS 4.0及之后的版本：
将mtk_sdk_api_addon-15.1\emulator对应文件夹下的emulator,emulator-arm,emulator-x86这三支文件替换android原本sdk的tools目录下的emulator,emulator-arm,emulator-x86这三支文件(建议备份google原始sdk下的emulator,emulator-arm,emulator-x86，以便后面用到Google emulator)。

4. 创建新的AVD
在Target里面选择带有MediaTek标志的，然后启动这一AVD就可以了
PS：创建AVD时需要同步将SDK的版本升级到相对的android版本，比如JB2对应的android API level 17,则对应SDK的版本也要升级到level 17,否则将在创建AVD的时候将load不出带MediaTek标志的target
```

## [FAQ10259] 如何将桌面和主菜单较长的图标名称显示完整?

```
有些APP的图标名称太长，在主菜单中显示不全，而且在桌面建立这些APP的快捷方式后，这些图标名称也会显示不全，如何将其显示完整？

[SOLUTION]

1. 请修改styles.xml，将
<style name="WorkspaceIcon.Portrait">
    <item name="android:drawablePadding">0dp</item>
    <item name="android:paddingLeft">4dp</item>
    <item name="android:paddingRight">4dp</item>
    <item name="android:paddingTop">@dimen/app_icon_padding_top</item>
    <item name="android:paddingBottom">4dp</item>
    <item name="android:textSize">13sp</item>
</style>

修改为：
<style name="WorkspaceIcon.Portrait">
    <item name="android:drawablePadding">0dp</item>
    <item name="android:paddingLeft">4dp</item>
    <item name="android:paddingRight">4dp</item>
    <item name="android:paddingTop">@dimen/app_icon_padding_top</item>
    <item name="android:paddingBottom">4dp</item>
    <item name="android:textSize">13sp</item>
    <item name="android:singleLine">false</item>
    <item name="android:lines">2</item>
</style>

2. 请修改BubbleTextView.java的applyFromShortcutInfo方法，将
setCompoundDrawablePadding((int) ((grid.folderIconSizePx - grid.iconSizePx) / 2f));
这行代码中的参数改小为合适的值。

3. 请修改PagedViewIcon.java的applyFromApplicationInfo方法，如下：
public void applyFromApplicationInfo(AppInfo info, boolean scaleUp, PagedViewIcon.PressedCallback cb) {
    mIcon = info.iconBitmap;
    mPressedCallback = cb;
    setCompoundDrawablesWithIntrinsicBounds(null, Utilities.createIconDrawable(mIcon), null, null);
    setCompoundDrawablePadding(xxxx);//mtk add（xxxx请自行调整为合适的值）
    setText(info.title);
    setTag(info);
}
```

## [FAQ14660] [Audio framework] 音量警告提示框选择OK，重启后再增大音量希望还会弹出音量警告提示框

```
目前的做法是:
音量警告提示框选择OK，重启后就不会再弹出警告提示框, 除非恢复出厂设置
 
如果希望重启后再增大音量希望还会弹出音量警告提示框
请参考如下修改:
 
 
[SOLUTION]
 
1: 可以在 AudioService.java 的构造方法中设个变量, 比如 bool bIsFirstBoot = true;

2: 然后在 checkSafeMediaVolume 方法中, 判断此变量, 如下:

private boolean checkSafeMediaVolume(int streamType, int index, int device) {
    synchronized (mSafeMediaVolumeState) {
        //add begin
        if(bIsFirstBoot){
            mSafeMediaVolumeState = SAFE_MEDIA_VOLUME_ACTIVE;
            bIsFirstBoot = false;
        }
        //add ends
        if ((mSafeMediaVolumeState == SAFE_MEDIA_VOLUME_ACTIVE) &&
                (mStreamVolumeAlias[streamType] == AudioSystem.STREAM_MUSIC) &&
                ((device & mSafeMediaVolumeDevices) != 0) &&
                (index > mSafeMediaVolumeIndex)) {
            return false;
        }
        return true;
    }
}
```

## [FAQ14685] 从2G log获取手机加密算法支持情况(A5 & GEA)

```
从catcher/ELT log中解码attach request信令，即可获取手机A5/GEA加密算法的支持信息。
具体解码工具的使用可参考：
[FAQ14417]Free 3GPP decode tool使用简介
```

## [FAQ11459] [AAL]动态开关AAL功能

```
手机连接ADB
cd sys/kernel/debug
echo aaloff>dispsys
```

## [FAQ09912] [MT6572]工厂模式背光测试，测试图片不是全屏显示

```
MT6572项目，配置qHD分辨率后，在工厂模式中测试背光，显示测试图片不是全屏显示

[SOLUTION]
默认测试资源分辨率是WVGA的，如要显示其他分辨率图片，需要在对应的工程目录中进行客制化

1、修改如下文件中的值为对应分辨率
    alps/mediatek/custom/{$project}factory/inc/cust_lcd.h
2、修改如下目录中的资源，为想要显示的对应分辨率图片 (请使用为png格式)
    alps/mediatek/custom/{$project}factory/res/images
```

## [FAQ10019] HDMI/MHL如何修改手机默认横竖屏显示方式

```
插入HDMI/MHL后，手机资源默认会横屏显示，如何去掉不用默认横屏显示，而根据G-sensor改变显示呢？

[SOLUTION]
请如下修改：
PhoneWindowManager.java
(alps/frameworks/base/policy/src/com/android/internal/policy/impl)

public int rotationForOrientationLw(int orientation, int lastRotation) {
    else if (mHdmiPlugged && mHdmiRotationLock && false) {  //添加红色部分
        // Ignore sensor when plugged into HDMI.
        // Note that the dock orientation overrides the HDMI orientation.
        preferredRotation = mHdmiRotation;
    }
    . . . . . .
}
```

## [FAQ08763] adb命令点亮屏幕说明

```
之前77平台在终端输入如下两个命令屏幕就可以点亮
echo on > /sys/power/state
echo 222 > /sys/class/leds/lcd-backlight/brightness

现在89平台输入这两个命令屏幕不能点亮，请问如何可以直接在终端通过命令来点亮屏幕？

[SOLUTION]
89以后平台和77之前的架构不一样，

可以如下操作测试：

在系统正常开启的时候，adb输入 
echo mem >/sys/power/state ==> kernel休眠
echo on >/sys/power/state  ==> kernel唤醒
echo 255 >/ sys/class/leds/lcd-backlight/brightness ==>点亮屏幕
这时候正常唤醒

在系统已经睡眠的时候，adb输入
echo on >/sys/power/state  ==> kernel唤醒
echo 255 >/ sys/class/leds/lcd-backlight/brightness ==>点亮屏幕
此时可以看到，背光已经被点亮了，然后再输入
./system/bin/boot_logo_updater
可以看到可以正常输出logo，说明adb cmd是可以正常唤醒系统的，并且LCM也是正常工作的。
不过现在ovl那边系统是disable的，所以只有黑色的数据。

75和77上面直接echo on >/sys/power/state就可以正常开启系统，89上面无法显示，是89的架构不同导致的，HWC那边在睡眠的时候就会关掉OVL这边的layer，故输入power on后只能显示黑色。
```

## [FAQ04402] 如何加载LCD相应的资源保证显示正常

```
1. 保证开机Logo可以正常显示
根据屏幕分辨率，在ProjectConfig.mk中修改宏BOOT_LOGO为相应的分辨率(如wvga/hvga/qhd……)，支持的分辨率可以在目录（Turnkey Project: mediatek/custom/common/lk/logo/）（AOSP Project：
bootable/bootloader/lk/dev/logo）中进行查找
如果在目录（Turnkey Project: mediatek/custom/common/lk/logo/）（AOSP Project：

bootable/bootloader/lk/dev/logo）中未找到屏幕相应的分辨率，请自行添加目录并添加相应的资源图片
2. 保证UI中的CP能够正常显示

需要根据屏幕分辨率，屏幕尺寸，计算DPI（dot per inch，每英寸像素数），再根据计算结果在ProjectConfig.mk中为宏MTK_PRODUCT_LOCALES添加相应的值(ldpi/mdpi/hdpi/xhdpi)

DPI计算方法
1)   利用勾股定理，计算屏幕对角线像素数 = (屏幕宽像素2+屏幕高像素2)0.5
2)   利用屏幕对角线像素数与屏幕尺寸计算DPI = 屏幕对角线像素数/屏幕尺寸
3)   以4.3英寸，720×1280屏幕为例，对角线像素数 = (7202+12802)0.5=1468.6，DPI = 1468.6/4.5 = 326.4
4)   根据dpi的值，选择适用的范围

如何根据DPI的值确定MTK_PRODUCT_LOCALES的参数，请参看下图
```

## [FAQ08889] 如何抓取hprof文件？

```
1. 命令行方式抓取，方法如下：

a) 通过输入adb命令的方式抓取，PIDXXX为对应进程的PID：
    adb remount
    adb shell chmod 0777 /data/misc
    adb shell kill -10 PIDXXX
b) 会在/data/misc目录下生成一个以pidXXX.hprof结尾的hprof文件。
c) 然后通过adb pull或其他方式将这个文件导出来即可。

2. 通过DDMS抓取：
a) 打开Eclipse，点击device窗口的Dump Hprof file 图标(绿色圆柱体，右边一条向下红色箭头线)
b) 等几秒中会弹出保存hporf的路径，然后就可以获取到当时的hprof了。

注意：hprof只能在ENG或开启了Root的User load上来抓取，这样才是有效的。
```

## [FAQ14644] 如何将GPRS/Edge Class改为Class 10

```
Method 1：Meta tool （Modify NVRAM）
other_LID->NVRAM_EF_CLASSMARK_RACAP_LID->1
Modify byte10 and byte12
    if byte10=0xb3,modify to byte10=0xab
    if byte10=0xb2,modify to byte10=0xaa
    byte12=0xd9, modify to byte12=0xd5

     /* BYTE 10:
                            * bit 8: multislot capability present,
                            * bit 7 ~ 3: mutlislot capability,
                            * bit 2: GPRS extended Dynamic Allocation cap =1
                            * bit 1 : RL indicator = 0 => R98 MS, 1 => R99 MS */

    /* BYTE 12: Lanslo 20060215: for selecting GPRS or EGPRS capability
                             * bit 8: PFC mode = 0b
                             * bit 7: EDGE multislot class present / EDGE support = 1b
                             * bit 6 ~ 2: EDGE multislot capability = 01100b
                             * bit 1: EDGE extended dynamic allocation capability = 1b
                             * Old value 0x80, new 0xd9(PFC on), 0x59 (PFC off) */
 Save NVRAM
Method 2：Modify nvram_data_items.c
For GPRS, change 0xb3 to oxab, 0xb2 to 0xaa
 #if defined(__EDGE_CARD_CLASS_10__) || defined(__GPRS_MULTISLOT_CLASS_10__)
                  0xab,   /* Default GPRS multislot class 10, ext DA support, R99 */
   #else
                  0xb3,  /* Default GPRS multislot class 12, ext DA support, R99 */
   #endif
#else /* __R99__*/
   #if defined(__EDGE_CARD_CLASS_10__) || defined(__GPRS_MULTISLOT_CLASS_10__)
                  0xaa,   /* Default GPRS multislot class 10, ext DA support, R98 */
   #else
                  0xb2,  /* Default GPRS multislot class 12, ext DA support, R98 */
   #endif
#endif /* __R99__ */
For EDGE, change 0xD9 to 0xD5
#ifdef __EGPRS_MODE__
   #if defined(__EDGE_CARD_CLASS_10__) || defined(__EDGE_MULTISLOT_CLASS_10__)
                  0xD5,   /* PFC on, EGPRS multislot class 10, Ext DA support */
   #else
                  0xD9,   /* PFC on, EGPRS multislot class 12, Ext DA support */
   #endif
 
Method 3：MTK builds code
```

## [FAQ14620] [Speech Common] 如何使2G通话支持AMR_WB编码

```
MTK release给客户的code默认情况为：
2G不支持AMR_WB，3G支持AMR_WB
如果贵司希望2G也要支持AMR_WB请参考此FAQ
[SOLUTION]
1.将custom_l4_utility.c的custom_check_white_list()里面所有的*is_gsm_white_list = KAL_TRUE;
2.修改好后replace modem load并format modem NVRAM
replace modem load方法：
– 把modem的bin file重命名为modem.img并放在adb.exe路径下
– adb remount
– adb push modem.img /system/etc/firmware/modem.img
– adb shell sync
– adb shell reboot
format modem NVRAM方法：
– adb shell
– cd data/nvram 
– rm –r md 
– reboot
```

## [FAQ10979] [SP Flash Tool]What is the difference between BROM VCOM and Pre-Loader VCOM?

```
Both BROM and Pre-Loader VCOM can be used to connect FlashTool or META tool, by which the device boots to download mode or META mode.

However, there are still some differences:
1. Different triggering ways and time-outs (USB only)
BROM: Usually you have to press download key(KCOL0) to force BROM VCOM; 3S time-out by default.
With an empty device, it boots to BROM mode with 40S time-out by default.
Pre-Loader: Always generates VCOM when USB cable in; 2.5S time-out by default.
Also called the Pre-Loader VCOM auto-detection.

2. Different handshaking protocols for PC tool (for both USB and UART)
The PC tool have to distinguishes VCOM as  BROM VCOM or Pre-Loader VCOM,

and applies the right commands or protocol to successfully connect to the device.
This action is done by MTK FlashtoolLib.dll for USB, you do not have to configure anything.
However, for UART VCOM, the device ID is not defined by BROM or Pre-Loader;
therefore PC tool can not distinguish between BROM and Pre-Loader, and has to configure it manually.

By default, MTK META tool supports Pre-Loader UART VCOM only.

3. Different USB capability and spec(USB only)
BROM VCOM is based on USB 1.1 with HW code stack(BROM means Boot-ROM in chip)
Pre-Loader VCOM is based on USB 2.0 with open source code stack, 
you can update Pre-Loader to change its flow and behavior.

4. Device side environment and HW module state may be different (for both USB and UART)
Like USB/PLL clock/DDR clock/External DRAM and other modules, it may be inited or re-inited.

5. For security project, BROM and Pre-Loader mode have different authority designs. 
There is no difference among non-security projects.

This applies to both USB and UART VCOM.

Note. "VCOM" mentioned here stands for both USB and UART VCOM, if not dedicated.
```

## [FAQ02249] IMEI、IMEISV、SVN

```
Description
关于IMEI、IMEISV、SVN
Solution
概念：
IMEI(International Mobile Equipment Identity)是国际移动设备身份码的缩写，固化于手机中，每个手机的IMEI应该是唯一、不变的。
IMEI码由GSM（全球移动通信协会）统一分配，授权BABT（英国通信认证管理委员会）审受。
2004年以前的标准中，IMEI共15位（取值必须是0~9的数字），依次分别是6位TAC、2位FAC、6位SNR、1位CD校验位。
2004年以后的标准中删去了最后的1位CD校验位，新加入了2位SVN(software version number)，故称IMEISV，共16位（取值仍必须是0~9的数字）。
SVN的取值也必须是0~9的数字，而且99这个值是被保留的。
网络对于IMEI或者IMEISV的检查：
网络对于IMEI或者IMEISV的检查是非必须的，各运营商会按照自己的策略在通信的某个阶段检查手机的IMEI或者IMEISV，并可能做进一步的动作。
可能检查IMEI或者IMEISV的阶段有：
开机注册网络时
周期性位置更新时
进行接打电话、收发短信、上网等业务时
或者其他（根据运营商的策略决定）
网络检查的时候会指明检查IMEI还是IMEISV，如果是检查IMEI，则手机许上报前14位IMEI（1位CD校验位不上报），如果是检查IMEISV，则手机上报16位IMEISV
 
与IMEI和IMEISV相关的协议标准是3GPP TS 23.003
```

## [FAQ02069] NITZ网络自动对时功能不起作用

```
在手机选项中开启了自动更新时间/日期，但是时间日期并没有自动更新
Root Cause
1. 网络不支持NITZ功能
2. NITZ信息在PS域(GPRS/EDGE)上发送
Solution
1. 请用对比机测试看是否能自动更新时间，如果其他平台手机也不行则可能是当地的移动网络不支持NITZ功能，或者可以在开机过程的catcher log中搜索是否有MM_Information这个消息，没有的话说明网络不支持NITZ
2. 请把GPRS连接设置为“一直在线”，或者打开会上网的程序以激活GPRS连接看时间是否能更新
```

## [FAQ02064] 信号跳变严重

```
在空闲待机状态下，信号跳变严重
Root Cause
可能的原因有：
天线性能不良
RF校准数据不正确
当时环境中的信号确实不稳定
金属外壳或者手握的方法使信号衰减
插入USB线时的电磁干扰影响到天线

Solution
首先检查以上各种可能的原因，如果都排除后还是信号跳变严重，请抓取log提交给我司分析
```

## [FAQ02411] [Field Trial]怎样从log中查看手机支持哪些GEA加密方法

```
首先连接上catcher抓取FT的log。做GPRS attach的动作。
在trace中查找[MS->NW]GMM_ATTACH_REQUEST.在primitive log窗口中。
点击[MS->NW]GMM_ATTACH_REQUEST他后面的第一条 DATA_REQ消息。
察看peer_message.08 01 02 f5 e0 41 08 02 05 f4 e2 38...
从第三个octect开始，就是MS NETWORK CAPABILITY
02表示MS NW CAPABILITY的长度为两个octect

8 7 6 5 4 3 2 1
1 1 1 1 0 1 0 1
1 1 1 0 0 0 0 0

第1排第8bit表示GEA/1=1表示avilable。
第2排第2-第7bit开始，从高位到低位表示GEA/2-GEA/7，因此
GEA/2 avilable
GEA/3 avilable
GEA/4 not avilable
GEA/5 not avilable
GEA/6 not avilable
GEA/7 not avilable
```

## [FAQ08885] Activity和Broadcast行为不正常时，如何抓取log？

```
1)    请使用mtklog抓取，保证有main log和event log产生
2)     对于activity行为不正常，请打开activity的log开关再抓取：
adb shell dumpsys activity log a on
这个命令只对当次开机有效

3)    对于broadcast行为不正常，请打开broadcast的log开关再抓取：
adb shell dumpsys activity log br on
这个命令只对当次开机有效

4)    请记录下问题发生时手机上的时间
```

## [FAQ14456] system.img>2G导致编译otapackage时报错如何处理

```
当system分区预制过多apk时如果image size超过2G 在make otapackage时会报如下错误
zipfile.LargeZipFile: Zipfile size would require ZIP64 extensions
或
in writestr zinfo.CRC = crc32(bytes) & 0xffffffff # CRC-32 checksum OverflowError: size does not fit in an int

[SOLUTION]
这是由于python 2.7 脚本限制
参考/prebuilts/python/linux-x86/2.7.5/lib/python2.7/
ZIP64_LIMIT = (1 << 31) - 1       (31bits相当于2G)

python 3.0+ 已提供solution,  但目前Android 编译环境使用2.x 语法与 3.0不兼容
对此google提供一个workaround solution
参考以下网址有提供详细patch内容
https://android-review.googlesource.com/#/c/142984 


另外还需修改以下脚本  build/tool/releasetools/
1、sign_target_files_apks
2、replace_img_from_target_files.py 
3、ota_from_target_files
4、img_from_target_files.py 
5 、img_from_target_files
6、common.py 
7、add_img_to_target_files
针对所有zipfile.ZipFile  添加最后 allowZip64=True 参数值
ex:
原始文件：
output_zip = zipfile.ZipFile(filename, "a", compression=zipfile.ZIP_DEFLATED) 
修改为：
output_zip = zipfile.ZipFile(filename, "a", compression=zipfile.ZIP_DEFLATED, allowZip64=True)
```

## [FAQ14484] 如何修改L版本recovery mode 小机器人界面进入菜单，由volume up&power改为直接按power(如同KK以前版本)

```
L版本进入recovery mode 会出现小机器人界面
需同时按volume up & power 才能进入菜单，
如何改为像KK以前版本，直接按power 进入菜单
 
[SOLUTION]
 
1.alps/bootable/recovery/Ui.cpp

key_long_press(false), 
key_down_count(0), 
enable_reboot(true), 
+ recovery_show_menu_flag(0), 
consecutive_power_keys(false), 
consecutive_alternate_keys(0), 

RecoveryUI::KeyAction RecoveryUI::CheckKey(int key) { 

+    if (key == KEY_POWER && recovery_show_menu_flag==false) { 
+      recovery_show_menu_flag=true; 
+      return TOGGLE; 
+    } 

if ((IsKeyPressed(KEY_POWER) && key == KEY_VOLUMEUP) || key == KEY_HOME) { 

2.alps/bootable/recovery/ui.h

int rel_sum; 
+ bool recovery_show_menu_flag; 
int consecutive_power_keys; 
int consecutive_alternate_keys; 
```

## [FAQ14229] 不编译原本的camera，只保留Gallery

```
当您有如下需求时，可以参考该FAQ：
目前gallery跟camera都是属于同一个进程，并且编译出来只有一个gallery2.apk。
如果有自己单独的camera apk，原生的Gallery2.apk中只希望包含gallery，不需要camera。
 
[solution]
如下修改：
1.修改gallery2中的android.mk，将camera相关的都注释掉。
2.将camera中的btn_shutter_video_pressed文件移到gallery2的drawable
3.将gallery2中将video_preferences.xml文件删除
```

## [FAQ14424] 拍照时强制开多颗CPU

```
进入相机拍照，拍照动画和拍照声音会概率性发生卡顿

[ANALYSE]

此问题发生的原因是在拍照期间概率性打开的CPU个数不够处理拍照时loading，所以会出现拍照动画和拍照声音卡顿的问题。

解决方法：拍照时强制开多颗（3或者4）CPU，足以处理拍照时的loading。

L版本上可以按以下方法修改。

[SOLUTION]

在PhotoMode.java (alps\packages\apps\camera\src\com\mediatek\camera\mode) 中：

一，import PerfServiceWrapper，IPerfServiceWrapper
import com.mediatek.perfservice.PerfServiceWrapper;
import com.mediatek.perfservice.IPerfServiceWrapper;
二，添加如下变量：
IPerfServiceWrapper mPerfService = null;
int mPerfHandle = -1;
三，public PhotoMode(ICameraContext cameraContext)中加入：
if(mPerfService!=null&&mPerfHandle==-1)
{
mPerfHandle=mPerfService.userReg(4,0);//第一个参数表示要开的CPU个数
}
四，public boolean capture()中加入
if(mPerfService!=null&&mPerfHandle==-1)
{
mPerfService.userEnableTimeout(mPerfHandle,10);//第二个参数表示多少秒之后timeout
}
```

## [FAQ14396] 【Audio Profile】如何取消安全音量警示框？

```
当插入有线耳机调节音量时，有一个音量保护，当超过某一个值时会弹出安全音量警示框，如何使之默认不显示？

[SOLUTION]
KK版本：
关闭宏 MTK_SAFEMEDIA_SUPPORT
L版本：
alps\frameworks\base\core\res\res\config.xml 里的 config-safe_media_volume_enabled 设为 false
```

## [FAQ14013] setting-关于手机-法律信息中对源码全选后 操作无反应

```
由于该网页非常大，所以全选这个操作非常费时，而且还有可能导致mem问题。
建议修改是去掉select all的action bar
[SOLUTION]
可以通过以下改动去掉ActionBar中的Select All功能
也就是在这个节目不show出这个选中全部的acitonbar，

external/chromium_org/content/public/android/java/src/org/chromium/content/browser/SelectActionModeCallback.java
...
private void createActionMenu(ActionMode mode, Menu menu) {
    mode.getMenuInflater().inflate(R.menu.select_action_menu, menu);
    /// M: delete select all in settings app @{
    /// M: delete select all in settings app @{
    if (mContext.getPackageName().contains("com.android.settings")) {
        menu.removeItem(R.id.select_action_menu_select_all);
    }
    /// @}
...
```

## [FAQ04513] 如何添加新的字库

```
新增字库有2种方法，一是替换原有的字库、二是加入到系统字库，其具体方法如下：

一、替换系统原有的字库：
如替换中文字库，把这个三方字库重命名为DroidSansFallBack.ttf，并拷贝到alps\frameworks\base\data\fonts下进行替换，重新编译就行。
如需替换其他字库（请参考FAQ12255 ，FAQ04224 ）找出对应的字库并替换。

二、添加到系统字库
1.         把对应的字库文件拷贝到frameworks/base/data/fonts下
2.         修改fallback_fonts.xml (frameworks/base/data/fonts)文件
<family>
    <fileset>
        <file>myfont.ttf </file>
    </fileset>
</family>

添加字库的时候需要把自己需要添加的字库写到fallback_fonts.xml 文件的前面，
如果写到结尾处如果之前的字库有该字体就会使得自己添加的字库无法生效。

（2.1 ） 在ANDROID L上同时需要在framework/base/data/fonts/目录下FONTS.XM文件中加入定义如
<font weight="100" style="normal">Roboto-Thin.ttf</font>
（weight代表字体的粗细 style是字体风格。可以根据贵司自定义字库和FONT文件中的字库定义）（其他android版本无需这个步骤）

3.         修改fonts.mk (frameworks/base/data/fonts)

a、ICS
PRODUCT_COPY_FILES := \
......
frameworks/base/data/fonts/NewFontFile.ttf:system/fonts/myfont.ttf \

b、JB
PRODUCT_PACKAGES:= \
myfont.ttf \
DroidSansFallback.ttf  \
......

4. 对于JB2,JB3,JB5,JB9,KK,L还需修改Android.mk
ifeq ($(MINIMAL_FONT_FOOTPRINT),true)
……
else # !MINIMAL_FONT
font_src_files += 
myfont.ttf \
……

5.对于GB版本的添加方法如下
1) 拷贝myfont.ttf文件到 alps\frameworks\base\data\fonts下
2) 修改frameworks/base/data/fonts/Android.mk文件：
copy_from := \ 
DroidSansMono.ttf \ 
myfont.ttf\ 
……

3) 修改external/skia/src/ports/SkFontHost_android.cpp 文件：
//增加以下语句
{"myfont.ttf", gFBNames}, 

6.         重新编译工程，download bin到手机测试。
```

## [FAQ09809] [NW]运营商名称支持多语言

```
运营商的名称显示，和多个方面有关系，在阅读本FAQ之前建议先参考
“FAQ09394 [NW]网络运营商名称显示&SIM名称显示”
 
如FAQ09394所讲，运营商名称有4种来源，这里讲到的只会是第4种，也就是存储在xml中的，也只有用这种来源显示的名字才能扩展成支持多语言。那在xml中的，只有一种显示语言，就是spn这个字段的内容，如果切换语言，这个名称也不会变。
 
例如Spn-conf.xml中有个字段<spnOverrides numeric="31000" spn="NEPW"/>，也就是运营商的plmn是31000，其对应的名称是“NEPW”。当运营商的来源是xml时，那这种case下这个运营商的名称会显示“NEPW”，那即使当前手机切换到其他语言，仍然显示的是“NEPW”。
 
[SOLUTION]
有了上面的背景，那就切入正题，要想在这种case下(当运营商的来源是xml)支持多语言显示，就要在对应res中添加一个Strings，然后再添加各种语言的翻译，然后显示的时候就用res中string，而不用读取xml中的spn了。 具体做法如下:
(1)在alps\mediatek\frameworks\base\res\res\values\Strings.xml(L之后的版本：alps\vendor\mediatek\proprietary\frameworks\base\res\res\values\strings.xml)中定义个字串,其名称为A
(2)在同res目录下的其他values添加A对应的语言翻译
(3)在alps\mediatek\frameworks\base\res\res\values\public.xml (L之后的版本：alps\vendor\mediatek\proprietary\frameworks\base\res\res\values\ public.xml)中添加A的id, id取值type为string的那一组的最后一个string的id+1 
(4)在alps\frameworks\opt\telephony\src\java\com\android\internal\telephony\Ril.java (L之后的版本：alps\frameworks\opt\telephony\src\java\com\android\internal\telephony\uicc\SpnOverride.java)中的lookupOperatorName()方法，依照numeric等于A运营商的plmn，其operName就是这个字串A的内容。
 
因为运营商有很多，把所有的运营商名称都换成这个样子比较耗工作量(请按照需求添加)。
 
注: 目前只支持实体运营商，MVNO还不支持
```

## [FAQ12075] 如何让 keguard run 在 com.android.keyguard 进程

```
如何让 keguard run 在 com.android.keyguard 进程
[SOLUTION]
KK 上, keyguard 默认会 run 在 com.android.systemui 进程中
如果需要将 keyguard run 在 com.android.keyguard 进程中
请修改 alps\frameworks\base\packages\Keyguard\res\values\mtk_config.xml
- <string name="keyguard_process_name">com.android.systemui</string>
+ <string name="keyguard_process_name">com.android.keyguard</string>

L上keyguard作为SystemUI的一个lib,不再是一个独立的apk,不能运行在单独的进程。
```

## [FAQ08700] 锁屏界面播放音乐或者FM时, 按音量键没有VolumePanel显示

```
在 Keyguard 界面，播放music 或者FM时，按音量键可以调节音量大小，但是不显示出 VolumePanel, 这是 Google  default design，Google 原生对比机也是这样的行为。

在 Keyguard 出现的時候，之所以不显示 VolumePanel 是因为 KeyguardViewBase .interceptMediaKey()把 volume 相关的 keys 拦下來，直接呼叫 AudioManager 的调整音量 API，直接调整音量，但不显示出 UI.

[SOLUTION]
如果希望在 Keyguard 画面下仍然要 show 出 VolumePanel，可以改写 KeyguardViewBase
private static final boolean KEYGUARD_MANAGES_VOLUME = true; // 把这里改成 false即可。
keyguard界面调节音量并显示VolumePanel只针对当前播放music 或者FM时，并不是调整当前情景模式的音量，二者不要混淆，后者目前不支持。
```

## [FAQ13826] android L 上切换字库方法

```
本FAQ介绍的是在 android  L上需要实现切换字库的功能。
 其他android版本上切换字库请参考FAQ09662 
[SOLUTION]
切换字体我司提供两种方法
方法一：无论是在何种语言下都使用客户定制的字库
方法二：在特定的语言下使用客户定制的字库

方法一
1.         把对应的字库文件拷贝到frameworks/base/data/fonts下

2.         修改fallback_fonts.xml (frameworks/base/data/fonts)文件（在文件中加入客户定制的字库）
例如
<family>
    <fileset>
       <file>myfont.ttf </file>
    </fileset>
</family>

3. framework/base/data/fonts/目录下FONTS.XM文件中加入定义如
<font weight="100" style="normal">Roboto-Thin.ttf</font>

方法二
前面两步和方法一的前两步一致，第三步改为如下
3. 如果是需要在某些语言需要切换字库而其他语言不需要，直接加入如下步骤。
framework\base\graphics\java\android\graphics\FontListParser.java
中的
private static Family readFamily(XmlPullParser parser) 这个函数中在下面对应位置加入红色代码
        throws XmlPullParserException, IOException {
    String name = parser.getAttributeValue(null, "name");
    String lang = parser.getAttributeValue(null, "lang");
    String variant = parser.getAttributeValue(null, "variant");
    List<Font> fonts = new ArrayList<Font>();
    while (parser.next() != XmlPullParser.END_TAG) {
        if (parser.getEventType() != XmlPullParser.START_TAG) continue;
        String tag = parser.getName();
        if (tag.equals("font")) {
            String weightStr = parser.getAttributeValue(null, "weight");
            int weight = weightStr == null ? 400 : Integer.parseInt(weightStr);
            boolean isItalic = "italic".equals(parser.getAttributeValue(null, "style"));
            String filename = parser.nextText();
 //added 
 String country_code=SystemProperties.get("persist.sys.lang_country", "GB");
 if(country_code.equals("RU") ||country_code.equals("UA")){
        if(filename.equals("Roboto-Regular.ttf")){
                      filename = "RobotoCondensed-Regular.ttf";
  }
}
 //end
```

## [FAQ14324] [Audio App]L1(>=5.1)版本, 后台播放音乐，浏览器访问百度音乐首页，后台音乐不会停

```
L1 之后的版本, 后台播放音乐的状态下,使用浏览器(google chromium )访问百度音乐首页, 后台音乐不会停止播放
而 KK 或之前的版本, 相同的情况下, 后台音乐会停止播放

[SOLUTION]
这个问题是 L1 版本所特有的, 通过分析我司发现:

chromium 浏览器在播放百度首页上音乐的时候, 去 requestAudioFocus 时发出的通知是 AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK, 这个通知不会停止其它程序的声音输出,
但会使其它程序的声音输出暂时变低一下. 这个是 google chromium ap 行为.

相比于 L 或之前 KK 的版本, 其 requestAudioFocus 时发出的通知是 AUDIOFOCUS_LOSS,
所以后台音乐会停止播放
```

## [FAQ13715] [Gallery] 如何修改gallery的背景色

```
Gallery的背景色定义在：
Gallery2/res/values/colors.xml 文件中

<!-- configuration for album set page -->
<color name="albumset_background">#1A1A1A</color>

<!-- configuration for album page -->
<color name="album_background">#1A1A1A</color>

<!-- configuration for photo page -->
<color name="photo_background">#1A1A1A</color>

上述3个定义分别对应了gallery3个page的背景色；
如果需要修改背景色为黑色，则需要将对应值修改为#000000；
如果需要修改背景色为白色，则需要将对应值修改为#FFFFFF。

L版本补充说明：
在L版本Photopage页面，背景色不再从上述文件中获得，则第三项修改不起效；
请参照如下方式进行修改：
PhotoPage.java
protected float[] getBackgroundColor() {
    if (mModel != null && mModel.isCamera(0)) {
        mPhotoPageBackgroundColor[0] = 0.0f;
    } else {
        mPhotoPageBackgroundColor[0] = 1.0f;
        mPhotoPageBackgroundColor[1] = 1.0f;
        mPhotoPageBackgroundColor[2] = 1.0f;
        mPhotoPageBackgroundColor[3] = 1.0f;
        Log.d(TAG, "PhotoPage.getBackgroundColor");
    }
    mBackgroundColor = mPhotoPageBackgroundColor;
    return mPhotoPageBackgroundColor;
}
如上蓝色标示位置，都修改为1.0f则是白色；如果都修改为0.0f则是对应黑色。


补充问题分析：
修改整个window的theme为白色，再修改以上背景色为白色后，进入gallery时仍会闪出一帧黑色背景：
可尝试修改Gallery2/res/layout/gl_root_group.xml文件如下：
<View android:id="@+id/gl_root_cover"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@android:color/black"
    android:visibility="gone"/>
请将android:background="@android:color/black"  颜色修改为白色。
```

## [FAQ03851] 打开/关闭RDS方法

```
目前没有宏来切换RDS的开启与关闭，如果需要修改的话必须通过修改代码来完成。具体如下：
1、Fmradioservice在启动过程中会调用isRDSSupported（）从而调用native 层的isRDSsupport()来获取RDS的开关状态，如下代码片段：
public boolean isRDSSupported() {
    boolean isRDSSupported = (FMRadioNative.isRDSsupport() == 1);
    LogUtils.d(TAG, "FMRadioService.isRDSSupported: " + isRDSSupported);
    return isRDSSupported;
}直接修改上层APK上的接口isRDSSupported即可。

2、Natvie 层isRDSsupport()会调用drivr端的设定，如下：

case FM_IOCTL_RDS_SUPPORT: {
    fm_s32 support = FM_RDS_ENABLE;
    WCN_DBG(FM_NTC | MAIN, "FM_IOCTL_RDS_SUPPORT\n");
    if (copy_to_user((void*)arg, &support, sizeof(fm_s32))) {
        ret = -EFAULT;
        goto out;
    }
    break;
由上面这段代码可以看到driver端默认RDS为打开状态。

通过以上的描述可以看到，打开/关闭 RDS有两种方式：

方法一：在Fmradioservice --> isRDSSupported 中直接将变量isRDSSupported值修改掉。0：关闭RDS，1：打开RDS

方法二： 修改driver端的设定，即native层将case FM_IOCTL_RDS_SUPPORT中fm_s32 support = FM_RDS_ENABLE值改掉， 0：关闭RDS， 1：打开RDS
```

## [FAQ10669] 设定FM打开时默认频率的方法

```
同的FM chip 会包含各种不同的频率反馈以满足不同国家/区域的使用，鉴于此情况就会有FM打开时默认开启的频率的修改需求。
此FAQ 提供客户定制自己FM 开启时的默认频率。由于此部分的设定是在java层，所以不同平台、不同chip修改方法都是一样的。
具体方法如下。

修改 alps/mediatek/packages/apps/FMRadio/src/com/mediatek/FMRadio/FMRadioUtils.java 中
public static final int DEFAULT_STATION = FeatureOption.MTK_FM_50KHZ_SUPPORT ? 8000 : 800;
```

## [FAQ14168] GPS问题调试—MobileLog中有关GPS关键LOG的释义

```
在mobile log中，有很多GPS相关的log出现在main log和kernel log、properties文件中，他们的意思是什么，通过这篇文档进行总结，以便在处理GPS 问题时，能够根据这些log快速的收敛问题。

特别先提醒，这些log并非所有的软件版本上都有，所以只需要根据已经的log结合这份文档即可。

l  Properties文件，可以收集到该问题相关的版本信息

1.   168 [ro.mediatek.version.branch]: [KK2.MP13]
2.   169 [ro.mediatek.version.release]: [ALPS.KK2.MP13.V1.1]
3.   222 [gsm.project.baseband]: [6752_LWT_KK_MD1_HW(DEFAULT)]
4.   227 [gsm.version.baseband]: [MOLY.LR9.W1423.MD.LWTG.CMCC.MP.V1.P33

l  Kernel log文件

1.    16468 <3>[  280.806548] (0)[341:mtk_wmtd][WMT-PLAT][I]wmt_plat_dump_pin_conf:GPS_SYNC(not defined)

GPS SYNC pin不用配置

2.   16469 <3>[  280.806557] (0)[341:mtk_wmtd][WMT-PLAT][I]wmt_plat_dump_pin_conf:GPS_LNA(GPIO-2147483580)

GPIO-2147483580表示的GPIO68,这个GPIO的配置在“GPS问题大全.docx”的4.1章节有提到如何配置该GPIO。如果没有使用外部LNA，那么就不需要配置该GPIO了。

3.    16626 <3>[  280.852549] (1)[341:mtk_wmtd][WMT-CONF][I]wmt_conf_parse:#32(co_clock_flag)=>0x0

从这一条中的co_clock_flag=0表示采用的TCXO的方案，如果为1表示采用的是Coclock.

4.    17055 <4>[  281.533172] (0)[237:mnld][GPS] GPS_open: WMT turn on GPS OK!
打开GPS

5.    45005 <4>[  437.737848] (0)[237:mnld][GPS] GPS_close: WMT turn off GPS OK!
关闭GPS
 
l  Main log文件

1.   03400 05-13 16:07:58.210429   766  1337 V Provider/Settings:  from settings cache , name = location_providers_allowed , value = gps,network

Value后面的值表示的定位方式，这里表示gps定位和网络定位。

2.   04132 05-13 16:08:06.191351   766  1387 D LocationManagerService: request 42815df8 gps Request[ACCURACY_FINE gps requested=0 fastest=0] from com.mediatek.ygps(1001)

这里是表示gps定位，其应用是ygps，这一点经常会被用到debug 问题

3.   04142 05-13 16:08:06.193005   766   787 D GpsLocationProvider: startNavigating, singleShot is false

打开GPS

4.   04227 05-13 16:08:06.295280   237   237 D mnl_linux: mnl_utl_load_property: EPO_Enabled: 1

这里表示EPO使能,EPO是可以提供星历辅助数据

5.   04228 05-13 16:08:06.295286   237   237 D mnl_linux: mnl_utl_load_property: BEE_Enabled: 1

这里表示BEE使能，BEE是可以提供星历辅助数据。

6.   04229 05-13 16:08:06.295548   237   237 D mnl_linux: mnl_utl_load_property: SUPL_Enabled: 1

这里表示AGPS使能

7.   04238 05-13 16:08:06.296514   237   237 D MNLD    : launch_daemon_thread: chip_id is 0x6752

GPS chip是6752

8.   04279 05-13 16:08:06.301853   237   237 D mnl_linux: mtk_gps_sys_init: gps_tcxo_hz : 26000000

采用26M时钟

9.   04280 05-13 16:08:06.301861   237   237 D mnl_linux: mtk_gps_sys_init: gps_tcxo_ppb : 0

0表示时钟频偏采用默认2000ppm

10.  04286 05-13 16:08:06.301995   237   237 D MNLD    : linux_gps_init: TCXO

表示采用的是TCXO，非省晶体方案

11.  03928 01-14 23:36:49.154   171   171 D MNLD    : linux_gps_init: GPS coclock

表示采用的是Coclock，省晶体方案

12.  05-13 16:08:07.030960   237   237 D MNLD    : linux_gps_init: GNSSOPMode: 2

这里GNSSOPMode=2

13.  17129 05-15 03:36:25.760   288   325 D agps    : [agps][n][AGPS] [MNL] read  pmtk=[$PMTK764,0,0,0,1,0,128*3D

PMTK764这个log可以知道当前是支持什么卫星系统的， 三个0后面的1表示支持1种卫星系统；

1后面的0和128表示对这个卫星系统的说明，0表示是GPS卫星

0042 $$PMTK764,0,0,0,2,0,128,4,128*15

这个PMTK764中的2表示支持2种卫星系统，（0，128）表示GPS卫星系统，（4，128）表示GLONASS

14.  05-13 16:08:07.031018   237   237 D MNLD    : linux_gps_init: init_cfg.C0 = 0

如果是Coclock方案，0表示没有校准

15.  05-13 16:08:07.031026   237   237 D MNLD    : linux_gps_init: init_cfg.C1 = 0

如果是Coclock方案，0表示没有校准

16.  05-13 16:08:07.031035   237   237 D MNLD    : linux_gps_init: init_cfg.initU = 0

如果是Coclock方案，0表示没有校准

17.  05-13 16:08:07.031043   237   237 D MNLD    : linux_gps_init: init_cfg.lastU = 0

如果是Coclock方案，0表示没有校准

18.  04377 05-13 16:08:07.036831   237   237 D MNLD    : linux_gps_init: dbg_file_name (/data/misc/gpsdebug.log) 

这里表示gps debug log存放在/data/misc下面

19.  016963 05-12 09:48:22.431   266   266 D MNLD    : linux_gps_init: dbg_file_name (/storage/sdcard0/mtklog/gpsdbglog/gpsdebug.log) 

这里表示gps debug log存放在/storage/sdcard0/mtklog/gpsdbglog/下面

20.  04408 05-13 16:08:07.526851   237  2792 D mnl_linux: mtk_gps_sys_nmea_output_to_app: $PMTK010,001*2E

PMTK010表示GPS软件已经跑正常了，这一点是判断GPS软件正常工作常用的手段。

21.  04419 05-13 16:08:07.531313   237  2792 D mnl_linux: $GNRMC,080807.009,V,3953.7875,N,11620.6085,E,0.000,0.00,130515,,,N*5B

NMEA也是判断GPS软件正常工作常用的手段

22.  04439 05-13 16:08:07.531876   766   787 D gps_mtk : mtk_gps_start: line = 3644sta.status = GPS_STATUS_ENGINE_ON

通过该log“GPS_STATUS_ENGINE_ON”，在手机最上面的状态栏，是可以看到GPS定位状态图标

23.  05944 05-13 16:08:20.550455   766  2574 D GpsLocationProvider: TTFF: 13003

表示GPS的定位时间死13.003s

24.  25275 05-13 16:10:42.491472   766   787 D GpsLocationProvider: stopNavigating

关闭GPS

25.  25366 05-13 16:10:42.511134   766  2574 D gps_mtk : mnld_to_gps_handler: line = 3020sta.status = GPS_STATUS_ENGINE_OFF

通过该log“GPS_STATUS_ENGINE_OFF”，在手机最上面的状态栏，GPS定位状态图标消失

26.  25378 05-13 16:10:42.795323   766  1376 D gps_mtk : mtk_gps_delete_aiding_data: line = 3898Send MNL_CMD_RESTART_FULL in HAL

这里的log表示是FULL start，如果看到下面图片的log，请对应查找

27.  083004 05-12 09:50:00.510   827  1468 D LocationManagerService: request 1434db9 gps Request[ACCURACY_FINE gps requested=+10s0ms fastest=+10s0ms] from com.tct.weather(10052)

108716 05-12 09:50:31.004   827  1468 I LocationManagerService: remove 1434db9

通过上面的log可得知GPS定位开始的时间和结束的时间，是com.tct.weather这个应用打开的GPS，这里的1434db9很重要，是你判断结束的对应log点

28. 
109104 05-12 09:50:31.404   827  8800 V GpsLocationProvider: GNSS SV count: 9 ephemerisMask: 0 almanacMask: 0
109105 05-12 09:50:31.405   827  8800 V GpsLocationProvider: sv: 22 snr: 0.0 elev: 66.0 azimuth: 198.0
109106 05-12 09:50:31.406   827  8800 V GpsLocationProvider: sv: 14 snr: 0.0 elev: 54.0 azimuth: 15.0
109107 05-12 09:50:31.408   827  8800 V GpsLocationProvider: sv: 25 snr: 3.0 elev: 52.0 azimuth: 55.0   U
109110 05-12 09:50:31.409   827  8800 V GpsLocationProvider: sv: 31 snr: 2.3600001 elev: 48.0 azimuth: 289.0   U
109111 05-12 09:50:31.409   827  8800 V GpsLocationProvider: sv: 18 snr: 2.48 elev: 36.0 azimuth: 162.0   U
109113 05-12 09:50:31.410   827  8800 V GpsLocationProvider: sv: 32 snr: 0.0 elev: 24.0 azimuth: 318.0
109116 05-12 09:50:31.412   827  8800 V GpsLocationProvider: sv: 12 snr: 3.2 elev: 16.0 azimuth: 39.0   U
109117 05-12 09:50:31.412   827  8800 V GpsLocationProvider: sv: 29 snr: 0.0 elev: 13.0 azimuth: 115.0
109120 05-12 09:50:31.413   827  8800 V GpsLocationProvider: sv: 4 snr: 0.0 elev: 7.0 azimuth: 280.0
从上面的log上可以看到可视卫星有9颗，每颗卫星的ID、SNR、ELEV、AZIMUTH

29. 
109109 05-12 09:50:31.408   827   860 D LocationManagerService: incoming location: Location[gps 23.032397,114.349453 acc=7 et=+35m46s616ms alt=43.0 vel=0.0 bear=10.53 {Bundle[{}]}]

有这行log，表示这一秒一定是定位成功的，这个log中的gps表示这个定位成功的位置是GPS提供出来的。

30.  
04520 05-13 16:08:07.548131   766  1378 D LocationManagerService: request 42509ab8 network Request[POWER_LOW network requested=+1s0ms fastest=+1s0ms] from com.mediatek.nlpservice(10047)
04566 05-13 16:08:07.576011   766   787 D LocationManagerService: incoming location: Location[network 39.896459,116.343475 acc=257 et=+23m51s504ms]
04580 05-13 16:08:07.582307   766  1226 I LocationManagerService: remove 42509ab8
从这几行log中的“network Request[POWER_LOW network requested”表示是网络定位，是” com.mediatek.nlpservice”应用或者是服务去请求的，网络定位比较快，可以看到立即就拿到了位置，根据42509ab8，可以判断什么时候关闭了这次网络定位

31.  
04581 05-13 16:08:07.582319   766   787 D gps_mtk : mtk_gps_inject_location: line = 3845ts.tv_sec= 229820461603619098,ts.tv_nsec = 8953004843085074432
04582 05-13 16:08:07.582352   766   787 D gps_mtk : mtk_gps_inject_location: line = 3846inject location lati= 39.896459, longi = 116.343475,accuracy =257.000000

这里的log表示将位置辅助和参考时间数据注入给GPS 模块，来加速GPS定位。
```

## [FAQ07950] 如何分析GPSLog

```
对于GPSLog有两种类型的文件，主要是依据其文件内容划分。文件内部存储的只是$GP开口的log，那么这种log称为NMEA log；文件内部除了$GP的log，还有其他的一些log，例如$PMTK的log等等，这种log称为GPS DebugLog。

其实一般情况下，可以通过NMEALog就可以看出来很多的信息。看NMEALog主要是对NMEA协议里的集中常用NMEA语句的各个字段熟悉即可。

1.   基本检查

GPGGA中可以得到UTC时间、经纬度、当前定位状态、使用的卫星数目、HDOP等等；

GPGSA中可以得到定位类型、所使用到的卫星ID；

GPGSV中可以得到可视卫星的数目，然后会一次列举出每科可视卫星的ID、方位角、仰角和信号强度；

GPRMC中可以得到UTC时间、定位状态、经纬度、速度、UTC日期；

GPACCURACY是我司加入的获取定位精度的语句。

2.   检查SNR

根据SNR值是很好的判断卫星信号强弱的方法，强信号是指CNR大于40db，中讯号是指 CNR大于30db，弱讯号是指CNR大于20db，20db以下视为极弱讯号。我司根据的spec:6颗卫星SNR>40db，可以达到CEP:3m。

在测试传导性能/整机性能的时候，打入-130dbm的信号，如果可以看到收到的卫星SNR>40.5db,这表示贵司的硬件GPS天线做的不错;如果是在35db以下，可能就是表示硬件GPS做的很差喽。

3.   缺少哪些辅助资讯

如果产看是否触发AGPS，需要从GPS debug Log中分析，搜索PMTK730这个语句，因为辅助数据主要是看时间、位置、星历这三个。$PMTK730,0,0,0,1,0,1,1,0：从这个语句中的一个1表示缺少星历、第二个1表示缺少位置、第三个1表示缺少时间。PMTK710表示获取星历辅助数据，PMTK712表示获取时间辅助资讯，PMTK713表示缺少位置辅助资讯。

当所有的辅助资讯都有拿到之后，显示出来的PMTK730后面的都会是0.

4.   查看卫星分布如何

通过看GPGSV里的卫星的方位角和仰角可以判断卫星的位置，通过判断GPGSA里的卫星可以知道当前定位使用了哪些卫星，这样就可以知道当前使用定位计算的这些卫星的卫星分布如何、信号强度如何。

通过GPGGA里的HDOP来判断当前卫星的分布如何，这个值越小越好。卫星分布越好，越有可能产生的定位精度越高。所以HDOP是定位精度的充分但非必要条件。

5.   当前有哪些星历被保存

通过搜索GPS Debug Log文件中PMTKEPH，该关键词会告诉你当前有哪些卫星是已经解析下来辅助资讯的。例如PMTKEPH,3,12,15,18表示有3颗卫星已经解析下来了星历数据，他们的卫星ID 是12、15、18.

6.   如何判断GPS已经正常工作

GPS工作起来首先会在GPS debug Log中打印出来PMTK010的字样，所以通过判断这个可以知道GPS是否有正常工作起来。

7.   星历数据是来自EPO、HotStill还是实时解算

如果知道当前使用到的卫星星历数据是来自实时接收解算下来的星历、还是EPP,或者是HotStill，同样也是通过判断PMTKEPH。

如果该关键字后面跟着的卫星ID是正整数，那么是实时接收解算下来的星历；

如果是浮点数，而且是负数，但是小数点后都是0，表示的是EPO；

如果是浮点数，而且是负数，但是小数点后的是非0，表示的是Hotstill；

8.   判断AGPS/EPO/HotStill是否工作

从GPS Debug log中搜索到wk，epo表示EPO有工作；

从GPS debug log中搜索到wkbee表示Hotstill有工作；

从GPS Debug log中搜索到wkssi表示AGPS有工作。

9.   H/W/C/F GPS Start

通过从打开GPS的第一条GPGGA语句来确认是什么启动方式，如果该语句中的时间是235944，那么表示没有时间辅助资讯，这是完全冷启动；如果有时间信息，但是位置是8960.0000，N，0000.0000，E，这表示是冷启动；如果既有时间也有位置，可以看第一条PMTKEPH中是几颗有卫星的星历，如果一颗没有，那么这是暖启动；如果发现也有位置、时间、而且至少4颗以上的星历，那么这是热启动。

10. 定位

看定位精度，请以3D定位为准。因为2D定位下定位精度会很大。

11. 如何判断是否是coclock
000045.784,HBD,IF1,BOT,ClkType,254
这里的254表示是coclock，255表示是TCXO。
如果是coclock，那么可以通过如下log判断是否有校准成功。
000069 $PMTK013,32,ClkType,254,C0,1.373238,C1,-0.196573,k,1*24
12, 如何判断GPS power 成功。
请通过GPS_INIT_DONE来确认。
13，如何判断之前有没有定位成功过。
这在AGPS 认证测试中经常会用来判断测试前是否有3D fix过。
请通过PMTKDBG的倒数第五个数据是否非0，如下红色部分。
000103 $PMTKDBG,12,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
0093,0001,0002,0000,0000,0022,0001,0000,0.0000,0.0224,0.0000,0.0000,0.0000,0.0000,*4C

14, 如何确认MNL Version。
通过000045.807,HBD,IF1,BOT,MNLVer,AXN_3.60,1312,MNL_VER_14011701ALPS05_3.60_06,22,40
15,如何确认acqusition、bit sync、subframe sync的状态。
请过如下log，下面log中表示捕获到9颗卫星，有9颗卫星已经bit sync，6颗卫星子帧同步。
$PMTK015,532335,6,438756,NACQ,9,NBS,9,NSFS,6,NEXS,6*6C
```

## [FAQ14127] GPS问题调试—NTP/NLP/EPO加速定位功能

```
NTP/NLP的加速定位功能，是由NTP提供时间辅助、NLP提供位置辅助，再加上EPO 提供星历辅助，旨在达到在有网络情况下，所有场景都是热启动。

 

这篇文档会介绍

1， NTP/NLP/EPO的下载和触发原理。

2， 如何check NTP/NLP/EPO起到作用。

[SOLUTION]

NTP/NLP主要是加速定位时间TTFF，其原理是获取如下三者，以此来加速定位时间。

NTP给时间；

NLP给位置；

EPO给星历。
NTP/NLP/EPO的下载和触发原理。

对于NTP，在手机开机后，要通过网络同步一次时间时间就可以了,那么在后续（没有网络也没有问题）使用gps应用时，NTP就可以派上用场。

对于NLP，必须要每次都要有网络，而且手机设置下位置辅助需要设置为高精度，那么在打开gps应用是，NLP才会起到作用。

对于EPO，触发下载的流程如下：


该功能要在客户的软件包里，需要包含两件事情，这两件事情都可以通过这个FAQ里的几个check工作检查。
1，ALPS01856056的patch。
2，NLP APP，例如百度、GMS、高德。对于这一点，MTK已经和baidu合作，对于客户可以有两种方式来做。方式一是客户可以直接从MTK拿BAIDU NLP APP；方式二是客户和NLP 厂商取得。

 

要判断NTP/NLP是否有起到加速作用，check 工作是必要的。

l  对于NTP

不会有问题，不需要检查。

l  对于EPO

不会有问题，不需要检查。
可以从录制的gps debug log中check “$[AGT],Extract epo done”

l  对于NLP 

可以从录制的gps debug log中check “$DBnm_NLP”

或者是check mobile log中的 “gps_mtk : mtk_gps_inject_location:”

否则，请check如下5步。。

1， Does your NLP package name (ex: GMS or Baidu NLP) exist in config.xml?

frameworks\base\core\res\res\values\config.xml

<string-array name="config_locationProviderPackageNames" translatable="false">
    <!-- The standard AOSP fused location provider -->
    <item>com.android.location.fused</item>
    <!-- MTK add for GMS -->
    <item>com.google.android.gms</item>           请重点看这这里：GMS
    <item>com.baidu.map.location</item>           请重点看这这里：BAIDU
    <!-- MTK add end -->
</string-array>

2， Is NLP (ex: GMS or Baidu NLP) installed in your DUT?

对于GMS，可以check在手机上是否有google map、gmail、play store等app。

对于Baidu，可以check setting-》app->all， 检查是否有NetworkLocation（网络定位）存在。如果没有，请安装。如果是手动安装，请一定要重启一次手机才可以生效。
 
对于其他，请check 相关NLP 服务是否有安装。

3， Does NLP service (MTK proprietary module) exist?

请到设置-》app->all， 检查是否有MTK NLP Service存在。如果没有，请到PMS系统上申请ALPS01856056的patch。

4， Is NLP enabled from Settings?

可以check setting-》location-》mode，如下：

5， Does you turn on Wi-Fi connection or Data connection?
```

## [FAQ14117] 单个APP优化时间过长的问题

```
单个APP优化时间过长会导致开机时间过长的问题，这种情况主要是dex2oat使用的优化线程数较少导致的。可以尝试如下的解法。

[SOLUTION]
1.判断当前使用的线程数
形如下面的Log表示，当前使用了2个线程
dex2oat : dex2oat took 5.745s (threads: 2)
2.如果线程数小于CPU的核心数，在L0版本上可以申请如下的patch:
ALPS02069213 
3.在某些L1版本上面需要修改如下的文件：
修改的art/dex2oat/dex2oat.cc这个文件中的下面的代码：
818 static int dex2oat(int argc, char** argv) {
   ............
872   int thread_count = sysconf(_SC_NPROCESSORS_CONF);
873   //if (thread_count >= 2)  {
874   //  thread_count /= 2;
875   //}
```

## [FAQ13090] 三方apk接收不到开机广播

```
自启动失败/接收不到BOOT_COMPLETED广播可能的原因:

[SOLUTION]
(必现)
(1)、BOOT_COMPLETED对应的action和uses-permission没有一起添加
需要三方应用在AndroidManifest.xml中写入：
<action android:name="android.intent.action.BOOT_COMPLETED" ⁄>
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" ⁄>
(2)、应用安装到了sd卡内，安装在sd卡内的应用是收不到BOOT_COMPLETED广播的.
(概率出现 )
(3)、对于android3.1以后版本，如果要应用接收开机广播有两种方法：
a).将应用预置到/system/app/目录。
b).安装应用后先启动一次，适用于有Activity的应用。
注释：
1、BOOT_COMPLETED这个广播比较特殊，预置到system/app下面的apk才会通过android.intent.action.BOOT_COMPLETED来开机自启动。而预置到data/app,vendor/app下面的三方apk，若安装从来没有启动过和被用户手动强制停止，它就是处于“stopped state”(此应用的信息保存在/data/system/users/0/package-restrictions.xml中)，它的接收器将会无法接收任何广播，无法开机之后自动启动。但是安装这个应用之后只要是有手动去点击下这个apk，下次开机就肯定是会自动启动起来的，也是接收这个BOOT_COMPLETED广播。

2、与此同时系统增加了2个Flag：FLAG_INCLUDE_STOPPED_PACKAGES和FLAG_EXCLUDE_STOPPED_PACKAGES ，来标识一个intent是否激活处于“stopped state”的应用。

3、Google允许应用和后台服务通过给广播intent设置FLAG_INCLUDE_STOPPED_PACKAGES来唤醒处于“stopped state”的程序，也就是用户自己写的广播intent可以控制这个机制，但是系统自带的广播intent默认都是FLAG_EXCLUDE_STOPPED_PACKAGES，由于不能修改，所以就没法通过系统广播自启动了。
```

## [FAQ13790] L如何让三方APK发送的SMS不显示出来

```
在GsmSMSDispatcher.java (alps\frameworks\opt\telephony\src\java\com\android\internal\telephony\gsm) 中找到所有
if (SmsApplication.shouldWriteMessageForPackage(callingPkg, mContext) ...){...}的地方有五处

在此if语句块条件外面增加一个判断，如：
if(!callingPkg.equals("贵司的三方应用名")){
    if (SmsApplication.shouldWriteMessageForPackage(callingPkg, mContext) &&!isFilterOutByPpl(destAddr, text)) {
        messageUri = writeOutboxMessage(getSubId(), destAddr, text, deliveryIntent != null,callingPkg);
    }
}
温馨提示：如果不确定"贵司的三方应用名"是怎样，可以在修改前添加log打印出callingPkg
```

## [FAQ08791] 设置中，辅助功能下的增强网页辅助功能解释

```
设置->辅助功能->增强网页辅助功能
使用talkback（谷歌辅助程序，帮助盲人等视障用户操作设备）操作手机，浏览网页的时候，辅助功能里面允许插入网页脚本以后，就可以操作浏览器了。
```

## [FAQ14081] 如何判断android OS是32位还是64位？

```
简单的方法是查看是否存在/system/lib64目录，可以通过adb shell ls /system/lib64看是否可以看到。
```

## [FAQ13906] [Others]从“百度图片”下载图片出现异常

```
步骤： 默认浏览器进入百度-》选择图片-》进入单张图片-》点击浏览器底端的“下载”按钮（重要）
可能会出现如下现象：
 
1. 去下载app里直接点击刚才下载的图片, 提示图片无法打开. 
2. 去设置、显示、壁纸、图库, 在图库里选择刚才下载的图片就会报错.
3. 下载gif格式图片，在图库中打开后发现图片是静态的.
4. 下载多张图片后, 去图库查看, 只有部分显示.
 
[SOLUTION]

经过确认：所有问题的根源均在于下载时，服务器传送的图片mime_type类型出错:
原本image/jpeg类型的，下载后是"image/jpeg"
原本image/gif类型的，下载后是"image/gif"
即：比原本的mime_type类型多了一对引号。且该mime_type值是写入到数据库（db）中的。

问题1的原因是下载app的intent中mime_type不匹配；
问题2的原因同上；
问题3的原因是因为显示时，从db中读出的类型不对，不会按照动态显示；
问题4的原因是有些图片插入数据库之后，还会再次扫描update，从db中读出的mime_type不对，导致修改了media_type为0，gallery中query数据库时限制media_type为1，因此不会在gallery中显示。

因为是服务器的原因（本身服务器传的mime_type值有问题），一般情况下由于服务器的error类型各种各样，Download端不可能针对所有情况都处理，因此默认不做处理，即：保持这些错误。

若必须要修改，请参考FAQ12292：浏览器下载文件无法打开的修改方法，在图片信息插入到db之前就更改错误的mime_type。
```

## [FAQ13934] 如何添加Static Library (静态库)到Share Library(共享库)

```
如何添加Static Library (静态库)到Share Library(共享库)

如:如何添加libnexsound.a到libaudio.primary.default.so
[SOLUTION]
如: 修改 mediatek\platform\mt6592\hardware\audio\android.mk  (各个不同的版本和平台均可参考)

include $(CLEAR_VARS)
LOCAL_MODULE :=libnexsound
LOCAL_SRC_FILES:=libnexsound.a
LOCAL_MODULE_CLASS:=STATIC_LIBRARIES
LOCAL_MODULE_SUFFIX:=.a
include $(BUILD_PREBUILT)

LOCAL_STATIC_LIBRARIES := libnexsound

动态库和静态库的区别？？？？？？？
```

## [FAQ13557] [Audio Profile]打开MTK_SAFEMEDIA_SUPPORT后，插入耳机，第三方播放器的音量无法调节到最大。

```
第三方视频播放器，用的音量调节框是播放器自身的，所以不能跟系统自带的铃声选择框一样，可以弹出铃声最大警告框，点击“确认”后，才可以继续调大音量。
改法：
将VolumePanel.java里的在onDisplaySafeVolumeWaring()里最前面的if((flags&AudioManager.FLAG_SHOW_UI)!=0 || mDilalog.isShowing())  这个判断条件去掉
```

## [FAQ13933] 如何修改系统提示音 (ex:触摸提示音)

```
有两种方法可以修改:
1.修改音频参数,系统音的参数位于

KK: AudioMTKPolicyManager.cpp
L:AudioCustomVolume.h
根据如下mode调整
audiovolume_system[NUM_OF_VOL_MODE][AUDIO_MAX_VOLUME_STEP]数组:
enum VolumeMode {
    VOLUME_NORMAL_MODE = 0,
    VOLUME_HEADSET_MODE,
    VOLUME_SPEAKER_MODE,
    VOLUME_HEADSET_SPEAKER_MODE,
    NUM_OF_VOL_MODE
};

2.修改音源:

修改相应音源,
如: 触摸提示音的音源是/media/audio/ui/Effect_Tick.ogg 
```

## [FAQ13899] [VS]RTSP流媒体UA/UAProfile修改方法

```
方法一：直接修改配置脚本custom.conf
*.UAProfileURL = http://218.249.47.94/Xianghe/MTK_Phone_KK_UAprofile.xml
改为
*.UAProfileURL = http://218.249.47.94/Xianghe/MTK_Athens15_UAProfile.xml 
 
KK版本路径：alps/mediatek/config/&project_name/custom.conf里下面行
L版本路径在：alps/vendor/mediatek/proprietary/frameworks/base/custom/custom.conf
客户的也可以放在alps/device/mediatek/&project_name/custom.conf

方法二：修改代码
请修改frameworks/av/media/libstagefright/rtsp/ARTSPConnection.cpp
Void ARTSPConnection:: MakeUserAgent(AString *userAgent) 
里面有两处userAgent->append(“x-wap-profile: http://218.249.47.94/Xianghe/MTK_Athens15_UAProfile.xml”)让它always跑到.
```

## [FAQ05690] [USB] How to add ISO files into BICR?

```
对于KK版本：
1. 将ISO文件放到alps/system/mobile_toolkit/目录下
2. 修改LOCAL_MODULE为ISO文件名，修改LOCAL_MODULE_TAGS为optional alps/system/mobile_toolkit/Android.mk
3. 将ISO文件名添加进PRODUCT_PACKAGES  alps/build/target/product/$project.mk
4. 修改ISO文件名 alps/mediatek/config/<project>/init.rc
5. 编译：./mk <project> new

对于L版本：
1. 替换alps\device\mediatek\common\iAmCdRom.iso
2. 如果要设置BICR为默认，修改alps\device\mediatek\common\device.mk文件相应的ADDITIONAL_DEFAULT_PROPERTIES += persist.sys.usb.config=bicr
3. make & download
```

## [FAQ08810] [Others]如何将工厂模式的内容显示，从中文修改为英文

```
开机按开机键+下音量键，进入工厂模式。目前内容显示为中文，如何修改为英文显示。
[SOLUTION]
（1）关掉GB2312 option。
ICS版本：
\mediatek\source\factory\src\miniui\font.mk中SUPPORT_GB2312 := yes改为no
GB3,JB,JB2版本：
\mediatek\factory\src\miniui\font.mk中SUPPORT_GB2312 := yes改为no
JB3及JB3之后版本：
\mediatek\config\[project name]\ProjectConfig.mk
和\mediatek\config\common\ProjectConfig.mk中MTK_FACTORY_MODE_IN_GB2312=yes改为no
（2）参考uistrings_eng.h将factory.ini中各MenuItem翻译为英文。
例如：
MenuItem=Keys;
MenuItem=Jogball;
MenuItem=OpticalFingerNavi;
MenuItem=Touch Panel;
（3）重新build，再验证，可以使用ADB command（cat /etc/factory.ini）来验证手机中的factory.ini是否有更新成功。
```

## [FAQ13883] 如何配置mtklogger各种参数

```
配置mtklogger各项参数
[SOLUTION]
配置文件路径
KK版本 :
alps/mediatek/external/xlog/tools/mtklog-config-eng.prop (若配置userload则是mtklog-config-user.prop）
L 版本:
alps\vendor\mediatek\proprietary\external\xlog\tools\mtklog-config-eng.prop  (若配置userload则是mtklog-config-user.prop）

配置文件内容解析
#注意所有赋值后面不要有空格，否则无法解析
#默认存储路径
mtklog_path = internal_sd/external_sd
#默认是否开机自启动
com.mediatek.log.mobile.enabled = true/false
com.mediatek.log.modem.enabled = true/false
com.mediatek.log.net.enabled = true/false
com.mediatek.log.taglog.enabled = true/false
#默认存储大小
com.mediatek.log.mobile.maxsize = 300
com.mediatek.log.mobile.totalmaxsize = 800
com.mediatek.log.net.maxsize = 200
com.mediatek.log.modem.maxsize = 600
 
查看手机中mtklogger当前设置状态
cat /data/data/com.mediatek.mtklogger/shared_prefs/com.mediatek.mtklogger_preferences.xml
```

## [FAQ07757] [Audio Tuning Tool] adb.exe识别不到设备

```
由于adb.exe会与VID&PID绑定，如果客户修改了ADB的VID&PID，可能会导致SDK(Software Development Kit)中的adb.exe识别不到设备，此时在命令行提示符界面下敲入adb devices或者adb shell都会提示错误。
[SOLUTION]
可以按照下面的方法适配ADB的VID。
使用Google原生的adb.exe，然后添加一个外部的配置文件adb_usb.ini。具体操作如下：
找到adb.exe的安装目录，假如adb.exe在C盘：
— 搜索整个C盘寻找文件夹“.android”
— 新建“adb_usb.ini”文件拷贝到“.android”文件夹下
— 在“adb_usb.ini”文件中填写相应ADB设备的VID，可以参考如下截图，e.g. 0x17EF 
 
— 运行：adb kill-server
— 运行：adb start-server
— 此时再运行“adb shell” 就可以连上ADB了。
```

## [FAQ08064] [Debug]如何抓取vm log

```
抓取VM log步骤如下：
1，Enter Engineer Mode\Audio\SpeechLogger，Mark "Enable Speech log" 
2，Mark "Normal -VM+EPL" 
3, Mark"Dump Speech Debug Info" 
4,Set Engineer Mode\Audio\speech enhancement/Common para 0=6 
5，After finish above setting, every call will be recorded as a .vm file automatically, and saved in ""mtk log\audio dump\"
VM log是用来记录声音数据的，您在测试时麻烦讲话大声一点，而且通话时间也稍稍长一点，至少保证通话有一分钟，这样方便我们来解析数据分析。
```

## [FAQ11544] [USB]-[CDROM]如何设定打开CDROM后windows弹出自动播放窗口？

```
该feature实现与代码无关，是通过CDROM内置的iso镜像客户化完成的。
制作iso镜像文件时，在根目录添加autorun.inf文件，
内容格式：
[autorun]
Icon=my.ico                                      //光盘图标
open=客制化执行程序的路径                    //默认执行的程序
shell\加密文件\command=UDE.exe          //右键磁盘的操作项
==================================================================
同理，如果要修改连接PC后的UMS功能出现的U盘的盘符对应的图标，
 1、用记事本在U盘或硬盘下编辑如下内容： 
[autorun] 
icon=*.ico 
2、把*.ico图标文件复制到移动存储设备根目录。 
3、然后把此文件保存为Autorun.inf 
4、将这两个文件（图标文件和inf文件）的属性改为只读、隐藏。 
注：*代表图标文件名 
Notice:
–这个autorun.inf的方法适用于U盘，CDROM.iso，UMS时可能需要修改android的权限，默认不能在根目录放文件。
```

## [FAQ13720] [Audio APP]歌曲名称以拼音排序时，以‘a’ 'an' 'the'开始的歌曲不做任何处理

```
1、请在PinyinKeyUtils.java文件的keyFor方法中修改如下：
public static String keyFor(String name) {
    ……
    name = name.trim().toLowerCase();
    //删除以下
    if (name.startsWith("the ")) {
        name = name.substring(4);
    }
    if (name.startsWith("an ")) {
        name = name.substring(3);
    }
    if (name.startsWith("a ")) {
        name = name.substring(2);
    }
    //删除以上
    ……
}
2、将歌曲文件删除后重新copy才会生效。
```

## [FAQ13721] [AudioApp]软件disable FM

```
请在mediatek\config\project下的ProjectConfig.mk文件中修改如下：
MTK_FM_SUPPORT=no
MTK_FMRADIO_APP=no
```

## [FAQ13722] [AudioApp]FMRadio录音时，若意外停止，能保存录音文件

```
请在如下进行修改,
1、FMRadioService.java
  private void exitFM() {
      ……
     else if (FMRecorder.STATE_RECORDING == fmState) {
               //添加如下
               mFMRecorder.StopRecordOrPlay();     
                LogUtils.d(TAG, "StopRecordOrPlay");
String defaultName = getRecordingName();
saveRecording(defaultName);
               //添加如上     
                /*mFMRecorder.discardRecording();  
                LogUtils.d(TAG, "Discard Recording.");*/    //删除原来的代码
            }……
2、请在FMRecorder.java文件中添加如下：
public void StopRecordOrPlay() {
   LogUtils.d(TAG, ">> StopRecordOrPlay");
    // release recorder
    if ((STATE_RECORDING == mInternalState) && (null != mRecorder)) {
        stopRecorder();
   // release player
    } else if ((STATE_PLAYBACK == mInternalState) && (null != mPlayer)) {
        stopPlayer();
    }
}
```

## [FAQ13788] 关于平台PPPoE的支持情况

```
PPPoE协议全称是PPP over Ethernet，是在以太网络中转播数据包的一种拨号上网技术，比如电信网络的ADSL就是用PPPoE进行拨号链接。
那么Android支持PPPoE功能吗？
[SOLUTION]
Android本身是不支持PPPoE的，而PPPoE并非类似TCP/IP的基础协议，而是一种封装协议，即可以通过3rd的资源来实现。
MTK平台也不支持PPPoE功能，在部分版本开放了PPPoE的API，java层对应的编译开关为MTK_CTPPPOE_SUPPORT，可以通过在工程中搜索这个编译开关来跟踪代码流程。
```

## [FAQ13739] Camera界面的pickermanager icon较慢显示出来

```
1.      Launch camera；
2. 在capture mode icon & preview screen全部显示出来后, pickermanager icon要等2s左右才显示出来 
[SOLUTION]
请在PMS上直接申请patch: ALPS01988332
或做如下修改
alps\packages\apps\Camera\src\com\android\camera\bridge\CameraAppUiImpl.java as below:
    @Override

    public void setViewState(ViewState state) {

        Log.i(TAG, "[setViewState],mCurrentViewState:" + mCurrentViewState + ",newState:" + state);

        if (mCurrentViewState == state) {

            return;

        }
       ...................

        switch (mCurrentViewState) {

        case VIEW_STATE_NORMAL:

            setViewManagerVisible(true);

            setViewManagerEnable(true);

            mShutterManager.setEnabled(true);            mShutterManager.setVideoShutterEnabled(mIsVideoShutterButtonEanble);

            mSettingManager.setFileter(true);

            mSettingManager.setAnimationEnabled(true, true);

            // For tablet

            if (FeatureSwitcher.isSubSettingEnabled()) {

                mSubSettingManager.setFileter(true);

                mSubSettingManager.setAnimationEnabled(true, true);

            }

            ///add this if statement

            if ((!mCameraActivity.isVideoMode() || !mCameraActivity.isNonePickIntent()) .

                    && mCameraActivity.isCameraOpened()) {

                mPickerManager.show();

            }

            ///add end

            if (!mMainHandler.hasMessages(MSG_SHOW_ONSCREEN_INDICATOR)) {

                showIndicator(0);

            } else {

                Log.d(TAG, "[setViewState]mMainHandler has message MSG_SHOW_ONSCREEN_INDICATOR");

            }

            break;

       

        case VIEW_STATE_CAPTURE:

            mModePicker.hideToast();

            mSettingManager.collapse(true);

 

................................

}
```

## [FAQ13614] NOD32 认为DM.apk以及SmsReg.apk是病毒的原因

```
通过NOD32 Mobile Security & Antivirus应用检查软件会出现Gedma. E, Gedma. C 俩个疑似病毒,经分析怀疑NOD32 Mobile Security & Antivirus应用检测出来的结果因为手机存在dm.apk和SmsReg.apk俩个APK导致的
[SOLUTION]
Dm.apk和SmsReg.都会去向服务器发送注册的信息，其中内容包含：IMEI,Manufacture,Model,Software Vewsion
杀毒软件认为两个apk有去收集手机信息而去做这种判断。
 
dm是指device manager，而smsreg是CMCC需要的dm，也就是定制的dm。
dm中比较常用的是FOTA功能，也就是OTA升级，它会收集手机的信息到服务器，服务器根据这些信息做鉴权，然后检查是否有新版本，然后决定是否给手机新版本的差分包。
那smsreg也是会收集一些常用的配置信息，而且smsreg这个需求，CMCC目前已经不再要求，这个功能可以直接去掉。
另外dm中主要是FOTA功能，如果不用，也可以关闭。具体请参照FAQ12918。
```

## [FAQ13601] 怎样打印出手机上网时访问的网址内容？

```
手机访问网络时会用浏览器输入网址，这些是用户界面可见的；
apk也需要通过网址访问apk的服务器，这些在用户界面不可见。
那么如何在手机端把访问的网址打印出来呢？
[SOLUTION]
其实平台默认已经会打印这些dns query数据了，示例如下：
01-30 17:54:12.740885 241 6353 D libc-netbsd: res_queryN name = gmail-smtp-in.l.google.com, class = 1, type = 1
01-30 17:54:12.741026 241 6353 D libc-netbsd: res_queryN name = gmail-smtp-in.l.google.com succeed
01-30 17:54:13.921741 241 6354 D libc-netbsd: res_queryN name = www.google.com <http://www.google.com/> , class = 1, type = 1
01-30 17:54:13.944311 241 6354 D libc-netbsd: res_queryN name = www.google.com <http://www.google.com/>  succeed
01-30 17:57:59.523221 241 6378 D libc-netbsd: res_queryN name = supl.sonyericsson.com, class = 1, type = 1
01-30 17:57:59.555766 241 6378 D libc-netbsd: res_queryN name = supl.sonyericsson.com succeed

这部分代码在getaddrinfo.c中的res_queryN()函数中，只要是本机发起的dns query，不论是使用wifi或data及使用浏览器或apk都会经由这里。
所以我们可以在这里打印出本机主动发起的链接。
提醒：
若本机作为热点，其他链接到热点的设备访问网络，这样的访问信息在本机是没有办法抓到的。
原因是本机当前作为热点启用的是dnsmasq应用，这个应用只有转发数据包的功能，并不会到dns libc。
```

## [FAQ13589] [Audo framework] L 版本上播放歌曲是否使用 NuPlayer

```
在 Android default code 中, L 版本播放歌曲是使用 NuPlayer 来做的
但出于功耗方面的考量, 我司对下面两种格式的歌曲仍然会使用 awesomeplayer 来播放
这两种格式是
audio/mpeg
audio/ape
 
AwesomePlayer 在工作时开的 thread 更少, 所以功耗表现会相比与 NuPlayer 好
如果希望与 android default code 保持一致
请参考如下 solution
[SOLUTION]
修改frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp 中的
status_t MediaPlayerService::Client::setDataSource(int fd, int64_t offset, int64_t length) 方法内
找到下面这段代码, 并将其注释掉:
if(!strcasecmp(tmp,"audio/mpeg") || !strcasecmp(tmp,"audio/ape")) {
    playerType = STAGEFRIGHT_PLAYER;
}
```

## [FAQ13587] [Audio App]音效设置界面右上角的开关图标未居中显示

```
在 KK 版本上, 上述图标会显示为相对居中, 显示效果比较友好
而 L 版本上, 此图标则相对比较靠左, 或靠右显示
 
如果需要调整为较居中显示开关图标,
可以参考以下解法
 
[SOLUTION]
修改 vendor/mediatek/proprietary/frameworks/base/res/res/values/styles.xml
中 <item name="android:switchMinWidth">80dp</item> 的定义
原值是 80, 可改为 60 或其它实际调整后觉得看起来比较合适的值
```

## [FAQ13583] [Audio APP]如何在music中屏蔽不支持的音乐

```
首先, 你需要知道这些要屏蔽的音乐文件的 mimeType,
如果不知道, 可去mediaProvier 的 database 中查询对应的音乐文件的 mime_type 的值
 
假定我们已经知道要屏蔽的音乐文件的 mimeType 为 audio/x-ms-wma
 则我们可以通过如下方法去做屏蔽处理
 
 
[SOLUTION]
 1: 如果只在 Music apk 中做屏蔽处理(其它三方 apk 不做屏蔽处理)的话, 可以参考下面改法:
修改 Music apk 包中 TrackBrowserActivity.java 
在 getTrackCursor 方法内
找到下面这行
where.append(" AND " + MediaStore.Audio.Media.IS_MUSIC + "=1");
在它后面加入:
where.append(" AND mime_type != 'audio/x-ms-wma'");  //其中红色字体的为所需要屏蔽的 mimetype, 请按需修改
 
2: 如果要在 framework 中做屏蔽处理(任何 apk 都无法查到被屏蔽的文件):
可以参考下面的改法:
修改 MediaScanner.java
 
1: 添加定义:
static String MIME_UNKNOWN = "unknown_mime";
 
2: 增加方法
private boolean isUnsupportMime(){
 if(mMimeType == null)
  return false;
 if(mMimeType.equals("audio/x-ms-wma")){ 
    return true;
    } //如果还有其它想过滤掉的 mimetype, 请再加入 else if(mMimeType.equals("xxx")) return true;
 
 return false;
}

3: private ContentValues toValues() 方法首行加入:
if(isUnsupportMime()){
    Log.d(TAG,"change mime to unknown");
    mMimeType = MIME_UNKNOWN;
    mNoMedia = true;
}

4: endFile 方法中在如下参考行
ContentValues values = toValues();
之后加入:
if(mMimeType != null && mMimeType.equals(MIME_UNKNOWN)){
    mFileType = 0;
    music = 0;
}
```

## [FAQ12999] [Audio App] 音乐播放列表丢失

```
开启MTK_2SDCARD_SWAP后，内置SD CARD的第一次开机：
1.进入本地音乐点击任意歌曲添加至新建播放列表A;
2.连接USB存储添加任意音频文件至SD卡;
3.添加成功后关闭USB存储，返回查看新建播放列表：发现之前创建的列表A已经丢失;
4.再次新建一个播放列表B;
5.连接USB存储后，进入本地音乐查看新建播放列表：第一次创建的列表A重新出现，但列表B不存在；
6.关闭USB存储,查看新建播放列表：列表B正常显示;
 
[SOLUTION]

=====================================================================
开启MTK_2SDCARD_SWAP后，内置SD CARD的第一次开机：
 
1.进入本地音乐点击任意歌曲添加至新建播放列表 A 
>>>创建external-xxx.db; 列表A在external-xxx.db

2.连接USB存储添加任意音频文件至SD卡
>>>external-xxx.db被重命名为external.db;

3.添加成功后关闭USB存储，返回查看新建播放列表
>>>创建一个新的external-xxx.db；从external-xxx.db查询，从而这里找不到之前的列表A

4.再次新建一个播放列表B
>>>列表B被写入external-xxx.db
 
5.连接USB存储后，进入本地音乐查看新建播放列表：第一次创建的列表A重新出现，但列表B不存在；
>>>查询external.db,从而找到了之前的列表A，找不到列表B
 
6.关闭USB存储,查看新建播放列表：列表B正常显示;
>>>查询external-xxx.db，找到列表B
=====================================================================
```

## [FAQ13558] 取消录像按键音

```
进入camera，点击录像开始和录像结束的button时，默认是有声音的。现希望取消录像的按键音。
[SOLUTION]
alps\packages\apps\Camera\src\com\android\camera\SettingChecker.java文件中的setParameterValue()函数内:
case ROW_SETTING_MUTE_RECORDING_SOUND:
          Log.i(TAG, "enableRecordingSound value = " + value);
           parameters.enableRecordingSound(value);
修改为
case ROW_SETTING_MUTE_RECORDING_SOUND:
          Log.i(TAG, "enableRecordingSound value = " + value);         
                  parameters.enableRecordingSound(1);
```

## GPS 相关问题

```
FAQ13253	GPS问题分类--AGPS认证相关	SW > ALPS > GPS	2014-12-31
FAQ13252	GPS问题分类--GPS资料	SW > ALPS > GPS	2014-12-31
FAQ13251	GPS问题分类--测试相关	SW > ALPS > GPS	2014-12-31
FAQ13247	GPS问题分类--LOG相关	SW > ALPS > GPS	2014-12-31
```

## [FAQ11156] 手机做热点时，如何获取连过来设备的具体信息？

```
手机做热点时，可以读取连过来的client的信息，平台默认会显示mac地址在热点热点设定界面。
[SOLUTION]
1、连过来的设备的信息存放在/data/misc/dhcp/dnsmasq.leases中
2、它的格式是：
/系统id，不需取值/client mac地址/client ip地址/ client device name/加权后mac地址，也不需取值
1357041758   88:00:12:34:56:78 192.168.43.133 android-184cc6c105d7a3b 01:88:00:12:34:56:78
 
2、参考WifiServie.java的getClientIp()方法，可以客制化这个方法取得device name，具体如下：
public String getClientDeviceName(String deviceAddress) {//传mac地址进来
    enforceAccessPermission();
    if (TextUtils.isEmpty(deviceAddress)) {
        return null;
    }
//读取对应的文件信息
    for (String s : readClientList("/data/misc/dhcp/dnsmasq.leases")) {
        if (s.indexOf(deviceAddress) != -1) {
            String[] fields = s.split(" ");
//校验数据是否破损
            if (fields.length > 4) {
//返回第4个栏位
                return fields[3];
            }
        }
    }
    return null;
}
```

## [FAQ11153] 如何确认是谁修改了SettingsProvider中某变量的值

```
以下以Settings.Global.WIFI_SLEEP_POLICY为例，对应的value是wifi_sleep_policy，其他变量请具体配置对应value：
1:修改Settings.java (alps\frameworks\base\core\java\android\provider) 中
在 class Secure 内部类的
public static boolean putStringForUser(ContentResolver resolver, String name, String value, int userHandle) {
    //的后面添加
    if(name.equals(Settings.Global.WIFI_SLEEP_POLICY)){ //add begin
        Log.d(TAG,"@@## name = "+ name+ "value = "+value,new Exception("Settings"));
    } //add end

2:修改
ContentResolver.java (alps\frameworks\base\core\java\android\content)中
在
public final Uri insert(Uri url, ContentValues values) {
    后添加
    if(values.containsKey("wifi_sleep_policy")){//add begin
        Log.d("Settings","@@##@@ url = "+ url+", values = "+ values,new Exception("Settings"));
    }//add end
在
public final int update(Uri uri, ContentValues values, String where, String[] selectionArgs) {
后添加
    if(values.containsKey("wifi_sleep_policy")){//add begin
        Log.d("Settings","@@## url = "+ uri+", values = "+ values,new Exception("Settings"));
    }//add end
 
3、复制问题并提供main_log，通过对应的callstack可以找到是谁操作了变量。
```

## [FAQ11160] 定位是谁通过注册AlarmManager来发intent

```
有些intent是通过AlarmManager注册后发送的，可能是第三方的apk，这会为user带来干扰以为出现了bug，可以通过下面的log进行定位。
 
[SOLUTION]
以某次发送 WifiManager.action.DELAYED_DRIVER_STOP 为例：
01-01 00:07:31.773   669   717 E AlarmManager: Alarm at trigger: Alarm{42d14330 type 0 android}
01-01 00:07:31.773   669   717 V AlarmManager: Native set alarm :Alarm{41c22b28 type 0 com.xxxx.safecenter}
01-01 00:07:31.773   669   717 V ActivityManager: Broadcast: Intent { act=com.android.server.WifiManager.action.DELAYED_DRIVER_STOP flg=0x14 (has extras) } ordered=true userid=0 callerApp=null
 
可以看到在 setalarm 后 intent 就被发出，往前看log找到是 com.xxxx.safecenter 设定了它；
对应的代码在 AlarmManagerService.java 的 toString() 方法，会打印 package name。
```

## [FAQ12094] 拼音以v结尾的中文字，搜索时输入v搜索不到

```
所有拼音以V结尾的中文字，如“女”，“吕”，“绿”等。
1.添加号码时可以用V输入添加；
2.搜索时，将V之前的拼音输入，能搜到目标结果；
3.输入V之后，无法搜索到目标结果；

[SOLUTION]

汉语拼音的声母韵母表中没有V，只是在输入法中把u加两点的韵母设置在V键上，而搜索时，我们只是搜索汉字所对应的拼音，所以不可以用V来搜索，且u，u加两点的韵母，本来两者之间界限比较模糊，如yu,就是用u替代的u加两点的韵母，且google原生参考机：Nexus也是同样的现象，请知悉和验证。
谢谢！
```

## [FAQ10074] 勾选USB调试后关闭开发者选项后退出再进入开发者选项为打开状态

```
Developer options的总开关会在进入developer options的时候去做这样的一个判断：
是否所有的developer options选项都被关闭，若没有，就会重新开启developer options总开关；
所以若是想要总开关成功关闭，需要先关掉所有的developer选项，然后再关闭总开关才能生效。
相关代码：DevelopmentSettings.java onResume()
if (mHaveDebugSettings && !mLastEnabledState) {
    // Overall debugging is disabled, but there are some debug
    // settings that are enabled.  This is an invalid state.  Switch
    // to debug settings being enabled, so the user knows there is
    // stuff enabled and can turn it all off if they want.
    Settings.Global.putInt(getActivity().getContentResolver(), Settings.Global.DEVELOPMENT_SETTINGS_ENABLED, 1);
    mLastEnabledState = true;
    mEnabledSwitch.setChecked(mLastEnabledState);
    setPrefsEnabledState(mLastEnabledState);
}

此为google 原生设计。
```

## [FAQ13193] [DCT]Android L版本上codegen.dws文件的路径

```
1. 在Android L版本上 DCT tool配置的codegen.dws文件在preloader、lk、kernel中是独立的，被分开放置，其路径如下：
preloader： 
alps\bootable\bootloader\preloader\custom\$(proj)\dct\dct\codegen.dws

lk:
alps\bootable\bootloader\lk\target\$(proj)\dct\dct\codegen.dws

kernel:
alps\kernel-3.10\arch\arm\mach-$(platform)\$(proj)\dct\dct\codegen.dws

or

alps\kernel-3.10\drivers\misc\mediatek\mach\$(platform)\$(proj)\dct\dct\codegen.dws

2. 修改某一个路径下的dws文件，不会影响其他两个路径下的dws文件，所以在修改dws文件之后，必须copy到上面的三个路径下，您的修改才会正常生效。

3. 对应的，DCT tool也被分开放置在3个路径中，具体如下：
preloader：
alps\bootable\bootloader\preloader\tools\dct\
lk：
alps\bootable\bootloader\lk\scripts\dct\
kernel：
alps\kernel-3.10\tools\dct\

4. 重新编译使修改后的codegen.dws文件生效
make -j24 pl 2>&1 | tee preloader.log
make -j24 lk 2>&1 | tee lk.log
make -j24 kernel 2>&1 | tee kernel.log
make -j24 bootimage 2>&1 | tee bootimage.log

备注：
$(platform)：指所用的platform
$(proj)：指所用的project
```

## [FAQ12984] 从Camera滑入空的Gallery背景有一根黑线

```
1. Camera文件夹内容为空
2. 进入Camera, 向左滑动进入Gallery
3. 显示0 images/videos available, 同时查看背景有一根黑线
 
解决方法：
packages\apps\Gallery2\src\com\android\gallery3d\glrenderer\GLES20Canvas.java
为：
public void drawTexture(BasicTexture texture, int x, int y, int width, int height) {
    if (width <= 0 || height <= 0) {
        return;
    }
    copyTextureCoordinates(texture, mTempSourceRect);
    mTempTargetRect.set(x, y, x + width - 1, y + height - 1); // M: modify this line
    convertCoordinate(mTempSourceRect, mTempTargetRect, texture);
    Log.d(TAG, "[Gallery Issue] drawTexture src: " + mTempSourceRect + ", target: " + mTempTargetRect);
    drawTextureRect(texture, mTempSourceRect, mTempTargetRect);
}
private static void copyTextureCoordinates(BasicTexture texture, RectF outRect) {
    int left = 0;
    int top = 0;
    int right = texture.getWidth() - 1;      // M: modify this line
    int bottom = texture.getHeight() - 1; // M: modify this line
    if (texture.hasBorder()) {
        left = 1;
        top = 1;
        right -= 1;
        bottom -= 1;
    }
    outRect.set(left, top, right, bottom);
}
```

## [FAQ13081] 64bit系统上，如何判断运行的进程是32bit还是64bit

```
64bit系统上，运行的进程可能是32bit，也可能是64bit，这里给出判断的方法。
[SOLUTION]
确认adb可以连接成功后，执行命令: adb shell ps --abi，ABI一栏如果包含"32 "，说明为32bit，否则为64bit。下面以内部参考机运行上述命令后的结果为示例：
```

## [FAQ13077] 如何判断当前机器运行的kernel是32 bit还是64bit

```
搭载64bit芯片的机器，运行的kernel可能是32bit，也可能是64bit，这里给出判断的方法。 
 
[SOLUTION] 
判断方法有如下两种： 
1. 确认adb可以连接成功后，执行命令: adb shell cat /proc/cpuinfo，Processor一项如果包含"aarch64 "，说明为64bit kernel，否则为32bit。下面为内部参考机kernel分别为32bit、64bit时运行上述命令后的结果：

2. 确认adb可以连接成功后，执行命令: adb shell cat /proc/sys/kernel/osbit，如结果为"64 "，说明为64bit kernel，否则为32bit。
下面为内部参考机kernel为64bit时运行上述命令后的结果：
```

## [FAQ08944] 预置邮件客户端中的签名

```
预置或者客制化邮件客户端中的发信人签名，如：
英文:
Send via Pandora
中文:
发送自潘多拉
 
[SOLUTION]
File:
Email/src/com/android/email/activity/setup/AccountSetupNames.java
# class FinalSetupTask # function doInBackground(Void... params):
add line：
        cv.put(AccountColumns.SIGNATURE, getString(R.string.signature));
below the line:
        ContentValues cv = new ContentValues();
Please NOTE that "R.string.signature" is a new string resource you need to add.
For your case, please add a new String resource R.string.signature as "Send via Pandora", which is easy to do i18n as well.
If you want to change this default signature to others, modify the R.string.signature as you wish.
```

## [FAQ12752] 如何修改MTKlogger默认存储容量大小

```
有时候debug问题需要，需要修改MTKlogger的默认存储容量。

请修改alps\mediatek\external\xlog\tools\ 下的mtklog-config-XXX.prop文件,
将对应mobile log，modem log，net log的maxsize修改为需要的值即可。
```

## [FAQ13440] 用搜狗表情符号命名文件夹，有的成功，有的不成功

```
不同的文件系统对表情符号的支持度是不同的：
EXT4：支持
FAT：不支持

在打开SD SAHRED的情况下：
phone storage：文件系统是ext4，在file manager中用表情符号命名，是可以成功的。
SD：文件系统是FAT，在file manager中用表情符号命名，会返回操作失败的信息

在没有打开SD SHARED的情况下：
phone storage和SD： 文件系统是FAT，不支持表情符号命名。

上述描述的是手机端，手机端支持并不表示PC端也会支持，因为PC端是FAT的文件格式，请知悉～


FAT 和 EXT4 文件格式的区别？？？
```

## [FAQ13537] [Gallery]将PC图片收藏里的图片cpy至手机，会不显示缩略图查看detail会报错

```
Win7 拷过来的图从ultraedit中看到它的exif header并不算是标准的，会导致gallery读取exif时发生exception，因此无法显示缩略图和detail信息
修改方法如下：
在ExifParser.java文件readTag函数中约561 行

System.arraycopy(mDataAboveIfd0, (int)***************)
修改为：
if (mDataAboveIfd0 == null) return null;
System.arraycopy(mDataAboveIfd0, (int)***************)
```

## [FAQ13535] 将保存照片的文件夹camera改为西班牙语Cámara导致livePhoto拍照异常

```
在 packages/apps/Camera/src/com/android/camera/Storage.java 中把照片的保存路径做如下修改后导致livephoto拍照异常：

public static final String DIRECTORY = DCIM + "/Cámara";
public static final String FOLDER_PATH = "/" + Environment.DIRECTORY_DCIM + "/Cámara";

[SOLUTION]
此问题是由于á这个字母编码比较特殊，从String转成字符流时出现错误，现在使用新的ByteArrayInputStream对象，然后指定utf-8编码可以解决。
具体修改方法如下：
1、在 VideoLivePhotoActor.java 中的 getScenario() 函数中
将
"<?xml version=\"1.0\"?>"
改为
"<?xml version=\"1.0\" encoding=\"utf-8\"?>"
2、在 ScenarioReader.java 中的 getScenario() 函数中
将
StringBufferInputStream myXML = new StringBufferInputStream(xml);
改为
ByteArrayInputStream myXML = new ByteArrayInputStream(xml.getBytes("UTF-8"));
```

## [FAQ12118] 关于修改底色为白色后，设置中菜单字体显示为灰色字体问题（白底黑字）

```
修改背景底色为白色后，设置下有些菜单字体显示为灰色，如下：
设置里安全选项里 “Auto start management,App permissions,Clear Credentials”三个字体的颜色灰色
要修改字体为黑色，请参考如下solution
 
[SOLUTION]
请修改  mediatek/packages/apps/PermissionControl/AndroidManifest.xml
<application
    android:taskAffinity=""
    android:persistent="true"
    android:icon="@mipmap/ic_launcher_settings"
    android:theme="@android:style/Theme.Holo"
    android:allowClearUserData="false" >
修改android:theme和贵司setting使用的theme一致。
请修改后测试即可。如果仍然有疑问请再联系MTK技术人员。
```

## [FAQ12117] 手动安装apk,恢复出厂设置后，应用没有删除

```
关闭 ProjectConfig.mk 中的 MTK_SPECIAL_FACTORY_RESET 或者 push 一个内容为空的 .keep_list 到 data/app 即可解决此问题
```

## [FAQ11264] 无法保存包含“{CID}”的网址为书签

```
由于"{" / "}"为非法的URL字符，所以无法保存，如果您需要保存此类网址，建议在保存前将“{CID}” 替换成Client ID，可以按如下方式修改：
AddBookmarkPage.java
import com.android.browser.provider.BrowserProvider;
 
 boolean save() {
 ...
  if (unfilteredUrl.indexOf("{CID}") != -1) { 
    unfilteredUrl = unfilteredUrl.replace("{CID}", 
    BrowserProvider.getClientId(getApplicationContext().getContentResolver())); 
  }
  String url = unfilteredUrl.trim();
 ...

```

## [FAQ10927] [USB serial number客制化][系列6]：能否实现adb devices的序列号，usb serial number, cts device ID，SN一致？

```
adb devices, Serial number, 手机序列号, USB serialno, usb序列号, sn, cts device ID
[SOLUTION]
adb devices的序列号 : 为sys/class/android_usb/android0/iSerial结点值，在开机过程中on init阶段（init.usb.rc文件中）写入
usb serial number : 即usb spec规定的usb的serial number, 代码中对应sys/class/android_usb/android0/iSerial结点值
cts device ID : 就是adb devices的序列号
SN : 为getSystemService(Context.TELEPHONY_SERVICE)).getSN()获取到的，需要在android起来之后获取
综上，adb devices的序列号，usb serial number, cts device ID是一致的，但是不能做到与SN一致
```

## [FAQ10924] [USB serial number客制化][系列3]：如何修改手机序列号为Barcode？

```
adb devices, Serial number, 手机序列号, USB serialno, usb序列号, sn, Barcode
[SOLUTION]
请参考：[FAQ09340] 如何使SN Write tool写入的Barcode在“设置->关于手机->状态信息->序列号”中显示出来？
需要注意的是，此Barcode是由SN Write tool写入的。
```

## [FAQ04349] 不能添加系统属性system property, 提示： permission denied uid:xxxxx name:xxxxx

```
system property  permission denied  无法写入 没有权限
 
[Solution]
首先说明一下system property 的使用API
Java API
android.os.SystemProperties
public String get(String key);
public String get(String key, String def);
public int getInt(String key, int def);
public long getLong(String key, long def);
public void set(String key, String val); => the return value is void

Native API
libcutils/Properties.h & Properties.c
int property_set(const char* key, const char* value);
int property_get(const char* key, char* value, const char* def);
int property_list(void(*propfn)(const char* key, const char* value, void * cookie), void * cookie);

Android Toolbox
adb shell getprop
 return all properties, as list
adb shell getprop <key>
    return the property base on key
adb shell setprop <key> <value>
    set the property <key> <-> <value>

Init.rc
setprop <key> <value>
on property:<key>=<value>
 some actions.

其次 system property 的重要性
system property 是存在在init 进程中的关键系统属性，如系统安全，系统稳定性，系统的版本信息等，一般情况下，都不建议使用system property 来进行信息共享，一来容量有限，二来可能导致系统安全等其他问题。
 
最后 如何添加:

(1). android L(5.0) 以前的版本:

Init 通过socket 对端的UID 和 system/core/init/property_service.c 中的permission table 匹配来确认是否可以添加。table 一般分成三列：
{ prefix.,   UID,    GID },
比如
{ "sys.",   AID_SYSTEM,   0 }, 即说明如果是以sys. 开头，那么uid 是system (1000) 的 或者gid 是 root(0) 的都可以访问，修改。注意如果是"ro." 开头，则忽略掉"ro." 这三个字符。
Permission Table 有两个，对于非 ctl.start/ctl.stop 开头的系统属性，即普通属性，通过property_perms 来控制。
如果是 ctl.start/ctl.stop 即控制属性，那么通过 control_perms 来控制。
对于"ro." 开头的系统属性，如果原本已经存在，则无法再修改，所谓"read only", 即最多写一次。

一般APP 因为没有固定的UID(每次安装可能都不一样), 所以肯定无法添加。所以首先就要在AndroidMenifest.xml 添加对应的UID 说明，其次需要使用系统相对应的签名，然后push 到system/app 下面，成为系统APK。这样你启动这个APP 之后就可以ps 去查看它的UID 了，确认正确。
然后就是去更新 system/core/init/property_service.c 添加对应的访问权限

普通APP 因为没有固定的UID， 故是无法直接添加system property.

(2). android L(5.0) 以及以后的版本: 
Google 删除了permission table, 而是直接通过SELinux 来限制SELinux 的添加与修改.
对于"ro." 开头的系统属性，如果原本已经存在，则无法修改，所谓"read only", 即最多写一次。
对于一个 "xxx.yyy.zzz" 的系统属性("ro.xxx.yyy.zzz" 当作 "xxx.yyy.zzz" 看待),

(2.0) 首先到external/sepolicy/property_contexts , device/mediatek/common/sepolicy/property_contexts 查看是否有绑定它或者它的前缀(如 xxx.yyy.zzz, xxx.yyy, xxx.yyy., xxx.,xxx 等) 的SELinux Context, 如果有, 则忽略掉(2.1), (2.2) 这两步.

(2.1) 在device/mediatek/common/sepolicy/property.te 中 定义这个系统属性 "xxx.yyy.zzz" 的SELinux Context.
 type xxx_yyy_zzz_prop, property_type;
 
(2.2) 在device/mediatek/common/sepolicy/property_contexts 中 绑定这个系统属性所对应的SELinux Context.
 xxx.yyy.zzz xxx_yyy_zzz_prop;

(2.3) 在对应的Process(假设为demo)在device/mediatek/common/sepolicy/demo.te 中新增
   unix_socket_connect(demo,property,init);
   allow demo xxx_yyy_zzz_prop:property_service set;
   
同样Google 严禁普通的app (untrusted app)增加和修改system property.
```

## [FAQ11164] 关于systemproperty ro.baseband, ro.bootloader, ro.bootmode的设置问题

```
这三个属性值目前Mediatek platform 并没有使用到，如果需要设置，可以直接更新system/core/init/init.c 中export_kernel_boot_props 函数中的prop_map 数组， 默认都是unknown.
注意的是如果修改对应project 中的system.prop 是无效的，因为此时export_kernel_boot_props 的执行在load system/build.prop 之前。 而ro. 开头的system property 一旦写入就无法再更新。
 
[相关FAQ]
FAQ07367: 如何设置system property 默认值
FAQ04349: 不能添加system property, 提示： permission denied uid:xxxxx  name:xxxxx
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ03778: 如何对system property 进行扩容
FAQ06739: system property 设置失败的可能性分析和初步诊断
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ10716：system property 重启或者恢复出厂设置后无效(丢失)
FAQ10974: Android KK 4.4 后，在host 端使用system property 无法编译通过
```

## [FAQ03778] 如何对系统属性 systemproperty 进行扩容

```
在KK 4.4 以前, 因为system property 线性设计简单，只为共享有限关键数据而设计，如果增加容量将会导致执行变慢, Google 不推崇对system property 进行扩容.
在线性结构下， system property 的buffer 分成三块，
     Head 块固定32个字节; 
     Info 块存放property name 的简单hash值，每个4个字节; 
     Data 区存放property 的key<->value 真实数据，每个128个字节;
 
system property 实现定义在system/core/init/property_service.c 中，扩容涉及到三个参数, 即三个宏的更新:
     PA_COUNT_MAX 定义property 的最多数量，google 默认为247, 我司已经增加128，至247+128=375
     PA_INFO_START 定义Data 区的起始位置，故PA_INFO_START 为Head + Info >= 32 + PA_COUNT_MAX*4, 最好取32的整数倍，以便对齐
     PA_SIZE 定义整个buffer 的大小，故PA_SIZE >= PA_INFO_START + PA_COUNT_MAX*128
  
 在JB 4.2 版本，MTK 为方便大家更新已经将这三个宏对接起来，大家只需要更新PA_COUNT_MAX 即可
  
KK 4.4 以后，Google 已经使用Hybird trie/binary tree 结构代替了原来的线性结构，性能大为提升，对应的system property 数量也大为提升, 接近1024 个，通常已经足够使用。设置是在
alps/bionic/libc/include/sys/_system_properties.h 中
#define PA_SIZE         (128 * 1024)
 
 
FAQ07367: 如何设置system property 默认值
FAQ04349: 不能添加system property, 提示： permission denied uid:xxxxx name:xxxxx
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ06739: system property 设置失败的可能性分析和初步诊断
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ10716：system property 重启或者恢复出厂设置后无效(丢失)
```

## [FAQ06739] system property 设置失败的可能性分析和初步诊断

```
首先说明一下system property 的使用API
Java API
android.os.SystemProperties
public String get(String key);
public String get(String key, String def);
public int getInt(String key, int def);
public long getLong(String key, long def);
public void set(String key, String val); => the return value is void

Native API
libcutils/Properties.h & Properties.c
int property_set(const char* key, const char* value);
int property_get(const char* key, char* value, const char* def);
int property_list(void(*propfn)(const char* key, const char* value, void * cookie), void * cookie);

Android Toolbox
adb shell getprop
return all properties, as list
adb shell getprop <key>
return the property base on key
adb shell setprop <key> <value>
set the property <key> <-> <value>

Init.rc
setprop <key> <value>
on property:<key>=<value>
some actions.

其次 system property 的重要性
system property 是存在在init 进程中的关键系统属性，如系统安全，系统稳定性，系统的版本信息等，system property 容量有限，不能随意添加。

那system property 设置失败，通常有哪些可能的原因呢，在这里我列举常见的五类:
Case 1: 没有在property_service.c 中增加相关的权限，请参考FAQ:  不能添加system property, 提示： permission denied uid:xxxxx  name:xxxxx
Case 2: system prop 已经满，无法再写入，请参考FAQ: 如何对system property 进行扩容
Case 3: 这个property <key,value> 的key 的长度超过了32， value 的长度超过了92, 直接拒绝, 注意长度包括结尾字符.
Case 4: socket 连接有问题，因为其他非init process 是通过socket 连接到init process 来设置system property的，如果socket 不能正常的连接，即设置无法成功。socket 最有可能出的问题就是无法申请到fd(文件句柄)，即如果当时的process 发生了fd leak, fd 的数量已经达到或者接近1024 时，就无法申请到新的fd， 从而无法创建socket 连接。您可以通过ls -a -l proc/processid/fd 来查看具体的process 的fd list. 从而确认fd 的使用情况，去分析fd leak 的原因，更多fd leak 的分析，需要您们针对具体的case 提eservice 由MTK 的工程师协助分析。
Case 5: KK 版本以后版本, 对应进程如果没有设置system property 的权限，被SELinux Reject 掉, 请参考FAQ： [SELinux Policy] 如何设置SELinux 策略规则 ? 在Kernel Log 中出现"avc: denied" 要如何处理？

相关FAQ:
[FAQ04349]: 不能添加system property, 提示： permission denied uid:xxxxx  name:xxxxx
https://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ04349
[FAQ03778]: 如何对system property 进行扩容
https://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ03778
[FAQ11486]: [SELinux Policy] 如何设置SELinux 策略规则 ? 在Kernel Log 中出现"avc: denied" 要如何处理？
https://online.mediatek.com/Pages/FAQ.aspx?List=SW&FAQID=FAQ11486
```

## [FAQ12691] [Gallery]图库中设置高分辨率壁纸出错

```
Root Cause: Bitmap RegionDecode 时发生OutOfMemoryError;
 
修改alps/packages/Gallery2/src/com.android.gallery3d.filtershow.crop/CropActivity.java中 (between” Edit Start “and “Edit End” )：
.…..
BitmapIOTask(…) {
….
doInBackground(Bitmap … params) {
…
    Bitmap crop = null;
            if (decoder != null) {
                // Do region decoding to get crop bitmap
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inMutable = true;
/**********************************************Edit Start *****************************************************************************/
                /// M: increase sample size to avoid OOM for extremely large image. @{
                int sampleSize = 1;
                long maxMemory = Runtime.getRuntime().maxMemory();
                while ((roundedTrueCrop.width() >> (sampleSize - 1)) * (roundedTrueCrop.height() >> (sampleSize - 1)) * 4
                        > maxMemory) {
                    if (sampleSize > 5) break;
                    sampleSize++;
                    Log.i(LOGTAG, "BitmapIOTask.doInBackground, image too large, set sample size to " + sampleSize);
                }
                options.inSampleSize = sampleSize;
                /// @}

/***************************************************************Edit End *************************************************************/
                crop = decoder.decodeRegion(roundedTrueCrop, options);
                decoder.recycle();
            }
```

## [FAQ04156] [Hotspot]如何修改便携式热点的默认SSID名称

```
TD项目修改alps\mediatek\source\frameworks\base\core\res\res\values\Strings.xml中

的wifi_tether_configure_ssid_default_for_cmcc变量

非TD项目修改alps\frameworks\base\core\res\res\values\strings.xml中的wifi_tether_configure_ssid_default变量

JB版本：
TD:\alps\mediatek\frameworks\base\res\res\values\Strings.xml中wifi_tether_configure_ssid_default_for_cmcc变量
非TD：alps\frameworks\base\core\res\res\values\strings.xml中的wifi_tether_configure_ssid_default变量

JB2&JB3&JB5版本：
首选配置alps\mediatek\config\$(项目名)\custom.conf文件下的wlan.SSID名字

若这里没有配置，则规则与JB版本相同
```

## [FAQ13066] [Audio Profile]后台播放音乐，进入情景模式预览铃声音量时，后台音乐不停止播放

```
android是允许声音同时播放的，这个是google default设计。如果想在预览铃声时关闭后台音乐播放，JB版本可以参考FAQ04474进行修改，KK版本上，请按如下方式修改：
在RingerVolumePreference.java中，
onBindDialogView 的时候
((AudioManager) getSystemService(AUDIO_SERVICE)).requestAudioFocus(null, AudioManager.STREAM_RING, AudioManager.AUDIOFOCUS_GAIN_TRANSIENT);

然后在onDialogClosed 的时候
((AudioManager) getSystemService(AUDIO_SERVICE)).abandonAudioFocus(null);
```

## [FAQ13010] 如何在Camera拍照时往Jpeg的EXIF新增栏位

```
这边以CustomRendered这个栏位为例，
首先在EXIF官方spec查看该栏位的定义
http://www.kodak.com/global/plugins/acrobat/en/service/digCam/exifStandard2.pdf
官方有如下定义
CustomRendered
This tag indicates the use of special processing on image data, such as rendering geared to output. When special
processing is performed, the reader is expected to disable or minimize any further processing.
Tag = 41985 (A401.H)
Type = SHORT
Count = 1
Default = 0
0 = Normal process
1 = Custom process
Other = reserved

[SOLUTION]
1. 首先需要定义
Exif_type.h (mediatek\hardware\mtkcam\exif\common)
1)    定义
....
#define EXIF_TAG_CUSTOMRENDERED    0xA401
.....
2) 加入数组
static unsigned short exifTagID[] = {
.....
      EXIF_TAG_CUSTOMRENDERED,
.....
};

2. 指出它的类型，CustomRendered为SHORT类型
Exif_ifdinit.cpp (mediatek\hardware\mtkcam\exif\common)
unsigned int
ifdExifIFDValInit(
    ifdNode_t *pnode,
    struct exifIFDList *plist
)
{
    case EXIF_TAG_CUSTOMRENDERED:
        pifd->type = IFD_DATATYPE_SHORT;
        pifd->count = 1;
        write16((unsigned char*)&pifd->valoff, 0);
        break;
}

3.需要在exif api中添加栏位的定义，以便capture流程中使用
IBaseExif.h (mediatek\hardware\mtkcam\exif\common)

typedef struct exifAPP1Info_s {
....
    unsigned short customRendered;
.....
} exifAPP1Info_t;

4. 让exif api的定义和exif_type中的定义map起来
Exif_make.cpp (mediatek\hardware\mtkcam\exif\common)
static unsigned int
exifTagUpdate(
    exifImageInfo_t *pexifImgInfo,
    exifAPP1Info_t *pexifAPP1Info
)
{
.....
    err = ifdListNodeModify(IFD_TYPE_EXIFIFD, EXIF_TAG_CUSTOMRENDERED, &pexifAPP1Info-> customRendered);
    if (err != 0) {
        return err;
    }
......
}
 
5. 写Exif的地方是在CamExif中，这里的pexifApp1Info 就是前面3中定义的exifAPP1Info_s， 您添加的该栏位可以在这里去找个地方进行赋值。
CamExif.cpp (mediatek\hardware\mtkcam\exif\camera)
queryExifApp1Info(exifAPP1Info_s*const pexifApp1Info) {
         ………
        // [customRender]
        pexifApp1Info-> customRendered = 1;  
         …..
}
```

## [FAQ12385] [Jb][KK]版本判断能否实现横屏竖用

```
手机里面说的横屏，指的是他们width>height的屏，在屏的规格书里面，可以看到他显示的分辨率比如为：1024*600， 800*480。
手机里面说的竖屏，指的是他们width<height的屏，在屏的规格书里面，可以看到他显示的分辨率比如为：600*1024， 480*800，常规做法应该是手机使用这样的竖屏。
但是有些客户在选料的时候，会选用横屏LCM，实际手机用户还是作为竖屏在看，这就是横屏竖用。

[SOLUTION]
实现横屏竖用需要满足两个条件，一是满足平台的分辨率要求，即横屏的width不大于平台支持的最大分辨率的width；二是把资源旋转90°或者270°，使用户可以看到竖着的图形，通过配置MTK_LCM_PHYSICAL_ROTATION=90或者270实现旋转。

如下举两个例子说明横屏竖用：
1、92kk版本如何在1024*600 的横屏上实现竖用，首先判断92最大分辨率为1200*1920，可知1200 > 1024，所以满足分辨率要求，那么实现方案即为：lcm driver里面配置width=1024， height=600，ProjectConfig.mk里面配置width=1024， height=600，MTK_LCM_PHYSICAL_ROTATION=90或者270（这里的90/270是根据lcm来配置的，如果实际不知道该选哪个数字，可以都配置一下，哪个可以显示就使用那个）。

2、72JB版本如何在800*480的横屏上面实现竖用，首先判断72最大分辨率为540*960，可知540<800，所以不满足分辨率要求，那么就说明这个800*480的横屏，无法在72平台上面实现横屏竖用。
```

## [FAQ12715] 设置壁纸时，发生 java.lang.IllegalArgumentException: y + height must be <= bitmap.height()

```
当使用第三方应用或Launcher设置壁纸，如果走到WallpaperCropActivity.java (alps\frameworks\base\packages\wallpapercropper\src\com\android\wallpapercropper)
并且错误log如下：
08-23 14:48:20.688 11177 11208 E AndroidRuntime: Caused by: java.lang.IllegalArgumentException: y + height must be <= bitmap.height()
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at android.graphics.Bitmap.createBitmap(Bitmap.java:676)
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at android.graphics.Bitmap.createBitmap(Bitmap.java:640)
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at com.android.wallpapercropper.WallpaperCropActivity$BitmapCropTask.cropBitmap(WallpaperCropActivity.java:638)
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at com.android.wallpapercropper.WallpaperCropActivity$BitmapCropTask.doInBackground(WallpaperCropActivity.java:728)
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at com.android.wallpapercropper.WallpaperCropActivity$BitmapCropTask.doInBackground(WallpaperCropActivity.java:404)
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at android.os.AsyncTask$2.call(AsyncTask.java:288)
08-23 14:48:20.688 11177 11208 E AndroidRuntime:  at java.util.concurrent.FutureTask.run(FutureTask.java:237)
 
则属于这种case
 
[SOLUTION]
请按照如下修改: WallpaperCropActivity.java(alps\frameworks\base\packages\wallpapercropper\src\com\android\wallpapercropper)
     
public boolean cropBitmap() {
 boolean failure = false;
 ...................................
         if (fullSize != null) {
            mCropBounds.left /= scaleDownSampleSize;
            mCropBounds.top /= scaleDownSampleSize;
            mCropBounds.bottom /= scaleDownSampleSize;
            mCropBounds.right /= scaleDownSampleSize;
            mCropBounds.roundOut(roundedTrueCrop);
            
            /*mtk modify start*/
            if(roundedTrueCrop.left < 0) {
               roundedTrueCrop.left = 0;
               }
            if(roundedTrueCrop.top < 0) {
               roundedTrueCrop.top = 0;
               }
            if(roundedTrueCrop.left + roundedTrueCrop.width() > fullSize.getWidth()) {
               roundedTrueCrop.right -= roundedTrueCrop.left + roundedTrueCrop.width() - fullSize.getWidth();
                }
            if(roundedTrueCrop.top + roundedTrueCrop.height() > fullSize.getHeight()) {
                roundedTrueCrop.bottom -= roundedTrueCrop.top + roundedTrueCrop.height() - fullSize.getHeight();
                }
        /*mtk modify end*/
        
          crop = Bitmap.createBitmap(fullSize, roundedTrueCrop.left,
                    roundedTrueCrop.top, roundedTrueCrop.width(),
                    roundedTrueCrop.height());
                }

```

## [FAQ12010] [common]音乐播放器中随机播放（shuffle）功能异常

```
1. 进入音乐播放器，播放一首歌曲；
2. 打开随机播放；
3. 播放另一首歌；
4. 关闭随机播放；
5. 当播放完毕，不会顺序跳到下一首，而是跳到随机播放的歌曲。----》不符合预期.

[SOLUTION]
此问题是由于关闭随机播放后，并没有重新设置下一首待播放歌曲的音源，仍然使用开启随机播放时保存的下一首歌曲。
修改方法如下：
在packages\apps\Music\src\com\android\music\MediaPlaybackService.java中的如下函数：
public void setShuffleMode(int shufflemode)
如下代码之前：mShuffleMode = shufflemode
添加下面代码：
/// M: To make sure the shuffle mode will take effect after change shuffle mode.
/// The nextplayer shoud be reset,so we should set NextPlayer to null.
if (mPlayer.isInitialized()) {
    mPlayer.setNextDataSource(null);
}
```

## [FAQ12555] 手机中setting下CPU使用菜单里的数据信息所代表的含义

```
手机Setting菜单下开发者选项中菜单CPU使用显示信息所代表的含义
[SOLUTION]
如图：在选择了settings-->developer options-->show cpu usage 之后，手机界面会有以下信息显示

绿色代表普通优先级的进程，
蓝色代表低优先级的进程，
红色是系统进程，

这三个数值代表不同间隔下（1，5，15分钟）估算的平均负载（load average）
数字下面显示的就是正在运行的各种进程，包括系统和应用程序的执行序(process)。
一般会选择看后面的两个数字，了解系统是否会有长时间处在高负载的状况，短暂、突发的高负载并不会造成问题，
可忽略不管，数字越小越好，数字较大就表示机器过载或有某种问题
```

## [FAQ11641] 当文件夹路径从n层按back键退回到n-19层的时候，file manager自动退出

```
当文件夹路径从n层按back键退回到n-19层的时候，file manager自动退出，比如在63层按back 键退回到44层的时候，file manager自动退出。

1.FileManager默认设计, FileManager种只记录最多20条操作路径的记录, 如果超出就会把最早加入的记录删除. 贵司可以参考alps/mediatek/packages/apps/FileManager/src/com/mediatek/filemanager/FileInfoManager.java中这部分的代码．
    /** Max history size */
    private static final int MAX_LIST_SIZE = 20;
    private final List<NavigationRecord> mNavigationList = new LinkedList<NavigationRecord>();
    /**
     * This method gets the previous navigation directory path
     * 
     * @return the previous navigation path
     */
    protected NavigationRecord getPrevNavigation() {
        while (!mNavigationList.isEmpty()) {
            NavigationRecord navRecord = mNavigationList.get(mNavigationList.size() - 1);
            removeFromNavigationList();
            String path = navRecord.getRecordPath();
            if (!TextUtils.isEmpty(path)) {
                if (new File(path).exists() || MountPointManager.getInstance().isRootPath(path)) {
                    return navRecord;
                }
            }
        }
        return null;
    }
    /**
     * This method adds a navigationRecord to the navigation history
     * 
     * @param navigationRecord the Record
     */
    protected void addToNavigationList(NavigationRecord navigationRecord) {
        if (mNavigationList.size() <= MAX_LIST_SIZE) {
            mNavigationList.add(navigationRecord);
        } else {
            mNavigationList.remove(0);
            mNavigationList.add(navigationRecord);
        }
    }
    /**
     * This method removes a directory path from the navigation history
     */
    protected void removeFromNavigationList() {
        if (!mNavigationList.isEmpty()) {
            mNavigationList.remove(mNavigationList.size() - 1);
        }
    }
 
 
2.对于20条操作路径的history record, 贵司可以修改，只需要把FileInfo.Manager.java中的MAX_LIST_SIZE设为需要的最大路径记录数。这样修改带来的影响是，file manager APK可能会用到更多的内存，因为List<NavigationRecord> mNavigationList需要记录更多的路径数。
alps/mediatek/packages/apps/FileManager/src/com/mediatek/filemanager/FileInfoManager.java中这部分的代码．
    /** Max history size */
    private static final int MAX_LIST_SIZE = xxx;
```

## [FAQ11051] 文件管理器按大小排序时，只会排序file，不会排序folder

```
这是目前的design，主要考虑的是performance问题。
文件夹的大小是不能直接拿到的，必须遍历文件夹下面的子文件和子文件夹的文件大小加起来做为文件大小，如果一个文件夹下有很多文件和子文件夹，这样迭代拿大小会很费时间，所以文件夹没有按大小排序。
```

## [FAQ11556] 在file manager中重命名MP3的名称，进入Music中发现歌曲仍显示原来的名称

```
进入文件管理中，将一个MP3重命名，重命名完成后进入Music播放器，发现原先被重命名过的MP3显示的仍然是原先的名称，而非重命名后的名称。

[SOLUTION]
歌曲被Mediascanner扫描后，在Music播放器中，显示的是MP3中的ID3 tag，这个是内置在歌曲中的信息，所以即使在file manager中重命名，也不会改变在music中的名称.
note:有些工具，如格式工厂，将歌曲转换为MP3时会破坏tag里面的数据，此时若在file manager中修改，Music就会随着修改而改变。
```

## [FAQ07293] 如何用jar包代替java代码编译

```
1. 先完整编译一遍工程（任意eng/user），然后保存要替换java代码的jar包，在alps/out/target/common/obj/JAVA_LIBRARIES/xxx__intermediates目录下的
classes.jar
javalib.jar
 
2. 请将以下文件保存成java_library_prebuilt.mk，并放在alps/build/core/目录下面：
注意：有11处需要tab键开头（make语法对命令需要tab键开头，但网站不支持tab键），请保存成文件后打开编辑，将11处(以下有标志)重新用tab键处理一遍。
##Writen by guangye.yang@mediatek.com
##
LOCAL_SRC_FILES := 
ifdef LOCAL_IS_HOST_MODULE
  $(error $(LOCAL_PATH): Just for target java library)
endif
LOCAL_MODULE_SUFFIX := $(COMMON_JAVA_PACKAGE_SUFFIX)
LOCAL_MODULE_CLASS := JAVA_LIBRARIES
LOCAL_BUILT_MODULE_STEM := javalib.jar
intermediates.COMMON := $(call local-intermediates-dir,COMMON)
full_classes_jar := $(intermediates.COMMON)/classes.jar
common_javalib.jar := $(intermediates.COMMON)/$(LOCAL_BUILT_MODULE_STEM)
LOCAL_INTERMEDIATE_TARGETS += $(full_classes_jar) $(common_javalib.jar)
ifneq (true,$(WITH_DEXPREOPT))
  LOCAL_DEX_PREOPT :=
else
ifeq (,$(TARGET_BUILD_APPS))
ifndef LOCAL_DEX_PREOPT
LOCAL_DEX_PREOPT := true
endif
endif
endif
ifeq (false,$(LOCAL_DEX_PREOPT))
LOCAL_DEX_PREOPT :=
endif
include $(BUILD_SYSTEM)/base_rules.mk
$(cleantarget): PRIVATE_CLEAN_FILES += $(intermediates.COMMON)
$(full_classes_jar) : $(LOCAL_PATH)/classes.jar | $(ACP)
 $(call copy-file-to-target) #注意：这里必须以tab键开头
$(common_javalib.jar) : $(LOCAL_PATH)/$(LOCAL_BUILT_MODULE_STEM) | $(full_classes_jar) $(ACP)
 $(call copy-file-to-target) #注意：这里必须以tab键开头
ifdef LOCAL_DEX_PREOPT
dexpreopt_boot_jar_module := $(filter $(LOCAL_MODULE),$(DEXPREOPT_BOOT_JARS_MODULES))
ifneq ($(dexpreopt_boot_jar_module),)
dexpreopted_boot_jar := $(DEXPREOPT_BOOT_JAR_DIR_FULL_PATH)/$(dexpreopt_boot_jar_module)_nodex.jar
$(LOCAL_BUILT_MODULE) : $(dexpreopted_boot_jar) | $(ACP)
 $(call copy-file-to-target) #注意：这里必须以tab键开头
dexpreopted_boot_odex := $(DEXPREOPT_BOOT_JAR_DIR_FULL_PATH)/$(dexpreopt_boot_jar_module).odex
built_odex := $(basename $(LOCAL_BUILT_MODULE)).odex
$(built_odex) : $(dexpreopted_boot_odex) | $(ACP)
 $(call copy-file-to-target) #注意：这里必须以tab键开头
else
built_odex := $(basename $(LOCAL_BUILT_MODULE)).odex
$(built_odex): PRIVATE_MODULE := $(LOCAL_MODULE)
$(built_odex) : $(DEXPREOPT_BOOT_ODEXS)
$(built_odex) : $(common_javalib.jar) | $(DEXPREOPT) $(DEXOPT)
 @echo "Dexpreopt Jar: $(PRIVATE_MODULE) ($@)" #注意：这里必须以tab键开头
 $(hide) rm -f $@ #注意：这里必须以tab键开头
 @mkdir -p $(dir $@) #注意：这里必须以tab键开头
 $(call dexpreopt-one-file,$<,$@) #注意：这里必须以tab键开头
$(LOCAL_BUILT_MODULE) : $(common_javalib.jar) | $(ACP) $(AAPT)
 $(call copy-file-to-target) #注意：这里必须以tab键开头
ifneq (nostripping,$(LOCAL_DEX_PREOPT))
 $(call dexpreopt-remove-classes.dex,$@) #注意：这里必须以tab键开头
endif
endif
else
$(LOCAL_BUILT_MODULE) : $(common_javalib.jar) | $(ACP)
 $(call copy-file-to-target) #注意：这里必须以tab键开头
endif
 
3. 在alps/build/core/config.mk里添加：
BUILD_JAVA_LIBRARY_PREBUILT:= $(BUILD_SYSTEM)/java_library_prebuilt.mk
 
4. 删除对应的java代码及对应的Android.mk，然后在当前目录创建新的Android.mk，并复制第1步备份的2只文件到Android.mk旁边(注意，文件名不能修改，否则无法识别!!!)，新的Android.mk编写如下：
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := services
LOCAL_MODULE_PATH := $(TARGET_OUT_JAVA_LIBRARIES)
include $(BUILD_JAVA_LIBRARY_PREBUILT)
 
5. 重新完整的编译工程(任意eng/user)，下载查看效果
 
6. 重要提示，由于第1步保存的classes.jar是没有经过proguard，流出去很容易被反编译，请自行做proguard，但是请不要把接口proguard，否则编译失败！
```

## [FAQ11348] 共享ccache的缓存

```
1. android自带的ccache版本(2.4版本)过低，是无法支持以上的功能的，需要使用新版ccache。
2. 最新的ccache请到http://ccache.samba.org/download.html下载
3. 下载解压之后，在linux底下进入ccache目录，运行:
  ./configure
  ./make
  ./strip --strip-all ccache
4. 之后就可以在ccache目录下看到ccache文件，拿这个文件替换掉codebase里的alps/prebuilts/misc/linux-x86/ccache/ccache文件。
5. 请重复执行第4步将所有codebase的ccache替换掉（保证所有使用ccache缓存的ccache都是最新版本，因为不同版本的ccache生成的缓存无法共享！）
6. 所有需要共享的用户请添加以下环境变量：
  export CCACHE_DIR=<ccache缓存路径>
  export CACHE_UMASK=002
  unset CCACHE_HARDLINK
  可以将以上添加到$HOME/.bashrc，保证打开的终端都已经加载以上的环境变量。其中<ccache缓存路径>请替换为指定的绝对路径(必须是需要共享的用户都能读写的)。比如：/proj/.ccache
  注意：由于多人同时写ccache缓存可能引起IO带宽不够反而降低效率，强烈建议服务器编译可以按第6步配置，但是其他共享用户最好在第6步的基础上增加export CCACHE_READONLY=1仅只读缓存内容。
7. 设置好第6步后，重新登入终端使环境变量生效，然后创建<ccache缓存路径>，设置<ccache缓存路径>的共享权限，在终端输入：find $CCACHE_DIR -type d | xargs chmod g+s
8. 完成前面的步骤后，就可以开始共享使用了，注意ccache空间要足够大，否则反而拉长编译时间。如果遇到问题可以参考ccache的使用说明：http://ccache.samba.org/manual.html
```

## [FAQ05353] 如何添加第3方lib库到kernel中

```
注意：只能将lib库放在kernel编译到的地方，如下：
alps/kernel/
alps/mediatek/custom/common/kernel/
alps/mediatek/custom/$platform/kernel/
alps/mediatek/custom/$proj/kernel/
alps/mediatek/kernel/
alps/mediatek/platform/$platform/kernel/core/
alps/mediatek/platform/$platform/kernel/drivers/
假设第3方库名称为test.a
(1). 如果存放的目录存在Makefile，那么只需在该Makefile最后添加：
    obj-y += test.a
    然后将test.a文件复制到该目录下，
    重新命名为test.a_shipped，目的是防止clean kernel阶段把该库给清除掉！
    重新编译kernel即可。
(2). 如果存放的目录不存在Makefile，比如在alps/mediatek/custom/目录下的kernel目录都没有Makefile，这时需要自行添加一个Makefile，内容和第1种方法差不多：
    obj-y := xxx.o yyy.o test.a
    以上表示将xxx.c/yyy.c和test.a编译到kernel
    然后将test.a文件复制到该目录下并重新命名为test.a_shipped
    重新编译kernel即可。
注意：alps/mediatek/custom/common/kernel/touchpanel/xxx目录下的文件会和alps/mediatek/custom/common/kernel/touchpanel/src目录合并，obj-y要将两个目录下的obj全部加入才行，否则编译失败。也可以用以下Makefile，自动将所有obj加入obj-y，省却麻烦。其他目录如有类似的情形一样处理。
    添加的Makefile(将所有*.c变为*.o并加入obj-y)：
    include $(MTK_PATH_BUILD)/common.mk
    path := $(if $(filter yes,$(KBUILD_OUTPUT_SUPPORT)),$(srctree)/$(obj),$(obj))
    obj-y := $(patsubst %.c,%.o,$(subst $(path)/,,$(call wildcard2,$(path)/*.c)))
    obj-y += test.a
 
说明：对于kernel的Makefile编写规则说明，可以到网络搜索相关材料参考，比如obj-y表示要编译到kernel，而obj-m表示要编译成module，obj-n或obj-表示不编译
```

## [FAQ11786] 为何工厂模式下无法adb 无法重启机器 ？

```
KK 以后 Google 将关机/重启的最后转移到了init 进程上执行。 其他Process 通过system property sys.powerctl 通知init 执行。
sys.powerctl 的配置在init.rc 当中，可以参考
on property:sys.powerctl=*
   powerctl ${sys.powerctl}
   
然后执行system/core/init/builtins.c#do_powerctl 函数，call android_reboot 重启或者关机。
为何工厂模式下无法adb reboot ? 正常情况下adb reboot 可以重启， 其关键就是因为mediatek/config/{platform}factory_init.rc 中没有定义
on property:sys.powerctl=*
   powerctl ${sys.powerctl}
   
如果要添加此功能，只有在factory_init.rc 中添加这两行即可
```

## [FAQ10430] 在Native & App 层如何监测文件的更新

```
Linux内核从2.6.13开始引入inotify 机制，它可以高效地实时跟踪Linux文件系统的变化。
它的典型的API 包括：
inotify_init ： creates an inotify instance and returns a file descriptor referring to the inotify instance. 
inotify_add_watch：  manipulates the "watch list" associated with an inotify instance. 
inotify_rm_watch： removes an item from an inotify watch list.
read：to determine what events have occurred, an application read(2)s from the inotify file descriptor.
close：close file monitor
 
通常我们会利用epoll 机制和inotify 机制结合来进行file monitor, 即利用epoll 来监控inotify_init的fd.
 
在Android 中，已经有完整的实现，在java 层可以直接使用android.os.FileObserver, 如果在native 层，也可以参阅它结合epoll & inotify的 实现：frameworks/base/core/jni/android_util_FileObserver.cpp
```

## [FAQ09934] 相机prevew时候出现水印问题

```
使用DDMS截图和layer dump工具均能发现有有水印图片出现。
 
比对有水印和没有水印的layer dump log，发现出问题的时候的SurfaceView：

+ Layer 0x42505008 (SurfaceView)

  activeBuffer=[ 720x1280: 736,  4],  colorformat 是RGB565.

而正常时候的SurfaceView：

+ Layer 0x42505789 (SurfaceView)

  activeBuffer=[ 720x1280: 736,  5],  colorformat 是RGB888.

review修改camera ap部分发现在preview时候设定的color format就是RGB565, 这里导致颜色丢失而引发水印现象。需要做如下修改：

1. 在GLRootView.java中：
public GLRootView(Context context, AttributeSet attrs) { ......
        if(USE_RGB888)       
            getHolder().setFormat(PixelFormat.RGB_888); 
        else
            getHolder().setFormat(PixelFormat.RGB_565); 
}

在GalleryEGLConfigChooser.java中：增加RGB888的配置：

private final int mConfigSpec565[] = new int[] {
    EGL10.EGL_RED_SIZE, 5,
    EGL10.EGL_GREEN_SIZE, 6,
    EGL10.EGL_BLUE_SIZE, 5,
    EGL10.EGL_ALPHA_SIZE, 0,
    EGL10.EGL_NONE
}; 
private final int mConfigSpec888[] = new int[] {
    EGL10.EGL_RED_SIZE, 8,
    EGL10.EGL_GREEN_SIZE, 8,
    EGL10.EGL_BLUE_SIZE, 8,
    EGL10.EGL_ALPHA_SIZE, 0,
    EGL10.EGL_NONE
}; 

private boolean USE_RGB888 = true;
public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
int mConfigSpec[] = (USE_RGB888 == true)? mConfigSpec888 : mConfigSpec565;
```

## [FAQ06687] 【MT6572/89】【JB/JB2】如何读取GPU版本信息？

```
可以参考OpenGL相关函数调用

请使用eglQueryString() 或是 glGetString()函数

具体用法请参考：
http://www.khronos.org/registry/egl/sdk/docs/man/xhtml/eglQueryString.html
http://www.opengl.org/sdk/docs/man/xhtml/glGetString.xml

【Example】

调用libEGL.so,初始化EGL；
eglGetDisplay(EGL_DEFAULT_DISPLAY);
eglInitialize(display, NULL, NULL);
eglGetConfigs(display, NULL, 0, &numConfigs);
selectConfigForNativeWindow(display, attribs, mNativeWindow.get(), &config);
获取EGL相关参数；
================================================================
LOGI("EGL informations:");
LOGI("# of configs : %d", numConfigs);
LOGI("vendor    : %s", eglQueryString(display, EGL_VENDOR));
LOGI("version   : %s", eglQueryString(display, EGL_VERSION));
LOGI("extensions: %s", eglQueryString(display, EGL_EXTENSIONS));
LOGI("Client API: %s", eglQueryString(display, EGL_CLIENT_APIS)?:"Not Supported");
LOGI("EGLSurface: %d-%d-%d-%d, config=%p", r, g, b, a, config);
=====================================================================
获取GPU相关参数；
LOGI("OpenGL informations:");
LOGI("vendor    : %s", glGetString(GL_VENDOR));
LOGI("renderer  : %s", glGetString(GL_RENDERER));
LOGI("version   : %s", glGetString(GL_VERSION));
LOGI("extensions: %s", glGetString(GL_EXTENSIONS);

打印出来的信息如下：

EGL informations:
# of configs : 22
vendor    : Android
version   : 1.4 Android META-EGL
extensions: EGL_KHR_image EGL_KHR_image_base EGL_KHR_gl_texture_2D_image EGL_KHR_gl_texture_cubemap_image EGL_KHR_gl_renderbuffer_image EGL_KHR_fence_sync EGL_ANDROID_image_native_buffer
Client API: OpenGL_ES
EGLSurface: 8-8-8-8, config=0x2
OpenGL informations:
vendor    : Imagination Technologies
renderer  : PowerVR SGX 544MP
version   : OpenGL ES-CM 1.1
```

## [FAQ07632] 如何在编译的时候，控制删除apk不用的资源?

```
1. 修改alps/meidatek/config/xxx/ProjectConfig.mk下的MTK_PRODUCT_LOCALS,去掉不用的资源，比如屏幕密度或语言等.
2. nodpi和mipmap的相关resource因其特殊作用会被保留

PS:
nodpi: resource不会根据device density做scaling
mipmap:提供与device dpi不同的resource
```

## [FAQ10320] 如何判断网络更新时间是通过NITZ还是NTP方式的？

```
设置一个错误的时区，查看时区是否有被更新正确，若时区有被更新，则说明GSM网路有送NITZ消息上来;  若只有时间更新，则还无法区分，可以再通过对log进一步的分析才能区分，下面介绍如何通过log来区分:
1： 用wireshark打开tcp dump log
2： 用NTP过滤，如果在该时间点左右，有搜到相关的信息，则说明是通过NTP请求的
```

## [FAQ09600] 如何确认是哪个apk用SNTP来更新时间

```
这个需要自行添加代码来确认的，如下：

修改文件： alps/frameworks/base/core/java/android/net/SntpClient.java
修改步骤：
1：import java.lang.RuntimeException;

2：在requestTime()方法里加一段代码
RuntimeException re = new RuntimeException();
re.fillInStackTrace();
re.printStackTrace();
```

## [FAQ12350] 如何利用adb命令查看mtklogger的状态

```
（1）查看mtklogger settings.
adb command: cat /data/data/com.mediatek.mtklogger/shared_prefs/com.mediatek.mtklogger_preferences.xml

输出结果如下：
<?xml version='1.0' encoding='utf-8' standalone='yes' ?>
<map>
<string name="log_storage_location">2</string>    --> log path: 1 for phone storage, 2 for sd card
<boolean name="taglog_enable" value="true" />      -->  tag log enable or not
<boolean name="modemlog_switch" value="true" />  --> modemlog enable or not
<boolean name="exceptionreporter_enable" value="true" />  --> exception reporter enable or not
<boolean name="mobilelog_kernellog" value="true" />  --> kernel log enbale  or not
<string name="mobilelog_total_logsize">600</string>  --> mobile log total size
<boolean name="mobilelog_androidlog" value="true" />  -->android log enable or not
<string name="modemlog_logsize">600</string>  --> modem log size
<string name="networklog_logsize">200</string>  --> network log size
<boolean name="modemlog_autostart" value="false" /> --> modem log auto start or not
<boolean name="networklog_autostart" value="false" /> --> network log auto start or not
<string name="mobilelog_logsize">300</string>  --> mobile log size 
<boolean name="mobilelog_switch_bak" value="true" /> --> not used
<boolean name="networklog_switch" value="true" />  --> network log enable or not
<boolean name="mobilelog_autostart" value="false" /> --> mobile log auto start or not
<boolean name="mobilelog_switch" value="true" />  --> mobile log enable or not
<boolean name="mobilelog_btlog" value="true" />  --> bt log enable or not
<boolean name="ui_debug_mode_enable" value="false" /> --> UI Debug Mode enable or not
</map>

（2）查询mobile loggger的运行状态。
adb command:  getprop debug.MB.running  --> 如果为0, 表明mobile logger stopped; 如果为1，表明mobile logger recording。
adb command: getprop debug.MB.realpath  -->指明当前mobile log录制的路径。

（3）查询modem logger的运行状态。
adb command:  getprop debug.mdlogger.Running  --> 如果为0, 表明modem logger stopped; 如果为1，表明modem logger recording。

（4）查询network logger的运行状态。
adb command:  getprop debug.mtklog.netlog.Running  --> 如果为0, 表明network logger stopped; 如果为1，表明network logger recording。
adb command: getprop debug.netlog.writtingpath  -->指明当前network log录制的路径。
```

## [FAQ12535] 选择重启，可以完整播放完关机动画

```
敝司Default设计，关机过程会有一个delayForPlayAnimation，但是重启（除了恢复出产设置）不会，由于重启本身就牵涉到时间上的连续行，不会有任何delay。
修改方案：
贵司只需要在shutdownThread.java的
public static void rebootOrShutdown(boolean reboot, String reason) {
里面将如下if判断去掉：
if ((reason != null) && reason.equals("recovery")) {
    delayForPlayAnimation();
}
 
只保留
delayForPlayAnimation();
只要reboot都做delay
```

## [FAQ06257] Flash上新建分区的大小限定

```
目前的分区类型有如下两种：Rawdata和文件系统，文件系统的类型与Flash类型相关，Nand Flash上的文件系统为Yaffs2；Emmc上的文件系统为Ext4。
 
Rawdata：至少1*Block Size;
Yaffs2: 至少9*Block Size;
Ext4:至少5MB
 
目前常见的Nand Flash上，Block Size一般为128KB和256KB。
 
另外需要注意一点，新建分区的start address和size必须是Block align的。
```

## [FAQ07180] [Audio App]如何修改Music Player中EQ参数？

```
Google原始EQ参数定义在：
\frameworks\av\media\libeffects\lvm\wrapper\Bundle\EffectBundle.h
只需修改其中的定义即可
```

## [FAQ05362] 如何采用第三方带密码的密钥进行APK签名

```
修改build\tools\signapk\signapk.java，将其中函数 readPassword 中读取密码的code修改为从固定位置读取密码(比如从文件读取)，然后重新编译build\tools\signapk\，将生成的新的signapk.jar覆盖vendor\mediatek\[project]\artifacts\out\host\linux-x86\framework\signapk.jar，重新编译即可
 
PS：将该函数(readPassword)中try...catch语句删除，修改为从文件读取，或者直接return 贵司的密码即可
```

## [FAQ08222] 一个干净的Codebase，在没有new的前提下，如何单独编译某个Android模块？

```
可以用这个命令: ./makeMtk <project> r dr <module_name>
使用前提：module_name必须为带有Android.mk的Android模块，不能是preloader/lk/kernel/ko
```

## [FAQ08697] JB5版本中，输入adb shell之后，如何显示shell@android，而不是目前默认的shell@project_name

```
修改external/mksh/mkshrc
 
From：

: ${TERM:=vt100} ${HOME:=/data} ${MKSH:=/system/bin/sh} ${HOSTNAME:=$(getprop ro.product.device)}
: ${SHELL:=$MKSH} ${USER:=$(typeset x=$(id); x=${x#*\(}; print -r -- ${x%%\)*})} ${HOSTNAME:=android}
 
To:

: ${TERM:=vt100} ${HOME:=/data} ${MKSH:=/system/bin/sh} ${HOSTNAME:=android}
: ${SHELL:=$MKSH} ${USER:=$(typeset x=$(id); x=${x#*\(}; print -r -- ${x%%\)*})} ${HOSTNAME:=android}
```

## [FAQ12481] Recovery mode在cache/recovery目录下新建一支文件，重启后，新建文件消失了

```
1、在recovery.cpp文件的最后新建一支文件 /cache/recovery/wetest；并写入内容：welcome to recovery mode！
2、编译版本、烧写手机，开机后，进行恢复出厂设置；等手机进入自动重启状，并在弹出开机向导前，通过命令进入到/cache/recovery/，有wetest文件，内容也正确；但是等开机向导走完之后，再进入/cache/recovery查看，生成的文件就消失了。
[SOLUTION]
原因是：
开机完成后，在frameworks/base/core/java/android/os/recoverysystem.java里面会去判断/cache/recovery目录下面的文件是不是以"last_"开头的，如若不是，就会delete掉，目的是让该目录只存储recovery mode指定的几支文件。
如果有需求一定要在该目录下新建文件，请务必在您的文件名前加上前缀"last_"，以避免在重启后被删除。
```

## [FAQ10759] MOTA升级成功后想保留OTA升级包该怎么办？

```
MTK目前的默认设计是： MOTA升级成功后默认删除OTA包update.zip; 如果不想删除怎么办？
[SOLUTION]
修改文件recovery.cpp 如下处：

#endif
    fprintf(stdout, "write result : remove_mota_file\n");
    if (update_package) {
        remove_mota_file(update_package);
    }
把 if 语句及其下一行code注释掉即可！
```

## [FAQ12215] KK版本输入表情符号的图片在什么地方,如何删除其中的一些表情

```
1.KK版本中这些表情符号不是图片，都是从一个表情字库中获取直接显示，如果没有显示应该是字库出现问题。这个字库是alps\external\noto-fonts目录下的NotoColorEmoji.ttf。如果表情不显示或者显示不全因如何解决，请确认这个字库是否在手机中，查看这个字库是否完整。
2.如果要删除其中的一些表情，只要在packages\inputmethods\LatinIME\java\res\values-v19下的emoji-categories.xml文件中把这些表情对应的item去掉即可。
```

## [FAQ11124] 确定哪个APK在偷流量的方法

```
手机在平时的待机中，经常会看到用户并没有主动发起访问网络的操作
但是查看数据流量统计，还是会看到有增长
这个时候就需要去定位当前到底是哪些APK当前有在偷跑流量
[SOLUTION]
1. 从复现问题的mobile log包中的main log里，找对应的System.out: [socket][**] connenet这样的发起socket 连接的log
并记住黄色标记的那个数字，这个数字就是访问网络的那个APK的进程号:
02-26 09:56:39.096   742   840 I System.out: [socket][4] connection /189.247.134.104:443;LocalPort=50607(20000)

2. mobile log包中的events log里，搜索步骤一中黄色标记的那个数字的相关log
其中tag为am_proc_start代表的就是AMS启动该进程的地方，方括号里的第四个参数代表的就是742这个进程的APK的包名，从包名就可以定位到当前这个第三方的APK了。
02-25 09:56:30.948   477   701 I am_proc_start: [0,742,10012,com.google.process.location,service,com.google.android.location/.NetworkLocationService]
```

## [FAQ02951] wifi Rssi与信号等级的修改。

```
Android中，当RSSI <= -100时，信号level 为0, 当RSSI >=-55为满格信号,level为4，每个level之间的Rssi的跳变为15。
[SOLUTION]
如果想要修改Rssi与信号等级的对应关系，请直接将
WifiManager.java中的calculateSignalLevel()函数中将level与RSSI之间的对应关系修改即可。
```

## [FAQ03557] [Settings]修改蓝牙设备的默认名称

```
在JB以前的版本：
修改frameworks\base\core\jni\Android_bluetooth_common.h
将BTMTK_ANDROID_DEFAULT_LOCAL_NAME值改掉，注意此处有引号。
#define BTMTK_ANDROID_DEFAULT_LOCAL_NAME "ANDROID BT"
 
在JB上的版本：
可以通过修改/mediatek/config/common/custom.conf里面的 bluetooth.HostName = ANDROID BT
来实现修改名称的目的。
```

## [FAQ12128] 如何进入安全模式

```
长按 power 键关机菜单再长按就可以进入。
开机按 power + volume down 也可以进入。
开机检测是否要进入 safe mode，详见 WindowManagerService.java 中的 detectSafeMode()。
```

## [FAQ05169] [Storage]如何从手机上readback任意分区的image回来？

```
以读回userdata分区为例来说明详细的步骤：
1. 查看MT65XX_Android_scatter_emmc.txt中USRDATA  和其下一个Partition的StartAddress, 如URSDATA =0x425e4000，FAT=0x626e4000
2. 计算出Userdata 的Size =0x626e4000-0x425e4000 = 0x20100000
note:此方法不适用于最后一个有效分区。例：FAT分区或者当没有FAT分区时的userdata分区。最后一个分区size可参考cat /proc/dumchar_inof的值。
3. 使用flash tool 中的Read back 功能添加一个读取image项，并双击设置Start Address 和 Length .其中start address写入 0x425e4000，length写入 0x20100000。
4. 单击 Read back ，并连接手机读取data数据。
5. 如Image 读出来之后为EXT4 的image 格式，请参考《FAQ04247 如何解压编译生成的system/data等带ext4文件系统的image 》来对其进行分析。
```

## [FAQ11663] KK版本使用JAVA接口修改WIFI MAC地址后，打开WIFI，MAC地址不变

```
[FAQ06283][Legacy Wi-Fi]APK读写WIFI MACaddress方法
参数FAQ接口可以使用对NVRAM进行读写，以前版本读写后，重新打开WIFI，
WIFI高级选项中会显示重新写入的MAC地址，但是KK版本无效，需要重新开机

[SOLUTION]
KK版本，WIFI高级菜单新增了随时扫描选项，如果勾选了，开关WIFI
实际并没有真正关闭WIFI功能，MAC地址还是没有改变，需要重新开机。
需要去除随时扫描选项，打开WIFI，MAC才会重新从NVRAM读取
```

## [FAQ06283] [Legacy Wi-Fi]APK读写WIFI MAC address方法

```
MAC address是保存在NVRAM里面的，APK也可以通过调用接口进行读写。
alps/mediatek/packages/apps/cdsinfo/src/com/mediatek/connectivity/CdsWifiInfoActivity.java文件
updateMacAddr中有读写MAC address的DEMO
```

## [FAQ12018] 待机，主菜单及锁屏界面背景在设置墙纸是否可以分开设置

```
android 并不支持此功能,
如果要做到类似的效果, 应该可以采取如下方案
1: 壁纸仍然只有一个,在 idle 界面看到的是壁纸
2: 至于锁屏壁纸, 可以单独去给锁屏设置 background 图片, 在锁屏界面,看到的是它的 background,而非壁纸.锁屏的 view 对应的文件是 KeyguardHostView.java, 即需要给 KeyguardHostView 设置背景图片.
3: 主菜单界面同样采用背景图片的方式, 主菜单的 view 对应的文件是 AppsCustomizeTabHost.java, 即需要给 AppsCustomizeTabHost 设置背景图片
 
因背景图片会占用较多内存, 建议不宜过多设置.
```

## [FAQ11064] 新增Keyguard layout资源放在哪个目录？

```
需要在锁屏中新增一个UI相关的自定义layout，编译OK，但运行时报错，举例如下:
AndroidRuntime: android.content.res.Resources$NotFoundException: Resource ID #0x1090033
如何去解决呢？
[SOLUTION]
1. log中报Resource ID #0x1090033找不到，那这个resource ID实际是0x01090033，注意要在0x后面加一个0.
   然后在out\target\common\R\com\android\internal\R.java中找到0x01090033代表的资源名，如果该资源是一个layout，则参考第2步。
 
2. 确认layout文件放置路径正确，新增锁屏layout资源需要同时支持横屏和竖屏。有两种添加方法：
   1）添加在frameworks\base\core\res\res\layout\路径下。
   2）添加在frameworks\base\core\res\res\layout-land 和 frameworks\base\core\res\res\layout-port两个路径下。
```

## [FAQ10458] 如何使锁屏界面的日期按照设置中的日期格式显示

```
google default设计下，锁屏上日期是“EEE, MMMM d”固定格式显示。如果需要根据设置--》日期和时间--》选择日期格式来改变，可参考这个修改方法。
 
[SOLUTION]
1. default设计，从KeyguardStatusView.java中refreshDate()中可以看到mDateFormatString是一个固定的常量，所以keyguard日期格式是固定的。
2. 如果要修改的话，可以在KeyguardStatusView.java中仿照ClockView.java写一个FormatChangeObserver类, 然后在updateTime()方法中根据setting中日期格式化字串更新日期。
3. 获取setting中设置的日期格式化字串方式如下：
java.text.DateFormat shortDateFormat = DateFormat.getDateFormat(mContext);
CharSequence dateValue = shortDateFormat.format(details.date);
```

## [FAQ08686] 怎样添加或者修改一个kconfig ?

```
第一种方式：
a、在Kconfig文件添加/修改一个Kconfig 选项 ：
    在 mediatek/platform/<platform>/kernel/Kconfig/*  配置一个Kconfig选项，
    例如：config MTK_TEST
            bool  "test item"
            default y
            ---help---
              for test
b、为添加的Kconfig 选项设置其值：
    在 mediatek/config/<platform>/autoconfig/kconifg/platform or mediatek/config/<project>/autoconfig/kconifg/project添加kconfig选项的值，
    例如：CONFIG_MTK_TEST=y  表示build into kernel
    
    然后就可以在文件中使用该选项：例，在mediatek/kernel/drivers/test/Makefile 中
    obj - $(CONFIG_MTK_TEST) +=test.o
 
第二种方式：
    使用make menuconfig ，来配置kernel的选项

a、首先通过下面的方式进入menuconfig, 在project 下输入：
    cd kernel
    TARGET_PRODUCT=<project> make menuconfig
    在弹出的窗口后，enter  < / > 进入查找窗口，输入要查找的kernel feature名称
    查到该feature后，选择开启或者关闭该feature， 保存，退出menuconfig
 
b、 完成上述配置后，将.config复制到mediatek/config/$project/autoconfig/kconfig/目录下并重命名为project
    然后进行编译kernel
```

## [FAQ08753] 如何查看某个宏定义的含义

```
请参 http://dcc.mediatek.com上的Feature_Option_Info_Table_n.xlsx，查看最新的xls即可。
```

## [FAQ09190] apk里的so库如何摆放

```
在android APK的根目录有一个libs文件夹，此文件夹下包含了armeabi 和armeabi-v7a两个文件夹，我们的c代码编译成的本地库（各种.so）就会放在这两个文件夹其中的一个。
那armeabi-v7a 与armeabi有什么区别，该将so库放哪个文件夹？

[KEYWORD]
armeabi
lib库
apk

[SOLUTION]
armeabi和armeabi-v7a是表示cpu的类型，我们知道一般的手机或平板都是用arm的cpu，不同的cpu的特性不一样，
armeabi     就是针对普通的或旧的arm cpu
armeabi-v7a 是针对有浮点运算或高级扩展功能的arm cpu
这两个目录都可以放，具体要看开发的apk的定位，如果想将apk发布到网络上供不同的机器使用，那么建议用armeabi（兼容性好），如果只是自己平台上用，则可以用armeabi-v7a
```

## [FAQ03781] 如何分析编译到某个阶段卡死的问题

```
可能的原因：
1. 修改或添加编译代码导致
2. 编译环境没按SOP安装
3. 其他软件引起冲突

分析方法：
1. 首先修改为单线程编译(-j1)
    1)MTK代码编译为多线程编译(加快编译速度，但是增加系统负担，增加memory消耗)
    2)在mediatek/build/makemtk.mk里
        CPUCORES := $(shell cat /proc/cpuinfo|grep processor|wc -l)
        MAKEJOBS := -j$(CPUCORES)
        修改为
        MAKEJOBS := -j1
2. 然后在编译卡死时用ps -u查看编译进程，看卡死在哪个进程
```

## [FAQ03782] 如何添加一个apk使模拟器和真机都编译进去

```
1. 编译模拟器时，会将以下文件中的PRODUCT_PACKAGES定义的apk都编译进去
build/target/product/banyan_addon.mk
build/target/product/sdk.mk
sdk/build/product_sdk.mk
development/build/product_sdk.mk
build/target/product/core.mk

2. 编译真机版本是，会将以下文件中的PRODUCT_PACKAGES定义的apk都编译进去
build/target/product/$project.mk
build/target/product/common.mk
build/target/product/telephony.mk
build/target/product/core.mk

所以如果想添加一个apk使模拟器和真机都编译进去的话，就必须添加到core.mk（模拟器和真机都会包含）
```

## [FAQ03719] 如何修改apk版本号(格式类似为4.0.4-eng.root.1235877699)

```
在apk中显示类似版本号+编译信息(比如4.0.4-eng.xiaoming.1235877699)，该信息会将你当时编译的用户名一起放进去了(比如前面的信息里的用户名为xiaoming), 最后一串数字是编译时间(以秒为单位)
 
[KEYWORD]
apk
版本号
aapt
 
[SOLUTION]
这个显示的来源是apk里的AndroidManifest.xml里的versionName, 但是该字段在编译前的AndroidManifest.xml没有，只有在apk里的AndroidManifest.xml才有。
对比AndroidManifest.xml编译前后的状况
 
这个变化是在打包apk时添加的，在build/core/definitions.mk里的create-resource-java-files和add-assets-to-package用aapt打包时有传--version-name的参数导致
define create-resource-java-files
$(hide) $(AAPT) package $(PRIVATE_AAPT_FLAGS) -m \
    ......
    $(if $(filter --version-code,$(PRIVATE_AAPT_FLAGS)),,$(addprefix --version-code , $(PLATFORM_SDK_VERSION))) \
    $(if $(filter --version-name,$(PRIVATE_AAPT_FLAGS)),,$(addprefix --version-name , $(PLATFORM_VERSION)-$(BUILD_NUMBER))) \
    ......
endef
define add-assets-to-package
$(hide) $(AAPT) package -u $(PRIVATE_AAPT_FLAGS) \
    ......
    $(if $(filter --version-code,$(PRIVATE_AAPT_FLAGS)),,$(addprefix --version-code , $(PLATFORM_SDK_VERSION))) \
    $(if $(filter --version-name,$(PRIVATE_AAPT_FLAGS)),,$(addprefix --version-name , $(PLATFORM_VERSION)-$(BUILD_NUMBER))) \
    ......
endef
 
如果需要修改，则可以直接修改$(PLATFORM_VERSION)-$(BUILD_NUMBER)即可
```

## [FAQ03732] 如何压缩代码并共享

```
解压代码包后，里面有很多linux的软链接并且编译后也会生成很多软链接，如何将代码复制给其他人，并且也可以正常编译很重要。
禁止以下方法压缩软件：
1. 不能在windows下用压缩软件压缩或用复制粘贴的方式
2. 不能再linux下用右键压缩的方法压缩代码
以上方式都是使链接失效
 
[SOLUTION]
正确的方法是：tar czfv <project_name>.tar.gz alps
其中<project_name>为任意名字，最好是项目+版本的命名方式
alps为源代码目录，已当前要压缩的目录为准
```

## [FAQ03534] [Recovery]如何给OTA升级包重新签章

```
某些OTA升级包需要重新签名
 
[SOLUTION]
 
在alps目录下，如下command做签章动作：
java -Xmx1024m -jar out/host/linux-x86/framework/signapk.jar -w build/target/product/security/releasekey.x509.pem build/target/product/security/releasekey.pk8 ~/NEWOTA/update.zip ~/NEWOTA/update_with_new_key.zip
 
NOTE:releasekey为您要使用的新签章。
```

## [FAQ03437] [Recovery]special factory reset preserve or restore apk to /data/app

```
首先您需在DCC上下载文档《Android SD upgrade application note》来了解special factory reset。
 
一、factory reset preserve /data/app/*.apk
以Notification1.apk、Notification2.apk、Notification3.apk为例
 
详细步骤：
1、在alps\mediatek\config\project_name\ProjectConfig.mk中找到MTK_SPECIAL_FACTORY_RESET，把它设为yes；
2、在alps\vendor\mediatek\project_name\artifacts\out\target\product\project_name\下创建data目录，然后在data目录下创建app目录
3、将Notification1.apk、Notification2.apk、Notification3.apk放入alps\vendor\mediatek\project_name\artifacts\out\target\product\project_name\data\app目录中
4、在vendor\mediatek\project_name\artifacts\out\target\product\project_name\data\app目录下创建 .keep_list 文件，.keep_list 文件的内容为：
/data/app/Notification1.apk
/data/app/Notification2.apk
/data/app/Notification3.apk
 
PS:多个apk的话，每个apk占一行.
5. 重新new
 
二、factory reset restore /system/somewhere/*.apk to /data/app
 
详细步骤：
1、在alps\mediatek\config\project_name\ProjectConfig.mk中找到MTK_SPECIAL_FACTORY_RESET，把它设为yes；
2、在alps\vendor\mediatek\project_name\artifacts\out\target\product\project_name\system下创建appbackup目录
3、将Notification1.apk、Notification2.apk、Notification3.apk放入alps\vendor\mediatek\project_name\artifacts\out\target\product\project_name\system\appbackup目录中
4、在vendor\mediatek\project_name\artifacts\out\target\product\project_name\system\app路径下创建.restore_list文件，.restore_list文件的内容为:
 
/system/appbackup/Notification1.apk
/system/appbackup/Notification2.apk
/system/appbackup/Notification3.apk
 
PS:多个apk的话，每个apk占一行.
5. 重新new
```

## [FAQ08335] 如何在Latin 输入法中增加一种语言的词库

```
ICS的版本没有任何语言的词库，要添加词库，请用下面的方法：

生成字库方法：

1 准备好sample.xml文件

   注意格式与packages/inputmethods/latinIME/dictionaries/sample.xml相同

2 把/out/host/linux-x86/framework/makedict.jar文件和自己写的 sample.xml 放在同一目录下。在windows 命令行中运行如下指令：

    java -jar makedict .jar sample.xml main.dict   （必须已安装JDK）

（其中是以sample.xml 作为例子）

会在当前目录下生成文件main.dict

3 将生成的main.dict文件拷贝到对应语言的路径下，如英文packages\inputmethods\LatinIME\java\res\raw下

4.然后在packages\inputmethods\LatinIME\java\res\xml\spellchecker.xml文件中查看是否已经有该语言的subtype，如果没有则添加对应语言的subtype。

5.然后重编latin 输入法。

JB版本在 /packages/inputmethods/LatinIME/java/res/raw/目录下已经有英语等一些语言的单词库，要添加

自己的词库，请用下面的方法：

1 准备好sample.xml文件
   注意格式与packages/inputmethods/latinIME/dictionaries/sample.xml相同
2 把/out/host/linux-x86/framework/dicttool_aosp.jar 文件和自己写的 sample.xml 放在同一目录下。在windows 命令行中运行如下指令：
    java -jar dicttool_aosp.jar makedict -s sample.xml -d main_xx.dict （其中的xx代表语言码，例如英语为 en, 俄文为 ru，
    要生成英文词库就是 java -jar dicttool_aosp.jar makedict -s sample.xml -d main_en.dict）
    （必须已安装JDK,版本需高于build 1.6.0_39-b04，否则可能会报某些方法找不到的错误）
会在当前目录下生成文件main_xx.dict 
3 将生成的main_xx.dict文件拷贝到packages\inputmethods\LatinIME\java\res\raw下
4.然后在packages\inputmethods\LatinIME\java\res\xml\spellchecker.xml文件中查看是否已经有该语言的subtype，如果没有则添加对应语言的subtype。
5.然后重编latin 输入法。
KK版本编译dicttool_aosp.jar的方法略有不同，具体如下：

 mk   xxx  mma packages/inputmethods/LatinIME/tools/
xxx为贵司的project名称， 这样就会在
out/host/linux-x86/framework/中生成dicttool_aosp.jar。
KK 版本在 /packages/inputmethods/LatinIME/java/res/raw/目录下已经有英语等一些语言的单词库，要添加
自己的词库，请用下面的方法：
1 准备好sample.combinded文件
   注意格式与packages/inputmethods/latinIME/dictionaries/sample.combinded相同,
   同时packages/inputmethods/latinIME/dictionaries/下一句有很多.combinded.gz的文件，把这些文件解压就是
   .combinded文件了。
2 把/out/host/linux-x86/framework/dicttool_aosp.jar 文件和自己写的 sample.combinded 放在同一目录下。在windows 命令行中运行如下指令：
    java -jar dicttool_aosp.jar makedict -s sample.combinded -d main_xx.dict （其中的xx代表语言码，例如英语为 en, 俄文为 ru，
    要生成英文词库就是 java -jar dicttool_aosp.jar makedict -s sample.combinded -d main_en.dict） 
    （必须已安装JDK,版本需高于build 1.6.0_39-b04，否则可能会报某些方法找不到的错误）
会在当前目录下生成文件main_xx.dict 
3 将生成的main_xx.dict文件拷贝到packages\inputmethods\LatinIME\java\res\raw下
4.然后在packages\inputmethods\LatinIME\java\res\xml\spellchecker.xml文件中查看是否已经有该语言的subtype，如果没有则添加对应语言的subtype。
5.然后重编latin 输入法。
```

## [FAQ11526] [COMMON]modem版本如何实现通话DTMF检测功能

```
1. 在aud_speech.c文件中函数aud_speech_on里添加如下：

void aud_speech_on(kal_uint8 rat_mode) {
   ...
    L1SP_Speech_On(rat_mode);
    aud_context_p->speech_on = KAL_TRUE;
    aud_keytone_detect_start();//xxx add
    ...
}

void aud_speech_off(void) {
    ...
    aud_keytone_detect_stop();//xxx add
    L1SP_Speech_Off();
    aud_context_p->speech_on = KAL_FALSE;
    ...
}

2. 在aud_keytone.c文件中添加函数

//xxx add
void aud_keytone_detect_start(void) {
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_uint32 result = MED_RES_OK;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    KtDetectStart(aud_keytone_detect_callback);
}

void aud_keytone_detect_stop(void) {
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
     KtDetectStop();
}
//xxx add end

3. 在aud_main.h中将定义的这两个函数
extern void aud_keytone_detect_start(void);//xxx add
extern void aud_keytone_detect_stop(void);//xxx add

4. 在void aud_keytone_detect_callback(kal_int16 key)函数里添加trace，可以把key值打印出来，看看是否和按键匹配，
void aud_keytone_detect_callback(kal_int16 key) {
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    media_aud_kt_process_callback_struct *ind_p = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ind_p = (media_aud_kt_process_callback_struct*)
    construct_local_para(sizeof(media_aud_kt_process_callback_struct), TD_CTRL);
    ind_p->key = key;
     kal_prompt_trace(MOD_MED,"~~~key = %d",key);
    aud_send_ilm(MOD_MED, MSG_ID_MEDIA_AUD_KT_PROCESS_CALLBACK, ind_p, NULL);

}
打印log，就能看到是否有按键按下，如果需要对特殊按键做处理，可以在该回调函数里做对应的处理.
```

## [FAQ11618] 打开应用提示不能在已root手机使用

```
总结来看，一般这些应用会做以下三个方面的检查：
1. 判断是否有/system/app/Superuser.apk
2. 判断是否有/system/xbin/su
3. 判断ro.build.tags的值是否为"test-keys"
如果以上三个条件某一个满足，则会被判定为手机已被root，即不符合它的安全要求而不能正常使用。

ps: ro.build.tags默认设置为"test-keys"，而在user版本需要（建议）更改为"release-keys"或其它需要的值
```

## [FAQ02509] [Recovery]如何编译带logo的OTA升级包

```
1. Change directory to the root of code base
2. ./mk <project> bm_new
3. ./mk <project> otapackage
4. ./build/tools/releasetools/ota_form_target_files -k build\target\product\security\common\releasekey  -l out/target/product/<project>/logo.bin out/target/product/<project>/obj/PACKAGING/target_files_intermediates/<project>-target_files-<mode>.<user_id>.zip update.zip
```

## [FAQ02507] [Recovery]如何编译完整升级包

```
Find the steps as the following:
1.     Change directory to the root of code base
2.     ./makeMtk <project>bm_new
3.     ./makeMtk <project> otapackage
4.     Copy out/target/product/<project>/<project>-ota-<mode>.<user_id>.zip to root directory of SD card and rename it to update.zip
5.     The full OTA package size is about equal to boot.img size + system.img size.
```

## [FAQ09369] 如何查看系统的memory swap 资讯/信息

```
对于LCA 版本，通常有打开swap config, 那如何查看系统的memory swap 资讯呢？
[Solution]
1. 整个系统的memory swap 资讯，可以直接读取/proc/meminfo 的资讯，其中有两行:
SwapTotal:            xxxx kB
SwapFree:             yyyy kB
 
2. 某个process 的memory swap 资讯，可以读取/proc/{PID}/status 的资讯，其中有:
VmPeak:   480944 kB
VmSize:   480936 kB
VmLck:         0 kB
VmPin:         0 kB
VmHWM:     19180 kB
VmRSS:     19180 kB
VmData:    12352 kB
VmStk:       136 kB
VmExe:         8 kB
VmLib:     35656 kB
VmPTE:        96 kB
VmSwap:        xxx kB
VmSwap 即当时的swap memory

查看 swap 信息有什么用？？？
```

## [FAQ09536] 如何在java/native层修改一个文件的权限(mode)与用户(owner)？

```
如何在java/native层修改一个文件的权限(mode),用户(owner),组(group)，以满足安全需要？
 
[Solution]
在native 层:
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
 
//chmod/fchmod 用来更新访问权限
int chmod(const char *path, mode_t mode);
int fchmod(int fildes, mode_t mode);
 
//chown/fchown/lchown 用来更新文件owner 和 group
int chown(const char *path, uid_t owner, gid_t group);
int fchown(int fd, uid_t owner, gid_t group);
int lchown(const char *path, uid_t owner, gid_t group);
 
//用来读取文件元数据
int stat(const char *path, struct stat *buf);
int fstat(int filedes, struct stat *buf);
int lstat(const char *path, struct stat *buf);
 
更多的资讯可以在linux 中 man chmod ; man chown ; man stat
 
在java 层:
java default 并不提供这样的功能，android 为满足内部需要，在android.os.FileUtils 类中提供了setPermissions 方法，结合了chmod 与chown. 参数中mode 即chmod 参数中的mode，当不需要设置file 的uid 和 group 时，可将uid 和 gid 都设置成-1；
android.os.FileUtils
public static native int setPermissions(String file, int mode, int uid, int gid);
```

## [FAQ09494] 如果确认一个process 所拥有的root 权限(capabilities)

```
linux 将root 权限分割成一个一个的capabilities，如何查看每个process 所拥有的root capabilities？
 
[Keyword]
root process capabilities 
 
[Solution]
从adb shell 命令操作中，我们可以:
adb shell cat proc/PID/status其中会打印.

比如对于system server:
CapInh: 0000000000000000
CapPrm: 0000000007c13c20
CapEff: 0000000007c13c20
CapBnd: ffffffffffffffff
 
比如对于zygote & init 等root process：
CapInh: 0000000000000000
CapPrm: ffffffffffffffff
CapEff: ffffffffffffffff
CapBnd: ffffffffffffffff
即包含原始的任何的capabilities.
 
而对于普通的app process:
CapInh: 0000000000000000
CapPrm: 0000000000000000
CapEff: 0000000000000000
CapBnd: ffffffffffffffff
即任何的root 的capabilities 都被剥夺了。
 
从native 层操作，即可使用capget 函数获取相关的资讯，具体函数的使用可以man capget 获取函数使用方法。
从kernel 层即可直接读取task 中的struct cred 结构体，然后读取其资讯，如:
const struct cred * cred = __task_cred(task);
然后就可直接读取相关的数据了 , 具体可以参考kernel/fs/proc/array.c 中的task_cap 函数
```

## [FAQ09272] 如何从手机，代码工程，运行环境 MTKLOG 中获取android 的版本(version)信息

```
1. 直接从手机上查看
   我们可以从设置(Settings)-> 关于手机(About phone) -> Android version 得知该资讯
   
2. 从代码工程中查看
   在alps/build/core/version_defaults.mk 中有定义两个关键的属性
   PLATFORM_VERSION : Android 系统版本，通常为一个x.y.z 的字符串
   PLATFORM_SDK_VERSION : Android 系统对应的SDK 版本 为一个整数
   
   这两个值，在编译完后将会放置在system/build.prop 中，分别对应ro.build.version.release ， ro.build.version.sdk
   
3. 运行环境
    命令行操作: 
        查看android 版本: adb shell getprop ro.build.version.release  
        查看SDK 版本:     adb shell getprop ro.build.version.sdk
 执行代码:
        可以读取system property ro.build.version.release 和 ro.build.version.sdk
        从JAVA 代码可以直接访问下面的两个字段:
        android.os.Build.VERSION.RELEASE
        android.os.BUILD.VERSION.SDK_INT
  
4. MTKLOG
   在android 4.1 以及以前版本，MTKLOG ->mobile log->AP LOG 中有一个versions 文件; 在android 4.1 之后，改名成properties 文件。对应里面存储了系统的相关system property ，可以直接读取中，分别对应ro.build.version.release ， ro.build.version.sdk
```

## [FAQ09021] 如何修改系统内置文件的权限, 用户，属性

```
修改系统内置文件的权限，通常分成三种方式:
1). 在打包成image 时，就已经修改/定制/调整好；
2). 在开机时强制性更新；
3). 开机后，通过命令操作的方式修改，通常仅仅用于有root 权限时的debug 操作，或者借助root 权限强制性调用相关的API
针对正式版本，明显第三种方式不合适，前两种方式中，第一种方式在打包image 时直接处理比较好(推荐使用)，而开机时处理无疑会拉长处理的开机的时间(只是执行速度块，影响比较小)
 
下面分别说明这三种方式:

第一种方式: 打包成image 时处理
在将系统文件打包成image 时，相关的权限，用户，属性配置项都定义在alps/system/core/inlcude/private/android_filesystem_config.h 中
在该文件中包括三个关键的定义:
1) 系统用户的定义，即不同的用户对应不同的user id
2) 系统目录权限定义，即android_dirs 数组
3) 系统特别文件权限定义， 即android_files 数组
如果您需要增加特别的目录权限定义，可以放置在android_dirs 定义中; 如果您需要增加特别文件权限的定义，可以增加在android_files 数组中。
注意的是增加的特别权限设置要在广泛设置之前。
    { 06755, AID_ROOT,      AID_ROOT,      0, "system/xbin/su" },
要放在
    { 00755, AID_ROOT,      AID_SHELL,     0, "system/xbin/*" },
之前
 
第二种方式: 在开机时强制性更新
System 文件夹在init.rc 中被描述为 ro (read only)， 即被mount 成ro, 所以即使您再去chmod or chown 某个文件的权限或者所有者，都无法达到目的。
目前system image 会mount 两次，您必须在system 被remount 成ro 前修改文件权限方可。
针对yaffs2 文件系统(其他文件系统类似)，您要增加的代码须放置在:
on fs
# mount mtd partitions
write /proc/bootprof "INIT:NAND:Mount_START"
# Mount /system rw first to give the filesystem a chance to save a checkpoint
mount yaffs2 mtd@system /system nandboot
mkdir /system/secro 0600 system system
# RIL need to do this before the folder /system changed to read only
chown radio system /system/etc/ril
chmod 0770 /system/etc/ril
chmod 0444 /system/etc/ril/oper.lis

#Add your code here...
mount yaffs2 mtd@system /system ro remount nandboot
mount yaffs2 mtd@userdata /data nosuid nodev nandboot
mount yaffs2 mtd@cache /cache nosuid nodev nandboot
write /proc/bootprof "INIT:NAND:Mount_END"

第三种方式: 命令方式修改
下面以将一个su 内置到system/xbin 进行说明 
adb remount 《= 调整system image 的mount 方式rw:read-write
adb push su system/xbin 《= push 到system/xbin
adb shell chmod 6755 system/xbin/su 《= 更新文件权限，并设置s bit
```

## [FAQ08008] 普通APP APK 如何确认系统是MTK 平台

```
有一些APP 厂商，可能针对MTK 平台进行优化设计，那么普通APP 如何确认系统是MTK 平台呢？
目前在手机运行系统中，要能够直接判断是MTK 系统，可以读取下面的system property.
Java API
android.os.SystemProperties
public String get(String key);
public String get(String key, String def);
 
可以读取下面的三个MTK 平台独有的system property， 有即是MTK 平台了，并且可以获取具体的MTK 平台释放资讯。
ro.mediatek.platform          对应MTK IC， 注意不区分2G，3G， 如MT6575/MT6515 都统一会是MT6575
ro.mediatek.version.branch    对应MTK 内部branch， 如ALPS.ICS.MP,  ALPS.ICS2.MP, ALPS.JB.MP 等之类
ro.mediatek.version.release   对应MTK 内部branch 的释放版本，如ALPS.ICS.MP.V2.47, ALPS.JB2.MP.V1.9
 
如ICS2 75 的手机
[ro.mediatek.platform]: [MT6575]
[ro.mediatek.version.branch]: [ALPS.ICS.MP]
[ro.mediatek.version.release]: [ALPS.ICS.MP.V2.47]
 
JB2.MP 89 的手机
[ro.mediatek.platform]: [MT6589]
[ro.mediatek.version.branch]: [ALPS.JB2.MP]
[ro.mediatek.version.release]: [ALPS.JB2.MP.V1.9]
 
下面是一个demo 的util java class.
 
import android.os.SystemProperties;
/**
* A simple util demo for Mediatek Platform Information
*/
public class MediatekPlatformUtil{
 
  public static final String MTK_PLATFORM_KEY = "ro.mediatek.platform";
  public static final String MTK_VERSION_BRANCH_KEY = "ro.mediatek.version.branch";
  public static final String MTK_VERSION_RELEASE_KEY = "ro.mediatek.version.release";
 
  /**
   * Check is or not Mediatek platfrom 
   */
  public static boolean isMediatekPlatform(){
    String platform = SystemProperties.get(MTK_PLATFORM_KEY);
    return platform != null && (platform.startsWith("MT") || platform.startsWith("mt"));
  }
 
  /**
   * Get the Mediatek Platform information, such as MT6589, MT6577.....
   * @Warning It does not distinguish between 2G and 3G IC. IE. MT6515, MT6575 => MT6575
   */
  public static String getMediatekPlatform(){
    return SystemProperties.get(MTK_PLATFORM_KEY);
  }
 
  /**
   * Get the mediatek version information.
   * Return a string array with two elements. first element is branch, and the second is release version.
   */
  public static String[] getMediatekVersion(){
    String[] result = new String[2];
    result[0] = SystemProperties.get(MTK_VERSION_BRANCH_KEY);
    result[1] = SystemProperties.get(MTK_VERSION_RELEASE_KEY);
    return result;
  }
}
```

## [FAQ07367] 如何设置系统属性 systemproperty 默认值

```
system property 是存在在init 进程中的关键系统属性，如系统安全，系统稳定性，系统的版本信息等，system property 容量有限，不能随意添加与设置。
设置system property 的默认值通常可以分成2种:
1. 在build 的时候即填写好，然后保存在手机系统中(/default.prop system/build.prop 等)。
 default.prop 中的属性属于系统安全属性，通常请下严禁在运行时修改，有build 时的变量 ADDITION_DEFAULT_PROPERTIES 产生，如ro.secure, ro.debuggable 等。
 具体可以参考alps/build/core/main.mk 中这个ADDITION_DEFAULT_PROPERTIES变量的设置。
 
 system/build.porp 中的属性称为常规属性，由build 时的变量 ADDITION_BUILD_PROPERTIES 产生，通常可以在如alps/build/tools/buildinfo.sh, 
 alps/mediatek/config/project-name/system.prop 中添加，或者直接修改ADDITION_BUILD_PROPERTIES 变量；建议在system.prop 中添加。
 
2. 在系统启动的时候强制性添加，通常是在init process 启动，并且property service 已经初始化后，通过配置init.rc 写入，使用的命令是
 setprop key value 的方式设置。
 
 建议采用第一种方式进行设置，以便维护
 
[相关FAQ]
FAQ04349: 不能添加system property, 提示： permission denied uid:xxxxx  name:xxxxx
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ03778: 如何对system property 进行扩容 
FAQ06739: system property 设置失败的可能性分析和初步诊断
```

## [FAQ03994] system property 写入/更新后，马上读取无效问题

```
首先说明一下system property 的使用API
Java API
android.os.SystemProperties
public String get(String key);
public String get(String key, String def);
public int getInt(String key, int def);
public long getLong(String key, long def);
public void set(String key, String val); => the return value is void
 
Native API
libcutils/Properties.h & Properties.c
int property_set(const char* key, const char* value);
int property_get(const char* key, char* value, const char* def);
int property_list(void(*propfn)(const char* key, const char* value, void * cookie), void * cookie);
 
Android Toolbox
adb shell getprop
    return all properties, as list
adb shell getprop <key>
    return the property base on key
adb shell setprop <key> <value>
    set the property <key> <-> <value>
 
Init.rc
setprop <key> <value>
on property:<key>=<value>
     some actions.
 
Android 2.3 版本，其他process 写入system properties 时，只是通过socket 将其发送到init 的system properties，然后直接返回；而至于init 什么时候读取socket 中的message, 然后update/write system properties, 这个还不得而知，所以可能产生不可推断的延时。
Android 4.0 版本后，init 的properties_service update 完后才去关闭socket， 而其他process wait socket closed 后才返回，这个wait time 最长为250ms, 即如果init 延时的时间超过250ms, 将强制返回。原则上从Android 4.0 后，可以规避掉绝大部分写入后不能马上读取出来的情况。
另外一个方面，read 是直接通过memory mmap 的方式，直接在对应的process 中直接读取，无需透过socket 请求init 读取。从而就可能出现时间差，即写入后无法即时读取的情况。相比2.3版本 4.0 版本之后出现的概率要大大的降低。
```

## [FAQ04776] 如何默认打开user版本 debug 选项, 默认打开adb 连接

```
1. 在android 4.0 之前，这个设置是在frameworks/base/service/..../SystemServer.java 里面设置会根据system property 的persist.service.adb.enable 来设置。您可以看到类似如代码：
        // make sure the ADB_ENABLED setting value matches the secure property value
        Settings.Secure.putInt(mContentResolver, Settings.Secure.ADB_ENABLED,
                "1".equals(SystemProperties.get("persist.service.adb.enable")) ? 1 : 0);
        // register observer to listen for settings changes
        mContentResolver.registerContentObserver(Settings.Secure.getUriFor(Settings.Secure.ADB_ENABLED),
                false, new AdbSettingsObserver());
    
 而这个persist.service.adb.enable 默认是放在在default.prop 中，在编译的时候在build/core/main.mk 中确认, 
 ifeq (true,$(strip $(enable_target_debugging)))
   # Target is more debuggable and adbd is on by default
   ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1 persist.service.adb.enable=1
   # Include the debugging/testing OTA keys in this build.
   INCLUDE_TEST_OTA_KEYS := true
 else # !enable_target_debugging
   # Target is less debuggable and adbd is off by default
   ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=0 persist.service.adb.enable=0 
 endif # !enable_target_debugging
 您需要将: ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=0 persist.service.adb.enable=0  改成
 ADDITIONAL_DEFAULT_PROPERTIES += ro.debuggable=1 persist.service.adb.enable=1 
    
2. 在android 4.0 之后，因为adb 的控制，统一使用了persist.sys.usb.config 来控制，于是对应的设置点也改到了frameworks/base/service/...../usb/UsbDeviceManager.java 中，您也可以看到类似的代码如：
public  UsbHandler(Looper looper) {
        // persist.sys.usb.config should never be unset.  But if it is, set it to "adb"
        // so we have a chance of debugging what happened.
         mDefaultFunctions = SystemProperties.get("persist.sys.usb.config", "adb");
        // sanity check the sys.usb.config system property
        // this may be necessary if we crashed while switching USB configurations
        String config = SystemProperties.get("sys.usb.config", "none");
        if (!config.equals(mDefaultFunctions)) {
            Slog.w(TAG, "resetting config to persistent property: " + mDefaultFunctions);
            SystemProperties.set("sys.usb.config", mDefaultFunctions);
        }
        mCurrentFunctions = mDefaultFunctions;
        String state = FileUtils.readTextFile(new File(STATE_PATH), 0, null).trim();
        updateState(state);
        mAdbEnabled = containsFunction(mCurrentFunctions, UsbManager.USB_FUNCTION_ADB);
public void  systemReady() {
 // make sure the ADB_ENABLED setting value matches the current state
    Settings.Secure.putInt(mContentResolver, Settings.Secure.ADB_ENABLED, mAdbEnabled ? 1 : 0);
 
而这个persist.sys.usb.config 中adb 的配置是在alps/build/tools/post_process_props.py 中根据ro.debuggable = 1 or 0 来设置，1 就是开启adb, 0 即关闭adb debug. 而这个ro.debuggable 也是在alps/build/core/main.mk 中设置，和2.3 修改类似
不过您这样打开之后，对于user 版本adb shell 开启的还是shell 权限，而不是root 权限，如果您需要root 权限，需要再改一下system/core/adb/adb.c 里面的should_drop_privileges() 这个函数，在#ifndef ALLOW_ADBD_ROOT 时return 0; 而不是return 1; 即可。
```

## [FAQ08893] 如何抓取app 进程的hprof

```
在分析app 时，我们通常需要分析app 的java heap 资料，如分析java 的memory leak, 追查heap 中相关变量情况等。
在android 中抓取app 的hprof 操作方式有下面几种:
第一种方式: 使用am 命令 
adb shell am dumpheap {Process} file
如 adb shell am dumpheap com.android.phone /data/anr/phone.hprof
adb pull /data/anr/phone.hprof

第二种方式: 使用DDMS 命令
在DDMS 中选择对应的process, 然后在Devices 按钮栏中选择Dump Hprof file， 保存即可

第三种方式: 通过代码的方式
在android.os.Debug 这个class 中有定义相关的抓取hprof 的method.
如: public static void dumpHprofData(String fileName) throws IOException;
这样即可在代码中直接将这个process 的hprof 保存到相对应的文件中，注意这个只能抓取当时的process.
如果想抓其他的process 的hprof, 那么就必须通过AMS 帮忙了。
可以先获取IActivityManager 接口，然后调用它的dumpheap 方法。具体的代码，大家可以参考
frameworks/base/cmds/am/src/com/android/commands/am/am.java 中的调用代码

抓取回hprof 后，就可以用hprof-conv 命令将DVM 格式的hprof 转换成标准的java 命令的hprof
hprof-conv in.hprof out.hprof

然后使用如MAT 之类的工具进行具体的分析
```

## [FAQ08150] 如何快速确认文件系统空间使用情况

```
1. df 命令 显示各个分区文件使用情况
root@android:/ # df
df
Filesystem             Size   Used   Free   Blksize
/dev                   237M    52K   237M   4096
/mnt/secure            237M     0K   237M   4096
/mnt/asec              237M     0K   237M   4096
/mnt/obb               237M     0K   237M   4096
/system                640M   427M   213M   4096
/data                    1G   183M     1G   4096
/cache                 370M     6M   364M   4096
/protect_f               8M     4M     4M   4096
/protect_s               8M     4M     4M   4096
/mnt/cd-rom             17M    17M     0K   2048
/storage/sdcard0         1G     1G   118M   16384
/mnt/secure/asec         1G     1G   118M   16384
 
2. du 命令查询目录占用空间
usage: du [-H | -L | -P] [-a | -d depth | -s] [-cgkmrx] [file ...]
具体可以在linux 上直接man du 查看使用手法
举例如去追查/data 分区
root@android:/ # du -d 1 /data
du -d 1 /data
8       /data/lost+found
133328  /data/app
53352   /data/data
8       /data/app-private
84768   /data/dalvik-cache
8       /data/anr
8       /data/dontpanic
32      /data/drm
1104    /data/local
16      /data/agps_supl
16      /data/ssh
16      /data/mdl
1024    /data/nvram
8       /data/resource-cache
256     /data/misc
38040   /data/app-lib
8       /data/amit
8       /data/user
1392    /data/system
8       /data/app-asec
8       /data/acdapi
24      /data/media
32      /data/backup
144     /data/property
80      /data/@btmtk
32      /data/cust
8       /data/SF_dump
8       /data/tombstones
8       /data/aee_exp
8       /data/core
324088  /data
 
这样确定是某个目录xxx_dir占用量最大，最有嫌疑，然后再进一步
du -d 1 /data/xxx_dir
 
经过几次迭代后，很快就可以找到最终是哪个文件目录，哪些文件占用了太多空间了
```

## [FAQ07789] Android shell 如何copy/复制文件

```
在4.2 之前，toolbox 没有内置cp 命令，需要使用
cat 或者 dd 操作如：
cat source_file > dest_file
dd if=source_file of=dest_file
 
在4.2 之后，toolbox 中引入了cp 命令，可以直接使用cp 操作:
cp source target
usage: cp [-R [-H | -L | -P]] [-f | -i] [-alNpv] src target
            cp [-R [-H | -L | -P]] [-f | -i] [-alNpv] src1 ... srcN directory

```

## [FAQ10134] [BMT]电量测试需要做什么实验？

```
请参考下面的文件：
Path:
MediaTek DCC > External Document > HW > Common Design Notes > PMU > Fuel Gauge >Fuel Gauge Application Notes
Fuel Gauge Test Way Introduction
```

## [FAQ05785] [BMT]如果需要客制化关机充电动画，需要注意的事项

```
1.如果需要客制化关机充电，需要注意哪些事项：

A.关机充电图片的位置
alps\mediatek\custom\common\lk\logo\分辨率\
在这个文件路径下面有很多充电图片，总共有38张。
38张图片通过alps\mediatek\custom\common\lk\logo\update脚本，
打包存储在一个档案下面。

B.38张图片,在档案里面存在序号，具体的排序号，请查看update脚本:
譬如：
从update脚本上面可以看出，低电量的图片的序号为2
在软件里调用低电量的图片就是用

C.动画是怎么实现的？以低电量显示为例子
循环调用序号为25-34的10张图片，跟update脚本刚好对应起来。
update脚本里面，低电量的10张图片的序号为25-34

D. 如果需要显示自己的图片，怎么做？
请把自己的图片，替换成logo底下的同名文件，这样就可以不用修改脚本，直接调用
show_logo_surface,调用相应序号就可以显示出来了。
不过有一点需要特别注意，所使用的图片格式必须是bmp,位数必须是24.否则无法显示
```

## [FAQ10548] OTA升级，无法找到更新包

```
OTA升级，服务器上已经上传了新版本，但是手机检索的时候，仍然提示版本已经是最新版本，找不到更新包。
从log看：提示如下：
{"status":1000,"name":"mp.v1.1","size":4455854,"android_version":"4.2.2","release_notes":"MP.V1.1","deltaId":181,"fingerprint":"XXXXX/vh075_td_emmc_xxxxx_s4509/vh075_td_emmc_xxxxx_s4509:4.2.2/JDQ39/1387464158:user/test-keys"}//这个log说明找到了新的软件版本
12-20 09:49:20.887: INFO/SystemUpdate/HttpManager(2002): parseCheckVersionInfo
12-20 09:49:20.894: INFO/SystemUpdate/HttpManager(2002): HTTP_RESPONSE_SUCCESS
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): res.mVersionName = mp.v1.1
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): res.fileSize = 4455854
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): res.releaseNote = MP.V1.1
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): delta package: res.packageId = 181
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): res.packageId = 181res.isFullPkg = false
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): fingerPrintPkg = XXXXX/vh075_td_emmc_xxxxx_s4509/vh075_td_emmc_xxxxx_s4509:4.2.2/JDQ39/1387464158:user/test-keys
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): fingerPrintLocal = 
12-20 09:49:20.898: INFO/SystemUpdate/HttpManager(2002): sendErrorMessage, mErrorCode = 1010//这里说明软件版本不匹配

[SOLUTION]
在对比版本的时候，会对比fingerprint值，log来看这里
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): fingerPrintPkg = XXXXX/vh075_td_emmc_xxxxx_s4509/vh075_td_emmc_xxxxx_s4509:4.2.2/JDQ39/1387464158:user/test-keys
12-20 09:49:20.895: INFO/SystemUpdate/HttpManager(2002): fingerPrintLocal =
fingerPrintLocal是获取来的本地手机的fingerprint值，这边获取为null，是因为客户定义的版本号太长了，导致在组装成fingerprint值的时候，超出了google限制的property的长度92 byte，这种情况下，请改小客户定义版本内容，即
XXXXX/vh075_td_emmc_xxxxx_s4509/vh075_td_emmc_xxxxx_s4509:4.2.2/JDQ39/1387464158:user/test-keys
XXXXX表示OEM，例如alps
vh075_td_emmc_xxxxx_s4509表示版本号，注意一定不能太长。
```

## [FAQ08670] [Others]Enable ”CONFIG_MTK_USB_UNIQUE_SERIAL“，每台手机进meta mode都要安装驱动

```
Enable ”CONFIG_MTK_USB_UNIQUE_SERIAL“ 之后，产线SN Writer Tool/HW Test Tool/ATE Tool 测试每台手机时候，都要求安装驱动，给产线生产带来不便
[SOLUTION]

1. SN Writer Tool
修改SN Writer Tool执行路径下SN_SETUP.txt 文件设置，如下
IS Composite Device Enable = False

2. HW Test Tool
界面上取消勾选Option->Enable composite kernel device

3. ATE Tool
修改ATE Tool 执行路径下Customer_Setup.txt 文件设置，如下：
IS Composite Device Enable = 0

4. 客户自己写工具，请在调用
LIBEXPORT int __stdcall SP_Preloader_BootMode(SP_BOOT_ARG_S * pArg);
boot meta mode 时候设置传入参数
pArg->m_bIsCompositeDeviceEnable = 0;
```

## [FAQ10411] 关机充电下，怎样show高温警告图片

```
alps\mediatek\external\ipod\bootlogo.cpp
1.
bootlogo_show_charging()中仿照高压充电显示警告图片的方法来修改高温警告图片即可
在
if (get_ov_status()) {
    mt65xx_disp_show_charger_ov_logo();
    return;
}
后面添加
if (get_ot_status()) {
    mt65xx_disp_show_battery_ot_logo();
    return;
}
 
void mt65xx_disp_show_battery_ot_logo(void) {
    XLOGD("[ChargingAnimation %s %d]show battery_ot logo, index = x \n",__FUNCTION__,__LINE__);
    mt_show_logo(x);  // 这里的x是您可以自行选择的
}
2.
alps\mediatek\external\ipod\ipodcommon.cpp
在
开头增加
#define BATTERY_TEMPERATURE_PATH "/sys/class/power_supply/battery/batt_temp"
#define BATTERY_OVER_TEMP 500
int get_ov_status()函数的后面添加
int get_ot_status() {
     int temp = get_int_value(BATTERY_TEMPERATURE_PATH);
     SXLOGI("battery temperature : %d\n", temp);
 
     if(temp >= BATTERY_OVER_TEMP)
     {
           return 1;
     }
     return 0;
}
```

## [FAQ04490] Monkey test确定package name的一种特殊方法

```
用Monkey的调试模式命令可以获取到package name

Monkey 单元测试需要确定所测模块的package name，一般用Dev tools/Package browser 或者豌豆荚等程序就可以查找到对应的package name，现在这里介绍另外一种特殊的方法：

连上USB cable并保证adb devices命令能识别到设备的前提下，输入adb shell monkey --port PORT_NUMBER -v -v 可以进入调试模式(其中PORT_NUMBER可以随意指定),然后手机这边点击相应的模块，CMD窗口会显示出对应的log信息，其中就包含package name.
```

## [FAQ03439] [Recovery]如何进入recovery mode立即显示menu菜单

```
请将alps/bootable/recovery/ui.c文件中的static int show_text = 0;
修改为static int show_text = 1;
```

## [FAQ04270] [LEDS] 如何通过adb shell 控制 LEDs

```
列出所有的LED名字：
adb shell "ls /sys/devices/platform/leds-mt65xx/leds/"
adb shell 控制LED：
// 打开
adb shell "echo 255 > /sys/devices/platform/leds-mt65xx/leds/LEDNAME/brightness"
LEDNAME = "button-backlight" or "lcd-backlight" ...
// 关闭
adb shell "echo 0 > /sys/devices/platform/leds-mt65xx/leds/LEDNAME/brightness"
```

## [FAQ03772] [LEDS]怎样添加一个自定义的LED灯？

```
1. 修改如下两个文件：

alps/mediatek/custom/common/kernel/leds/inc/cust_leds.h

-----------------------------------------------------------

enum mt65xx_led_type

{

    MT65XX_LED_TYPE_RED = 0,

    ... ...

    MT65XX_LED_TYPE_LCD,

    MT65XX_LED_TYPE_ABC,        // Add a new LED type

    MT65XX_LED_TYPE_TOTAL,

};





alps/mediatek/custom/YOUR_PRJ/kernel/leds/mt65xx/cust_leds.c

----------------------------------------------------------------

static struct cust_mt65xx_led cust_led_list[MT65XX_LED_TYPE_TOTAL] = {

    {"red",               MT65XX_LED_MODE_NONE, -1,{0}},

    ... ...

    {"lcd-backlight",     MT65XX_LED_MODE_CUST, (int)Cust_SetBacklight,{0}},



    // Set LED params, Please refer to <Driver all in One>

    {"abc-backlight", MT65XX_LED_MODE_CUST, (int)Cust_SetBacklight_abc,{0}}, 

};





2. 重新编译后，在Kernel log 里可以看到如下信息:

--------------------------------------------------------------------

<7>[    1.021967] (0)Registered led device: button-backlight

<7>[    1.022013] (0)Registered led device: lcd-backlight

<7>[    1.022072] (0)Registered led device: abc-backlight   // <------- !



3. 用如下命令查看新LED的 sysfs节点

adb shell ls /sys/devices/platform/leds-mt65xx/leds/

------------------------------------------------------------------------

abc-backlight

button-backlight

lcd-backlight
```

## [FAQ04317] 如何在Android App中屏蔽（拦截）Home按键及其他按键

```
编写一个Acitivity，如下所示：
关键点1：屏蔽HOME按键，在onAttachedToWindow中设置FLAG_HOMEKEY_DISPATCHED
关键点2：屏蔽除Power , Home外的按键，覆盖dispatchKeyEvent方法，并返回为true
public class LockByKeyGuard extends Activity {
       @Override
       public void onCreate(Bundle savedInstanceState) {
              super.onCreate(savedInstanceState);
              setContentView(R.layout.main);
       }
       @Override
       public void onAttachedToWindow() {
       //关键：在onAttachedToWindow中设置FLAG_HOMEKEY_DISPATCHED
              this.getWindow().addFlags(WindowManager.LayoutParams. FLAG_HOMEKEY_DISPATCHED);
              super.onAttachedToWindow();
       }
       @Override
       public boolean dispatchKeyEvent(KeyEvent event) {
              // 返回true，不响应其他key
              return true;
       }
```

## [FAQ04321] 判断当前是否是飞行模式和侦听airplane mode change

```
在 AirplaneModeEnabler 中 提供了 isAirplaneModeOn 方法来判断当前是否是 Airplane mode：
public static boolean isAirplaneModeOn(Context context) {
    return Settings.System.getInt(context.getContentResolver(), Settings.System.AIRPLANE_MODE_ON, 0) != 0;
}

侦听是否airplane mode 发生改变，可以用注册intentFilter 来侦听。

BroadcastReceiver  mReceiver = new AirplaneModeBroadcastReceiver();
IntentFilter intentFilter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);
registerReceiver(mReceiver, intentFilter);

private class AirplaneModeBroadcastReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        String action = intent.getAction();
        if (action.equals(Intent.ACTION_AIRPLANE_MODE_CHANGED)) {
           // add your code here ………
        }
    }
}
```

## [FAQ04381] [Vibrator] 如何通过adb shell命令调试Vibrator

```
请执行下述界面，确认震动硬件是否正常工作.
下面的命令是用于调试，请试着用它找出你想要的时间和震动强度。 1000毫秒 = 1秒
adb shell "echo 1000 > /sys/devices/virtual/timed_output/vibrator/enable"
```

## [FAQ03946] FM支持的scan interval有几种

```
FM支持的scan interval有几种

scan interval 是什么意思？？
```

## [FAQ02506] [BMT]如何掌握Fuel Gauge 算法流程

```
(以下简述以MT6575+Android2.3为例)
1、Fuel Gauge 算法需要相关软、硬件支持，
    硬件方面：正常的电池温度检测电路，正常的Fuel Gauge 电流检测电路
    软件方面：开启FG功能（默认情况下已打开），由检测客户提供的样机及标配电池而得出的若干个FG数组（送检请与CPM联系）

2、Fuel Gauge 算法相关文件
    mediatek\platform\mt65xx\kernel\drivers\power\mt65xx_fuel_gauge.c
    mediatek\custom\[PROJECT]\kernel\battery\battery\Custom_fuel_gauge.h
    Custom_fuel_gauge.h 中的数组由检测样机及标配电池后生成。

3、Fuel Gauge 算法相关介绍资料
    Mediatek MT65xx Fuel Gauge      ；该资料可向CPM申请。

4、如何关闭 Fuel Gauge
    请参考相关FAQ
```

## [FAQ02510] [BMT]工厂测试模式下的电池温度不对

```
1、与工厂测试模式相关的电池检测函数位于以下文件，
    mediatek\source\factory\src\test\Ftm_battery.c
2、参考其中的温度转换函数BattThermistorConverTemp()
```

## [FAQ02511] [BMT]如何修改快速开机模式下的背光键？

```
在启用快速开机功能的情况下，如何修改背光键为开机键？
[PLATFORM]
MT6575/15 + Android 2.3
MT6573/13 + Android 2.3

[Solution]
(以下简述以MT6575+Android2.3为例)

1、与快速开机功能相关的文件位于以下路径：
    mediatek\source\external\ipod\*.*
2、定义ipod 模式下的背光键及开机键
    修改文件ipodmian.c 中的数组：pwrkeys[],blkkeys[]
```

## [FAQ03561] 编译vm-tests-tf出现Too many open files

```
出错的log中有一句：
Caused by: java.io.FileNotFoundException: cts/tools/vm-tests-tf/src/dot/junit/opcodes/iget_char/Test_iget_char.java (Too many open files)

[KEYWORD]
java.io.FileNotFoundException
Too many open files
vm-tests-tf

[SOLUTION]
这是由于linux限制了一次会话中，程序最大同时打开文件数目(default:1024, MTK:65535)
 
详细分析：
在linux下跑一个多线程读取文件的程序，待读取文件有数十万个。程序读取过程中抛出如下异常*****(Too many open files)。

原因是由于linux限制了一次会话中，程序最大同时打开文件数目。在redhat5中，该数值为1024。可以使用ulimit -n 验证。

解决办法
1、临时修改该数值，可使用
ulimit -n XXXX
ulimit -n XXXX

2、永久修改
2.1. 查看当前设置
ulimit -n
(默认是1024，MTK是65535)

2.2. 查看系统可接受的最大打开文件数(一般默认已足够，不用修改)
# cat /proc/sys/fs/file-max
（默认可能是372998，已足够）如果小于你期望的值，可以改大：

# echo 327998 > /proc/sys/fs/file-max
或者写入 /etc/sysctl.conf中，以便重启也能生效：
fs.file-max = 327998

2.3. 修改/etc/security/limits.conf文件，设置用户最大打开文件数
#<domain>      <type> <item>         <value>
* - nofile 2048    (添加这一行)

这样即设置系统每个用户的最大打开文件数为2048。

注意 nofile 参数在 type 类型上有2个可能的选项：hard 和 soft ，这两个值都需要设置，“-”代表同时设置这2个值为后面的数字。

hard limit 只是作为 soft limit 的上限，soft limit 才是你设置的系统当前限制。当你设置 hard limit 后，你以后设置的 soft limit 的值就只能小于 hard limit 。普通用户可以降低 hard limit 的值，但是不能提高它，只有 root 用户才能提高 hard limit。

2.4. 退出shell登陆，重新登陆一次即生效(运行ulimit -n 检查)

已经启动的进程，可能需要关闭后重新启动才生效
```

## [FAQ03046] 如何通过USB抓取main/events/radio/kernel log

```
可以使用adb命令来抓这些log

1, radio log

线：usb cable

命令： adb logcat –b radio –v time >radio.txt

-v time: 表示log中加入了时间信息

1

2, main log

main log和我们从DDMS中看到的log是一致的

线: usb cable

命令: adb logcat –b main –v time >main.txt

-v time: 表示log中加入了时间信息

2

3, event log

event log属于system log

线: usb cable

命令: adb logcat –b events –v time >events.log

-v time: 表示log中加入了时间信息

3

4, kernal log

使用超级终端来抓kernal log，请参考以下步骤：

 

1) 选择正确的COM口(COM3)
2) 设定正确的波特率(921600)
3) 在超级终端中得到log
```

## [FAQ03519] [Power]关于待机平均功耗高的测试以及自行判断注意事项

```
如果贵司测试的时候，发现平均功耗高，
1》
首先请去掉所有的APK测试，看平均功耗是否有问题，
如果跟去掉APK之前一样，说明跟APK没有关系
如果跟去掉APK之前相比，功耗有所降低，说明跟APK有一定的关系
跟APK有关系，请自行分析APK。
 
2》
另外，请抓取相应的待机的 mobilelog,
从 kernel_log 中分析，
如果 log 中可以查找到 wake up by RTC
请在相应的 main_log 中查找关键字 Alarm triggering, 其后面对应的type 0, type 2所对应的APk就是唤醒系统的唤醒源，
同样请去掉以后测试，
但是 com.android.phone 例外，
这个 APK 是 ICS android4.0 加上的一个 google default 的机制，
是一个每隔6分钟起来check数据连接是否有问题的机制，
检查是否只有TX没有RX的行为，
一旦检查到系统数据连接有问题，就会做相应的recovery动作
 
3》
从kernel_log中分析，
如果log中可以查找到
wake up by CCIF_MD
请查找后面一句log相应的CCIF_MD wakeup source: 
如果是在您没有打开modemlog的基础上面出现此问题，
请帮忙同时抓取待机时候的mobilelog以及modemlog并附上modem对应的database
便于我司查找问题
如果是 CCIF_MD wakeup source: Mdlogger_RX
说明是因为打开modemlog引起的问题，正常
 
4》
从kernel_log中分析，
如果log中可以查找到
wake up by EINT
一般情况下是由于press power key引起的，
在后面的log中可以看到有wakeup的字样，就说明是power key
其他的情况应当是异常的中断引起的问题
您可以在中断例程中查找此中断的来源
```

## [FAQ03776] [Power]关于RTC唤醒系统问题

```
RTC唤醒系统的特征是
     从kernel_log中可以查找到 "wake up by RTC"
 
RTC唤醒系统的原因是
     上层的APK
 
查找的方法：
     从main_log中查找关键字"Alarm triggering"
     然后看相对应的log后面表明是type 0 还是type 2,
     只有type 0或者type 2 的对应的APK才是能唤醒系统的APK
     
比如：
     AlarmManager: Alarm triggering: Alarm{41c36640 type 2 com.android.providers.calendar}
     从这一行您就可以看出，com.android.providers.canlendar就是能唤醒系统的APK
 
例外：
    目前com.android.phone这个APK也是type 2的APK，
    在存在数据链接的情况下，每隔6分钟就会唤醒系统起来检查是否当前的数据链接有问题，并及时做receovery动作
    所以在查找RTC唤醒源的时候，这个APK需要排除在外，
    这个APK是google default的机制
 
请您在提功耗相关的问题之前，
切记，请自行将RTC唤醒这部分分析，并将有关的APK都去掉以后再行测试，
这部分唤醒会增加系统的平均功耗，
有关这些第三方APK唤醒的问题我司不予cover。
```

## [FAQ03446] [Power]How to use catcher tool to get RTC clock (32KHz) frequency

```
具体确定时钟频率的方法如下：
    1. 利用SD卡来抓取系统睡眠时候的modemlog
    2. 然后在catcher tool中选择controls->Open Dump File, 打开MDLog_L1_XXX.dmp文件（modemlog中抓取的其中一个文件）
    3. 如果您看到advanced->sleep_mode本来就是勾选上的，那么您就可以不用做第4步，直接跳到第5步
    4. 如果您看到advanced->sleep_mode是未勾选上的，请您将目前打开的文件另存为xxx.clg文件，然后打开此.clg文件
    5. 选择sleep_mode以后，就可以看到弹出的框框中，左边一栏有三列
        分别是frame, Freq.Meas Result, 32K Freq
        其中32K Freq那一列就是32K时钟的真正的值，也就是RTC clock的真正的值
        此值得准确值为32768， 您可以比较一下看看。
```

## [FAQ03548] 手机软件测试注意事项

```
测试前准备:
       1:请备份编译后生成的alps/kernel/vmlinux  (解KE的关键)
       2:请备份编译后生成的apps/out/target/product/$project_name$/symbols/整个目录. (解NE的关键)
       3:清除T卡的所有记录

测试过程中:
       1:发现有异常,尽可能马上备份完整的LOG, 再进行下面测试,以免后来的测试把之前的LOG冲掉.
       2:调整手机的时间跟实际的时间一致.
       3:记录现场的情况: 是在什么情况下发生?  发生的时间?
       4:如果是成批有问题,请详细统计概略

如何抓取完整的LOG:
1. 使用GAT工具（该工具是MTK标准的debug工具，一般和flashtools一起释放），复现问题后连上usb （adb要能工作，如果不能工作，可以重启手机连上），打开GAT，点击DDMS Control这个界面下面一排按钮的最右边按钮（是个虫子图标的按钮），然后GAT会自动抓取手机里所有的log，并打包好（目录一般是放在临时目录下，注意看命令行），将压缩包上传。

2. 也可以用以下脚本（以下CODE保存为.bat文件）

%Writed by Yanghui Li%

adb devices

@echo "抓出sdcard/mtklog"
adb pull /sdcard/mtklog mtklog/

@echo “抓出sdcard2/mtklog”
adb pull /sdcard2/mtklog mtklog/sdcard2

@echo "抓出trace"
adb pull /data/anr mtklog/anr

@echo "抓出data aee db"
adb pull /data/aee_exp mtklog/data_aee_exp

@echo "抓出data mobilelog"
adb pull /data/mobilelog mtklog/data_mobilelog

@echo "抓出NE core"
adb pull /data/core mtklog/data_core

@echo "抓出tombstones"
adb pull /data/tombstones mtklog/tombstones

@echo "完成"

pause 
```

## [FAQ02625] 如何修改system 下面文件的权限

```
在init.rc 中修改system 下面文件的权限无效，请问如何修改？

由于某些特别的操作或者设计，我们需要读取或者去修改system 下面某个具体的文件(不推崇)。
System 文件夹在init.rc 中被描述为 ro (read only)， 即被mount 成ro, 所以即使您再去chmod or chown 某个文件的权限或者所有者，都无法达到目的。需要在system 被remount 成ro 前修改文件权限方可。
您要增加的代码须放置在:
on fs
# mount mtd partitions
    write /proc/bootprof "INIT:NAND:Mount_START"
    # Mount /system rw first to give the filesystem a chance to save a checkpoint
    mount yaffs2 mtd@system /system nandboot
    mkdir /system/secro 0600 system system
    # RIL need to do this before the folder /system changed to read only
    chown radio system /system/etc/ril
    chmod 0770 /system/etc/ril
    chmod 0444 /system/etc/ril/oper.lis
    #Add your code here...

    mount yaffs2 mtd@system /system ro remount nandboot
    mount yaffs2 mtd@userdata /data nosuid nodev nandboot
    mount yaffs2 mtd@cache /cache nosuid nodev nandboot
    write /proc/bootprof "INIT:NAND:Mount_END"

同样对于emmc 的机器，也需要在system 分区被remount 成read only 之前进行调整。
```

## [FAQ02634] 如何为机器增加client id

```
因为client id 包含项比较多，首先和客户确认需要内置的具体的参数，确认具体参数后，即可在

alps/mediatek/config/贵司工程/system.prop 的最后增加:

比如:
ro.com.google.clientidbase.ms = android-americamovil-br
ro.com.google.clientidbase.am = android-americamovil-br
ro.com.google.clientidbase.vs = android-americamovil-br

这些参数一般都是以ro.com.google.clientidbase 开头，具体的值需要和运营商确认后才可以。
```

## [FAQ03128] Android系统中的6种模式

```
1:一般启动模式（normal mode):
    功能是正常启动手机，方法为关机状态下按电源键启动。
2:安全模式（safe mode）:
    此模式和正常启动一样，但没有登记Google，所以不能访问Market或使用你的Google账号。操作方法为按住“menu”键，按电源键启动手机，直至手机启动完成松开“menu”键。
3:恢复模式（recovery mode）
    可打开命令解释程序（shell），刷新映像文件（flash image），执行备份等。当然这一切取决于你手机上的recovery image版本。使用方法很简单，就是home键和电源键一起按。
4:引导模式（bootloader mode）
    功能是从SD卡上安装新的系统映像（DREAIMG.NBH），只需再按一次电源键。值得一提的事为Android手机获取root权限，就是使用这个模式。操作方法为照相键和电源键一起按。
5:fastboot模式
    主要是在电脑上使用fastboot命令来刷新映像文件。使用方法为按住返回键，按电源键启动手机，直至屏幕出现FASTBOOT字样后松开返回键。
6:诊断模式（diagnostic mode）
    是为了测试手机各项功能的模式，刻意通过轨迹球中心键和电源键打开。
```

## [FAQ03308] 安全模式意义？ 如何启动安全模式？ 如何屏蔽安全模式？

```
1.Google 设计来确认在不启动第三方app/service 的情况下，确认机器的稳定性的一个开机方式，通常普通用户很少用到。在framework 内部会影响到AMS&WMS&PMS 的行为。
2.安全模式是在开机system server 的windowmanagerserivce 启动时检测的，一般是power + memu 键 ，并且在开机的过程中还要长按，或者滑轮之类。
3.如何屏蔽，这个最终的检测是在PhoneWindowManager.java 中执行。
alps/frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java 中的detectSafeMode() 方法，请参考里面的
mSafeMode= menuState > 0 ........................................ 
把这一行直接设置为
mSafeMode = false 即可。
在这一行你也可以看到哪些按键对safemode 有影响。
```

## [FAQ04355] 如何手动trigger一个modem exception？

```
1)GB/ICS 版本： adb shell am broadcast -a com.mediatek.mdlogger.FORCE_MODEM_ASSERT，
2)JB版本：adb shell am broadcast -a com.mediatek.mtklogger.ADB_CMD -e cmd_name force_modem_assert --ei cmd_target 2
```

## [FAQ04427] OTA升级不能进入到recovery mode

```
在OTA升级时，手机关机后没有进入到recovery mode，执行失败error提示log：
Error : onSetRebootRecoveryFlag,
engine error to set flag to reboot into recovery mode.
[SOLUTION]
原因：在初始化时没有将应用GoogleOtaBinder设置为user root。
解决：在init.rc中添加以下两行：
1.  service GoogleOtaAgent /system/bin/GoogleOtaBinder
2.  user root
```

## [FAQ05995] 如何把自己的代码包或开源项目的code, 编译进android

```
1.需要加入的是native 程序，即编译成elf 可执行文件，
或是共享库.so，或是lib库.a文件，建议将代码包放在alps\external 下面, 并编写相应的Android.mk 文件，

2.需要加入的是APK 程序或是JAVA lib库.jar文件,建议请将代码包放在alps\packages\apps下面，并编写相应的Android.mk 文件，

3.如何编写Android.mk
请搜索dcc 上文档 How_to_Write_an_Android.mk.pptx && Android_Build_System_for_customer_4.1.pptx  from page 56

4.build 系统在当前路径找到Android.mk 后，就不会在其子目录下搜索Android.mk文件，所以如果
代码包里面还有文件夹，需要include里面的Android.mk 进来
则要在代码包这级目录下的Android.mk 里面调用 include $(call all-makefiles-under,$(LOCAL_PATH)) 

5．Android.mk写完之后，还要将Android.mk 中的LOCAL_MODUEL=xxx，或LOCAL_PACKAGE_NAME=xxx

添加在在PRODUCT_PACKAGES后面：
PRODUCT_PACKAGES += xxx

这样系统在能编译到。

5.1. 编译模拟器时，会将以下文件中的PRODUCT_PACKAGES定义的都编译进去
build/target/product/banyan_addon.mk
build/target/product/sdk.mk
sdk/build/product_sdk.mk
development/build/product_sdk.mk
build/target/product/core.mk

5.2. 编译真机版本是，会将以下文件中的PRODUCT_PACKAGES定义的都编译进去
build/target/product/$project.mk
build/target/product/common.mk
build/target/product/telephony.mk
build/target/product/core.mk

所以如果想使模拟器和真机都编译进去的话，就必须添加到core.mk
```

## [FAQ05739] SD或者OTA升级secutiry device和non-security device的区别！

```
问题现象： 同样的升级包在升级non-security device可以升级成功，升级secutiry device确不能升级成功！

原因说明：SD在升级non-security device和security device的区别是：在升级security device时，SUPPORT_SBOOT_UPDATE这个宏会打开！然后升级security device时会去检查升级包中的SEC_VER.txt这个文件，并且检查SEC_VER.txt这个文件里的CUSTOM_NAME,BOOTIMG,RECOVERY,ANDROID四项，并且要求BOOTIMG,RECOVERY,ANDROID这三项的值要比手机里面这三项的值要相等或者大于手机版本里的值！否则会升级失败！

下面举一个例子来说明，假如bootimg第一版是version 1
1. 空机先烧录进bootimg，则device里面的记录是version 1 2. 假如发现bootimg有security bug，重新编出一版 version
2. 接着烧录，device里面就变成记录的是version 2
3. 假如发现bootimg有security bug，重新编出一版 version 3；接着烧录，device里面就变成记录的是version 3
4. (此时，如果要烧录回去verison 1或version 2，都是不允许的动作)
5. 假如这个时候USER透过OTA去升級，而OTA package记录的BOOTIMG版本號是4，那就允许更新；如果是2或3，都不允许更新
```

## [FAQ05446] 怎样快速拷贝及打包整个binary load（供下载）?

```
在alps目录下：

mkdir new_load
cp -uvL out/target/product/YOUR_PROJ/* new_load/
tar zcvf new_load.tar.gz new_load
```

## [FAQ03887] 为何Monkey测试后不能关机

```
1.连接adb
2.运行monkey test
3.等待monkey test finish
4.长按power 键，选取“关机”，无法弹出是否确定关机的对话框
从log上看，schpwroffreceiver.java在shutdowm()中，

Log.d(TAG, "!!! Request to shutdown !!!");
if (SystemProperties.getBoolean("ro.monkey", false)) {
    Log.d(TAG, "Cannot request to shutdown when Monkey is running, returning.");
    return;
}
可以看出运行monkey的状态，未被复位，导致无法关机。
 
[Solution]
这是敝司特意的设计, 主要针对: 运行Monkey的时候不会意外关闭电源, 以免Monkey Test提早结束。
此部份仅影响Monkey Test, 不影响用户其他使用, 建议贵司保留此项设计, 以免造成Monkey Test时无谓的困扰。
```

## [FAQ08776] 关于Monkey Test自动关机的问题

```
因为Monkey Test过程是随机的发出事件流，有几种可能产生自动关机的情况：通过发送broadcast去调用到关机，模拟powerkey关机，调用setting里面的恢复出厂设置关机等等，这几种发生自动关机的情况都是正常的，但是实际上Monkey Test即使走到关机流程也应该直接return，以保证Monkey Test的其它操作都可以正常进行。

因此如果发生自动关机，请首先check下面几个注意事项，确保Monkey Test的测试条件是正确的：
1. Monkey Test的版本是否是Eng Build？
2. 如果Monkey test没有用我司的脚本，请在Monkey Test之前务必先设置属性:
adb shell setprop ro.monkey true
然后再重新安排Monkey Test测试，如果还有发生自动关机，请务必提供相应的mobilelog。
```

## [FAQ02496] MT6573 Android 拔掉电池开机时间拉长问题

```
Android 采用yaffs2 文件系统， 基于yaffs 的checkpoint 原因，当开机时无法找到checkpoint, 就会scan 对应的patition, 这个时间决定于patition的大小，和文件的数量，从而拉长开机的时间。
当有应用程序在写文件之前，kernel会将checkpoint删除掉，然后在将数据写到flash中，如果这时断电，下次开机的时候就会找不到checkpoint从而scan整个分区，这时yaffs的设计，避免断电导致 checkpoint与分区的具体使用情况不一致。
如果开机不去checkpoint， 有可能会导致整个分区的文件丢失或者文件大小，或者分区的使用情况
```

## [FAQ03652] [FlashTool]flashtool的format whole flash和MDT format and download all的区别

```
对nand flash, 因为有bad block, 两者的行为会有所差异.
对emmc则是无差别的.
 
[Solution]
flashtool的format whole flash, 默认是做logical format,
start address为0x0, length为0x1f5c0000
MDT的format and download all则是做physical format,
start address：0x0, length为0x20000000
 
flashtool和MDT的firmware upgrade均会做format, 并且都是physical format, start address:0x0, length为0x20000000
```

## [FAQ01922] [ATE] Database 在软件中的路径

```
如果是 6573平台:
Modem 的 database path: Alps\mediatek\custom\common\modem\projectname\BPLGUInfoCustomApp_XXX
AP 的 database path: Alps\mediatek\source\cgen\APDB_xxxx  (文件后缀不带 _ENUM 的)

如果是 6516 平台，
MD database路径:Alps\mtk\custom\src\csutom\common\modem\BPLGUInfoCustomApp
AP 的 database 路径为：Alps\mtk\src\cgen\APDB_xxx
```

## [FAQ03465] [FlashTool]按键下载与不按键下载的区别

```
下载可分为按键下载和不按键下载,flashtool可自动识别这两种方式，MDT需要手动切换.
什么情况下可以不按键下载？
产线使用MDT如何进行切换?
 
[Solution]
1 如果空板第一次下载，不用按键. PC端设备管理器中枚举的端口为mtk usb port.
2 如果下载过preloader, 75/77可以不按键下载，直接插usb线. PC枚举出的端口为preloader usb port
3 MDT默认是bootrom -> da, 即空板不按键下载，或者按kcol0下载.
如果产线升级不使用夹具, MDT的download type为firmware upgrade,  usb port的选项需要切换到preloader ->DA
```

## [FAQ04654] 如何修改UART输出数据的波特率

```
有以下3个地方分别控制不同的部分的波特率
1.  设置  preloader  波特率，这里不会设置到uboot和kernel
文件为mediatek/custom/proj/preloader/inc/cus_bldr.h
#define CFG_LOG_BAUDRATE  (115200)

2.   修改uboot 波特率
mediatek/custom/proj/uboot/inc/configs/ubconfigs.h
#define CFG_LOG_BAUDRATE  (115200)

3.  修改kernel 波特率
mediatek/config/mt6575/autoconfig/kconfig/platform
CONFIG_CMDLINE="console=ttyMt3, 115200"
```

## [FAQ04689] Mediatek 释放版本信息

```
MTK 的版本信息一般包括MTK_BRANCH， MTK_BUILD_VERNO， MTK_WEEK_NO 这些参数存储在alps/mediatek/config/common/ProjectConfig.mk 中。在编译时会将这些信息转换成system property 存放在
system/build.prop 文件中，download 到手机后您可以通过:
adb getprop ro.mediatek.version.branch
adb getprop ro.mediatek.version.release
来查看
```

## [FAQ04813] update.zip包中各个文件的含义

```
将全量升级包update.zip包解压后里面的各个文件的含义如下： 
boot.img:(boot.img=kernel+ramdisk) 
system:(升级后会放在系统的system分区。主要用来更新系统的一些应用或则应用会用到的一些库) 
recovery/recovery-from-boot.p:(是boot.img和recovery.img的补丁) 
recovery/etc/install-recovery.sh:(install-recovery.sh是更新脚本) 
META-INF/CERT.RSA:(签名文件相关,保存公匙和加密算法) 
META-INF/CERT.SF:(签名文件相关,保存私匙,CERT代表签名者) 
META-INF/MAINFEST.MF:(这个manifest文件定义了与包的组成结构相关的数据) 
com/google/android/update-binary:(一个脚本解释器，能够识别updater-script中描述的操作) 
com/google/android/updater-script:(脚本文件，具体描述了更新过程)
com/google/android/metadata:(描述设备信息及环境变量的元数据)
```

## [FAQ04879] MTK_LCA_SUPPORT=yes的版本不能开机

```
如果之前拿过手机download 过非LCA 版本的软体，因为LCA 版本和LCA 版本的image 分布不一样，特别是nvram 分布。
//LCA=NO
DSP_BL 0x40000
{

}

__NODL_NVRAM 0x100000
{

}

__NODL_SECCFG 0x600000
{

}

//LCA = YES
DSP_BL 0x40000
{

}

__NODL_NVRAM 0x1c0000
{

}

__NODL_SECCFG 0x4c0000
{

}

flash tool firmware upgrade 不会擦掉NVRAM 数据，导致lk 的image 和原本的nvram 冲突，才导致preloader 验证lk magic code 时fail.

因此需要全部format 一次后，才可以正常开机。
```

## [FAQ04979] 如何修改DVM虚拟机可用Heap大小的上限？

```
a.       对于ICS、ICS2和JB的平台，可以根据以下情况修改：

1.    若是希望修改成为出厂时的默认配置，可以找到build/tools/buildinfo.sh文件，在里面找到如下内容：
echo “dalvik.vm.heapsize=128M”
在此句的后面添加：
echo “dalvik.vm.heapgrowthlimit=64M”

其中64M为Heap增长所能达到的最大值。这个值可以根据需要设定，但是不能超过heapsize的大小，即不能超过上面的128M。此修改会在编译后生效，当编译生成的系统，烧到手机上后，默认的Heap增长的的上限就成为64M。即一个进程所能占用的最大空间不会超过64M。

2.    若不需要量产，只希望修改某一台手机，可以采用如下的办法：
adb pull /system/build.prop C:\build.prop
用文本编辑器打开build.prop找到dalvik.vm.heapsize=128m,在其后面添加dalvik.vm.heapgrowthlimit=64m(若已经有此句，则只需要修改为64m即可)。
然后通过adb push build.prop /system
最后重启手机生效。

b.       对于GB平台只需要按照上述方法修改dalvik.vm.heapsize即可。
```

## [FAQ05337] 修改camera拍照的默认保存路径

```
在ICS & JB & JB2版本上, Camera拍照的默认保存路径的修改方法为, 打开storage.java

将:

public static void updateDefaultDirectory(Activity activity, boolean stillCapture) {
    String defaultPath = StorageManager.getDefaultPath();
    MOUNT_POINT = defaultPath;
    Log.i(TAG, "Write default path =" + defaultPath);

    if (Util.CU) {
        DCIM = stillCapture ? (MOUNT_POINT + "/Photo") : (MOUNT_POINT + "/Video");
        DIRECTORY = DCIM;
    } else {
        DCIM = MOUNT_POINT + "/DCIM";
        DIRECTORY = DCIM + "/Camera";
    }

    BUCKET_ID = String.valueOf(DIRECTORY.toLowerCase().hashCode());

中的DIRECTORY=DCIM+”/Camera” 改为DIRECTORY = 您想要的目录名;

做完以上修改后,拍的照片就会默认保存在您定义的目录下.
```

## [FAQ05088] 如何通过命令行的方式抓取tcpdump

```
下载 tcpdump : wget https://www.androidtcpdump.com/download/4.9.2.1.9.0/tcpdump
如果要抓TCP数据包，我们可以使用TCPdump工具，类似于windows/linux下使用的这个工具一样。先下载tcpdump工具。

你需要root权限，
adb remount
adb push  tcpdump  /data/local/tcpdump
adb shell  chmod  6755  /data/local/tcpdump

抓包很简单
adb shell tcpdump   -w  /sdcard/capture.pcap

以下为其他参数：
# "-p": disable promiscuous mode (doesn't work anyway)
# "-s 0": capture the entire packet
# "-w": write packets to a file (rather than printing to stdout)
   ... do whatever you want to capture, then ^C to stop it ...

导出
adb pull /sdcard/capture.pcap
```

## [FAQ05127] 如何修改wifi重连次数

```
在SupplicantStateTracker.java文件中
修改MAX_RETRIES_ON_AUTHENTICATION_FAILURE的值。
```

## [FAQ05162] [Factory mode] 怎么配置工厂模式测试项？

```
alps/mediatek/custom/$proj/factory/factory.ini 可以定制Factory mode测试项，如：
MenuItem=M-Sensor;
MenuItem=ALS/PS;
Factory mode启动后，会先后寻找 /sdcard/factory.ini,/etc/factory.ini文件，所以可以复制factory.ini文件到SD卡，并修改其中的内容来配置测试项. 若找不到ini文件，则使用factory.c中的默认配置
▪      Related code all in alps/mediatek/factory/src/factory.c:
▪      Golbal test items array:
static item_t ftm_cust_items[ITEM_MAX_IDS]; // factory.ini settings
static item_t ftm_cust_auto_items[ITEM_MAX_IDS];// factory.ini settings
static item_t ftm_test_items[] // Default settings
static item_t ftm_auto_test_items[]  // Default settings
ftm_test_items &&  ftm_auto_test_items controled by MACROS
    (ie. FEATURE_FTM_KEYS/CUSTOM_KERNEL_ALSPS...)
▪      In main:
   read_config(/sdcard/factory.ini or /etc/factory.ini)
         ftm_cust_items = Items in (factory.ini && ftm_test_items)
         ftm_cust_auto_items = Items in (factory.ini &&  ftm_test_items &&  ftm_auto_test_items)
```

## [FAQ04380] [Vibrator] 如何定制vibrator的各种震动模式

```
一般振动时间的配置在如下文件：

frameworks/base/core/res/res/values/config.xml
<!-- 长按振动 -->
<!-- Vibrator pattern for feedback about a long screen/key press -->
<integer-array name="config_longPressVibePattern">
    <item>0</item>
    <item>1</item>
    <item>20</item>
    <item>21</item>
</integer-array>

<!-- 虚拟按键振动 -->
<!-- Vibrator pattern for feedback about touching a virtual key -->
<integer-array name="config_virtualKeyVibePattern">
    <item>0</item>
    <item>10</item>
    <item>20</item>
    <item>30</item>
</integer-array>

<!-- 软键盘按键振动 -->
<!-- Vibrator pattern for a very short but reliable vibration for soft keyboard tap -->
<integer-array name="config_keyboardTapVibePattern">
    <item>40</item>
</integer-array>

<!-- 非安全模式启动振动 -->
<!-- Vibrator pattern for feedback about booting with safe mode disabled -->
<integer-array name="config_safeModeDisabledVibePattern">
    <item>0</item>
    <item>1</item>
    <item>20</item>
    <item>21</item>
</integer-array>

<!-- 安全模式启动振动 -->
<!-- Vibrator pattern for feedback about booting with safe mode disabled -->
<integer-array name="config_safeModeEnabledVibePattern">
    <item>0</item>
    <item>1</item>
    <item>20</item>
    <item>21</item>
    <item>500</item>
    <item>600</item>
</integer-array>

上面以数组形式的表示的，奇数位置表示暂停时间，偶数位置表示振动时间，单位为 ms
```

## [FAQ05443] [Recovery]从data区读取状态来确定升级用内外置卡导致升级不成功

```
升级包有可能会被选择下载到内置卡或外置卡上，而从recovery mode升级时有个自动下载的选项，如果选择存储卡的设置出错，会导致升级不成功。

[客户方solution]
从/data/区域的文件中获知flag，来判断此时升级用的是内置卡还是外置卡。

[客户方risk]
从/data/区域的文件中获知flag ，这种方式涉及到权限问题。对加密过的/data/区，recovery mode下无法访问。加密方式可以通过settings-> phone encrypt设置，也就是说可以由end user设置加密，如果在用户手中设置了加密，normal mode下有界面可以输入密码访问，但是recovery mode下无法做出类似界面，就会导致下一次升级不成功。

[MTK提供的solution]
若有客户需要在recovery mode下同时支持内外置卡，需要在打ALPS00392239的patch之后，并修改bootable/recovery/Android.mk新增-DSUPPORT_SDCARD2，重新new即可。
ifeq ($(WITH_BACKUP_RESTORE),true)
    LOCAL_CFLAGS += -DSUPPORT_DATA_BACKUP_RESTORE -DSUPPORT_SDCARD2
endif

recovery mode就会多出/sdcard2供使用(default为外卡)。
PS：MP branch目前只有上ICS2.MP和JB.MP
```

## [FAQ06720] [Vibrator] 开机震动在哪调用的，怎样关闭?

```
frameworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java

public boolean performHapticFeedbackLw(WindowState win, int effectId, boolean always) {
.... ...
        case HapticFeedbackConstants.SAFE_MODE_DISABLED:
            return ; //正常模式启动， 如果不想震动， 直接return;
            pattern = mSafeModeDisabledVibePattern;
            break;
        case HapticFeedbackConstants.SAFE_MODE_ENABLED:
            return ; //安全模式启动， 如果不想震动， 直接return;
            pattern = mSafeModeEnabledVibePattern;
            break;
        default:
            return false;
    }
}
```

## [FAQ06717] [General] 如何快速搜索、定位ALPS代码目录中的文件?

```
在alps目录中， 执行如下命令可以获得额外的 shell命令，
source build/envsetup.sh
比较常用的一个功能是： godir

第一次执行此命令时会在alps创建名为filelist的索引文件， 需要花费一点时间，后面执行此命令会非常快。 请试下如下命令列出GPIO 相关的目录：
godir gpio

如下命令会在所有的C/C++文件中搜索gpio_set_output_value字符串
cgrep gpio_set_output_value

类似的jgrep是查找本地所有java文件，例如：
godir PhoneWindow.java

resgrep是查找本地所有资源文件res/*.xml

croot命令 :改变到ALPS顶层目录
```

## [FAQ06721] [UART] 如何通过串口进入敲 shell 命令?

```
Uart Tx Rx 在DCT中分别配制成  UTXD URXD模式。

Tx Rx 通过串口线和PC连接。确认Uart 能吐 log，此时PC串口软件（如超级终端）中敲回车，会出现输入提示符，可以敲 shell 命令了。

如不能输入， 请检查如下命令的输出：
1.  adb shell cat /proc/cmdline 可以看到Uart 输入输出的端口。
2.  adb shell cat /init.rc 确认有如下内容：
service console /system/bin/sh
    class core
    console
    disabled
    user root
    group log

on property:ro.debuggable=1
    start console

3. adb shell getprop ro.debuggable
    确认其值为 1

若上述都正确，请提供上述输出，并抓取板上 Tx Rx 的波形图，附在eService上供后续分析。
```

## [FAQ06711] [modem] 如何修改、更新modem?

```
所有类型的modem都放在./mediatek/custom/common/modem/ 目录下

可以在ProjectConfig.mk下修改modem的类型:
alps/mediatek/config/$YOUR_PROJECT/ProjectConfig.mk
CUSTOM_MODEM=YOUR_MODEM

执行如下编译命令，
./mk update-modem
这个命令会依次做如下步骤
1. custgen
2. check modem
3. sign modem
4. update modem

完成后重新烧写 System image
```

## [FAQ04656] 如何修改Android自带浏览器的User Agent

```
Android自带浏览器的User Agent是Android这个代理，但是访问一些特殊网页，排版等布局不正常，可能其他浏览器正常，这是因为其他浏览器是用的其他代理，目前来说有Android、Destop、iphone、ipad、Froyo-N1、Honeycomb-Xoom等代理，这个可以从UI或Code去作修改。

[SOLUTION]
一、UI修改UA
进入手机端浏览器界面，在地址栏输入about:debug(注意冒号是英文的冒号)后，触摸输入法键盘的回车键
再触摸Menu按钮，调出选项菜单，进入设置界面，在设置菜单下有一个调试菜单，触摸“调试”，再点击UAstring，换一个UA登录。

二、Code修改UA
在Browser的代码BrowserSettings.java里有设置UserAgent的位置，可以修改。

Note：
当然UA如果是operator定制的，一般是不能改的 。
```

## [FAQ08500] android 键盘中如何加入一个Rupee货币的符号

```
1.在android键盘中添加一个按键
以ICS为例，JB及之后的版本只要找到对应的xml文件，做相同改动即可：
如果要在所有的语言的符号中都添加一个符号，则只需要在packages\inputmethods\LatinIME\java\res\xml下的kbd_rows_symbols_shift.xml中增加一个key的item，其设置如下即可latin:keylabel="\u20B9"

如果只需要在在印度输入法的界面增加，则

则只需要把上面的文件copy到packages\inputmethods\LatinIME\java\res\xml_hi下，并做与上面相同的改动。具体的key item要增加在第几行，可以更具你们的需求在对应的行中增加即可。

2.在键盘调出的符号集中,将某个符号修改为卢比符号
只要在输入法的xml中把你想要修改的字符改成卢比符号即可。例如在JB及之后的版本只要在\packages\inputmethods\LatinIME\java\res\xml\key_styles_currency_dollar.xml中的
latin:keyLabel="$"
改为
latin:keyLabel="\u20b9"
就可以把美元符号改为卢比符号，如果要改动其他的符号，只要把其他符号修改即可。
```

## [FAQ08166] [Legacy Wi-Fi] factory mode 中怎样使wifi自动连接指定AP

```
假设当前您的手机处于factory mode ，测试wifi功能时想要手机自动连接SSID名为tp-link的AP
将alps\mediatek\custom\[project]\factory\factory.ini 中的

WIFI.SSID=mtkguest
改为WIFI.SSID=tp-link
```

## [FAQ04081] TTY功能简介

```
TTY这个功能是专为有听说障碍的残障人士使用的电传打字机(TTY) 功能，这项功能可以让听障人士使用现有的电话基础设施（包括行动电话）进行沟通。
这个功能是Google在Android 2.3中引入的功能，MTK目前对于这一功能保持Google的设计，基本没有做修改。
这个功能的测试需要有特殊的TTY外接设备以及当地运营商网络的支持，目前世界上北美地区的运营商网络（例如美国、墨西哥等）支持这个功能。若是手机项目市场没有在上述国家和地区，也可以考虑将这个功能关闭。开关的方式是在对用工程下面的ProjectConfig.mk文件中设置MTK_TTY_SUPPORT。

注意：TTY与VT有冲突，不能同时打开，即MTK_TTY_SUPPORT与MTK_3G324M_SUPPORT不能同时为yes
```

## [FAQ08070] 支持彩信发送报告提示

```
请在PushReceiver.java 中，当接收到MESSAGE_TYPE_DELIVERY_IND 时，从Pdu中获取联系人号码，并新建一个thread 去show，具体修改参考如下（GB3的代码为例，其他平台也是类似的）：

在PushReceiver.java 中导入：

import com.google.android.mms.pdu.EncodedStringValue;

import andriod.widget.Toast;

import android.os.Handler;

 

将doInBackground(Intent... intents) 方法修改如下：

try {
    switch (type) {
        case MESSAGE_TYPE_DELIVERY_IND:
            Xlog.d(MmsApp.TXN_TAG, "type=MESSAGE_TYPE_DELIVERY_IND");
        case MESSAGE_TYPE_READ_ORIG_IND: {
            Xlog.d(MmsApp.TXN_TAG, "type=MESSAGE_TYPE_READ_ORIG_IND");
            threadId = findThreadId(mContext, pdu, type);
            if (threadId == -1) {
                // The associated SendReq isn't found, therefore skip
                // processing this PDU.
                break;
            }

            Uri uri = p.persist(pdu, Inbox.CONTENT_URI);
            // Update thread ID for ReadOrigInd & DeliveryInd.
            ContentValues values = new ContentValues(1);
            values.put(Mms.THREAD_ID, threadId);
            SqliteWrapper.update(mContext, cr, uri, values, null, null);

        if(type==MESSAGE_TYPE_DELIVERY_IND){
        Xlog.d (MmsApp.TXN_TAG, "MTK show delivery toast");
            //MessagingNotification.blockingUpdateNewMessageIndicator(PushReceiver.this, false, true);
        final long timeMillis = 3000;
      //String address = pdu.getFrom().getString();
       String getTo = (EncodedStringValue.concat(((DeliveryInd)pdu).getTo()));
       Xlog.d (MmsApp.TXN_TAG, "MTK type=MESSAGE_TYPE_DELIVERY_IND sendTo=" + getTo);
       final String message1 = mContext.getString(R.string.delivery_toast_body,getTo) ;
        mToastHandler.post(new Runnable() {
                 public void run() {
                 Toast.makeText(mContext, message1, (int)timeMillis).show();
                }
            });
       //Toast.makeText(this, message1, (int)timeMIllis).show;

            }
            break;
        }
```

## [FAQ04462] 如何配置camera的feature table

```
配置camera 的feature table请按照如下进行：
RAW sensor 配置feature table涉及的文件,以main sensor为例，若是sub sensor，对应file name为*_sub.h

1）  alps\mediatek\custom\project name\hal\camera\camera\cfg_ftbl_custom_raw_main.h

2）  alps\mediatek\custom\common\hal\camera\camera\cfg_ftbl_custom_raw_main.h

YUV sensor 配置feature table涉及的文件,以main sensor为例，若是sub sensor，对应file name为*_sub.h

1）  alps\mediatek\custom\project name\hal\camera\camera\cfg_ftbl_custom_yuv_main.h

2）  alps\mediatek\custom\common\hal\camera\camera\cfg_ftbl_custom_yuv_main.h

3）  alps\mediatek\custom\common\hal\imgsensor\xxx_yuv\cfg_ftbl_xxx_yuv.h

注：xxx 是Sensor 的型号，比如OV5647

文件优先级规则：

对RAW/YUV sensor 涉及的配置文件，其生效优先级1） >  2） > 3）

即如果project name下有相应的文件，则仅需配置该文件，如没有再去配置common下的相应文件

配置方式：
#if 0/#if 1 控制feature的关闭/打开

BY_DEFAULT() 设定feature default值

BY_DEFAULT() 后面的枚举是feature的support Item

以Flash Light 为例，初始是配置如下

#if 0

    //  Flash Light

    CONFIG_FEATURE(FID_AE_STROBE,

        BY_DEFAULT(FLASHLIGHT_FORCE_OFF),

        FLASHLIGHT_AUTO, FLASHLIGHT_FORCE_ON, FLASHLIGHT_FORCE_OFF

    )

#endif

则表示项目上没有配置打开闪光灯功能，UI上也不会有闪光灯相关的菜单选项

如果需要配置打开Flash Light的feature，且想把default值修改为AUTO，另增加对TORCH的支持

则需要修改配置如下

#if 1

    //  Flash Light

    CONFIG_FEATURE(FID_AE_STROBE,

        BY_DEFAULT(FLASHLIGHT_AUTO),

        FLASHLIGHT_AUTO, FLASHLIGHT_FORCE_ON, FLASHLIGHT_FORCE_OFF,

                 FLASHLIGHT_TORCH

    )

#endif
```

## [FAQ07476] 如何添加一个固定的share uid

```
系统中已经定义了大量的系统UID ，如在system/core/include/private/android_filesystem_config.h 中的定义AID_SYSTEM, AID_ROOT 等
(1). 在android_filesystem_config.h 中,  对应的ID 不能够重复 "XXXX" 即您自己要添加的UID 的名字
#define  AID_XXXX          10KK  /* dhcp client */

(2). 在android_id_info android_ids 中定义具体的uid 的名称
{ "XXXXX",    AID_XXXX, },

(3). 在alps/frameworks/base/service/java/……/PackageManagerService.java 中添加
public PackageManagerService(Context context, Installer installer, boolean factoryTest, boolean onlyCore) {
的初始化中添加一行：
    mSettings.addSharedUserLPw("android.uid.system", Process.SYSTEM_UID, ApplicationInfo.FLAG_SYSTEM);
    mSettings.addSharedUserLPw("android.uid.phone", RADIO_UID, ApplicationInfo.FLAG_SYSTEM);
    mSettings.addSharedUserLPw("android.uid.log", LOG_UID, ApplicationInfo.FLAG_SYSTEM);
    mSettings.addSharedUserLPw("android.uid.nfc", NFC_UID, ApplicationInfo.FLAG_SYSTEM);
    mSettings.addSharedUserLPw("android.uid.bluetooth", BLUETOOTH_UID, ApplicationInfo.FLAG_SYSTEM);
    //add by Yanghui Li for new uid
     mSettings.addSharedUserLPw("android.uid.xxxx ", XXXX_UID, ApplicationInfo.FLAG_SYSTEM);

同时在PackageManagerService.java 中定义
     private static final int XXXX_UID = Process.XXXX_UID;

(4). 在frameworks/base/core/java/android/os/Process.java 中定义这个XXXX_UID 的值和android_filesystem_config.h 定义的值完全相等。
这样就可以在APP 中使用这个uid 了。具体如何使用，您可以参考如Settings app, 以及 Phone app 的AndroidManifest.xml 的写法. 
```

## [FAQ07802] 短信编译界面的软键盘上表情键修改为回车键

```
在\packages\apps\Mms\res\layout_xxx\compose_message_activity.xml中
<EditText
    android:textColor="@android:color/black"
    android:id="@+id/embedded_text_editor"
    android:layout_width="0dip"
    android:layout_gravity="bottom"
    android:layout_height="wrap_content"
    android:layout_weight="1.0"
    android:layout_marginLeft="8dip"
    android:autoText="true"
    android:textSize="16sp"
    android:capitalize="sentences"
    android:nextFocusRight="@+id/send_button"
    android:hint="@string/type_to_compose_text_enter_to_send"
    android:minHeight="@dimen/input_text_height"
    android:maxLines="3"
    android:inputType="textShortMessage|textAutoCorrect|textCapSentences|textMultiLine"     //去掉 textShortMessage 即可
    android:imeOptions="actionDone|flagNoEnterAction"
/>
这样就可以直接显示回车符了。
```

## [FAQ03739] 通过adb shell操作WIFI

```
1   ICS2及以前版本
打开wifi：

#adb shell
#cd   /sys/class/rfkill/rfkill1/
#cat  type                #输出值如果为wlan，则直接下一步，否则进入rfkill0，然后执行下一步
#echo  1 > state

关闭wifi：
同理，如果wifi已经打开，关闭wifi使用命令：
#echo  0 > state

如果要执行具体的命令，比如扫描，连接等，那么就需要wpa_cli工具，但是该工具是建立在supplicant启动基础上的，而supplicant的执行又建立在wifi加载的基础上。

打开supplicant：

#adb shell
#cd system/bin/
#./wpa_supplicant -Dwext -iwlan0 -c/data/misc/wifi/wpa_supplicant.conf

(如果配置文件不在上述目录，请使用这个路径：/system/etc/wifi/wpa_supplicant.conf)
(上述命令执行后会阻塞在命令行，如果要执行其他命令，请另开一个命令行界面)
(判断wifi或者supplicant是否运行起来，可以通过ps命令查看是否有tx_thread和./wpa_supplicant进程)

运行wpa_cli:

#adb shell
#wpa_cli
(如果上面命令不成功，请执行：wpa_cli  –p  /data/misc/wpa_supplicant)

接着就可以执行各种命令了，可以使用h参数查看wpa_cli有哪些命令可用，
比如有scan，scan_results等

2 JB版本

1. 启动wifi driver
echo 1 > /dev/wmtWifi

2. 启动supplicant
cd  /system/bin
./wpa_supplicant  -iwlan0  -Dnl80211 -c/system/etc/wifi/wpa_supplicant.conf

3. 启动wpa_cli
cd  /system/bin
wpa_cli -p /data/misc/wpa_supplicant
启动以后可以通过help获得帮助信息。

3 JB2版本
1. 启动wifi driver
echo 1 > /dev/wmtWifi

2. 启动supplicant
cd  /system/bin
iwpriv wlan0 set_p2p_mode 0 0
iwpriv wlan0 set_p2p_mode 1 0
./wpa_supplicant -iwlan0 -Dnl80211 -c/data/misc/wifi/wpa_supplicant.conf -N -ip2p0 -Dnl80211 -c/data/misc/wifi/p2p_supplicant.conf

3. 启动wpa_cli
cd  /system/bin
wpa_cli -p /data/misc/wpa_supplicant
启动以后可以通过help获得帮助信息。

关于内容中的iwpriv工具，如何获取，可以参考：

ID: FAQ03969
如何自己编译wireless tool

关于wpa_cli下的连接AP的操作，可以参考：

ID: FAQ03738
通过wpa_cli连接一个AP
```

## [FAQ07636] 如何让NFC在开机时默认关闭

```
将alps/packages/apps/Nfc/src/com/android/nfc/NfcService.java文件中的
static final boolean NFC_ON_DEFAULT = true;
改为
static final boolean NFC_ON_DEFAULT = false;
即可
```

## [FAQ07877] WFD(WiFi Display)和蓝牙为何不能同时打开

```
this is MTK design limitation。
Due to BT and WiFi share the same RF antenna, 
enabling BT(it will trigger BT search device) will effect WFD streaming
Use alarm dialog to notify user WFD/BT excluded
```

## [FAQ06827] 如何内置iperf到手机中

```
1. 将iperf放到Codebase的任意一个目录下(该目录必须能够在搜索Android.mk时被搜索到)，比如system/iperf/iperf
2. 在system/iperf目录下添加一个Android.mk文件，内容如下：
LOCAL_PATH:= $(call my-dir)
PRODUCT_COPY_FILES += $(LOCAL_PATH)/iperf:system/iperf/iperf

重新编译Codebase即可。
```

## [FAQ03425] “ 设置>安全>设置管理器 “ 功能是做什么的？

```
1、 Android SDK提供了一个可管理和操作设备的API叫DevicePolicyManager，使用这个API你可以接管手机的管理权限，对手机做出系统操作，比如清除所有数据、更改屏幕解锁密码、设置密码规则、监视屏幕解锁尝试次数、锁定屏幕等操作。

如何使用DevicePolicyManager：
(1) 首先，要想调用DevicePolicyManager，必须先要注册admin权限，有了admin权限，才可能对系统进行上述功能的操作。
(2) 其次，程序在启动激活的时候，会给用户相应提示，只有当用户点击“激活”后，自己定义的代码才能真正的运转。

2、安装自定义的设备管理器后，在设置>安全>设备管理器中看到自定义的设备管理器，可以激活此设备管理器，让自定义的设备管理器执行定义的系统操作。
开发设备管理器示例：
示例图：

代码：
(1) app中定义一个类继承DeviceAdminReceiver ，用来监听权限的变化。
(2) 在Manifest.xml中定义
(3) xml/device_admin.xml代码
```

## [FAQ07241] 如何添加一个jni库模块到整理编译中?

```
如在alps\packages\apps\Settings目录下增加目录，增加jni和android.mk文件 ，执行./mk mm packages\apps\Settings目录，是可以看到有jni的.so库文件生成到out\target\product\ztenj89_cu_jb\system\lib目录下，但执行./mk new时，没有生成相对应的so库。

[SOLUTION]
1.alps\packages\apps\Settings 下的 Android.mk文件，将LOCAL_MODULE_TAGS设定为optional。
2.修改build\target\product\$project.mk文件，将所添加的module name添加到PRODUCT_PACKAGES中。
```

## [FAQ04297] 如何确认一个应用程序的安装位置

```
Google 默认 PackageManager 管理安装包的机制如下 (按照优先级由高到低描述，如果高优先级的条件被满足, 则不继续参考较低优先级的选项)：

1.安装应用到SD卡，需要指定install flag: adb install –s      ***.apk
该设置拥有最高优先级，最终安装结果以这个为准，不管下面2个的配置.

2.若没有特别指定1中的install flag,将会检查 AndroidManifest.xml中android:installLocation的定义。
manifest的設定細分為：
android:installLocation = "auto"，表示先查看手机内存是否足够，如果够就安装在手机内存上，不够就安装在 T 卡上；
android:installLocation = "internalOnly"，表示安装在手机内存上；
android:installLocation = "preferExternal" ，表示安装在 T 卡上；

3.若AndroidManifest.xml中没有定义installLocation，则参考“设置”-“存储”-“首选安装位置”
首选安装位置会有3个选项：由系统决定，手机内存，手机存储。

注意：“首选安装位置”默认是关闭的，我们也不建议开启。因为有些应用google默认是要安装在手机内存中，若因为这个“首选安装位置”将应用安装到sd卡上，可能会导致cts测试失败。
```

## [FAQ06599] eng版本，同时长按上下音量键手机重启问题

```
1. eng版本，同时长按vol up + down(> 15 sec)，MTK当前设计会触发KDB（linux内核调试器），此时可通过UART从command line下指令debug，如果2分钟内没有任何输入，系统就会主动触发kernel panic，进而重启。kernel log会印出如下信息：
         KDB force kernel panic
2. user版本，不会存在这个问题，因此，对于最终用户没有影响。
 
**注: KDB的使用可以参考《Debugger_User Guide_xxxx_yy》，其中xxxx表示平台（如MT6577），yy表示android版本（如4.1），相关客户文档可以在http://dcc.mediatek.com下载。
```

## [FAQ09283] import android.support.v4, 提示 does not exist

```
如果贵司在改写 android 某些apk 源码时
有使用到 android.support.v4 包中的元素, 比如 view
但在文件头去 import android.support.v4.view
却会提示此包或 class 不存在
 
[SOLUTION]
需要修改这只 apk 的 mk 文件(android.mk)
找到 LOCAL_STATIC_JAVA_LIBRARIES 的定义
在其后面加入: android-support-v4
 
下面是一个例子:
修改前:
LOCAL_STATIC_JAVA_LIBRARIES := android-common-carousel \
                               com.mediatek.systemui.ext
 
修改后:
LOCAL_STATIC_JAVA_LIBRARIES := android-common-carousel \
                               com.mediatek.systemui.ext \
                               android-support-v4
 
 
 
同理, 如果是用到了 android.support.v13 中的 class
也需要在上述定义中追加 android-support-v13
```

## [FAQ09180] 语言和输入法下的pico TTS设置界面标题显示不正确

```
在TtsEngineSettingsFragment.java中的onCreat函数最后面增加如下语句：
getActivity().setTitle(getEngineLabel());
```

## [FAQ08998] MTK DRM 常见问题介绍

```
主要介绍MTK支持的DRM Widevine Level; WV与DRM feature option的开关;play movies play videos popups couldn't fetch license (error 43)
 
[SOLUTION]
一、DRM 基本信息：

1.       MTK DRM support Level：

OMA DRM V1.0

Widevine L3.

2.       OMA DRM support MIME format：

a.       DRM content MIME:

    application/vnd.oma.drm.content ---- .dcf

    application/vnd.oma.drm.message ---- .dm

b.       权限文件的MIME:

    application/vnd.oma.drm.rights+wbxml ---- .drc

    application/vnd.oma.drm.rights+xml ----- .dr

c.       MTK支持的非DRM protected的Image/Audio/Video格式，DRM就支持此media格式。DRM只是做了权限控制而已，DRM能支持的media格式就是Decoder能支持的格式。

3.       OMA DRM support types：

Default support ForwardLock, Combined Delivery, Seperate Delivery, ForwardLock_SeperateDelivery Total 4 types.

二、WV与OMA的feature option

Please follow the description section 2.3 below:

 

1 Introduction

Currently on JB SW packages, we've got 2 DRM features supported: OMA DRM v1.0 and Widevine DRM Level 3. By default these 2 DRM features are enabled.

This document describes how to disable these 2 features separately, or both.

 

2 Steps

 

2.1 Disable Widevine DRM Level 3 but keep OMA DRM v1.0 enabled

>> Define "MTK_WVDRM_SUPPORT=no" in your source file:

[alps/mediatek/config/$project/ProjectConfig.mk]

This overrides the default value.

>> Fully remake your software codebase.

 

2.2 Disable both Widevine DRM Level 3 and OMA DRM v1.0

>> Define "MTK_WVDRM_SUPPORT=no" and "MTK_DRM_APP=no" in your source file:

[alps/mediatek/config/$project/ProjectConfig.mk]

This overrides the default value.

>> Fully remake your software codebase.

 

2.3 Disable OMA DRM v1.0 but keep Widevine DRM Level 3 enabled

>> Define "MTK_DRM_APP=no" in your source file:

[alps/mediatek/config/$project/ProjectConfig.mk]

This overrides the default value.

>> Find the source file:

[alps/packages/providers/DrmProvider/src/com/android/providers/drm/BootCompletedReceiver.java]

In the overridden method "public void onReceive(...)", you shall find an "if (FeatureOption.MTK_DRM_APP) {...}" judgment part. Remove the "if" judgment so that those code can be executed at boot-up time.

>> You also need to make sure some utility libraries are installed on device.

Find the source file:

[alps/build/target/product/common.mk]

You shall then find the following part:

----------------------------------------------------------------------------

  ifeq ($(strip $(MTK_DRM_APP)),yes)

    PRODUCT_PACKAGES += \

      libdrmmtkplugin \

      drm_chmod \

      libdcfdecoderjni

  endif

----------------------------------------------------------------------------

Modify it as below to make sure "libdrmmtkplugin" & "libdrmmtkutil.so" is installed on device when "MTK_DRM_APP" is disabled.

----------------------------------------------------------------------------

PRODUCT_PACKAGES += libdrmmtkplugin

  ifeq ($(strip $(MTK_DRM_APP)),yes)

    PRODUCT_PACKAGES += \

      drm_chmod \

      libdcfdecoderjni

  endif

----------------------------------------------------------------------------

>> Fully remake your software codebase.

 

三、打开FL_ONLY的方法

You'll need to add "PRODUCT_PROPERTY_OVERRIDES" definition in order to set system property which enables "Forward-lock-only".

For example, you may modify the file: alps/build/target/product/common.mk

And add the following, which add the system property [drm.forwardlock.only], and set its value:

 

ifeq ($(strip $(MTK_DRM_APP)),yes)

  PRODUCT_PROPERTY_OVERRIDES += \

    drm.forwardlock.only=true

endif

 

Then it will disable the support for CD/SD of OMA DRM v1.0 feature.

 

四、OMA drm 测试网址

http://202.108.92.230


 

五、DRM专利问题

OMA不涉及到什么权限专利的问题, widevine见下面一点。

 

六、Widevine白名单问题

Widevine如果是要播google play store上的视频，需要加入google白名单，与google签协议。

log中有couldn't fetch license (error 43)的字样，表示是此问题。

以下引用Google早前答复的内容：

 

“...the devices must be offcially approved in order to be whitelisted and, therefore, be able to access the production WV contents. ...(one of the OEM) is our partner and they are not supposed to have Google Play in the first place. Please let them know they cannot use Google Play without license.”
```

## [FAQ09336] 获取data区剩余空间的API

```
import android.os.StatFs;

import android.os.Environment;

final StatFs internalStats = new StatFs(Environment.getDataDirectory().getPath());

final long availInternalSize = (long) internalStats.getAvailableBlocks() * (long) internalStats.getBlockSize();

上面availInternalSize就是data区的剩余空间。
```

## [FAQ09330] How to catch early kernel log in mobilelog

```
Because of the printk buffer size restrict, some early printk log is flushed away, so we usually can't see early printk log in mobilelog(kernel_log.boot).
 
We can modify the code to increase the buffer size to catch those early log:
 
alps/kernel/kernel/printk.c
#define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)
====>  Let buffer size x 32
#define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT << 5)
 
Caution:  Only apply this code change in debug time!
```

## [FAQ08536] android 如何获取与设置process 的uid

```
linux 中uid 包括
uid: real UID of the task
suid: saved UID of the task
euid: effective UID of the task
fsuid: UID for VFS ops

Kernel 层: cred.h 中有相关的API 常用的有task_uid(task) ;  current_uid();
Native 层：unistd.h 中getuid/setuid/getresuid/setresuid 等system call
Java 层： android.os.Process 类中提供了相关的方法：自身的uid myuid();  根据pid 查询: getUidForPid(); 设置uid: setUid();

命令操作: adb shell ps 第一列就是对应的uid, 完整的资讯可以通过 adb shell cat proc/[PID]status 获取，如:
1|root@android:/system/bin # cat /proc/6699/status
cat /proc/6699/status
Name:   ek.atci.service
State:  S (sleeping)
Tgid:   6699
Pid:    6699
PPid:   5301
TracerPid:      0
Uid:    1000    1000    1000    1000
Gid:    1000    1000    1000    1000
FDSize: 256
Groups: 1015 1028 3001 3002 3003 3005 3006
```

## [FAQ08161] Android SDK 中找不到android.os.SystemProperties 类

```
System Properties 作为系统的的关键属性，涉及到系统的一些机密信息，Google 不希望普通的APP 读取这些机密信息。
于是Google 将android.os.SystemProperties 标注成hidden API, 那么就不会包含在android SDK 的android.jar 当中，从而无法直接引用。
 
修正方法:
在SDK 目录： SDK_DIR/platforms/android-xx/data 下面有一个layoutlib.jar， 可以引用这个java lib, 里面有包含android.os.SystemProperties
这个class, 注意的是，需要确认在eclipse 里面的Java Build Path -> Order and Export 里面 不 选中这个lib, 否则最后export apk 时，会直接将这个lib 
打包到APK 当中，一方面可能和手机本身的API 不兼容，另外一方面增大了APK 包。 

[相关FAQ]
FAQ04349: 不能添加system property, 提示： permission denied uid:xxxxx  name:xxxxx
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ03778: 如何对system property 进行扩容 
FAQ06739: system property 设置失败的可能性分析和初步诊断
```

## [FAQ09104] 进入应用界面后发现会闪屏，此时要如何定位是否是relaunch activity引起的闪屏呢？

```
1 对于这类问题，抓取log时记得要打开AMS的log开关：
adb shell dumpsys activity log a on
2 请在main log里搜索Relaunching关键字，看下这个Activity是否有被Relaunching，如果是，那么闪屏就是这个原因了。
3 确定是Relaunching造成的问题后，要如何进一步定位问题呢？
AMS会relaunching activity的原因是：
config发生变化，而activity没有监听对应的config，AMS就会relaunch这个activity，现象上来讲就是屏幕会闪。
我们可以从log里查看下是哪些config发生了变化，然后请app端监听这个config，重写onConfiguartionChanged这个函数来处理config的变化。那么AMS就不会去relaunch这个activity了。
Apk监听config的方法为：
在apk的androidManifest.xml里设定
<android:configChanges=“layout_direction|locale|….”>
对于检查是哪些config发生变化，可以看main log。
举例：
V ActivityManager: Checking to restart yuku.perekammp3.ac.DaftarActivity: changed=0x2004, handles=0x4a4, newConfig={1.0 460mcc2mnc zh_CN ldltr sw320dp w320dp h508dp 240dpi nrml long port finger -keyb/v/h dpad/v skin=/system/framework/framework-res.apk s.11}
请注意红色字体：changed=0x2004
这个changed的值可以在ActivityInfo.java中查询，具体是CONFIG_开头的值。表示的含义就是当前这些config发生了变化。
比如0x2004就是CONFIG_LOCALE|CONFIG_LAYOUT_DIRECTION
注：
1        apk可以监听的config，请查询google的说明文档或者configuration class里的定义
Google的说明文档：
http://developer.android.com/guide/topics/manifest/activity-element.html
2 闪屏有很多原因，这里描述的只是一种。即AMS Relaunch Activity造成的闪屏。
```

## [FAQ09105] 开发人员选项中设置不容许后台进程,进入音乐等退出后此进程依然在后台运行

```
1 这是google的设计，对比机现象一致
2 原因是不保留后台进程，只针对adj大于9的process
若process带有service，adj会小于等于9，所以您进入音乐后退出，音乐在后台依然会运行。
```

## [FAQ09373] 互动屏保时点击屏幕，会直接解锁进入主菜单

```
因为互动屏保显示时，在DreamService.java的attach方法中，会添加FLAG_DISMISS_KEYGUARD。这个flag会引起PhoneWindowManager.java的finishPostLayoutPolicyLw方法去呼叫KeyguardViewMediator的keyguardDone方法解锁。
 
如果不想在互动屏保显示时解锁，请去掉这个flag即可。但是建议维持google default design。
```

## [FAQ08993] DialerSearch不能搜索含”.”号的联系

```
1.       新建联系人， 点击姓名后的下拉选项，将”abc.efg ”设置为名字
2.       输入号码，保存
3.       进入dialer拨号 334 (efg), 不能搜索出abc.efg这一联系人
[SOLUTION]
在"ContactsDatabaseHelper.java"的方法"setNameForDialerSearch() "开始部分添加如下code：
-----------------------------------------------------------------------------------
if (displayNamePrimary != null) {
    displayNamePrimary = displayNamePrimary.replace('.', ' ');
}
if (displayNameAlternative != null) {
    displayNameAlternative = displayNameAlternative.replace('.', ' ');
}
------------------------------------------------------------------------------------------------
```

## [FAQ09002] 阿拉伯语下，为何添加账户时输入密码区域的提示语左对齐

```
1.预置条件：
系统语言设置为阿拉伯语
2.操作步骤：
电子邮件-账户设置
【实际结果】
用户名输入在右边，密码输入在左边
[SOLUTION]
这是google默认的设计，android4.2.1及以后的版本密码编辑框都是按照从左向右显示的。
如果确实需要实现居右可以按照如下修改：
TextView.java(alps\frameworks\base\core\java\android\widget)
TextDirectionHeuristic getTextDirectionHeuristic() {
    if (hasPasswordTransformationMethod()) {
        // passwords fields should be LTR
        return TextDirectionHeuristics.LTR;//改为 return TextDirectionHeuristics. LOCALE
    }
```

## [FAQ03091] 如何限制计算器输入框输入多个无效“0”

```
在Logic.java中修改方法acceptInsert，增加红色标注的语句：

boolean acceptInsert(String delta) {
    String text = getText();
    //mtk added for calculator
    if (text.equals("0") && delta.equals("0")) {
        //return false;
        //mtk added for calculator
        return !mIsError && (!mResult.equals(text) || isOperator(delta) || mDisplay.getSelectionStart() != text.length());
    }
}
```

## [FAQ07239] SD卡配置方案介绍

```
由于MTK Default Release的SD卡方案以内置SD卡为主（支持EMMC双卡）,但内置SD容量较小而容易塞满，且不能有效利用外置SD卡空间。
[SOLUTION]
针对此问题，MTK开发几种SD卡的配置方案，具体信息可参考如下：
视频：
MTK On Line上搜索“SD卡配置方案介绍”，此视频分别介绍了：MTK offical方案，sdswap外部sd卡优先方案，完全无内置sd方案，shared sdcard方案，FAT on nand方案。
其中JB/JB2/JB3/JB5的修改方法同ICS,但除fat on nand方案之外，其他方案在JB/JB2/JB3/JB5上都不需申请patch。
文档：
1.      DCC上下载“SD卡配置方案介绍.pptx”,该文档属于上述视频对应的文档；
2.      DCC上下载“Multi-Storage_Application_Note”这篇文档，该文档介绍EMMC双卡下的方案（外置sd卡优先方案、无内置sd卡方案）；
3.      DCC上下载“Shared sdcard Appliction Note_V1.0”这篇文档,该文档介绍内置sd卡与data分区共享空间的方案
4.      DCC上下载“FAT on NAND Application Note”这篇文档，该文档介绍在nand flash上虚拟出一块区域当作内置sd卡使用的方案
```

## [FAQ04501] 如何去掉横竖屏切换时的转屏动画？

```
性能不好的手机上，当在横竖屏画面之间进行切换时会觉得屏幕有些卡。如果在“设置”-> “开发人员选项”中关掉窗口过渡动画，就不会有卡的问题，但这样一来，所有窗口画面的动画切换效果都没有了。如果只想在横竖屏切换时关掉切换动画，应该如何实现呢？
[SOLUTION]
可以修改WindowManagerService.java中的boolean值：static final boolean CUSTOM_SCREEN_ROTATION = true;  把默认的true修改成false，然后重新mm frameworks/base/services/java，并把新生成的services.jar档案push到手机，reboot手机。
```

## [FAQ04500] 如何客制化某两个activity切换时的窗口动画?

```
Activity.java中提供了一个可供ap端override窗口切换动画效果的方法：
public void overridePendingTransition(int enterAnim, int exitAnim)
以Launcher中使用这个API的代码为例：
// Launcher.java
public void onClickVoiceButton(View v) {
    v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
    try {
        final SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
        ComponentName activityName = searchManager.getGlobalSearchActivity();
        Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        if (activityName != null) {
            intent.setPackage(activityName.getPackageName());
        }
        startActivity(null, intent, "onClickVoiceButton");
        // R.anim.fade_in_fast和R.anim.fade_out_fast分别表示要启动的activity 窗口的enterAnim资源ID和exitAnim资源ID
        overridePendingTransition(R.anim.fade_in_fast, R.anim.fade_out_fast);
    } catch (ActivityNotFoundException e) {
        Intent intent = new Intent(RecognizerIntent.ACTION_WEB_SEARCH);
        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        startActivitySafely(null, intent, "onClickVoiceButton");
    }
}
```

## [FAQ03556] [Settings]蓝牙设置界面高级选项功能解析

```
1、文件传输服务：是指蓝牙 File Transfer Profile (FTP)，允许支持蓝牙FTP客户端的蓝牙设备进行连接，实现对服务端文件的访问和操作。
2、远程SIM卡模式：是指蓝牙SIM Access Profile（SAP），允许带有内置 GSM 收发器的车载电话之类的设备连接到蓝牙电话中的 SIM 卡，因此车载电话本身并不需要单独的 SIM 卡。
3、蓝牙网络热点：是指蓝牙PAN profile的NAP——Network Access Point，为其他蓝牙设备提供访问Internet功能，类似于网络设备的网桥或者代理服务器，PC机通过蓝牙连接手机蓝牙后，使PC机通过手机上网的功能。PC机要先安装蓝牙软件Bluesoleil，断开本地PC机的局域网（即公司的内部局域网），确认手机可以通过GPRS上网，即可通过该软件连接NAP实现上网功能。
4、蓝牙局域网：是指蓝牙PAN profile的GN——Group Ad-hoc Network，允许支持蓝牙组网功能的其他蓝牙设备组成蓝牙局域网。
5、远程信息访问：是指蓝牙Message Access Profile (MAP), 允许支持蓝牙远程信息访问的蓝牙车载设备访问手机上的短信、彩信和邮件。
```

## [FAQ04499] 如何去掉activity启动时的启动窗口(starting window)? 如何修改启动窗口的背景色?

```
用户看到的“闪一下黑色”的画面，其实是应用程序的“启动窗口”(starting window)。启动窗口有以下特点：
1， 仅在要启动的activity在新的task或者新的process时，才可能显示启动窗口
2， 启动窗口先于activity窗口显示，当activity窗口的内容准备好之后，启动窗口就会被移除掉，show出真正的activity window
3， 启动窗口和普通的activity window类似，只是没有画任何内容，默认是一个黑色背景的窗口
正是由于启动窗口默认是黑色背景的，所以在当前的手机主题为浅色调的时候，就比较容易因为颜色的深浅对比而产生一种视觉上的闪动感。

针对以上情况的解决方法：
- 修改方案一：去掉启动窗口（不显示启动窗口）
- 修改方案二：修改启动窗口的背景颜色（修改成和主题颜色比较接近的颜色）

修改方案一：去掉启动窗口。做法如下：
修改ActivityStack.java文件，如下：
static final boolean SHOW_APP_STARTING_PREVIEW = true;  // 把这里的true修改成false
重新执行./makeMtk project_name mm frameworks/base/services/java，并把services.jar 重新push到手机并reboot

修改方案二：修改启动窗口的背景颜色。做法如下：
修改PhoneWindowManager.java中的方法addStartingWindow，如下：
public View addStartingWindow(IBinder appToken, String packageName, int theme, CompatibilityInfo compatInfo, CharSequence nonLocalizedLabel, int labelRes,
            int icon, int windowFlags) {
    . . . . . .
    View view = win.getDecorView();
    //mtk added begin
    View.setBackgroundColor(...);     //把默认的黑色背景修改成和当前手机主题颜色相近的颜色
    //mtk added end
    . . . . . .
    wm.addView(view, params);
    . . . . . .
}
```

## [FAQ08845] 怎样延长锁屏界面显示时间？

```
屏灭状态，按power键，显示锁屏界面，然后又进入灭屏状态，现在显示锁屏界面，到又进入灭屏状态大概5s，怎样延长该时间到15s。
[SOLUTION]
修改KeyguardViewMediator.java中的KEYGUARD_LOCK_AFTER_DELAY_DEFAULT的值。
```

## [FAQ08935] Email账户自动建立参数预置

```
如果需要预置一些邮件服务账户的参数信息到Email Client端，如
邮箱域名为mail.ru, list.ru, inbox.ru, bk.ru, corp.mail.ru自适应如下参数：
Incoming Server: imap.mail.ru
Incoming Server Port: 993
Ssl on the incoming server: enabled
Username: full email user
Outgoing Server: smtp.mail.ru
Outgoing server port: 465
Ssl on the outgoing server: enabled
Protocol: IMAP4
 
[SOLUTION]
自定义预置邮箱配置：
首先您可能要做的改动是去配置Email/res/xml/providers.xml 中的 incoming 和 outgoing 的URI。
该URI是由如下几部分组成的：
    协议类型 + 安全类型 +：// 服务器地址。
Server port 是不需要专门去配置的，因为他是由 协议类型和是否使用SSL来确定的。
如果您需要使用SSL，那么您在配置的时候就不用去添加trustallcerts部分，应该配置成类似这样的： imap+ssl+://imap.163.com 
Protocol的配置就是上面说的 协议类型 部分，后面的服务器地址部分应该和协议类型对应
```

## [FAQ08939] Email 客户端支持的最大附件大小与邮件大小

```
1. Maximum size of attached files for download (KB)
    GPRS: 5M
    WIFI: Not limits
2. Maximum size of messages (KB)
    Not limits
```

## [FAQ08938] Email 客户端中 Push 与 SmartPush的区别

```
1. Push就是Exchange protocol的一个概念, 简单说就是有新的信来服务器就会及时通知我们client去收信.
2. Smart push是我们Email client特别添加的一个功能, 刚开始2-3天跟push一样, 但它后台会自动收集用户的使用习惯, 收集到一定量后就会按照一个算法来推算出一系列的sync interval值(一天24小时,每2小时一个值, 一共12个值), 然后按照这些值每2小时自动调整一次收信的的sync interval (可能自动调节为push, 1hour或never), 以达到省电的目的 (普通push电耗高一些).
 
SmartPush特点：
1. 計算是一天才計算一次,  sync interval的值會是三種中的一種, 調整sync interval的時間點會在以2小時為單位的整點.
舉個例子:  今天下午3:20進行了一次計算, 會得出12個時間段的12個值, 然後到了4:00就會按照4:00的值進行調整, 6:00又會進行一次調整(假如4:00和6:00的值一樣則不用做調整).
2. SmartPush存在用戶的使用習慣不規律, 造成計算結果不能很貼合實際使用情況的風險. 所以在建賬戶時會有一個smartpush的提示對話框給用戶.
3. 我們採集三種action: 1. 有一封新mail到來  2.用戶進入了一次Email app , 3 用戶使用一次Email app的duration.
4. 算法裏面有按照一定權重配比來根據action的數據進行計算, 最终会生成一个代表用户在某个时间段使用Email的期望值，值越高代表用户可能越想在这个时间点使用Email，即更希望邮件即时被收到.
```

## [FAQ08937] Email中支持的邮件协议

```
1. POP3
2. IMAP4
3. Exchange 2003, 2007, 2007SP1, 2010.
 
PS.
是否支持Notes?
Lotus Notes是私有协议，如果Notes Server允许使用POP3或者IMAP方式登录，则支持，否则就不支持。
```

## [FAQ08945] 请问一下Email 、Exchange 与google原生的Email相比，做了哪些改动呢？

```
请问一下我们MTK的Email 和Exchange 与google原生的Email相比，做了哪些改动呢？
[MTK:]
MTK对Email及Exchange的修改主要是bug fix和极少数的new feature.
Email中new feature增加了VIP, local search, partial download, Out of Office等。
Exchange中主要增加了Smart Push和partial download， 另外有对原生的Exchange中存在的一些电耗问题做修改。
```

## [FAQ08943] 邮件客户端为什么在重启后仅保留25封邮件，更早的邮件会丢失

```
1.为什么没有重启手机前已经在收件箱中查看到有50封邮件，重启后就只有前25封邮件了？
[MTK:]
在Email中有个机制是对可见邮件数目的控制，即通过一个可见邮件限制来控制默认的邮件数量，默认是25，当第一次建立账户时，就会同步这么多信，且每次load more时也会多下载25封。
如果已经同步了50封信，此时对手机进行重启，或者Email进程因为任何原因退出，那么下次启动Email时则会重新应用25封这个可见邮件限制，那么会重新与Server同步一次看看是否有新邮件，并仅保留25封最新的信，因此会出现你提到的问题。
另外你所述有时会偶然碰到不重启也恢复到25，就是因为Email进程退出了（比如用户手动杀进程，Low memory killer， background process kill等）。
 
2.如果在50封邮件可见的时候，将数据连接断掉，然后重启手机，此时进入收件箱会是原来的50封邮件，不知道这是为什么？
[MTK:]
如上面提到的，当下次启动Email时，会重新与Server同于一次看看是否有新邮件，并保留25封最新的，但如果网络中断，则会同步失败，那么就会走不到删除流程，会等到同步成功后再删除。
这样设计的目的是Email的内容全部存储在data partition, 为了防止所占的ROM空间无限增大，所以做了这样一个限制的策略。
相关文件在：
Fille:  Email/src/com/android/email/Email.java
public static final int VISIBLE_LIMIT_DEFAULT = 25;
You could change this number to define how many messages default to display.
每次Email启动时，会在Email.java中重新应用上面这个数目限制，通过下面的方法。
 Controller.getInstance(this).resetVisibleLimits();
如果想改变25这个数目，可以修改上面的宏，但仍然会被reset，如果想不被删除已下载的邮件，则请注释掉下面那句调用。
```

## [FAQ07810] 【GPS】GPS Co-clock 是否需要进行校准？

```
GPS Co-clock 是需要在产线进行校准的，是在RF站位完成RF校准之后校准，按照标准流程，是需要7~10s的校准时间，不需要额外的仪器和站位。 详细请参考如下文档 MT6572平台： MediaTek DCC > External Document > SW > 3G Phone Data > Smart Phone > Standard Package > MT6572 SW Doc Package > Connectivity > GPS > MT6572_6582_GPS_coclk_factory_tool_SOP_V1 0.pdf MT6582 平台：MediaTek DCC > External Document > SW > 3G Phone Data > Smart Phone > Standard Package > MT6582 SW doc package > Connectivity > GPS > MT6572_6582_GPS_coclk_factory_tool_SOP_V1 0.pdf
```

## [FAQ09512] 如何修改拨号盘中号码显示分隔符，由现在的空格符修改为"-"符号

```
经过分析，发现拨号盘中输入的号码的空格分隔符是由如下方法(红字表示的地方)设置了format所引起的。
  Dialpadfragment.onCreateView(...){
......
  PhoneNumberFormatter.setPhoneNumberFormatteringTextWatcher(getactivity(),mDigits,mHandler);
......
}
      从上述方法(红字表示的地方)进一步跟踪代码，可找到代码的修改点(红字表示的地方)是如下文件中的如下方法：
1.frameworks\base\telephony\java\android\telephony\PhoneNumberFormattingTextWatcher.java
private String reformat(CharSequence s, int cursor) {
        // The index of char to the leftward of the cursor.
        int curIndex = cursor - 1;
        String formatted = null;
        mFormatter.clear();
        char lastNonSeparator = 0;
        boolean hasCursor = false;
        int len = s.length();
          for (int i = 0; i < len; i++) {
            char c = s.charAt(i);
            if (PhoneNumberUtils.isNonSeparator(c)) {
                if (lastNonSeparator != 0) {
                    formatted = getFormattedNumber(lastNonSeparator, hasCursor);
                    hasCursor = false;
                }
                lastNonSeparator = c;
            }
            if (i == curIndex) {
                hasCursor = true;
            }
        }
        if (lastNonSeparator != 0) {
            formatted = getFormattedNumber(lastNonSeparator, hasCursor);
        }
  
  if(formatted != null) {
      formatted = formatted.replace(" ", "-");//add by MTK 20130117
    }
   String tmpFormatted = formatted;
   String tmpS = ((CharSequence)s).toString();
   tmpS = tmpS.replace("-","");//add by MTK 20130117
   if (tmpFormatted != null) {
       tmpFormatted = tmpFormatted.replace(" ", "").replace("-", "");
       if (tmpS.trim().length() > tmpFormatted.length()) {
        //Log.d("reformat", "s.length() > tmpFormatted.length()");
        formatted = ((CharSequence)s).toString();
       }
   }
     
        return formatted;
    }
```

## [FAQ03066] Settings中About Phone的Model number等信息的修改

```
修改alps\build\tools\buildinfo.sh
-修改echo "ro.build.display.id=$BUILD_DISPLAY_ID", 把 $BUILD_DISPLAY_ID 修改成其他的名称可改变 Build Nubmer. 注意此时要去除$.
-修改echo "ro.product.model=$PRODUCT_MODEL",   把  $PRODUCT_MODEL 修改成其他的名称可改变 Model Nubmer. 注意此时要去除$
-修改echo  "ro.build.version.release=2.1" , 中的2.1, 可改变显示的Firmware version

-但是做上述修改时需要注意，某些属性是跟fingerprint相关的，如果修改了跟fingerprint相关的属性，那么ro.build.fingerprint也要做出相应修改
原始状态下ro.product.fingerprint属性设置如下：echo “ro.build.fingerprint=$BUILD_FINGERPRINT”
其中$BUILD_FINGERPRINT=$( PRODUCT_BRAND)/$(PRODUCT_NAME)/$( TARGET_DEVICE):$( PLATFORM_VERSION)/$(BUILD_ID)/$(BUILD_NUMBER):$( TARGET_BUILD_TYPE)/$( BUILD_VERSION_TAGS)
=>[ro.build.brand]/[ro.product.name]/[ro.product.device]:[ro.build.version.release]/[ro.build.id]/[ro.build.version.incremental]:[ro.build.type]/[ro.build.tags]
所以，如果修改了ro.build.brand、ro.product.name、ro.product.device、ro.build.version.release、ro.build.id、ro.build.version.incremental、ro.build.type、 ro.build.tags这些属性
那么，ro.product.fingerprint的属性设置需要做出修改
假如贵司修改了”echo ro.product.name=test_name”，那么ro.product.fingerprint的属性设置需要修改为：
echo "ro.build.fingerprint=${PRODUCT_BRAND}/test_name/${TARGET_DEVICE}:${PLATFORM_VERSION}/${BUILD_ID}/ ${BUILD_NUMBER}:${TARGET_BUILD_TYPE}/${BUILD_VERSION_TAGS}"

Baseband Version 直接写在 modem.img 中，开机后modem 自动推送到AP 端。

Kernel Version 为linux 编译过程中产生, 按照标准的linux格式生成(compile.h), 最后版本信息写在文件/proc/version 下，所有的版本信息即在该文件的第 一行，然后使用了一个正则表达式过滤了版本信息中一些字符，参考DeviceInfoSettings 下的getFormattedKernelVersion 方法。
```

## [FAQ09558] 如何快速获取完整的调试信息

```
当手机发生异常，不确定需要取哪些log来调试时，推荐使用GAT Bugreport功能，它会一键打包完整的调试信息。

以GAT 3.0为例，步骤如下：
1. 进入设置 -> 确认USB Debugging是开启的  （GAT依赖adb，因此要确认adb可用）
2. 将问题机连USB至PC
3. 打开GAT （确认已连接上，视图Devices中会显示手机name）
4. 点击工具栏 -> Bugreport （蜘蛛形状的按钮）
5. 此时会弹出框，在后台运行脚本，最后生成一个压缩包(mtk_bugreport_xxxxxx_xxxxxx.zip)。
 
如下图所示：
```

## [FAQ09535] 当系统存在多个浏览器时，如何预置某个浏览器为系统默认的浏览器？

```
以设定UC浏览器为默认浏览器为例：

设计思路：第一次开机默认选择UC浏览器来打开网页,而且用户也是可以清除该默认选择的浏览器的，如果用户清除默认的浏览器设置,那么我们也保留用户的选择,直到reset机器。

具体方法：

1.在PackageManagerService.java中的构造函数结尾添加：setDefaultBrowser();

2.setDefaultBrowser()的具体实现：

private final void setDefaultBrowser(){

                   Log.d("debug_default","setDefaultBrowser is called.");

                   if(!isFirstBoot()) {

                            Log.d("debug_default","not first boot, return");

                            return;

                            }

                  

                   String str1 = "android.intent.category.DEFAULT";

                   String str2 = "android.intent.category.BROWSABLE";

                   String str3 = "android.intent.action.VIEW";

                   //intent filter

                   IntentFilter filter = new IntentFilter(str3);

                   filter.addCategory(str1);

                   filter.addCategory(str2);

                   filter.addDataScheme("http");

        

                   //intent

                   Intent intent = new Intent(str3);

                   intent.addCategory(str2);

                   intent.addCategory(str1);

                   Uri uri = Uri.parse("http://");

                   intent.setDataAndType(uri, null);

                  

                   //set UC，if your want set other browser as default, modify below code, add package name and activiy name

                   ComponentName component = new ComponentName("com.UCMobile","com.UCMobile.main.UCMobile");

                  

                   //find all browsers

                   List<ResolveInfo> resolveInfoList = queryIntentActivities(intent,intent.getType(),PackageManager.GET_INTENT_FILTERS);

                   int size = resolveInfoList.size();

                   ComponentName[] arrayOfComponentName = new ComponentName[size];

                   //make sure the default browser in phone

                   boolean no_UC = true;

                   for (int i = 0; i < size; i++)

                   {

                            ActivityInfo activityInfo = resolveInfoList.get(i).activityInfo;

                            String packageName = activityInfo.packageName;

                            String className = activityInfo.name;

                            //if your want set other browser as default, modify below package name

                            if (packageName.equals("com.UCMobile")) no_UC = false;

                           

                            ComponentName componentName = new ComponentName(packageName, className);

                            arrayOfComponentName[i] = componentName;

                   }

                   if (no_UC){

                            Log.d("debug_default","no uc package");

                            return;

                            }else{

                            Log.d("debug_default","uc package is in, set it as Preferred.");

                            }

        

                   //set default

                   addPreferredActivity2(filter,IntentFilter.MATCH_CATEGORY_SCHEME, arrayOfComponentName,component);

                   Log.d("debug_default","add UC to PreferredActivity");

        

                   }

3.增加addPreferredActivity2接口（还是在PackageManagerService.java中）：

public void addPreferredActivity2(IntentFilter filter, int match,

            ComponentName[] set, ComponentName activity) {

        Log.d("debug_default","addPreferredActivity2 is called.");

        // writer

        synchronized (mPackages) {           

            Slog.i(TAG, "Adding preferred activity " + activity + ":");

            filter.dump(new LogPrinter(Log.INFO, TAG), "  ");

            mSettings.mPreferredActivities.addFilter(

                    new PreferredActivity(filter, match, set, activity));

            scheduleWriteSettingsLocked();            

        }

    }

        

上面是设置UC 为默认浏览器的方法，如果要设置其他浏览器为系统默认，需要修改两个地方：

1.ComponentName component = new ComponentName("packageName ","activityName");

2.if (packageName.equals("packageName")) no_UC = false;

其它都不变。

packageName代表要设置为默认浏览器的那个browser对应的包名，activityName代表要设置为默认浏览器的那个浏览器对应的类名。

 

红色标注的API，在android新版本上由于支持multi-user的缘故，所以接口定义发生改变，有两处需要修改（上面红色标记的语句）：

1, 把List<ResolveInfo> resolveInfoList = queryIntentActivities(intent,intent.getType(),PackageManager.GET_INTENT_FILTERS);

修改成:

List<ResolveInfo> resolveInfoList = queryIntentActivities(intent,intent.getType(),PackageManager.GET_INTENT_FILTERS, 0);

 

2,把mSettings.mPreferredActivities.addFilter(

                    new PreferredActivity(filter, match, set, activity));

            scheduleWriteSettingsLocked();   

修改成

mSettings.editPreferredActivitiesLPw(0).addFilter(

                    new PreferredActivity(filter, match, set, activity));

            mSettings.writePackageRestrictionsLPr(0);
```

## [FAQ09666] 时钟和日历里的Home time zone显示不一致

```
时钟里的Home time zone跟日历里的Home time zone本身就是不一致的
日历的的时区是：家所在时区
时钟里的时区是：当前所在的时区
家所在时区：这个功能主要是为了方便，在出差或者旅行时，用户不在国内在境外的时候，在日历中设置家所在时区，可以随时了解到国内的当前时间和日期
```

## [FAQ09651] 设置-开发者选项-严格模式(Strict mode)开关从On设为Off后，还会闪红色边框是否正常？

```
手机的设置-开发者选项-严格模式(Strict mode)菜单，当其开关从On设为Off后，再去操作手机的其他界面，有时候还是会闪烁红色边框；
那这个现象是否正常？
 
[SOLUTION]
开发者选项是在ViewRoot被创建起来时才会去读取当前的开关状态（ViewRoot是App启动过程中当Activity/Window被创建之后才创建的）；
例如应用A启动时，发现这个选项是开着的，那它在某些情况下就会闪烁红色边框，此时去设置中把这个选项关闭，但如果应用A还是在后台运行并没有被kill掉时，当它在回到前台运行时，还是会闪烁红边框，只有当应用A真正退出并且process死掉之后，当下次再重新创建ViewRoot时，读取的才是最新的值。
所以这并不是一个bug；
 
当然，如果开关已经设置为Off了，并且手机已经reboot过了，开机之后经过检查开关依然为Off的情况下，如果再去操作手机其他界面时还是会闪红色边框，那就不正常了；如果遇到这种情况，请提交eService，并提供复现问题的操作视频和闪红边框的截图，以及对应的mobile log。
```

## [FAQ09665] MTP和PC数据同步时所支持的文件格式

```
具体支持的媒体文件格式如下结构体所示：
private int[] getSupportedPlaybackFormats() {
    return new int[] {
        // allow transfering arbitrary files
        MtpConstants.FORMAT_UNDEFINED,
        MtpConstants.FORMAT_ASSOCIATION,
        MtpConstants.FORMAT_TEXT,
        MtpConstants.FORMAT_HTML,
        MtpConstants.FORMAT_WAV,
        MtpConstants.FORMAT_MP3,
        MtpConstants.FORMAT_MPEG,
        MtpConstants.FORMAT_EXIF_JPEG,
        MtpConstants.FORMAT_TIFF_EP,
        MtpConstants.FORMAT_BMP,
        MtpConstants.FORMAT_GIF,
        MtpConstants.FORMAT_JFIF,
        MtpConstants.FORMAT_PNG,
        MtpConstants.FORMAT_TIFF,
        MtpConstants.FORMAT_WMA,
        MtpConstants.FORMAT_OGG,
        MtpConstants.FORMAT_AAC,
        MtpConstants.FORMAT_MP4_CONTAINER,
        MtpConstants.FORMAT_MP2,
        MtpConstants.FORMAT_3GP_CONTAINER,
        MtpConstants.FORMAT_ABSTRACT_AV_PLAYLIST,
        MtpConstants.FORMAT_WPL_PLAYLIST,
        MtpConstants.FORMAT_M3U_PLAYLIST,
        MtpConstants.FORMAT_PLS_PLAYLIST,
        MtpConstants.FORMAT_XML_DOCUMENT,
        MtpConstants.FORMAT_FLAC,
    };
}
注：当PC为XP系统时，要求WMP的版本要为10或者11
```

## android 判断是否是第三方应用

```
系统内置应用对应的flag为 ApplicationInfo.FLAG_SYSTEM

boolean isSystemApp(Application aInfo) {
    if ((aInfo.flags & aInfo.FLAG_SYSTEM) == 0) {
        return false;
    } else {
        return true;
    }
}
```

## [FAQ09578] 如何确定GIF播放时间

```
gif播放的原理是这样：
1. 依次从gif file里面读取出每一帧，以及每一帧的duration
2. 先播放第一帧，间隔该帧duration之后再播放下一帧

alps/mediatek/frameworks/base/media/gif/java/com/mediatek/gifdecoder.java
里面有定义MINIMAL_DURATION

MINIMAL_DURATION = 40
这个改动其实也是针对特别的case，为了是播放平滑，所以修改为40的，可以修改这个值，或者自行调整这个值。
```

## [FAQ09417] [Audio Common]如何调整录像和拍照的声音大小

```
CameraService.cpp
playSound(...) {
    ...
    player->seekTo(0);
    //增加下行
    player->setVolume(leftVolume,rightVolume);
    ...
}
其中leftVolume & rightVolume  大小限定在0~1 之间。
```

## [FAQ08421] [Audio App]在播放器界面,使用侧键如何调整Media音量

```
在当前界面对应的XXXActivity.onCreate方法中，加上如下
setVolumeControlStream(AudioManager.STREAM_MUSIC);
```

## [FAQ09179] [Audio App]后台播放FM或者Music，前台进入VideoPlayer再退出，后台不能恢复

```
方案一:
请按照如下修改2个地方：
1.   在fmradioservice.java中onReceive方法
private class FMServiceBroadcastReceiver extends BroadcastReceiver {
。。。。。。。。。
    // other app want FM stop, stop FM
    if (ACTION_TOFMSERVICE_POWERDOWN.equals(action) || ACTION_FROMATVSERVICE_POWERUP.equals(action)
            || (SOUND_POWER_DOWN_MSG.equals(action) && CMDPAUSE.equals(command))) {
        // need remove all messages, make power down will be execute
        mFmServiceHandler.removeCallbacksAndMessages(null);
        stopFMFocusLoss(AudioManager.AUDIOFOCUS_LOSS_TRANSIENT);//修改该句
。。。。。。。。。

2.在mediaplaybackservice.java中onReceive方法
。。。。。。。。。
else if (CMDPAUSE.equals(cmd) || PAUSE_ACTION.equals(action)) {
pause();
mPausedByTransientLossOfFocus = true;//修改此行
}
。。。。。。。。。

方案二:
在MTKVideoView.java的openVideo()方法中移除如下代码：
。。。。。。。。。
// Tell the music playback service to pause
// TODO: these constants need to be published somewhere in the framework.
final Intent i = new Intent("com.android.music.musicservicecommand");
i.putExtra("command", "pause");
mContext.sendBroadcast(i);
```

## [FAQ09897] 如何修改可以缩短Activity进入和退出画面时的动画播放时间

```
在 frameworks/base/services/java/com/android/server/wm/WindowManagerService.java 中找到如下方法，并做修改
private Animation createScaleUpAnimationLocked(int transit, boolean enter) {
    Animation a;
    // Pick the desired duration.  If this is an inter-activity transition,
    // it  is the standard duration for that.  Otherwise we use the longer
    // task transition duration.
    int duration;
    switch (transit) {
        case WindowManagerPolicy.TRANSIT_ACTIVITY_OPEN:
        case WindowManagerPolicy.TRANSIT_ACTIVITY_CLOSE:
            duration = mContext.getResources().getInteger(
                    com.android.internal.R.integer.config_shortAnimTime);
            break;
        default:
            duration = 300;
            /// M: For Low Bandwidth Application Transition Animation @{
            if (FeatureOption.MTK_LOW_BAND_TRAN_ANIM) {
                duration = 200;
            }
            /// @}
            break;
    }
    //在此处重新设置duration的值，
   //上面的代码是去读取默认的配置，默认值是300，你可以依次逐渐减少该值，如250，200，150，100
   //你自己感觉这些值的效果，看哪个满意，你就用哪个；
    // TODO(multidisplay): For now assume all app animation is on main display.
    final DisplayInfo displayInfo = getDefaultDisplayInfoLocked();
    if (enter) {
```

## [FAQ09867] 【pro_info】如何使用pro_info分区来存储标记？

```
在很多情况下，需要使用一个flag来标记各种场景，比如开机logo切换，开机动画切换等等。以72为例，介绍用pro_info来存储这个标记，这样既可以在LK/Uboot中访问这个标记，同时在上层可以通过nvram的接口来读写这个标记。
 
[SOLUTION]
使用pro_info分区来存储标记，需哟做哪些工作？
1，客制化一个nvram item
请参考《customization inNvRAM.ppt》
2,客制化pro_info
请参考《Customization in NvRAM Product Info feature.pptx》
3,Uboot/LK读取标记
（1）在load_image.c中写一个读取标记的接口
–In the path of alps\bootable\bootlaoder\lk\platform\mediatek\mt65XX\LK 
（2）demo code

（3）dev->read（）
Start_addr：起始block的地址，一个block对应的是512个Byte.如果在g_new_nvram_lid[]中有多个LID，那么就要根据ABLE_FOR_SPECIAL_LID     的start_address来计算偏移，如start_address =128*1024， 那么start_addr=part->startblk*BLK_SIZE+128*1024 . 

4,apk中读写标记
请参考FAQ ：FAQ04542

如果还有其他疑问，请提交E-service，tks。
```

## [FAQ09949] 预览界面显示一个灰块

```
1.      进入相机界面拍摄一张照片或者一个视频
2.      向左滑动一次进入浏览图片界面
3.      在浏览图片界面点击back键后快速点击menu键---进入取景界面查看界面显示
4.      此时会在取景界面下方留下一个灰色长条，直到再次点击back键，灰色长条才会消失
[SOLUTION]
请作如下修改验证：
文件 photopage.java 函数
private void updateMenuOperations()
    int supportedOperations = mCurrentPhoto.getSupportedOperations();
    ////M: zhongchao
    if(0 == supportedOperations) {
        menu.close();
        return;
    }
```

## [FAQ09554] How to open/read/write UART in APP?

```
Refer to file: ./mediatek/factory/src/util/uart_op.c.

Operating UART is the same as that on the PC platform. You can google for related information,
e.g. http://www.ibm.com/developerworks/cn/linux/l-serials/
```

## [FAQ09810] 文件句柄开启过多导致系统异常排查方法

```
大多数系统异常重启问题首先就要要查看system_server是否存在异常行为，并在相关时间点确认kernel log中是否异常。如果在相关时间点出现如下sample log,需要做如下描述的进行确认FD的行为。
<3>[  733.216078] (0)[802:Binder Thread #]binder: 109:802 no unused fd available, -24
<6>[  733.216099] (0)[802:Binder Thread #]binder: 109:802 transaction failed 29201, size
104-4

从no unused fd available这个log可以得知当前的fd已经使用达到上限，超过了1024个文件句柄上限。所以这个时候需要追查是什么一直在开启文件句柄而没有关闭。需要输入以下命令：
adb shell ps -p -t system_server找到system_server的PID是269.然后使用开始复现现象，从第一次模拟开
始就输入如下命令：adb shell ls -l /proc/269/fd>d:\fd.log记录下状态,然后每隔一段时间后都用上面命令进
行记录。

以本例为例：从dump出来的fd log中可以明显看到：

data/app/com.jiubang.goscreenlock.theme.watch-1.apk 所使用的fd数量由最开始的40个一直
增加到出问题的743个，fd爆掉了导致系统异常重启。
所以需要检查该ap的行为，在关闭或退出该ap的时候即使关闭所占用的文件句柄以免造成系统异常。
```

## [FAQ09185] log里面有last_kmsg是系统有异常了么？

```
在讲last_kmsg之前，我们讲一下什么是ram console。
 
首先，在kernel里面通过printk吐log的时候会是下面的一个过程：
1. printk会将信息格式化到kernel log buffer里面去。
2. 然后将这些格式化信息送到console去，在我们的系统里面有两个console，一个是uart console，一个是ram console。uart console里面的内容呢就是我们看到的uart log了。

那ram console是如何工作的呢？
1. RAM Console是位于Internal SRAM上面的一个小的buffer。
2. 结合上图与下图我们可以知道，系统运行的时候kernel log将不会被记录在RAM Console里面。
3. 一旦发生了重启，log将会停止记录到RAM console，直到RAM Console再次初始化好。
4. 在RAM Console初始化的时候会将buffer里面原有的数据做备份，拷贝到另外一个buffer，这个buffer的数据我们可以通过/proc/last_kmsg来访问。
 
那结论是什么呢？
1. RAM Console是一种log机制，它可以记录重启前最后时刻的一段log，来说明系统最后做了哪些事情。
2. 只要是重启，不管是异常重启还是通过adb reboot，或者通过菜单重启，都会有last_kmsg，这是一种log机制，与exception机制没有直接联系。
 
但是这里面也有一些限制：
1. 由于重启之后DRAM数据会丢失，所以只能将RAM Console放到Internal SRAM。
2. 但是由于Internal SRAM空间有限，只能划分出7KB~9KB的空间给RAM Console使用，所以能够记录的log是很短的。
```

## [FAQ08897] 如何去掉首次进入camera时的引导动画

```
相机的引导动画是在函数showAppGuide()中实做的, 如果要去掉，请注释掉此函数中的以下代码：
if (sAppGuideExt != null) {
    sAppGuideExt.showCameraGuide(activity, type);
}

JB2与JB5除了做以上修改，
还需要在alps\packages\apps\camera\src\com\android\camera\camera.java中做如下修改：
在doOnResume()中将
if (isNonePickIntent() || isImageCaptureIntent()) {
    if (isAppGuideFinished()) {
        mVoiceManager.startUpdateVoiceState();
    }
}
改为：
if (isNonePickIntent() || isImageCaptureIntent()) {
    mVoiceManager.startUpdateVoiceState();
}
```

## [FAQ07404] 相机连拍快门声音和拍照数量不一致

```
长按快门连拍，快门声音比拍出的照片数量多。因为目前长按快门连拍时，声音的循环播放是AP端来控制的，跟拍照的次数没有关系，所以会不同步。
[SOLUTION]
JB版本按以下方法调整：
连拍时快门声音的播放是在modeactor.java中的函数onShutterButtonLongPressed()中通过调用以下代码来实现的:
mStreamID = mBurstSound.play(mSoundID, 1.0f, 1.0f, 1, -1, 1.0f);
最后一个参数表示播放的速率,可以在0.5-2之间进行调整,如果想让声音播放的慢一些,可以把这个值调小一些。

JB2/JB3版本按以下方法调整：
连拍时快门声音的播放是在photoactor.java中的函数shuttercallback的onShutter()中通过调用以下代码来实现的:
mStreamID = mBurstSound.play(mSoundID, 1.0f, 1.0f, 1, -1, 1.0f);
最后一个参数表示播放的速率,可以在0.5-2之间进行调整,如果想让声音播放的慢一些,可以把这个值调小一些。
如果调成0.5还是感觉比连拍播的快，那只能去更换拍照音的音源了，即/system/media/audio/ui/camera_shutter.ogg文件。
```

## [FAQ09188] 如何在代码中Kick Watchdog呢？

```
首先在kernel需要kick watchdog的前面加入如下代码：
enum wk_wdt_type {
    WK_WDT_LOC_TYPE,
    WK_WDT_EXT_TYPE,
    WK_WDT_LOC_TYPE_NOLOCK,
    WK_WDT_EXT_TYPE_NOLOCK,
};
extern void mtk_wdt_restart(enum wk_wdt_type type);
 
static void mtk_kick_wdt(void) {
    mtk_wdt_restart(WK_WDT_LOC_TYPE_NOLOCK);
    mtk_wdt_restart(WK_WDT_EXT_TYPE_NOLOCK);
}
 
然后在需要kick watchdog的地方调用mtk_kick_wdt()函数即可。如下：
void some_function() {
    //some stuffs
    ........
    //kick wachdog
    mtk_kick_wdt()
    //other stuff
}
```

## [FAQ09974] 在某些平台下，包含循环的代码使系统变慢的原因是什么？怎么解决？

```
由于我司某些平台下DVM内部机制的原因，遇到循环体中不包括函数调用，且会长时间处于循环体的循环算法时就会导致该线程抢占较多CPU从而导致系统变慢。
例如：
while(flag) {
    ;
}

此处的用意是等待另外一个线程改变flag的值，只有flag被设置为false时，代码才会向下执行，但是如果另外一线程迟迟不能改变flag的值就会引起系统变慢的情况。因此应当避免此种情况发生。
因此，解决此问题的方法想办法在循环体中存在函数调用的代码。例如在循环体中调用oject.wait在另外一个地方调用notify等。但是不可以调用一个函数体为空的函数。
```

## [FAQ10266] [Audio Common] 如何内置歌曲和视频文件等资源到手机文件系统。

```
针对该需求，我们有客制化的SOP文档。请登录DCC搜索以下文件即可：“Make_And_DL_FAT_Image.ppt”。
```

## [FAQ05244] 连拍结束后，少保存一张图片或者最后一张图片在图库预览为灰色（无缩略图）

```
在Package/apps/Camera/src/com/android/camera/ModeActor.java的

ActorContinuousShot类中： 

1．将cancelContinuousShot()方法替换为：
private void cancelContinuousShot() {
    mCameraDevice.cancelContinuousShot();
    mBurstSound.stop(mStreamID);
    //modified start
    /*
    mWaitSavingDoneThread = new Thread() {
        private ImageSaver mImageSaver = mCamera.mImageSaver;
        private ImageNamer mImageNamer = mCamera.mImageNamer;
        @Override
        public void run() {
            mImageSaver.waitDoneInSubThread();
            mHandler.sendEmptyMessage(MSG_BURST_SAVING_DONE);
            mImageNamer.cleanOldUriAndRequestSync();
        }
    };
    mWaitSavingDoneThread.start();
    */
    //modified end
}

2. 将onConinuousShotDone(int capNum) 方法替换为：

public void onConinuousShotDone(int capNum) {
    Log.i(TAG, "onContinuousShotDone, pictures saved = " + capNum);
    //modified start
    mWaitSavingDoneThread = new Thread() {
        private ImageSaver mImageSaver = mCamera.mImageSaver;
        private ImageNamer mImageNamer = mCamera.mImageNamer;
        @Override
        public void run() {
            mImageSaver.waitDoneInSubThread();
            mHandler.sendEmptyMessage(MSG_BURST_SAVING_DONE);
            mImageNamer.cleanOldUriAndRequestSync();
        }
    };
    mWaitSavingDoneThread.start();
    //modified end
    if (mWaitSavingDoneThread != null && mWaitSavingDoneThread.isAlive()) {
        updateSavingHint(true, true);
    }
}
```

## [FAQ04529] 连拍结束后加入动画效果

```
将ModeActor.java的ModeActorHandler做如下修改，添加“//add this line”处的那一行代码：
private class ModeActorHandler extends Handler {
    ……
    public void handleMessage(Message msg) {
        ……
        case MSG_BURST_SAVING_DONE:
            updateSavingHint(false);
            onBurstSaveDone();
            animateByIntentOrZSD(); //add this line
            break;
        }
    }
};
```

## [FAQ10297] 预制开机执行Iptables命令

```
修改方法如下：
1，新建一个文件脚本文件oem-iptables-init.sh，在这个文件里添加想要预制的命令。
2，adb push oem-iptables-init.sh push system/bin/
3，将oem-iptables-init.sh赋予可执行权限，chmod 777 oem-iptables-init.sh

PS: 此方法用于带root 权限的手机，执行adb 命令之前先执行adb remount
```

## [FAQ04528] 如何在静音模式下也开启拍照音

```
JB,ICS2,ICS需要做如下修改：
将mediatek/Config/<Project Name>/system.prop文件中的：
ro.camera.sound.forced=0
替换为：
ro.camera.sound.forced=1

JB2需要做如下修改：
将frameworks/base/core/res/res/values/config.xml中的：
<bool name="config_camera_sound_forced">false</bool>
修改为：
<bool name="config_camera_sound_forced">true</bool>
```

## [FAQ10366] 如何抓取View Hierarchy for UI Automator?

```
在遇到界面显示异常等问题的时候，需要排查界面异常是由哪个处理过程所引起的，画面显示的过程，大致上可以分为：
1、上层app定义view 大小、位置，和画面对应的layout；
2、View system处理view的这些属性，计算view tree的大小、位置、处理view的绘制逻辑；
3、native framework处理绘图指令，未开启硬件加速绘制时，是使用Skia图形库来执行绘图指令；如果开启了硬件加速，则是GPU来执行绘图指令

当前这个FAQ就是要提供方法来抓取View hierarchy，排查第1、2这两个步骤是否出现问题

[SOLUTION]
抓取方法是：
1、将手机用usb连接至电脑，确保手机软件版本是eng load，或者userdebug load，才可以抓View hierarchy，如果是user load，且没有打开对应的debug权限，则不可以抓；
2、打开Android sdk提供的Android Debug Monitor工具或Eclipse，进入DDMS这个视图界面；
3、打开Devices显示界面，在Devices的进程列表上方的那一排button中，找到最右边的button，将鼠标悬浮在button上方，显示的文字是"Dump View Hierarchy for UI Automator"；
4、在复现了画面显示异常的界面，保持画面不动，点击第3步中的那个button开始dump，完了之后系统会自动打开所dump到的文件，文件名是dump_xxx.uix，xxx通常是一串数字；
5、将鼠标移到文件名上，会悬浮显示出此文件的存放 folder 名称及路径，folder 命名格式为: uiautomatorviewer_xxxxx，xxxxx也是一串数字，将此folder打包提供给我们分析即可；
如果是自己分析该文件，那么直接在已经打开了的文件中，查看异常位置处的view的状态和属性是否正确即可，将鼠标移动到view的位置时，view会被红色虚线框highligh出来，右边的属性列表中会显示出该view的各项属性。
```

## [FAQ10738] Build otapackage后system.img没有打包进去

```
在进行OTA全包生成时，生成的包才5M（编译过程是先new ，后再执行otapackage），经过对比，OTA包中缺少文件system.img和SEC_VER.txt文件.

[SOLUTION]

Ota包里面缺失system img，原因是客户修改了prop里面的“ro.product.device” value值.
尝试以下两种方式，ota_from_target_files中不需要设定 cust_dir1 这个值了：
1. 修改ota_from_target_files 中的system_path：
system_path = os.path.join("out/target/product/g32wh_xfy","system.img")

2. 將 system.img copy 一份到不需要 device 相关的路径，比如out/target 下，那么在此处设置system_path值如下：
system_path = os.path.join("out/target", "system.img")
```

## [FAQ03747] 差分包升级时签章问题

```
原因：A版使用的key和B版使用的key不一致，导致签章error。
解决：先确定在ProjectConfig.mk文件中的宏：MTK_SIGNATURE_CUSTOMIZATION设置，
如果设置为yes， 客户需要自己去gen releasekey，生成key的文档参考DMS如下路径的资料：
/Product Line/WCX/3G Phone Data/Smart Phone/Software_Customer/Standard Package/MT6575 SW Doc Package/Build/V2.3 /Application Signing Process Enhancement.ppt ，
产生releasekey之后（releasekey在：alps/build/target/product/security/project下），
Build第一个版本，build A new， build A otapackage, 将A版download到手机上，再build第二版，build B new， build Botapackage。最后用命令
./build/tools/releasetools/ota_from_target_files –k alps/build/target/product/security/project/release –n –i oldotapackage.zip newotapackage.zip update.zip.
如果宏MTK_SIGNATURE_CUSTOMIZATION设置为no，则不需要产生key，使用默认的alps/build/target/product/security下的testkey。这时在build 完A、B两个版本后直接用命令：
./build/tools/releasetools/ota_from_target_files –n –i oldotapackage.zip newotapackage.zip update.zip.来制作差分包
```

## [FAQ08907] How to make OTA.zip for SDcard Upgrade

```
1. Enable SystemUpdate:  EngineerMode--->Others--->System update options--->Sd card Update
2. Build : makeMtk [project] new
     makeMtk [project] otapackages
     Full package:[project]-ota-eng.[username].zip ,rename as updat.zip;
 or delta package, please use command : build/tools/releasetools/ota_from_target_files -n -i old.zip new.zip update.zip
3. META-INF(/com/google/andriod/updater-script) (from full package)
scatter.txt:partition layout information(from full package)
type.txt: type of update package(from full package)
config.xml:(configure follow info by yourself ,please preference build.prop)
4. 将以上文件 files (update.zip, META-INF, scatter.txt, type.txt, configure.xml) 打包为 **.zip
5. copy **.zip to SD card , entry setting--->system update
 
config.xml info:
– Build number: The build number of the new version
– Language: The default language of the new version
– Oem: The oem of the new version
– Operator: The operator of the new version
– Product: The product of the new version
– Publish time: When the new version is published
– Version name: The version of the new version
– Android number: The version of Android (e.g. Android 4.2)
– Flavor:
– Notes: What’s new in the package, shown to users
```

## [FAQ08071] Build OTA升级包的时候出现异常,无法编译

```
在Build otapackage时，出现以下build error：
Build error:
ERROR: signapk.jar failed: return code 1
make[2]: *** [out/target/product/s9201/s9201-ota-55.zip] Error 1
make[2]: *** Deleting file `out/target/product/s9201/s9201-ota-55.zip’

 [SOLUTION]
解决：从log分析，是low memory 导致build otapackage 失败的：
需确定build otapackage时保证足够的memory，比较多的情况下在制作升级包时，都是采
用虚拟机的方式，而不是特定义的一台server，所以就会有low memory 的情况。如果可以，
增加此虚拟机的memory 也行
参考以下两种方案：
1. 将 partition_table_MT6589.xls中的android那个区域的大小改小一些, 删除一些内置在system区域的apk；（cause：对于build otapackage 失败，是在打包ota时，对ota进行签章时报了low memory的error。对于签章sign所需的memory的大小，取决于apk的大小，所以对partition_table_MT6589.xls 中的android 分区设定，如果android 分区设定大，则在对ota中的apk进行签章时要求的memory也要大。）

2. 修改SignFile.java 中的cmd = [“java”, “-Xmx2048m”, “-jar”, 这条 ，将“-Xmx2048m”，修改 为“-Xmx4096m” 或者更大，也可。（cause：对于这个SignFile 中的这个cmd，是指当前签章run 的虚拟机上，指定虚拟机可用的最大heap size为2048，这个值需要参考当前的build的pc server的可用内存的大小。
```

## [FAQ03873] 如何实现通过工程指令切换开关机动画铃声的功能？

```
通过工程指令切换开关机动画铃声的功能；
输入正确的指令(例如：*#123890#)后，返回home界面，即完成两套开关机动画铃声的切换动作。
[SOLUTION]
一、修改文件 /mediatek/config/${Project}/init.rc
在文件的末尾添加：
# Change the bootanimation and bootaudio
on property:persist.radio.change.bootanim=1
    user root
    group root
    write /proc/bootprof "INIT:NAND:Mount_START"
    # Mount /system rw first to give the filesystem a chance to save a checkpoint
    mount yaffs2 mtd@system /system nandboot
    chmod 0777 /system/media
    copy /system/bootanim/bootanimation.zip /system/media/bootanimation.zip
    copy /system/bootanim/bootaudio.mp3 /system/media/bootaudio.mp3
    copy /system/bootanim/shutanimation.zip /system/media/shutanimation.zip
    copy /system/bootanim/shutaudio.mp3 /system/media/shutaudio.mp3
    setprop persist.radio.change.bootanim 0
    mount yaffs2 mtd@system /system ro remount nandboot
    write /proc/bootprof "INIT:NAND:Mount_END"

二、修改文件
packages/apps/Contacts/src/com/android/contacts/SpecialCharSequenceMgr.java
添加 Code:
//设置处理更换开关机动画和铃声的命令
private static final String CHANGE_BOOTANIM = "*#123890#"; 
修改 Code:
static boolean handleChars(Context context, String input, boolean useSystemWindow, EditText textField) {
    Log.d(TAG, "handleChars() dialString:" + input);
    //get rid of the separators so that the string gets parsed correctly
    String dialString = PhoneNumberUtils.stripSeparators(input);
    if (handleIMEIDisplay(context, dialString, useSystemWindow)
        || handlePinEntry(context, dialString)
        || handleAdnEntry(context, dialString, textField)
        || handleSecretCode(context, dialString)
        || handleChangeBootanim(context, dialString)) {
            //此处添加处理更换开关机动画和铃声的 Code
        return true;
    }
    return false;
}

添加函数：
static boolean handleChangeBootanim(Context context, String input) {
   if (input.equals(CHANGE_BOOTANIM)) {
        Intent it = new Intent();
        it.setAction("persist.radio.change.bootanim");
        context.sendBroadcast(it);
        Intent intent = new Intent("android.intent.action.MAIN");
        intent.addCategory(Intent.CATEGORY_HOME);
        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(intent);
        return true; 
    }
    return false;
}

三、创建一个 APK，这个 APK 的 android:sharedUserId="android.uid.phone"，并签上系统签名；
这个 APK 里面只有一个 BroadCastReceiver，onReceive 函数里面的内容是：
if(intent.getAction().equals("persist.radio.change.bootanim")){
    android.os.SystemProperties.set("persist.radio.change.bootanim", "1");
}
AndroidManifest.xml 里面内容如下：
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.change.bootanim"
    android:versionCode="1"
    android:versionName="1.0"
    android:sharedUserId="android.uid.phone">
    <uses-sdk android:minSdkVersion="10" />
    <application
        android:icon="@drawable/ic_launcher"
        android:label="@string/app_name" >
        <receiver
            android:label="@string/app_name"
            android:name=".ChangeBootanimReceiver" >
            <intent-filter >
                <action android:name="persist.radio.change.bootanim"/>
                <category android:name="android.intent.category.DEFAULT"/>
            </intent-filter>
        </receiver>
    </application>
</manifest>

四、请贵司在如下目录下直接创建 bootanim
/vendor/mediatek/${Project}/artifacts/out/target/product/${Project}/system/
然后将 bootanimation.zip、bootaudio.mp3、shutanimation.zip 和 shutaudio.mp3  拷贝到该目录下，然后重新编译工程即可。
```

## [FAQ11318] 要增加實體home key，硬件/軟件該如何修改

```
有兩種解法
1. 硬件: 拉到keypad module的COL*/ROW*
軟件: 設定codegen.dws裡面的KEYPAD Setting，將相對的COL*/ROW*設定成"HOME"，GPIO or GPIO_EXT Setting使用到的GPIO pin要設定成COL*/ROW*
2. 硬件: 拉到PMIC的HOMEKEY
軟件: 設定codegen.dws裡面的KEYPAD Setting，將沒有在用的COL*/ROW*設定成"HOME"，且修改下列的define
alps/mediatek/custom/$Project_Name/kernel/kpd/kpd/mtk_kpd.h
#define KPD_PMIC_RSTKEY_MAP KEY_HOME
```

## [FAQ11136] [Audio Common]录像的时候会把拍照音录入进去，如何解决？

```
请把audiomtkstreaminmanager.h
AUDI_RECORD_DROP_MS  (120)  改为500
然后再把audiomtkstreaminmanager.cpp 中的
record_drop_ms_max  (200)  改为500。
```

## [FAQ11401] 手机中不能播放关机动画和铃声?

```
1.确认手机中有关机资源.可先Check下out目录是否有关机动画包(比如system/media目录下的shutanimation.zip)
2.修改alps\frameworks\base\services\java\com\android\server\power\shutdownThread.java的beginShutdownSequence作如下的修改：
   private static void beginShutdownSequence(Context context) {
     ……
     if (cust != null) {
        if (cust.equals("CUST")) {
            mShutOffAnimation = true;
        }
    }
   // MTK add for play shutdown animation
   mShutOffAnimation = true;  //增加这行代码，
   ……
}

3.重新编译frameworks/base/services/java,然后将更新后的services.jar push进手机的system/framework中再测试.
```

## [FAQ03201] 如何在c/c++代码里引用自定义ProjectConfig.mk宏开关

```
AUTO_ADD_GLOBAL_DEFINE_BY_NAME/AUTO_ADD_GLOBAL_DEFINE_BY_VALUE/AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE是编译系统开出的3个可以将ProjectConfig.mk中的宏(注意添加的宏必须大写)添加到C/C++源文件的接口。

 

[KEYWORD]

AUTO_ADD_GLOBAL_DEFINE_BY_NAME

AUTO_ADD_GLOBAL_DEFINE_BY_VALUE

AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE

ProjectConfig.mk

 

[SOLUTION]
详细如下:

AUTO_ADD_GLOBAL_DEFINE_BY_NAME:

如果你希望定义一个宏开关（作为一个功能模块的开关），然后在源文件(*.c/h等使用到这个宏开关)，比如你定义了一个XXX_SUPPORT这个宏的值只有yes和no。那么你可以在

ProjectConfig.mk中定义：

XXX_SUPPORT = yes

但是这样定义在源文件是找不到XXX_SUPPORT的，因此需要加入AUTO_ADD_GLOBAL_DEFINE_BY_NAME，加入之后就可以在源文件使用了，比如aa.c中：

#ifdef XXX_SUPPORT

......

#endif

注意：如果添加的宏的值为no/none/false（无论大小写），那么该宏不会被添加进去。

 


AUTO_ADD_GLOBAL_DEFINE_BY_VALUE:

同上，但是差别在于你希望将宏的值传给源文件，比如定义了：

XXX_TP = CTP#RTP or CTP

你希望在代码中去判断当前使用了RTP还是CTP，那么可以将XXX_TP加入AUTO_ADD_GLOBAL_DEFINE_BY_VALUE

这样在源文件中就可以引用了，比如aa.c中：

#ifdef CTP

......

#elif RTP

......

#endif

 

AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE:

它与AUTO_ADD_GLOBAL_DEFINE_BY_NAME差别在于AUTO_ADD_GLOBAL_DEFINE_BY_NAME只有定义和没有定义之分，而AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE还可以知道它的值是多少(注意这个值是字符串)，比如：

XXX_NUM = 1#1 or 2

那么加入AUTO_ADD_GLOBAL_DEFINE_BY_NAME_VALUE之后：

在源文件中就可以这样用(比如aa.c):

if (!strcmp(XXX_NUM, "1"))

{

}

else

{

}

---------------

java部分的引用请参考：

[FAQ03202] 如何在java代码里引用自定义projectConfig.mk宏开关
```

## [FAQ11375] 系统时间为12小时制，进入记事本保存一条记录，记录时间以24小时制显示

```
系统时间为12小时制，进入记事本保存一条记录，记录时间以24小时制显示
[SOLUTION]
该信息显示为24小时制是design 的行为，如果贵司想要修改可以参考以下信息。
1.format格式的资源  如，values/string.xml
    <string name="done_time_format">Done at %Y-%m-%d %H:%M</string>
2. timeFormat的地方在Utils.java, 可以自行修改timeFormat。
   public static String getDateText(Context context, long dateMillis, int type) {
   ...
     else if (type == DATE_TYPE_COMPLETE) { // get complete date
            if (dateMillis <= 0) {
                return null;
            }
            timeFormat = context.getResources().getString(R.string.done_time_format);
        }
   ...
}
```

## [FAQ11468] 如何在KK版本上支持蓝牙发送APK文件

```
将application/vnd.android.package-archive类型加到packages/apps/Bluetooth/AndroidManifest.xml文件中。
如： 
1. <activity android:name=".opp.BluetoothOppLauncherActivity"
            android:process="@string/process"
            android:theme="@android:style/Theme.Translucent.NoTitleBar"
            android:label="@string/bt_share_picker_label"
            android:enabled="@bool/profile_supported_opp">
            <intent-filter>
                <action android:name="android.intent.action.SEND" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="image/*" />
...
+++          <data android:mimeType="application/vnd.android.package-archive" />
 
2. <intent-filter>
                <action android:name="android.intent.action.SEND_MULTIPLE" />
                <category android:name="android.intent.category.DEFAULT" />
                <data android:mimeType="image/*" />
...
+++          <data android:mimeType="application/vnd.android.package-archive" />
```

## [FAQ10220] 如何修改factory mode下FM的默认测试频点及阀值

```
Factory mode下测试FM会默认测试四个频点88.5、105.8、98.0、108.0的RSSI值，如果小于阀值-95db则测试fail，高于阀值-95db则测试pass。
本文将说明如何修改默认测试频点及阀值。
[SOLUTION]
请修改alps/mediatek/custom/[project]/factory/factory.ini 以及 factory.chn.ini文件中的
FMRadio.CH1=885;
FMRadio.CH2=1058;
FMRadio.CH3=980;
FMRadio.CH4=1080;
```

## [FAQ04601] [Power/Thermal]如何读取CPU温度？

```
SW control path:
 
mediatek\platform\mt6577\kernel\core\mtk_ts_cpu.c

sysfs:
adb shell
cat  /sys/class/thermal/thermal_zone0/temp
 
各个thermal zone 对应的interface如下：
cat  /sys/class/thermal/thermal_zone0/temp
cat  /sys/class/thermal/thermal_zone1/temp 
cat  /sys/class/thermal/thermal_zone2/temp
......
您需要先透過type接口获知当前thermal_zone name, 以便于正确读取：
/sys/class/thermal/thermal_zone*/type

Notes:
1. PMIC 6329 HW 無法讀取thermal sensor溫度，回報給SW, 目前solution always 為100C(mt6320 支持)
2. ABB temp 與CPU temp 實驗測量結果溫度基本一致(相差不到0.1C), 因此Driver 基本类似。 
3. ADC3 是給3GPA RF IC 使用的, 读取的是external 摆放在IC 旁边的thermal sensor temperature
```

## [FAQ09755] 接收到配置短信，点安装，为什么有时候会显示要求输入Pin码，该如何解决？

```
修改文件 OmacpMessageSettingsDetail.java
如下判断地方修改为
if (!sPinUnlock) {
    sPinUnlock = true;
    // write the database
    markMessageAsPinUnlock();
    //showDialog(DIALOG_UNLOCK_PIN);
    // return;
}
```

## [FAQ10351] 开机时怎样区分是long press reboot还是normal reboot?

```
以72为例，在
mediatek\platform\mt6572\preloader\src\drivers\platform.c
platform_boot_status()这边可以添加如下判断
U32 just_rst;
pmic_read_interface(0x04A, &just_rst, 0x01, 4);
if(just_rst)
{
       // long press reboot
}
else
{
       //normal reboot
}
```

## [FAQ11678] KK版本任意按鍵喚醒系統功能的配置

```
目前版本上按键唤醒系统的功能默认是打电话状态下才有（除了powerkey），若要實現任意一個按鍵在系統深度睡眠後還可以喚醒，需要做一些修改，以home key為例，詳細如下：
 
[Solution]
1.确认唤醒源均已包含了WAKE_SRC_KP
mediatek\platform\mt6589\kernel\core\ mt_spm_sleep.c
#define WAKE_SRC_FOR_SUSPEND \
(WAKE_SRC_KP | WAKE_SRC_EINT | WAKE_SRC_CCIF_MD2 | WAKE_SRC_CCIF_MD1 | \
WAKE_SRC_USB0_CD | WAKE_SRC_USB1_CD | WAKE_SRC_PWRAP | \
WAKE_SRC_SYSPWREQ | WAKE_SRC_MD_WDT)
#define WAKE_SRC_FOR_DPIDLE \
(WAKE_SRC_KP | WAKE_SRC_GPT | WAKE_SRC_EINT | WAKE_SRC_CCIF_MD2 | \
WAKE_SRC_CCIF_MD1 | WAKE_SRC_USB0_CD | WAKE_SRC_USB1_CD | \
WAKE_SRC_USB1_PDN | WAKE_SRC_USB0_PDN | WAKE_SRC_AFE | \
WAKE_SRC_PWRAP | WAKE_SRC_SYSPWREQ | WAKE_SRC_MD_WDT)
 
2. \mediatek\config\hedy89_we_jb2\mtk-kpd.kl
增加 key 102 HOME WAKE
 
3、\alps\mediatek\kernel\drivers\keypad\kpd.c：
註釋掉//#define MTK_KP_WAKESOURCE
 
4、Android Framework有屏蔽部分特殊按鍵，
在alps/frameworks/base/policy/src/com/android/internal/policy/impl下的PhoneWindowManager.java文件中isWakeKeyWhenScreenOff()看是否有對應的keycode（如例子homekey），若有，請刪除.
 
这样修改后待机电流會稍微增大,请知悉.
```

## [FAQ11738] 如何测试camera中的GPS位置信息

```
测试camera中的GPS位置信息有分以下两种情形:
1.    手机有安装完整的与手机软件对应的GMS包, 即:JB2版本需要装JB2对应的GMS包;KK版本需要装与KK对应的GMS包.
2.    手机没有安装GMS包.
针对以上两种情况, 都需要把setting\location项打开.
[SOLUTION]
一.  手机有安装完整的对应GMS包,测试步骤为:
1.    进入setting\location, 把location打开.
2.    连接上一个可用的wifi ap或插入SIM卡后打开data account项
3.    通过地图软件看是否可以定位当前位置.
4.    地图软件能定位成功后进入camera, 打开GPS location info
5.    拍照,进入图库,查看当前拍照照片的详细信息,会显示位置信息项, 如:xx市xx路.

二.  手机未安装GMS包, 测试步骤为:
1.    移步到室外开阔的地方.
2.    进入setting\location, 把location打开.
3.    输入字串进入engineer mode\location\YGPS界面, 待搜出3颗以上的卫星且显示绿色后表示位置定位成功(见如下图片).
4.    进入camera, 打开GPS location info.
5.    拍照,进入图库,查看当前拍照照片的详细信息, 会显示出位置信息项, 如:经纬度.
```

## [FAQ10559] 如何更新LMK Low Memory Killer 的阈值

```
Low Memory Killer 的阈值分成两个数组，一个是adj 数组，描述process 所对应的oom_adj，另外一个是minfree 数组，描述process 所对应的memory 的阈值。
上层可以直接通过读写: 
 /sys/module/lowmemorykiller/parameters/adj 
 /sys/module/lowmemorykiller/parameters/minfree
来进行调整.minfree 以KB 为单位

在JB 以后版本，AMS 起到后，将根据屏幕分辨率以及内存大小调整默认的LMK 的阈值，对应的具体的代码在：
frameworks/base/services/java/com/android/server/am/ProcessList.java#updateOomLevel 
可以修正这个updateOomLevel 来调整LMK 的这两个参数

注意, 从JB9.MP 后，LMK 自动将oom_adj 转换成 oom_score_adj ，即写入时依旧是按照oom_adj 写入，而读取出来时，则是oom_score_adj. 
if oom_adj = 15 then oom_score_adj = 1000;
else oom_score_adj = oom_adj * 1000/17;
简单的oom_adj 与oom_score_adj 的转换表格：
oom_adj  oom_score_adj
-16             -941
-12             -705
0                  0
1                 58
2                117
4                235
6                352
9                529
15              1000
```

## [FAQ10755] 如何解决开机过程kernel logo到开机动画黑屏问题

```
在开机过程，如果将bootanimation.zip的图片换成非黑色背景，发现从kernel logo到bootanimation之间会黑屏一下或者黑屏时间过长，这类问题的原因有可能是和Display相关，也有可能和Bootup流程相关。因此根据测试手法结果的不同，采用对应的解决办法，测试前，手如下对比实验：

1.将出现黑屏手机内部的system/media/bootanimation.zip pull到没有黑屏问题的手机，check是否还有黑屏，排除动画的问题
2.将正常手机的 system/media/bootanimation.zip pull到目前有黑屏问题的手机，check是否依然黑屏，排除动画的问题

在对比实验确定和bootanimation.zip无关，与手机本身行为有关的情况下，进行如下实验
一、去掉开机铃声，如果黑屏依然存在：
1. 如果目前Project所用的LCM Panel是Command Mode，只需要申请Patch：ALPS00932048，适用 ICS、JB2、JB3、JB5。
2. 如果目前Project所用的LCM Panel是Video Mode，先申请Patch：ALPS00932048，适用 ICS、JB2、JB3、JB5；
然后如果是72 Platform ，SW Version：JB3，请再申请Patch: ALPS00845248；如果是82 Platform ，SW Version：JB5，请再申请Patch: ALPS00902086；
如果问题依然无法解决，请提交eService进一步分析解决。（请先排除bootanimation.zip的影响）

二、去掉开机铃声后，没有黑屏
如果去掉开机铃声，从Kernel Logo到动画是没有黑屏，请先参照相关FAQ：[FAQ09563] 开机过程kernel logo到开机动画黑屏时间过长，如果问题依然无法解决，请提交eService进一步分析解决。
```

## [FAQ10716] system property 重启或者恢复出厂设置后无效(丢失)

```
System Property 存读写上来说，存在两种特别的property.
第一种即是以ro. 开头的ro.xxxx.yyyy ，此类即称为只读的系统属性，即它只可设置一次。如果系统中已经存在，即无法再设置。
第二种即是以persist. 开头的persist.xxxx.yyyy , 此类称为持久化的系统属性，即设置一次后，将自动把结果保存在/data/property 当中，下次开机时会自动加载。

对于一般的system property 只是保存在init 的shared memory 当中, 不会更新disk 中的数据，一旦掉电即丢失; 对于以persist. 开头的持久化的系统属性，因为结果是保存在/data 分区，通常在恢复出厂设置时因为/data 分区被清掉，就也会丢失。针对此类，如果贵司一定要保存而不被清除，需要启用我司的Special Factory Mode, 将相关的文件保存下来。具体可以参考: Android SD upgrade application note.docx
 
[相关FAQ]
FAQ07367: 如何设置system property 默认值
FAQ04349: 不能添加system property, 提示： permission denied uid:xxxxx  name:xxxxx
FAQ03994: system property 写入/更新后，马上读取无效问题
FAQ03778: 如何对system property 进行扩容
FAQ06739: system property 设置失败的可能性分析和初步诊断
FAQ03994: system property 写入/更新后，马上读取无效问题
```

## df 等命令的源码位置

```
system/core/toolbox/df.c
```

## [FAQ10818] 如何给所有画面增加一层水印(WaterMark)效果?

```
1) 新建一个名为setup.conf的文件,写入以下内容:B79A939390%20
然后把这个conf文件push到手机的system/etc目录下
 
2) 以加水印字串“hello world,this is my mark”为例, 再修改:WaterMark.java(frameworks/base/services/java/com/android/server/wm)文件,
注释掉WaterMark构造函数中的这一句:

mText = builder.toString();
加上这一句:
mText = "xxx"  ,  xxx表示你想要加为水印的字符串

3) 重新编译生成services.jar文件并push到手机的system/framework下, reboot手机.
```

## [FAQ04088] 如何配置NTP对时server？

```
使用NTP方式对时时，由于需要与对时server进行交互，若对时server不work，就无法获取正确的时间，此时应替换为其他有效的server。
Server配置的地方为：
frameworks/base/core/res/values/Config.xml
<string translatable="false"name="config_ntpServer">cn.pool.ntp.org</string>
将“cn.pool.ntp.org”替换为其他server，如”asia.pool.ntp.org” 或“north-america.pool.ntp.org”等即可
```

## [FAQ11015] 通过组合键进入recovery模式选择sdcard菜单升级，升级完如何自动重启？

```
MTK默认设计：
将OTA升级包放入SD卡根目录下，按键进入recovery模式选择sdcard菜单升级，升级完成后无法自动重启，需要手动选择菜单完成重启；
客户若有需求实现自动重启，请问应该如何更改！

[SOLUTION]
修改recovery.cpp文件prompt_and_wait函数如下两处位置添加：return；//add

1、ui->Print("\nInstall from sdcard complete.\n");
finish_recovery(NULL);
return; //add

2、ui->Print("\nInstall from sdcard2 complete.\n");
finish_recovery(NULL);
return; //add

3、按照如下方式快速编译recovery.img并重新download即可验证：

./makeMtk mm bootable/recovery/
./makeMtk -opt=ONE_SHOT_MAKEFILE=build/target/board/Android.mk r recoveryimage
```

## [FAQ11086] 阿拉伯语下连拍的照片在图库中查看时只能显示第一张

```
请作如下修改：
文件  Util.java:
把
public ImageFileNamer(String format) {
    mFormat = new SimpleDateFormat(format);
}
To:
public ImageFileNamer(String format) {
    mFormat = new SimpleDateFormat(format,Locale.ENGLISH);
}
And modify Storage.java
Change to:
public static String getBucketId(String directory) {
    return String.valueOf(directory.toLowerCase().hashCode());
}
To:
public static String getBucketId(String directory) {
    return String.valueOf(directory.toLowerCase(Locale.ENGLISH).hashCode());
}
或直接在PMS上申请此patch: ALPS01445198
```

## [FAQ05276] 用错误的APN仍然能够上网的问题

```
如果测试机用错误的apn能够上网，请先用对比机进行对比测试。因为有的是因为网络端能够接受这样错误的APN，所以能够上网。如果测试机和对比机行为一致，那么说明测试机是正常的，是网络端的问题，如果行为不一致请再提交eservice并提供相应的mobile log和modem log。
```

## [FAQ02986] 如何查看TCP/IP缓冲大小

```
查看alps\mediatek\config\xxx(工程名)\Init.rc文件中，找到如下定义

# Define TCP buffer sizes for various networks

#   ReadMin, ReadInitial, ReadMax, WriteMin, WriteInitial, WriteMax,
setprop net.tcp.buffersize.default 4096,87380,110208,4096,16384,110208
setprop net.tcp.buffersize.wifi    4095,87380,110208,4096,16384,110208
setprop net.tcp.buffersize.umts    4094,87380,110208,4096,16384,110208
setprop net.tcp.buffersize.edge    4093,26280,35040,4096,16384,35040
setprop net.tcp.buffersize.gprs    4092,8760,11680,4096,8760,11680
```

## [FAQ11227] 去掉进入camera的引起动画，导致语音拍照功能无法使用

```
此问题是由于去掉进入camera的引导动画导致的，可以按以下方法修改：

在alps\packages\apps\camera\src\com\android\camera\camera.java
doOnResume()中
将
if (isNonePickIntent() || isImageCaptureIntent()) {
    if (isAppGuideFinished()) {
        mVoiceManager.startUpdateVoiceState();
    }
}
改为：
if (isNonePickIntent() || isImageCaptureIntent()) {
    mVoiceManager.startUpdateVoiceState();
}
```

## [FAQ09564] 如何抓取开机Log

```
一般分析开机失败或者开机过程异常问题，都牵涉到如何抓取开机log的问题，为了顺利抓取开机Log便于分析问题，参照如下抓取有效log：
1.如果开机过程还没有出现开机动画，就已经异常，直接抓取UART串口log；
2.如果开机动画已经显示，后面出现异常，可以首先check SD卡是否已经mount成功，如果SD卡mount成功，直接提供Mobilelog；否则，可以通过adb logcat抓取log或者通过我司release的GAT Tool抓取log，其中logcat抓取log的command：adb logcat -v time -b main -b events -b system>logcat.txt。
```

## [FAQ04967] [Android Debug] 如何抓取Java Backtrace

```
1. 连接adb,使用ps命令查看需要抓的Java Application的PID。
2. adb下，执行kill -3 PID，系统会将backtrace生成在 data/anr/traces.txt，然后将这支文件pul出来即可。
为了方便，您可以将下面这部分保存成windows下面的bat脚本，双击执行后获取Java Backtrace。
-------------------------------------------------------------------------
adb remount
adb shell chmod 0777 data/anr
adb shell ps

@echo off
set processid=
set /p processid=Please Input process id:

@echo on
adb shell kill -3 %processid%

@echo off
ping -n 2 127.0.0.1>nul

@echo on
adb pull data/anr/traces.txt trace-%processid%.txt

pause
------------------------------------------------------------------------- 
```

## [FAQ11106] SECURE OTA 升级包里面缺少SEC_VER.txt导致升级失败

## [FAQ11601] 如何抓取系统memory使用状况

## [FAQ03969] 如何自己编译wireless tool

## [FAQ11475] 升级报错"Error: System property does not match"怎么办？

```
现象：
如果升级过程在recovery.log或者last_log发现如下出错error：
Error: System property does not match
检查点：
首先：检查下升级包中的build.prop和手机里面的是否一致？ 获取手机里的build.prop方法：adb pull /system/build.prop  build.prop 升级包里的build.prop文件位于/system目录下。
其次；重点比对下ro.product.device和ro.build.product的value值，确保一致的前提下，看看是否value值包含多余的空格符及退格符、ro.product.device为空等。
如果还是解决不了问题，请提eservice给MTK，同时并把log及两份build.prop附上来。
```

## [FAQ11660] 关于KK上的chromium的几点说明

```
KK上的browser, 对于chromium的几个问题：
1>  所有的 WebView 都使用 Chromium 解析渲染，是否是这样的？
是的。

2>  如何查看浏览器的渲染引擎？
WebSettings.getUserAgentString()或者访问 www.show-ip.net/browserinfo
可以取得WebView的default User Agent, 例如：
Mozilla/5.0 (Linux; Android 4.4.2; DeviceName Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/30.0.0.0 Mobile Safari/537.36
代表是使用Chrome 30版的浏览器引擎，对应WebKit版本是537.36

3>  渲染引擎的职责是什么？
浏览器引擎主要的工作:
载入 -> 解析 -> 排版 -> 渲染 -> 显示， 还有执行网页的JavaScript等等。
```

## [FAQ06811] 如何查看蓝牙固件版本

```
一、通过log查看
可以通过kernel log看一下，搜索关键字“firmware”。
例如有如下一句：
(1)[117:mtk_wmtd][WMT-IC][I]mt6628_patch_dwn:the 1 time valid patch found: (/system/etc/firmware//mt6628_patch_e2_0_hdr.bin
可以看到bt是e2版本。

【注意】此log需要在在开机情况下任何wcn相关应用（包括BT、WIFI，FM，GPS）都没有打开的情况下，开启蓝牙才可以看到。

建议使用以下步骤：
1.清空全部log，设置开机自动抓取log选项，确保所有wcn相关应用已经关闭后关机。
2.重新开机，确认此时已经开始抓取log。
3.开启蓝牙。
4.关闭log，检查kernel log，搜索关键字“firmware”，检查蓝牙固件版本。

二、通过adb查看，命令如下所示：
=>cd adb
=>adb shell
=>cd /etc/firmware
=>ls

在etc/firmware下可能会看到好几个bin文件，请以带有“_0”、“_1”后缀的版本为基准。

举例如下:

etc/firmware路径下看到以下3个bin文件，
mt6628_patch_e1_hdr.bin
mt6628_patch_e2_0_hdr.bin
mt6628_patch_e2_1_hdr.bin
则bt最终版本就是e2。
```

## [FAQ09948] Performance问题的排查方法（如开机慢、系统卡顿等）

```
请参考《Performance_Tuning_Customer_Document》进行排查，相关客户文档可以在http://dcc.mediatek.com下载。
```

## [FAQ10004] 在关机界面添加重启菜单功能

## [FAQ09429] 在开机向导中的语言选择界面切换语言，当前的语言选择界面没有更新到设定的语言，该如何解决?

## [FAQ09441] mtk内置的apk及其用途总结

## [FAQ08595] Enable GPS location info功能后，在camera界面显示GPS icon

## [FAQ09759] [Audio APP]音乐播放器中显示歌曲的信息

## [FAQ08330] 在相机中拍照至空间满，删除部分图片后仍无法拍照

## [FAQ07553] [Storage]72平台Fat on nand功能实现

## [FAQ06920] [VideoEditor]VideoEditor（电影工作室）支持导入/导出哪些格式

## [FAQ03654] [FlashTool]How to customize download tool

## [FAQ04545] 【NvRAM】Native层读写nvram

## [FAQ03656] How to process Modem Exception?

## [FAQ02494] 在关机界面添加重启功能

## [FAQ11427] Camera Setting中添加拍照声音选项

## [FAQ11421] Camera Setting中增加保存照片选项菜单

## [FAQ11754] KitKat版本如何将camera service修改为强占式

## [FAQ12222] 下载的文件名会为乱码

## [FAQ06648] [Audio App]FileManager 中点击音乐文件设置为来电铃声。

## [FAQ09996] 同一套代码实现不同的项目使用不同的客制化分区表

## [FAQ11577] Linux 孤儿进程组问题说明

## [FAQ12988] 大量图片时Gallery打开图片速度很慢

## [FAQ13408] AOSP编译常见问题

## [FAQ13642] [Audio App]home界面点击fm图标后，fm不自动播放

## [FAQ13719] [Audio App]FM菜单选项中添加手动设置频率

## [FAQ12170] [sdcard-common]KK版本如何去掉内置T卡？

## [FAQ13908] [keypad]怎样实现单按PowerKey重启功能？

## [FAQ12958] [Audio Profile]如何在状态栏添加一个general和outdoor对应的图标

## [FAQ13474] [Audio Profile]如何让设置的通知音只播放前10秒

## [FAQ11130] WAP PUSH参数介绍

## [FAQ09383] [BMT] 如何设置长摁powerkey（或者powerkey+homekey）使得系统重启或者关机

## [FAQ08960] [Others]如何在工厂模式支持special factory reset功能，执行reset后可以清除测试痕迹并保留/data/app下预置apk？

## [FAQ13676] 在Dialpad中长按输入的号码，无复制粘贴等选项出来

## [FAQ09466] 如何关闭zram(内存压缩)以测试系统性能

## [FAQ13931] [keypad]怎样在Android L版本添加新Key？

## [FAQ14325] [Audio framework] 如何去掉AMR格式

## [FAQ14329] [Audio framework]如何在Framework层互斥两个通过 MediaPlayer 播放的音乐播放器

## [FAQ04521] 【ICU】如何修改某语言的数字显示系统

## [FAQ14364] 如何把L版本的Recents APP风格改成KK版本的风格

## [FAQ14178] L版本增加关机振动

## [FAQ14106] L版本如何enable "adb shell dumpsys alarm"命令

## [FAQ12947] [Recovery]Update LOGO&LK&PRELOADER via OTA upgrade

## [FAQ08919] [NW]网络运营商名称显示规则（锁屏界面，下拉列表）---网络名称 客制化方法 和 问题处理flow

## [FAQ09394] [NW]网络运营商名称显示&SIM名称显示

## [FAQ14481] [Audio Effect]玩游戏雷霆战机时发生卡顿的问题

## [FAQ12646] 适配开机lk阶段任意尺寸充电图标（比lcm size 小的图片）

## [FAQ14527] IPO（smart phone fast boot up）Enable Guide

## [FAQ14656] 检查版本是否支持SBP功能？？？SBP是什么？？？

## [FAQ14744] L版本APPIOT常见问题总结(对比机可以复现)  APPIOT 是什么意思？？

## [FAQ14751] L 版本Security OTA升级方法

## [FAQ14531] [Audio Profile]“提示音和通知”中试听手机铃声时来电，来电铃声和预览铃声声音重叠

## [FAQ14667] [Audio Profile]情景模式里如何增加通话音量进度条调节？

## [FAQ07275] 如何在linux中添加新的kernel module

## [FAQ13320] [Audio Profile]如何打开各个铃声选择框的default、silent、more选项

## [FAQ14861] mms去掉彩信功能

## [FAQ14768] 修改ART mode减少ROM大小 （如GMO project / FOTA升级）

## [FAQ14868] modem log用什么工具分析?????catcher

## [FAQ14724] Android 5.0上的Settings Search功能介绍

## [FAQ13137] 为什么MTKLogger UI显示的路径与实际路径不一致？

## [FAQ15040] 如何增加色度，饱和度，对比度，亮度的调节幅度

## [FAQ11062] 如何实现usb驱动自动安装？

## [FAQ12749] 联系人如何区分*123与123这两个号码

## [FAQ15070] Android5.0版本APN界面会显示运营商名字的问题

## [FAQ15113] 低电压关机，关机充电到15%自动开机

## [FAQ09065] [Others]MTK发布的Android software Tools 工具包中所有工具的说明

## [FAQ15257] [Audio App]如何在通知栏上显示 music 播放/暂停 的控件

## [FAQ15332] 快速开关wifi，导致wifi打不开

## [FAQ15503] 预置运营商的wifi AP之后引起功耗大

## [FAQ09200] [Dialer][Geocoding]如何关闭来电号码归属地？

## [FAQ09009] [Dialer]如何修改号码显示格式？比如将number修改为4-4-3分段格式

## [FAQ11929] [Dialer]相同号码联系人A和B, 拨打B时通话界面和通话记录都显示A

## [FAQ09449] [Dialer]通话记录匹配异常

## [FAQ10377] [Dialer]Google的固话号码归属地-区号与归属地对照表[中国大陆部分]

## [FAQ10383] 添加MCCMNC自动号码匹配后拨号匹配不到联系人

## [FAQ10342] [Dialer][Geocoding]修改手机号码归属地

## [FAQ14869] 如何分别设置前后Camera不同的默认Preview Size

## [FAQ17396] check jni问题解决方法

## [FAQ12677] 【Phone Call】带"*" "#"的语音信箱号码会匹配到联系人的问题

## [FAQ04400] [Others] 如何手动强制更新PC端USB驱动

## [FAQ09781] [Dialer]如何能在来电时始终在对方号码前加上国家码

## [FAQ11604] Email里面添加优先级指示

## [FAQ09450] 如何在"设置->关于手机"界面添加Logo

## [FAQ17438] 5G hotspot 设置

## [FAQ07588] [Audio App]FM播放时拔出耳机后,FM APP出现"拔出耳机，Fm停止"的提示框，然后自动close

## [FAQ04249] [sdcard-common]新开项目SDCard不识别，如何debug？

## [FAQ16262] [video recoder]录像时关闭Record audio,录的视频播放时间只有录制时间的一半

## [FAQ16263] [Video][Video Player] 进入视频播放器，播放视频文件提示“insufficient memory”

## [FAQ10251] MT6582/MT6592 平台上，dump camera buffer的方式

## [FAQ06196] [Audio App]FM搜台时如何选择性保存搜到的电台

## [FAQ03932] [Audio Driver]如何打开/关闭3G通话时对AMR-WB的支持

## [FAQ17482] [others]setting中删除视频和图片在Gallery中仍可以查看缩略图

## [FAQ03604] [Contacts Data] 联系人名字多音字的处理方法

## [FAQ17545] [AudioProfile]关于M版本双卡铃声

## [FAQ17578] omacp的email xml文件样本

## [FAQ12935] 【Contacts Data】预置联系人之Vcard预置联系人

## [FAQ10133] 【Contacts Data】 联系人列表如何将联系人名字为泰语的联系人归类到# group

## [FAQ10398] 【Contacts Data】"万俟" 应该排列在"M"下面,而不是"W"下面.

## [FAQ10385] 【Contacts Data】 Google默认群组名称可以修改吗？

## [FAQ08580] 【Zone】如何通过网络确定当前时区

## [FAQ17627] 电信自注册基础知识??????

## [FAQ17665] 快速修改调试Feature Table

## [FAQ13560] [BMT]长按power key（power key+home key）shutdown 或者reset phone

## [FAQ17710] Android UI显示电量跳变

## [FAQ17774] [People]美式英语下面输入特殊名字字符，出现 DisplayName变化为phone number

## [FAQ08972] [NW]信号格显示的平滑处理

## [FAQ17839] Browser参数支持情况

## [FAQ17838] Browser的M版本UA Profile

## [FAQ13734] 状态栏中的信号栏添加上下行标识

## [FAQ17968] new Mediaplayer耗时导致开机过程中kernel logo到开机动画之间黑屏

## [FAQ09041] [People]如何修改联系人地址显示格式？

## [FAQ09414] [People]分享可见的联系人，通过短信。短信内容修改成将注释和地址也显示出来

## [FAQ10047] [People][联系人头像】联系人通过拍照设置头像，图库中会有两张同样的图片，如何删除其中一张

## [FAQ11085] [People]联系人详情界面的某些字段前面加"!"

## [FAQ10667] [People]联系人字段中增加生日字段

## [FAQ11096] [People]【匈牙利】匈牙利语环境下，联系人的姓名顺序颠倒

## [FAQ11676] [People]需要每次新建联系人都弹出帐号选择列表

## [FAQ11693] [People]联系人详情界面设置默认号码后位置不移动只在末尾打上钩

## [FAQ12527] [People]输入8或者6会搜索出来name和number都没有6的联系人

## [FAQ12523] [People]在联系人搜索界面中同时搜到+7开头和8开头的记录

## [FAQ13132] [People]PeopleList搜索机制

## [FAQ14055] [People]Android平台系统语言从繁体中文切换到简体中文，联系人中文排序看似乱码

## [FAQ17502] [Gallery]照片详情中的时间格式与系统时间格式不一致

## [FAQ18017] recovery mode开机闪屏问题分析

## [FAQ18023] Settings--Storage&USB，选择图片--删除，提示不能删除此文件

## [FAQ04172] 如何修改有几张卡插入就显示几个信号图标

## [FAQ11117] 如何把状态栏信号格改为5格

## [FAQ09448] 如何在quicksettings中增加一个新的buttons

## [FAQ14365] 下拉通知栏底部如何显示运营商图标

## [FAQ18050] 如何获取2G服务小区信号强度和信号质量

## [FAQ17787] L-OS通过T卡升级到M-OS后（lk不升级）不能连接meta

## [FAQ14866] [Audio App]代码如何实现识别“耳机hook键长按”的动作？music和fm apk并对此进行响应

## [FAQ04679] 双卡项目如何在状态栏显示或隐藏G,3G以及卡1和卡2的信号标识

## [FAQ09081] NavigationBar（虚拟按键）横屏时显示位置

## [FAQ13709] 如何在 QuickSettings 上添加一个开关

## [FAQ08581] [Audio Profile] 如何修改情景模式的默认值

## [FAQ18073] M 版本快速开关飞行模式出现飞行模式开启时蓝牙打开

## [FAQ17995] How to do calibration with MauiMeta tool

## [FAQ18089] 短信SMS流程及解码方法介绍

## [FAQ18107] 如何解决ListView打开下拉回弹效果后有时无法回弹的问题？

## [FAQ18154] modemlog无法打开或关闭，提示命令超时

## [FAQ11447] [Recovery][Common]从JB(4.2)版本通过FOTA升级到KK(4.4)版本的注意事项

## [FAQ14051] 在长按power键弹出的关机对话框中添加“Airplane Mode”菜单

## [FAQ14053] L1下拉状态栏QuickSetting没有数据连接

## [FAQ18110] Vibrator概率性不震动

## [FAQ12073] [SEC]如何屏蔽SIMME LOCK解锁界面

## [FAQ13736] [Audio Profile]L版本上music如何设置双卡铃声

## [FAQ18193] [Audio Policy]如何添加开关修改指定场景的输出device

## [FAQ18234] 使用monitor中的systrace抓取时出现trace_marker:Bad File Descriptor(9)

## [FAQ15274] 如何使用watchpoint？

## [FAQ18098] [Graphics]Skia绘图的dump方法

## [FAQ10135] [People]新建/编辑联系人时，检测输入的email/邮件地址格式是否合法

## [FAQ14415] 如何开启early printk调试kernel？

## [FAQ12122] [SEC]过期卡锁卡需求-卡2依赖卡1 (越南为例)

## [FAQ12123] [SEC]过期卡锁卡需求-双卡相互依赖 (KK版本)

## [FAQ18351] How to fix MAC address by driver

## [FAQ12521] [Dialer]如何在通话界面上实现+7和8互相匹配

## [FAQ06838] 如何通过omnipeek抓取sniffer log--new

## [FAQ18373] qq音乐播放，进入多任务杀掉QQ音乐后，耳机hook键就不起作用

## [FAQ18202] [Recovery][Common]Android L ->M版本OTA/T卡升级注意事项

## [FAQ13232] L 预置apk

## [FAQ13893] android L小区广播预置方法

## [FAQ17487] [USB] PC上如何正确配置、安装USB驱动

## [FAQ14736] 【sdcard-FAT filesystem】如何预置资源到手机存储

## [FAQ12895] 如何使用工具抓取ftrace

## [FAQ18016] L/M版本开机黑屏问题区分

## [FAQ14102] L版本开机提示“Android正在升级或启动”

## [FAQ12410] Panorama照片在Gallery中沒有动画

## [FAQ09198] Setting语言与输入法列表客制化

## [FAQ08649] [SP FlashTool/SP Multiport Download Tool] Donwload完整性检查和开机检查客制化

## [FAQ06038] 如何打开DB文件

## [FAQ05872] 如何用DDMS分析native memory leak

## [FAQ13345] Android L版本上指南针apk读取不到sensor数据的原因分析

## [FAQ03718] 如何解包和打包boot.img/recovery.img/system.img/userdata.img

## [FAQ13697] L 版本如何将第三方so库打包到apk

## [FAQ03127] 当修改一些代码时,使用什么编译命令可以最有效率

## [FAQ08775] 如何客制化IPO开机动画，使IPO开机动画播放完整

## [FAQ04542] [NvRAM] APK（应用层）读写NvRAM

## [FAQ19126] [Audio framework]车载蓝牙停止播放, 手机music UI 显示停止但车载端音乐继续播放

## [FAQ10781] 如何开启与关闭adb 的认证机制(google adb secure) (adb RSA 指纹认证)

## [FAQ19141] After M version,how to dump heap profile automatically

## [FAQ12739] [CB] 如何设置小区广播的默认语言

## [FAQ18246] M版本上如何实现恢复出厂设置不丢失数据 (nvram,proinfo 分区注意事项)

## [FAQ17349] [SIM_ME_LOCK]SIM_ME_Lock_User_Guide文档中的枚举量的意思

## [FAQ12953] [AT Command][SIM] 如何使用AT+CRSM读取SIM卡文件

## [FAQ02097] [SIM]客制化"SIM卡已更改"提示

## [FAQ09816] [SP FlashTool] FlashTool Console Mode使用说明

```
FlashTool 终端模式的使用方法
```

## [FAQ17416] SIM卡设置内的卡名称及运营商名称的语言类别随系统语言切换而改变

## [FAQ06172] [AT Command][SIM_ME_LOCK]锁卡相关的AT+ESMLCK命令的用法

## [FAQ19162] Android N 设置中语言列表介绍

## [FAQ19202] 【Encryption】遇到加密问题，如何抓取log？

## [FAQ17485] SP Flashtool和SP Multiport Download Tool的Checksum功能介绍

## [FAQ13989] 【Phone Call】L版本上关于通话时间显示异常的处理

## [FAQ11506] [SIM]如何客制化SIM默认颜色

## [FAQ18298] 小区广播不要在短信列表里显示，只显示在notification

## [FAQ18140] [Gallery]Gallery不能打开隐藏文件夹中的图片

## [FAQ19618] 如何在ap获取拍照的yuv数据

## [FAQ19621] 开关机时根据SIM卡动态适配开关机动画

## [FAQ19779] Android N resource加载逻辑介绍（语言切换不成功等问题）

## [FAQ15097] OTA升级后Home键失灵

## [FAQ06210] 如何让主菜单的背景显示为壁纸?

## [FAQ03858] 滑动锁屏状态下如何禁止下拉状态栏？

## [FAQ12135] [SAT]怎么实现SAT icon一直显示在launcher菜单中

## [FAQ10107] [SAT]STK icon name动态修改成STK一级菜单的title

## [FAQ18531] [SAT]插入某种特定卡开机，点击STK Icon,显示STK未安装

## [FAQ18919] [SAT]正常使用中toast提示“发送短信”

## [FAQ09351] [Others]如何使用超级终端发送AT Command以及抓取Uart Log

## [FAQ04013] 如何开启或关闭VOIP(sip call)功能

## [FAQ19894] N上预置APK失败提示找不到so文件

## [FAQ10023] [SP Meta][META MODE]恢复出厂设置API????在哪里写？？如何开发

## [FAQ09795] [FastBoot]使用fastboot 下载image的方法

## [FAQ19877] 如何使用GDB分析KE问题

## [FAQ19917] [Android N] N版本 bluedroid蓝牙问题Log抓取

## [FAQ10400] 如何在小部件列表中隐藏某个widget或者shortcut？

## [FAQ18166] 从Play Store下载的App安装后，App在Launcher3的桌面自动生成的快捷方式图标为小机器人

## [FAQ11476] Launcher3如何设置桌面的行数和列数？

## [FAQ19902] 增加PIN/Password的密码最大长度

## [FAQ08916] [ICU][Time]如何修改或精确设置出厂默认时间

## [FAQ06452] [ICU][Time]如何修改时间中的上午/下午显示

## [FAQ04421] [ICU][Time]修改某语言环境下默认日期的格式

## [FAQ19932] 快霸(DuraSpeed)功能介绍

## [FAQ15096] 如何在Navigation Bar上长按recent button弹菜单出来

## [FAQ19780] How to auto update apn database by OTA

## [FAQ08124] 关于状态栏的电量百分比

## [FAQ11908] [FSA]进入图库编辑图片保存后，去掉原有图片被覆盖的方法

## [FAQ09895] [SAT]怎么实现没插卡时launcher中不显示STK icon

## [FAQ11770] [USB] MTK USB问题宝典

```
USB OTG问题：
FAQ06610 [USB] USB OTG功能如何打开及实现 
FAQ03872 [USB] 怎么开启OTG功能
FAQ04016 [USB] 如何实现OTG U盘自动挂载 
FAQ06656 [USB] 哪些平台支持OTG，OTG功能支持的设备 
FAQ11784 [USB] 如何实现USB OTG鼠标的右键为返回键功能？

USB 名称修改系列：
FAQ09991 【USB名称修改系列】第1项-为什么参考FAQ修改名称后却无效
FAQ04857 【USB名称修改系列】第2项-如何修改PTP在PC"我的电脑"中显示的label名称 
FAQ03524 【USB名称修改系列】第3项-如何修改MTP在PC"我的电脑"中显示的label名称 
FAQ04856 【USB名称修改系列】第4项-如何修改BICR在PC"我的电脑"中显示的label名称
FAQ07081 【USB名称修改系列】第5项-如何修改MTP在PC设备管理器中制造商的名称 
FAQ05691 【USB名称修改系列】第6项-如何修改手机在PC桌面右下角弹出的“MT65xx Android Phone”提示框
FAQ09979 【USB名称修改系列】第7项-如何修改PTP设备在PC上弹出的对话框的标题 
FAQ09980 【USB名称修改系列】第8项-如何修改mtp设备在设备管理器中的”Portable Devices”下的名称 
FAQ09982 【USB名称修改系列】第9项-如何修改UMS在设备管理器中DiskDrive下的名称 
FAQ09985 【USB名称修改系列】第10项-如何修改设备管理器中设备名后的数字 
FAQ09986 【USB名称修改系列】第11项-如何修改preloader阶段的vcom口在windows右下角的提示框的字符串显示 
FAQ09987 【USB名称修改系列】第12项-如何修改MTP在windows弹出的自动播放提示框标题
FAQ04906 [USB名称修改系列] 第13项-如何修改USB存储在PC"我的电脑"中显示的label名称 
FAQ11803 [USB]修改USB存储在PC"我的电脑"中显示的label名称，如何解决label中的小写字母全部变成大写字母的问题？
FAQ05418 【USB名称修改系列】第14项-如何修改pc端設備管理器中"Android Phone"目錄下的設備名
FAQ10612 【USB名称修改系列】第15项-如何修改USB设备在控制面板中显示的名称 
FAQ11542 [USB名称修改系列] 第16项-如何修改MTP在windows自动播放窗下的设备名称 
FAQ11559 [USB名称修改系列] 第17项-如何修改"USB tethering" 在PC端的显示
FAQ11561 [USB名称修改系列] 第18项-如何修改"ACM 虚拟串口" 在PC端设备管理器的显示
FAQ11984 [USB名称修改系列] 第19项-手机连上PC端，切成MTP mode，sd卡在电脑端的名称怎么修改
FAQ12212 [USB名称修改系列] 如何修改USB MTP模式下，“设备与打印机”中Model项的显示？
FAQ04779 [USB]如何修改设备管理器中的磁盘驱动器名
FAQ09627 修改UMS功能在设备管理器中名称的限制 

USB serial number客制化：
FAQ10922 [USB serial number客制化][系列1]如何修改adb devices的序列号 
FAQ10923 [USB serial number客制化][系列2]：如何实现每台手机的序列号唯一？
FAQ10924 [USB serial number客制化][系列3]：如何修改手机序列号为Barcode？
FAQ10925 [USB serial number客制化][系列4]：如何修改手机序列号为手机型号？ 
FAQ10926 [USB serial number客制化][系列5]：如何实现可以通过pc工具来修改serial number？ 
FAQ10927 [USB serial number客制化][系列6]：能否实现adb devices的序列号，usb serial number, cts device ID，SN一致?
FAQ12705 [USB serial number客制化][系列7]：MT6752/32 KK2版本定义CONFIG_MTK_USB_UNIQUE_SERIAL宏不起作用

USB 驱动安装问题：
FAQ11062 如何实现usb驱动自动安装？ 
FAQ05690 [USB] How to add ISO files into BICR? 
FAQ11544 [USB]-[CDROM]如何设定打开CDROM后windows弹出自动播放窗口？ 
FAQ03324 [USB] [在Factory Mode或Recovery Mode开机后，MT65xx Android Phone的驱动如何安装？] 
FAQ03468 [USB]ADB驱动申请与安装问题 
FAQ10010 win8 64位 adb usb 驱动安装不成功
FAQ03928 [USB]MTP的介绍？驱动如何安装？

USB 测试认证相关问题：
FAQ09341 [USB]monkey测试，CTS认证，mtbfb测试，或自动化测试等，adb掉口(adb offline)问题的解决办法 
FAQ11050 Google CTS测试的USB VID/PID组合相关问题 
FAQ11649 [USB]KK修改serialno导致CTS测试失败 
FAQ08570 Monkey test时跑com.android.settings，ADB会断开
FAQ07395 [USB] 微软WHQL认证的一些基本问题
FAQ11017 [USB] 入库测试时，USB注意事项 
FAQ11451 [USB] 过USB-IF测试注意事项及修改

USB VID修改相关问题：
FAQ02433 [USB] 如何修改VID?
FAQ02497 [USB] 如何刪去USB的註冊表 

USB UMS问题：
FAQ06836 [USB]usb存储模式，拷贝大文件失败
FAQ08240 [USB]没有外置SD卡，UMS模式下去掉PC端对应的盘符显示
FAQ06755 [USB]如何同时打开UMS和BICR(CD-ROM)
FAQ10331 打开UMS功能后，只能看到外置T卡，不能看到内置T卡
FAQ06926 [USB] 如何设置UMS模式内置SD卡只读
FAQ09406 插入USB线，没有自动弹出‘打开USB存储设备’的页面

USB MTP/PTP问题：
FAQ09160 USB PTP功能如何同时显示内置、外置SD卡内容[JB2]
FAQ09339 [USB]USB MTP模式下，copy mtklog到PC上时，出现拷贝错误，或者拷贝不全等问题
FAQ09470 MTP模式下，mtklog在PC 与file manager显示不同步，或者copy不完全
FAQ09665 MTP和PC数据同步时所支持的文件格式

USB ACM问题：
FAQ04694 [USB] 如何默认打开虚拟串口ACM的功能？
FAQ08605 GB2上怎么通过USB发AT命令
FAQ11178 User版本如何开启acm功能来下at command

USB ADB问题：
FAQ11513 [ADB]linux下的ADB在KK user版上无法使用的问题
FAQ10396 linux下使用adb出问题
FAQ11123 当修改VID PID后再连adb不识别的问题
FAQ03908 [USB]如何开关默认USB调试功能 
FAQ11787 [USB] KK user版本使用adb会提示error: device offline
FAQ13506 L版本ADB无法使用的问题

其他USB 相关问题：
FAQ04464 [USB]如何修改USB连接后的默认功能
FAQ02436 [USB]如何强制切换为USB 1.1?
FAQ10295 缓慢插入USB有时无法识别的问题 
FAQ11035 如何通过USB接口抓UART log 
FAQ09557 [USB] 使用USB互联网
FAQ11320 USB tethering以及USB internet的使用说明
FAQ10261 开启USB调试与打开USB Tethering成功与否的关系
FAQ10740 [ICUSB] How to enable IC-USB feature?
FAQ19176 Android N 版本以后，MTK 不再支持 USB_Mass_Storage(UMS)功能.
```

## [FAQ20147] how to update wifi firmware?

## [FAQ20366] 使用Android Studio debug Framework代码

## [FAQ04306] 如何通过 Eclipse 远端调试framework和APK？
## [FAQ11202] 如何在Eclipse中调试Framework和APK
## [FAQ03049] 如何在Eclipse里debug 系统内置的Application
## [FAQ03050] 如何解决Eclispe编译的android原生程序报找不到类的错误

```
将联系人应用提取出来，并且将所依赖的jar包导入 eclipse ，编译成功后，安装联系人应用的apk文件到模拟器，发现应用运行不起来，通过查看trace，发现是找不到phone，mediatek下面相关的类。
[SOLUTION]
这个主要是由静态编译和动态编译的原因造成。由于使用动态编译时，模拟器中没有可供调用的库，故报找不到类的错误。具体修改方法见下图:

见上图中，针对第三方库phone.jar和sns.jar需要使用Add External Jars的方式添加进来，这样 eclipse会以静态方式编译所依赖的库。就可以解决找不到类的问题。

备注：6573 Android V2.3上，LauncherPlus无法在MTK模拟器上debug和运行，需要使用真机来调试和运行看效果。
```

## [FAQ19267] wifi: 连接网络时提示“已连接无法访问互联网”几秒钟后消失

## [FAQ14409] [SIM]SIM卡默认名称客制化

## [FAQ20546] android O定时开关机说明

## [FAQ20603] [Framework-VPN]设置Always-on VPN 如何保存

## [FAQ20612] [Android O Build]如何正确的添加环境变量

## [FAQ19089] 状态栏时间不更新

## [FAQ20622] [SP FlashTool]SP Flashtool编译环境Qt Creator安装

## [FAQ20644] Android O、N版本修改dex2oat编译选项，减少占用ROM空间或者加快安装速度

## [FAQ20665] O1版本定制长按电源键弹出菜单选项

## [mtklog][FAQ12427] 如何监测MTKLogger的状态改变

## [IME][FAQ14050] 如何删除LatinIME中的特定表情

## [IME][FAQ04327] 如何修改默认输入法

## [IME][FAQ06649] Latin输入法怎么默认勾选几种语言？

## [FAQ20328] 如何减少lowmemory的发生几率

## [FAQ12532] [TimeZone]如何更新时区data文件

## [FAQ19927] [TimeZone]执行生成tzdata脚本时遇到的问题

## [FAQ02484] [BMT]关机充电动画客制化以及错位调整

## [FAQ03426] 当系统存在多个Launcher时，如何设置开机自动进入默认的Launcher？

## [FAQ20670] Android GO版本上 非首次进入应用过程中有从模糊到清晰的过程

## [FAQ18332] 如何修改 android log buffer 大小

=========================================== FAQ end ================================================

=========================================== WCP begin ================================================

## Android O版本 App 如何获取自定义节点的访问权限-SELinux

```
背景介绍：接到一个任务，要做一个高温报警的开关。我的想法是在EngineerMode下面做这个功能。驱动调出来一个proc节点，写0开关打开有高温报警；写1开关关闭高温报警关闭，于是这个问题就变成了上层如何读写proc节点的问题。

查阅了很多资料，也查阅了以前N上的代码，做出如下总结：

1.在alps/device/mediatek/sepolicy/basic/non_plat/file.te中增加一个自定义的名称，格式如下：

自定义名称                 文件类型
type temperature_proc, fs_type,sysfs_type;

2.在alps/device/mediatek/sepolicy/basic/non_plat/genfs_contexts中将proc文件与自定义的名称链接起来。格式如下：

proc文件路径               自定义名称
genfscon   proc /sagereal_switch/sagereal_ntc_poweroff_switch u:object_r:temperature_proc:s0

3.你要知道你修改的apk的uid是什么类型的，目前我知道两种：一种是systemapp，AndroidManifest.xml中声明的是：android:sharedUserId="android.uid.system"；另一种是radio app，AndroidManifest.xml中声明的是：android:sharedUserId="android.uid.phone"。这样的声明能使得apk获得相对应的权限。EngineerMode声明的是android:sharedUserId="android.uid.phone"。

需要在alps/device/mediatek/sepolicy/basic/non_plat/radio.te（systemapp是在同路径下的system_app.te）新增所需要申请的权限，格式如下：
app类     自定义的文件名称 类型                  需要申请的权限

allow   radio    temperature_proc:file    { read write open ioctl getattr };

4.很容易遗漏的一步：

在平台相关的init.平台.rc文件中声明：

chmod 0666 /proc/sagereal_switch/sagereal_ntc_poweroff_switch

让该proc文件获得权限。

以上四步之后，权限就申请完毕了。

相关知识：te文件
```

=========================================== WCP end ================================================

================================== Others begin ======================================

## [init.rc]init.rc详解

```
https://blog.csdn.net/morixinguan/article/details/50775266

本说明文件位于system/core/init/readme.txt

本文参考深入解析安卓系统一书，进行翻译，版权部分归书的作者  刘超，资深Android专家，系统架构师。

博客地址：http://blog.csdn.net/u013234805/article/details/45438219



Android Init Language

---------------------

The Android Init Language consists of four broadclasses of statements,

which are Actions, Commands, Services, and Options.

安卓的初始化脚本语言包括了4种基本的类型声明：行为，命令, 服务和选项。

 

All of these are line-oriented, consisting of tokensseparated by

whitespace.  Thec-style backslash escapes may be used to insert

whitespace into a token.  Double quotes may also be used to prevent

whitespace from breaking text into multipletokens.  The backslash,

when it is the last character on a line, may be usedfor line-folding.

所有的这些都以行为单位，各种符号则由空格分开。当然，C语言风格种的\反斜杠符号用在符号的期间插入相应的空格。双引号可以用于防止字符串被空格分割成多个记号。行的最后的反斜杠用于折行。

Lines which start with a # (leading whitespaceallowed) are comments.

注释的方法是以#号开头，当然也可以以空格开头。

 

Actions and Services implicitly declare a newsection.  All commands

or options belong to the section most recentlydeclared.  Commands

or options before the first section are ignored.

行为和服务声明一个新的分组。所有命令或者是选项都依赖于最近所声明的分组里。其中位于分组之前的命令或者是选项将会被忽略。

 

Actions and Services have unique names.  If a second Action or Service

is declared with the same name as an existing one, itis ignored as

an error.  (???should we override instead)

行为和服务有着独特的名字。如果第二行为或者服务宣告名字已经存在。那么这会导致行为或者服务被忽略或者产生相应的错误。（也许会被覆盖）

 

Actions  行为

-------

Actions are named sequences of commands.  Actions have a trigger which

is used to determine when the action shouldoccur.  When an event

occurs which matches an action's trigger, that actionis added to

the tail of a to-be-executed queue (unless it isalready on the

queue).

行为Actions其实就是一个序列的命令的集合。每个行为都有一个触发器trigger，触发器的作用决定了行为的什么时候将要执行。当一个符合Action触发条件的事件发生了，这个行为会加入到执行这个队列的结尾。

Each action in the queue is dequeued in sequence andeach command in

that action is executed in sequence.  Init handles other activities

(device creation/destruction, property setting,process restarting)

"between" the execution of the commands inactivities.

每一个行为都依次从队列里面被不断的取出来，然后这个行为的的每一个命令都将被一一执行。在这些命令执行的时候，init还同时处理着其它的活动，包括了设备节点的创建和销毁，设置属性，重新启动进程。

 

Actions take the form of:

Actions行为的格式如下：
on <trigger>
  <command>
  <command>
  <command>

Services 服务
--------
Services are programs which init launches and(optionally) restarts
when they exit. Services take the form of:
服务其实是一个后台的程序，这个程序在init进程中被启动，如果退出了可以由系统重新启动（可选择）。
服务的格式如下：
service <name> <pathname> [<argument> ]*
  <option>
  <option>
   ...

Options 选项
-------
Options are modifiers to services.  They affect how and when init runs the service.
选项是服务的一个修订项，他们决定了一个服务什么时候执行以及是如何去执行。

critical
   This is adevice-critical service. If it exits more than four times in
   four minutes,the device will reboot into recovery mode.
   Critical表示这是一个关键的服务。如果服务4分钟内重新启动超过4次的情况下，系统将会重新启动进入recovery模式。

disabled
   This servicewill not automatically start with its class.
   It must beexplicitly started by name.
   Disable表示服务不会通过trigger触发器启动，它必须是以命令“start service_name”的形式来进行启动。

setenv <name> <value>
   Set theenvironment variable <name> to <value> in the launched process.
    在服务启动的时候将环境变量name设置成value

socket <name> <type> <perm> [<user> [ <group> [ <context> ] ] ]
   Create a unixdomain socket named /dev/socket/<name> and pass
   its fd to thelaunched process.  <type> must be"dgram", "stream" or "seqpacket".
   User andgroup default to 0.  用户和组默认为0
   Context isthe SELinux security context for the socket.
   It defaultsto the service security context, as specified by seclabel or computedbased on the service executable file security context.
    创建名为/dev /socket/<name> UNIX域套接字，并传递
    ???其文件描述符fd的推出进程。 <类型>必须是“DGRAM”，“流”或“SEQPACKET”。
    ???用户和组默认为0。
    ???Context是套接字SELinux的安全上下文。
    ???它默认到服务的安全上下文，如SECLABEL指定或
    ???基于服务的可执行文件的安全上下文来计算。

user <username>
   Change tousername before exec'ing this service.
   Currentlydefaults to root.  (??? probably shoulddefault to nobody)
   Currently, ifyour process requires linux capabilities then you cannot use
   this command.You must instead request the capabilities in-process while
   still root,and then drop to your desired uid.

在启动这个服务前设置服务的用户名，默认是root。如果你的进程没有相应的权限，你将不能使用这个命令。如果这个进程由root权限，可以在程序中设置到你想要的组uid。

group <groupname> [ <groupname> ]*
   Change togroupname before exec'ing this service. Additional
   groupnamesbeyond the (required) first one are used to set the
   supplementalgroups of the process (via setgroups()).
   Currentlydefaults to root.  (??? probably shoulddefault to nobody)

在启动这个服务前设置服务的组名。除了第一个组名，剩下的组名通常用于设置进程的附加组（通过setgroups()）。默认是root。

seclabel <securitycontext>
  Change tosecuritycontext before exec'ing this service.
  Primarily foruse by services run from the rootfs, e.g. ueventd, adbd.
  Services onthe system partition can instead use policy-defined transitions
  based on theirfile security context.
  If notspecified and no transition is defined in policy, defaults to the init context.

SECLABEL<SecurityContext的>更改为执行该服务之前SecurityContext中。主要为按服务使用从根文件系统，例如运行ueventd，adbd。在系统分区服务可以改用基于其文件的安全上下文策略定义的转换。如果不指定，不转变政策规定，默认为初始化上下文。

oneshot

   Do not restartthe service when it exits.服务在退出后不会再重新启动。

class <name>
   Specify aclass name for the service.  All servicesin a
   named classmay be started or stopped together.  Aservice
   is in theclass "default" if one is not specified via the
   class option.
给服务指定一个名字，所有的同名字的服务可以同时启动和停止。如果不通过class选项指定一个名字，则默认的名字是default

onrestart
    Execute aCommand (see below) when service restarts.
    当服务重启的时候，执行一条命令。

Triggers
--------
   Triggers arestrings which can be used to match certain kinds
   of events andused to cause an action to occur.
    触发器是一个用于匹配某种事件类型的字符串，它将使对于的行为执行。

boot
   This is thefirst trigger that will occur when init starts
   (after/init.conf is loaded)
    Boot是init执行后第一个触发的行为。在/init.conf被装载以后。

<name>=<value>
   Triggers ofthis form occur when the property <name> is set to thespecific value <value>.

这种形式的触发会在属性name设置为指定的值value时触发或者删除

device-added-<path>
device-removed-<path>
   Triggers ofthese forms occur when a device node is added or removed.
这种形式的触发器会在一个设备文件增加或者删除的时候触发。

service-exited-<name>
   Triggers ofthis form occur when the specified service exits.
这种形式的触发器会在一个指定的服务退出的时候触发。
 
Commands 命令
--------
exec <path> [ <argument> ]*
   Fork andexecute a program (<path>).  Thiswill block until
   the programcompletes execution.  It is best to avoidexec
   as unlike thebuiltin commands, it runs the risk of getting
   init"stuck". (??? maybe there should be a timeout?)
   Fork和启动第一个程序。在程序完成启动前，init将会阻塞。应该尽量避免使用exec，它可能会引起init卡死。

export <name> <value>
   Set theenvironment variable <name> equal to <value> in the
   globalenvironment (which will be inherited by all processes
   started afterthis command is executed)

设置全局变量<name>为<value>，所有在这个命令执行后运行的进程都将继承该环境变量。

ifup <interface>
   Bring thenetwork interface <interface> online.

启动网络接口interface

import <filename>
   Parse an initconfig file, extending the current configuration.

引入一个init的配置文件，拓展当前配置。

hostname <name>
   Set the hostname.

设置主机名。

chdir <directory>
   Changeworking directory.

改变进程当前的工作目录。

chmod <octal-mode> <path>
   Change fileaccess permissions.

设置文件或者目录的访问权限。

chown <owner> <group> <path>
   Change fileowner and group.

设置文件或目录的所有者和组。

chroot <directory>
  Change processroot directory.

设置进程的根目录。

class_start <serviceclass>
   Start allservices of the specified class if they are not alreadyrunning.

启动所有指定服务名称下的未运行服务。

class_stop <serviceclass>
   Stop allservices of the specified class if they are currently running.

停止所有指定服务名称下的已经运行的服务。

domainname <name>
   Set thedomain name.
设置域名。

enable <servicename>
   Turns adisabled service into an enabled one as if the service did not
   specifydisabled.
   If theservice is supposed to be running, it will be started now.
   Typicallyused when the bootloader sets a variable that indicates a specific
   serviceshould be started when needed. E.g.
     onproperty:ro.boot.myfancyhardware=1
        enablemy_fancy_service_for_my_fancy_hardware

启用<服务>如果服务没有指定禁用，则打开这个被禁用的服务。

如果服务是应该运行时，将立即开始。当引导加载程序设置一个变量，表示需要时一个特定的服务应启动通常使用。 例如：
  service shouldbe started when needed. E.g.
     onproperty:ro.boot.myfancyhardware=1

insmod <path>
   Install themodule at <path>

安装一个驱动模块

mkdir <path> [mode] [owner] [group]
   Create adirectory at <path>, optionally with the given mode, owner, and
   group. If notprovided, the directory is created with permissions 755 and
   owned by theroot user and root group.

新建一个目录，可以指定访问权限、拥有者和组。如果没有被最后定，默认的访问权限是755，属于root用户和root组。

mount <type> <device> <dir> [<mountoption> ]*
   Attempt tomount the named device at the directory <dir>
  <device> may be of the form mtd@name to specify a mtd block
   device byname.
  <mountoption>s include "ro", "rw","remount", "noatime", ...
在指定的目录下挂载一个设备。可以是以mtd@name的格式指定的一个mtd块设备。
<mountoption>包括了 "ro","rw", "remount", "noatime", ...
 
restorecon <path> [ <path> ]*
   Restore thefile named by <path> to the security context specified
   in thefile_contexts configuration.
   Not requiredfor directories created by the init.rc as these are
   automaticallylabeled correctly by init.

重新存储指定的文件到一个由file_contexts配置的安全上下文。不用指定目录，它们会被init进程自动创建。

 

restorecon_recursive <path> [ <path> ]*

   Recursivelyrestore the directory tree named by <path> to the

   securitycontexts specified in the file_contexts configuration.

   Do NOT usethis with paths leading to shell-writable or app-writable

   directories,e.g. /data/local/tmp, /data/data or any prefix thereof.

递归的restorecon<路径> [<路径>] *递归恢复通过<路径>命名的目录树中存储在file_contexts配置中指定的安全上下文。不要用路径，这会导致shell可写或应用可写目录，

例如使用/data/local/tmp, /data/data数据或任何其前缀。

 

setcon <securitycontext>

   Set thecurrent process security context to the specified string.

   This istypically only used from early-init to set the init context

   before anyother process is started.

设置当前进程的安全上下文为指定的串。主要用在early-init中去设置init的安全上下文。

setenforce 0|1

   Set theSELinux system-wide enforcing status.

   0 ispermissive (i.e. log but do not deny), 1 is enforcing.

设置SELinux系统级的enforcing状态。0代表permissive（如记录但是不拒绝服务），1代表enforcing

 

setkey

   TBD 目前没有使用

 

setprop <name> <value>

   Set systemproperty <name> to <value>.

设置系统属性<name>为<value>值。

 

setrlimit <resource> <cur> <max>

   Set therlimit for a resource.

设置系统属性<resource>的rlimit值。

 

setsebool <name> <value>

   Set SELinuxboolean <name> to <value>.

   <value>may be 1|true|on or 0|false|off

设置SELinux的boolean型属性"name"的值为"value"、"value"可以是1|true|on或者0|false|off

 

start <service>

   Start aservice running if it is not already running.

如果服务没有被执行就启动指定的服务

 

stop <service>

   Stop aservice from running if it is currently running.

如果服务在运行，那么就停止指定的服务。

 

symlink <target> <path>

   Create asymbolic link at <path> with the value <target>

创建一个符号链接。

 

sysclktz <mins_west_of_gmt>

   Set thesystem clock base (0 if system clock ticks in GMT)

设置系统时钟基准,0代表格林尼治平均时GMT为准。

 

trigger <event>

   Trigger anevent.  Used to queue an action fromanother

   Action.

触发一个事件。用于将一个行为和另一个行为连接在一起执行。

 

wait <path> [ <timeout> ]

  Poll for theexistence of the given file and return when found,

  or the timeouthas been reached. If timeout is not specified it

  currentlydefaults to five seconds.

等待指定路径的文件创建出来，创建完成就停止等待，或者等待超时时间到。如果未指定超时时间，默认是5秒。

write <path> <string>

   Open the fileat <path> and write a string to it with write(2)

   withoutappending.

打开指定的文件，并写入一个或者多个字符串。

 

Properties 属性

----------

Init updates some system properties to provide someinsight into

what it's doing:

初始化更新一些系统属性来提供一些见解

它在做什么：

 

init.action

   Equal to thename of the action currently being executed or "" if none

等于当前正在执行或行动“的名义”，如果没有

 

init.command

   Equal to thecommand being executed or "" if none.

等于命令被执行或“”如果没有。

init.svc.<name>

   State of anamed service ("stopped", "running","restarting")

一个名为服务的状态（“停止”，“运行”，“重新启动”）

 

Example init.conf 例如init.conf

-----------------

 

# not complete -- just providing some examples ofusage

#

＃不完整 - 只是提供一些用法示例

＃

on boot

   export PATH/sbin:/system/sbin:/system/bin

   export LD_LIBRARY_PATH /system/lib

 

   mkdir /dev

   mkdir /proc

   mkdir /sys

 

   mount tmpfstmpfs /dev

   mkdir/dev/pts

   mkdir/dev/socket

   mount devptsdevpts /dev/pts

   mount procproc /proc

   mount sysfssysfs /sys

 

   write /proc/cpu/alignment4

 

   ifup lo

 

   hostnamelocalhost

   domainnamelocalhost

 

   mount yaffs2mtd@system /system

   mount yaffs2mtd@userdata /data

 

   import/system/etc/init.conf

 

   class_startdefault

 

service adbd /sbin/adbd

   user adb

   group adb

 

service usbd /system/bin/usbd -r

   user usbd

   group usbd

   socket usbd666

 

service zygote /system/bin/app_process -Xzygote/system/bin --zygote

   socket zygote666

 

service runtime /system/bin/runtime

   user system

   group system

 

on device-added-/dev/compass

   start akmd

 

on device-removed-/dev/compass

   stop akmd

 

service akmd /sbin/akmd

   disabled

   user akmd

   group akmd

 

Debugging notes 调试笔记

---------------

By default, programs executed by init will drop stdoutand stderr into

/dev/null. To help with debugging, you can executeyour program via the

Andoird program logwrapper. This will redirectstdout/stderr into the

Android logging system (accessed via logcat).

 

默认情况下，由init执行的程序将标准输出和标准错误信息输出定向到/dev/ null的。为帮助调试，您可以通过执行Android程序logwrapper。这将标准输出/标准错误重定向到Android的日志系统（通过logcat的访问）。

 

For example

service akmd /system/bin/logwrapper /sbin/akmd

例如

service akmd /system/bin/logwrapper /sbin/akmd
```

## 如何从MTK平台机器的NVRAM中获取WIFI mac地址

```
https://blog.csdn.net/morixinguan/article/details/76850600
```

## Android makefile编写基础

```
首先来看一个简单的Android makefile,这个是我上篇文章写的，重新摘出来:

LOCAL_PATH:=$(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE_TAGS := eng
LOCAL_LDLIBS := -L$(SYSROOT)/usr/lib -llog 
LOCAL_SRC_FILES:= \
		ppp.c
	
LOCAL_MODULE:= PPPreboot
include $(BUILD_EXECUTABLE)
#include $(BUILD_SHARED_LIBRARY)
下面对上面的语法进行解析:
LOCAL_PATH:=$(call my-dir) 					 定义了当前模块的相对路径
include $(CLEAR_VARS)      					 清空了当前的环境变量
LOCAL_MODULE_TAGS := eng   					 指定模块在eng模式下才进行编译 
LOCAL_LDLIBS := -L$(SYSROOT)/usr/lib -llog   编译需要的库
LOCAL_SRC_FILES:ppp.c      				     编译所需要的目标源文件，一般都是当前目录下，或者依赖于其它目录下
LOCAL_MODULE:= PPPreboot   					 编译生成该目标的名称，也就是最终的可执行文件
include $(BUILD_EXECUTABLE)				     编译所生成的目标的文件格式 
其中:
my-dir在build/core/definitions.mk定义
CLEAR_VARS在build/core/config.mk定义 

以下就是我之前写的源码，简单的功能。

#include <stdio.h>  
#include <stdlib.h>  
#include <android/log.h>  
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, "keymatch", __VA_ARGS__)  
int main(void) {
    int i ; 
    freopen("/dev/ttyMT0", "a", stdout);setbuf(stdout, NULL);
    freopen("/dev/ttyMT0", "a", stderr);setbuf(stderr, NULL);
    LOGD("YYX---->reboot system!!!!!!--->201612.1\n");
    system("reboot");
    return 0 ;
} 
makefile还有源码写完以后我们就可以进行编译了。
首先，需要source build/envsetup.sh  初始化参数和环境变量
接着lunch  对应的平台的版本

接着就拥有了mm、mmm等编译工具
然后对刚刚写的程序进行手动编译: mmm external/test/
```

## 在android系统上写C语言程序--开机启动该程序不进入安卓系统

```
今天要写的这篇博文意义重大，也是网上很少有的，这是在我工作中学会的一项技术，当然，它也是由简单的问题组合而来的。如何在安卓中写C语言程序，调试安卓驱动，测试程序的的一项重要技能，下面我就不说废话了，直接说实用的，怎么用这个东西。


     关于这个问题，相信很多学Android的都会去关注这个问题,大家普遍会有个这样的疑问：安卓是怎么跑起来的？

    最简单的说法，安卓系统是这样加载的：

    Bootloader------Kernel(对应平台版本的Linux内核)------filesystem文件系统(这个就是Android了)

    所以说，安卓其实不是操作系统，而是一个基于linux内核的文件系统。

   那么，我们标题所说的，要在开机的时候就运行我们的程序而不选择进入安卓系统，那么如何来实现呢?首先，得了解一个问题，filesystem是怎么启动的。

   从网上搜索的资料还有一些讲Andorid系统的书籍来看，文件系统的加载是从init.rc开始一步步的，创建文件系统所需的目录，还有给这些目录加权限，拷贝相关的程序，等待操作，最重要的，一个文件系统的运行需要加载这些服务才可以实现。至于怎么加载的，原理我就不多说了，说来话长，推荐大家可以去搜索init.rc，init.c这样的字眼就可以明白了。

   我们现在讲的是如何来实现开机就执行bin文件，而不进入安卓系统。

1、  为了区别我的服务跟别的服务的不同，我的服务独立于一个on来进行触发。

on YYX
class_start core
service pppService /system/bin/PPPreboot 
   class core 
   user root
   group root
   oneshot
    我写的这个服务名字叫做pppService,服务对应需要执行的bin文件是PPPreboot，实现的就是平板一开机打印语句然后就重启，一直反复，这样就不会进入安卓文件系统了，也就看不到我们平常使用的安卓UI界面，而是黑压压的一篇，但是你在串口上可以看到调试信息输出，当然，如果你了解驱动应用编程，你可以在此时在屏幕上画点东西，做你自己的界面,其实就是写C或者C++的程序了，就是写linux的应用程序。

2、源码如下(位置:external/test/ppp.c)

#include <stdio.h>
#include <stdlib.h>
#include <android/log.h>
#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, "keymatch", __VA_ARGS__)
int main(void)
{
	int i ;
    freopen("/dev/ttyMT0", "a", stdout);setbuf(stdout, NULL);
	freopen("/dev/ttyMT0", "a", stderr);setbuf(stderr, NULL);
	LOGD("YYX---->reboot system!!!!!!--->201612.1\n");
	system("reboot");
	return 0 ;
}
对应的Android.mk

LOCAL_PATH:=$(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE_TAGS := eng
LOCAL_LDLIBS := -llog
LOCAL_SRC_FILES:= \
    	ppp.c
	
LOCAL_MODULE:= PPPreboot
include $(BUILD_EXECUTABLE)
#include $(BUILD_SHARED_LIBRARY)
1.对编写好的这个C程序进行编译，用命令mm或者mmm进行编译，编译生成的PPPreboot就位于我们开机启动的安卓文件系统的system/bin/这个目录下

2.在init.rc中调用trigger命令触发这个on YYX,只要再适当的位置加上:trigger  YYX  就可以了

3.编译:make –j8

将对应的文件下载到安卓平板，开机你就会发现平板可以打印信息也可以不断的重启了。

如果此时不加上:

freopen("/dev/ttyMT0","a", stdout);setbuf(stdout, NULL);

freopen("/dev/ttyMT0","a", stderr);setbuf(stderr, NULL);

你不会在安卓的串口上看到任何的输出信息，因为串口在init.cpp的时候就已经做了这步设置，详情请查看system/core/init/init.cpp代码:

open_devnull_stdio();

这一句的作用就是将安卓中的标准输入输出重定向到/dev/null，众所周知，这被称为是linux的一个空洞文件，这个文件可以接收一切的信息，它就像一个垃圾桶一样。但是有个特点，它是只进不出的。

所以，我们在自己写的C程序或者C++程序中需要先重定向到标准输入输出，freopen的作用就是这样的，还应该要注意，你的板子的串口输出设备节点是什么，我的是/dev/ttyMT0，有可能你的就跟我不一样了。

关于上面说的这个应用，应用范围，一些PCBA的产测工具可以在这个时候进行实现，或者手动OTA更新等等，应用非常广泛，需要大家在工作中孰能生巧。
```

=========================================== TODO begin ================================================

## Android 逆向？？？

```
https://blog.csdn.net/qq_36869808/article/details/78999010
```

## 按键配置？？？

## 学习使用 QAAT 工具？？？

## efuse????

## WAPI 是什么？？？

## PICS 是什么？？

## SharedUserId 有哪几种？？

## 如何查看进程的 uid, gid ？？？

## 自拍杆的原理？？？自拍杆上的按键键值如何定义？？

## smart PA 是什么东西？？？

## Bluetooth蓝牙协议有哪些？？？分别有什么用？？？

```
[FAQ03558] [Settings]6573 & 6575平台支持哪些蓝牙Profile
OPP    ：Object Push Profile
SIMAP ：SIM Access Profile
PRXM  ：Proximity Monitor
PRXR   ：Proximity Reporter
HIDH   ：Human Interface Device Host
FTP    ：File Transfer Profile
PBAP  ：Phone Book Access Profile
BPP    ：Basic Printing Profile
BIP    ：Basic Imaging Profile
DUN   ：Dial-up Networking
PAN   ：Personal Area Network
HFP   ：Hands-free Profile
A2DP  ：Advanced Audio Distribution Profile
AVRCP ：Audio/Video Remote Control Profile
MAPS  ：Message Access Profile (Server)
SPP   ：Serial Port Profile
```

## ADB root 和 手机 root 的区别？？现在手机可以root吗？？？

## 研究pinyinIME？？？

## 能否通过命令行显示 toast ？？？

## system/bin 和 system/xbin 下的命令的用法？？？

## 如何搭建mota服务器？？？？

## C2K 是什么意思？？？

```
C2K：CDMA2000

EVDO : 表示支持中国电信3G数据业务。
CDMA2000是网络制式，类似于GSM、WCDMA、TD-SCDMA
EVDO是该制式下的一种网络技术，以实现3G的高速数据链接，类似于WCDMA的EDGE、HSPA等。
在中国电信3G网络中，将CDMA2000划分为CDMA 1X和CDMA EVDO，其中1X特指CS业务（主要是语音通话业务），而EVDO则独立支持高速3G数据业务，也就是通常用户体验的高速数据业务下载应用，都承载在EVDO网络上
```

## I2C是什么东西？？？

## ResourceOverlay 怎么用？？？

## 如何读取和修改 SIM 卡里的文件？？

## 如何自定义状态栏上的图标？？就像KIKA输入法那样？？

## 如何自定义AT命令？？？怎么发送？？怎么接收处理？？

## 如何在添加 nomedia 文件？？

## 什么是三段式耳机？？什么是四段式耳机？？

## 手机加密算法？？？ GEA？？？

## [FAQ20977] 如何配置VoLTE, ViLTE and VoWifi(IMS config for VoLTE, ViLTE and VoWifi)

## webview 是个什么应用？和chromewebview有什么区别？

## system/priv-app 和 system/app 的区别？？

## 如何在 Gedit 中添加 CodeSnippets ???

## [FAQ11012]如何为锁屏设置一张不同于launcher的，固定加载的背景图片

## [FAQ09296]如何将APN设置为不可编辑 ???

## TODO : UIAutomator 的学习和使用？？？？

## TODO : AccessibilityService 的学习和使用？？？？？

## TODO : TextView去掉上下边距？？？？

## TODO : AndroidManifest中的模板？？？？

## TODO : Activity模板？？？？

## TODO : Service模板？？？？

## TODO : Receiver模板？？？？

## TODO : ContentProvider模板？？？？

## TODO : Adapter模板(ListView+GridView)？？？

## TODO : Adapter模板(RecyclerView)

## TODO : startActivity模板

## TODO : sendBroadcast模板

## TODO : startService模板

## TODO : SharedPreference模板

## TODO : Bitmap解析模板？？？

## TODO : Http请求模板

## TODO : Notification模板

## TODO : File操作模板

## TODO : SystemProperties的反射模板类？？？

## TODO : 反射模板？？？

## TODO : icu如何编译？？？

## TODO : Kotlin，Flutter 写的代码，怎么反编译？？

## TODO : 阿拉伯语相关问题修改？

## TODO : android_id的获取？？？这个东西有什么用？？？

```
adb shell settings get secure android_id
```

## 通过自定义暗码启动

```
<receiver
    android:name=".SecretCodeReceiver">
    <intent-filter>
        <action android:name="android.provider.Telephony.SECRET_CODE" />
        <data android:scheme="android_secret_code" android:host="1010"  />
    </intent-filter>
</receiver>

public class SecretCodeReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        if (intent != null && SECRET_CODE_ACTION.equals(intent.getAction())){
            Intent i = new Intent(Intent.ACTION_MAIN);
            i.setClass(context, MainActivity.class);
            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            context.startActivity(i);
        }
    }
}
```

## 获取 IMEI 码 ？？

```
adb shell service call iphonesubinfo 1
```

## 获取 IP 地址 ？？？

```
adb shell ifconfig | grep Mask
```

## [FAQ14252] MT6735/35M/35P/53/53T软件包使用说明(L1.MP3&L1.MP3.TC7SP&M0.MP1适用)

```
flashtool 报错 STATUS_DA_HASH_MISMATCH : flash不兼容的问题
```

## [FAQ10820]Android 8.1移植：针对某个APK做到wifi和gprs分别做到允许和禁止两种策略

```
https://blog.csdn.net/zengrunxiu/article/details/81027275
```

## TODO : 如何把 FAQ 的标题和链接都保存下来？？？

=========================================== TODO end ================================================

## 必看！java后端，亮剑诛仙（最全知识点）

```
https://juejin.im/post/5d2d2ba96fb9a07f050a9ad6
```

## 设计模式

```
https://juejin.im/post/5d27495fe51d4556dc2936c3
```

## Android优化总结

```
https://juejin.im/post/5d072dbc51882540b7104709
```

## Android复习资料——Android知识点汇总（一）

```
https://juejin.im/post/5d19cec5f265da1baa1e8c0a
```

## Android手机信息获取很难？

```
App信息获取
App安装列表获取
音量数据获取
版本数据获取
电池数据获取
Cpu实时数据获取
蓝牙数据获取
系统Build数据获取
摄像头数据获取
Cpu数据获取
调试数据获取
host数据获取
模拟器数据获取
hook数据获取
本地数据获取
内存数据获取
多开数据获取
网络数据获取
root数据获取
屏幕数据获取
SDCard数据获取
设置数据获取
信号数据获取
手机卡数据获取
堆栈数据获取
唯一ID数据获取
UA数据获取
Xposed数据获取
```

## Java高级开发必会的45个性能优化的细节（珍藏版）

```
https://juejin.im/post/5d1d9d2e6fb9a07ecf72429e
```

## BootLoader 锁是什么意思？？如何解锁bootloader？？？fastboot？？？

## shadow 是什么东西？？？

```
Shadow是通过字节码编辑技术向插件插入中间层，完成插件技术的核心工作的
```

## 事件分发机制

```
public boolean dispatchTouchEvent(MotionEvent ev){
    boolean consume = false;
    if(onInterceptTouchEvent(ev)){
        consume = onTouchEvent(ev);
    }else{
        consume = child.dispatchTouchEvent(ev);
    }
    return consume;
}
```

## 安装包瘦身

```
icon 图标使用 svg
icon状态区分使用 Tint 着色器
App内大图压缩,使用webp格式图片,我们可以通过 智图 或者isparta将其它格式的图片转换成webP格式，isparta可实现批量转换。
图片压缩：ImageOptim + ImageAlpha + TinyPNG

移除无用资源
资源打包设置:由于第三方库的引入,如appcompat-v7的引入库中包含了大量的国际化资源,可根据自身业务进行相应保留和删除。

defaultConfig { 
    applicationId "com.zthx.xianglian" 
    minSdkVersion 19 
    targetSdkVersion 28 
    versionCode 1 
    versionName "1.0.0" 
    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" 
    //只保留指定和默认的资源 
    resConfigs('zh-rCN','ko') 
}
动态库打包配置
开启代码混淆压缩
使用 protobuf 作为序列化数据, flatbuffers
LeakCanary是由Square公司开源的一款轻量的第三方检测内存泄露的工具
BlockCanary
Facebook redex压缩，优化

AndroidStudio使用lint清除无用的资源文件

https://www.cnblogs.com/mengdd/p/reduce-size-of-android-app.html
```

## 日志记录

```
timber + logger + LogUtils
```

## JSON 解析

```
gson + jackson + fastjson + logansquare
```

## 数据库

```
ActiveAndroid + ormlite + greenDAO + realm
```

## 网络

```
android-async-http + okhttp + volley + retrofit
```

## 图片缓存

```
BitmapFun + Picasso + Glide + Fresco + Android-Universal-Image+Loader
```

## 插件化

```
dynamic-load-apk + DynamicApk + DroidPlugin + Small
```

## Crash 日志收集

```
UncaughtExceptionHandler
保存SharedPreference信息
保存Settings数据库信息

public String collectSecureSettings() {
    final StringBuilder result = new StringBuilder();
    final Field[] keys = Settings.Secure.class.getFields();
    for (final Field key : keys) {
        if (!key.isAnnotationPresent(Deprecated.class) && key.getType() == String.class && isAuthorized(key)) {
            final Object value = Settings.Secure.getString(mContext.getContentResolver(), (String) key.get(null));
            if (value != null) {
                result.append(key.getName()).append("=").append(value).append("\n");
            }
        }
    }
    return result.toString();
}

通过 Runtime 执行 logcat 命令保存 logcat 信息
通过 Runtime 执行 dumpsys 命令保存 meminfo 信息
保存应用版本号
保存系统类型及版本号
保存手机设备型号
保存IMEI
保存渠道号
保存crash发生的时间
保存应用的包名
```

## 隐藏敏感信息

```
隐藏在strings.xml中
隐藏在Java源码中
隐藏在BuildConfig中
使用DexGuard
对敏感信息进行伪装或加密
敏感信息隐藏在原声函数库中
对apk进行加固处理
```

## 本地拒绝服务

```
将不需要给其他app调用的组件在AndroidManifest.xml中设置exported="false"
使用Intent获取extra数据时增加try{}catch
注意getAction() 为空的处理
使用intent获取数组，列表灯数据时要作长度验证
强制类型转换时要增加 try{}catch{}
```

## 使用 AES 加密

```
public static byte[] encrypt(String content, String password) {
    try {
        KeyGenerator kgen = KeyGenerator.getInstance("AES");
        kgen.init(128, new SecureRandom(password.getBytes()));
        SecretKey secretKey = kgen.generateKey();
        byte[] enCodeFormat = secretKey.getEncoded();
        SecretKeySpec key = new SecretKeySpec(enCodeFormat, "AES");
        Cipher cipher = Cipher.getInstance("AES");
        byte[] byteContent = content.getBytes("utf-8");
        cipher.init(Cipher.ENCRYPT_MODE, key);
        byte[] result = cipher.doFinal(byteContent);
        return result;
    } catch (Exception e) {
    }
    return null;
}
```

## 热修复hotfix

```
dexposed + AndFix 阿里的技术，基于 xposed + hook

Nuwa + HotFix + DroidFix 腾讯的技术，基于 ClassLoader
```

## AOP ???????

## FaceBook buck 构建系统

## Handler 静态内部类

```
public class HandlerActivity extends Activity {
    private static class InnerHandler extends Handler {
        private final WeakReference<HandlerActivity> mActivity;
        public InnerHandler(HandlerActivity activity) {
            mActivity = new WeakReference<HandlerActivity>(activity);
        }
        public void handleMessage(Message msg) {
            HandlerActivity activity = mActivity.get();
             (activity != null) {
                //
             }
        }
    }
    private final InnerHandler mHandler = new InnerHandler(this);
    private static final Runnable sRunnable = new Runnable() {
        public void run() {
        }
    };
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        mHandler.postDelayed(sRunnable, 1000 * 60 * 5);
    }
}
```

## Context 的单例实现

```
public class SingleInstance {
    private Context mContext;
    private static SingleInstance sInstance;
    private SingleInstance(Context context) {
        mContext = context;
    }
    private static SingleInstance getInstance(Context context) {
        if (sInstance == null) {
            sInstance = new SingleInstance(context.getApplicationContext());
        }
        return sInstance;
    }
}
```

## Android调试工具 Facebook Stetho

```
dumpapp
```

## Redmine 在 AndroidStudio 中的集成？？？在自动化工具中集成？？？

## 单元测试

```
Robolectric

模拟测试框架 mockito

MonkeyRunner

UIAutomator

robotium

espresso

appium
```

## 静态代码分析

```
CheckStyle

FindBugs

PMD

Lint
```

## 宏内核 微内核

```
Android 是基于 Linux 的宏内核
Fusion 和 鸿蒙 是基于 微内核
```

## Jenkins + Gradle 搭建 Android 持续集成编译环境

## Burp Suite 网络监测套件

```
http://portswigger.net/burp/download.html
```

## [adb]content 命令的使用

```
adb shell content query --uri content://settings/system --where "_id=1"
```

## 预置app需要 zipalign 吗？？

## [adb]手动编译 Java 文件生成 .class 再编译成 .dex 文件并push到 data/local/tmp 运行

```
Main.java
public class Main{
    public static void main(String[] args) {
        System.out.println("hello world");
    }
}

// 用 javac 编译生成 .class 字节码文件
javac Main.java

// 用 dx 把 .class 字节码文件编译成 .dex 文件 (dx 文件路径 ~/Android/Sdk/build-tools/27.0.3/dx)
dx --dex --output=Main.dex Main.class

adb push Main.dex /data/local/tmp/

// 用 dalvikvm 运行 Main.dex
adb shell dalvikvm -cp /data/local/tmp/Main.dex Main

// 或用 app_process 运行 dex 文件
adb shell app_process -Djava.class.path=/data/local/tmp/hello.dex /data/local/tmp shellService.Main
```

## [adb]查看应用的 userid

```
adb shell cat /data/system/packages.xml
<package name="com.android.mms" codePath="/system/priv-app/MtkMms" nativeLibraryPath="/system/priv-app/MtkMms/lib" publicFlags="940097125" privateFlags="8" pkgFlagsEx="0" ft="16bda77f4d8" it="16bda77f4d8" ut="16bda77f4d8" version="27" sharedUserId="10020" isOrphaned="true">

adb shell ps | grep "u0"
u0_a20       19013   315 1090980  44876 SyS_epoll_wait aa022c00 S com.android.mms

a20 就是对应的 10020
```

## 安装使用 drozer

```

drozer console connect

list

// 获取 apk 安装信息
run app.package.list -a com.android.launcher3

// 查看 apk 存在的安全隐患
run app.package.attacksurface com.android.launcher3

run app.activity.info -a com.android.launcher3

run app.activity.start --component com.android.launcher3 com.android.launcher3.Launcher
```

## 安装使用 QARK(Quick Android review kit) 静态代码分析工具

```
https://github.com/linkedin/qark .
```

## [adb]adb backup 备份命令

```
adb backup -f backup.ab com.whatsapplock

备份出来的是 .ab 格式的压缩包，需要用 adbextractor 工具打开 或 https://github.com/nelenkov/android-backup-extractor

http://sourceforge.net/projects/adbextractor/

java -jar abe.jar -debug unpack backup.ab backup.tar

pax -r < backup.tar
```

## [adb][Android]利用run-as命令在不root情况下读取data下面的数据

```
over@over-ThinkPad-R52:~$ adb shell
$ run-as com.package
$ cd /data/data/com.package
$ ls
databases
lib
$ cd databases
$ ls
preferences.db
$ cat preferences.db > /mnt/sdcard/preferences1.db

代码说明：

注意com.package换成自己的完整包名，关键是run-as命令，最后使用cat命令把数据库拷贝到sd卡下面。
二、补充

同事分享/data/data/package/lib这个目录是可以直接访问的，也就是说adb shell后虽然无法读取/data目录，但是可以直接访问这个目录下的文件，可以通过上面的run-as命令看得出其权限与其他目录的权限是不同的，为system权限，这为多apk共享so提供了便利，这也是Vitamio所使用的方式。

如果签名了并且指定设置了android:debuggable="false"将无法使用该命令。 

如何查看应用是否是 debuggable 的？？adb shell cat /data/system/packages.xml | grep "debuggable"
也可以使用Android中的 dumpsys package 命令来查看指定应用的详细信息：

感谢网友分享（见评论），注意不要把adb shell 和 run-as作为一条命令一起执行，例如：adb shell run-as com.pack

三、参考文件 　　　　android上使用手機跑adb存取data資料夾[blogspot] 　　　　Why do I get access denied to data folder when using adb?

结束

关于共享数据也可以研究一下/data/data/package/files，使用openFileOutput的第二个参数来指定访问权限。事物总有其多面性，本文有鼓励窥视apk之嫌，方法分享给你，至于你用来做什么我可以
```

## [adb]adb restore 还原命令 ？？？？

## [adb]adb shell pm list 已废弃，改用 adb shell cmd package list

## [adb]adb jdwp查看设备中可以被调试的应用的进程号

```
adb jdwp
```

## [adb]dexdump 可以查看一个 dex 文件的相信信息

```
dexdump classes.dex
```

## tcpdump 在哪里下载？？？

```
adb push tcpdump /data/local/tmp

chmod 755 tcpdump

./tcpdump -v -s 0 -w traffic.pcap

• -v is to provide verbose output
• -s is to snarf the number of bytes specified
• -w is to write the packets into a file

adb pull /data/local/tmp/traffic.pcap

用 Wireshark 打开 .pcap 文件

可以上传 apk 到 http://sanddroid.xjtu.edu.cn/ 进行分析
```

## Ettercap 怎么用？？可以监听网络请求？？？

## msfconsole

## 破解手势解锁密码？？

```
cp /data/system/gesture.key /mnt/sdcard
adb pull /mnt/sdcard/gesture.key
grep -i `xxd -p gesture.key` AndroidGestureSHA1.txt  //AndroidGestureSHA1.txt 这个文件怎么写的？？？
```

## 破解PIN码和PASSWORD码？？

```
cp /data/system/password.key /mnt/sdcard/
cp /data/system/locksettings.db /mnt/sdcard/

用 hex editor(Hex workshop) 打开 password.key 文件，得到一串 hashcode

用 sqlite3 查看 locksettings.db 数据库，得到 salt

12|lockscreen.password_salt|0|6305598215633793568

到 http://www.cclgroupltd.com/product/android-pin-password-lock-tool/ 下载 BruteForceAndroidPin.py 工具

Python BruteForceAndroidPin.py [hash] [salt] [max_length_of_PIN]
```

## 命令行解锁

```
adb shell am start -n com.android.settings/com.android.settings.ChooseLockGeneric --ez confirm_credentials false --ei lockscreen.password_type 0 --activity-clear-task
```

## development/samples 中有很多例子可以参考学习

## external/svox/ 语音相关库
http://cnmsdn.com/html/201010/1287296527ID8341.html

## external/neven 人脸识别库

## opencv

```
简单的说这是基于图像动态捕捉处理、人脸识别、机器人视觉处理、图像信息认知录
入等多为一体计算机视觉库

下载ndk
http://bbs.weiphone.com/read-htm-tid-521406.html
2) 安装 ndk
$ tar xvjf OpenCV-2.1.0.tar.bz2
$ cd android-ndk-1.6_r1
$ export NDKROOT=`pwd`
$ ./build/host-setup.sh
3) 下载opencv
http://github.com/billmccord/OpenCV-Android/downloads
4) 编译 opencv
$ tar xvzf bill*
$ cd app
$ ln -s bill* opencv
$ make APP=opencv
5) 安装 opencv
$ adb push out/apps/opencv/libopencv.so /system/lib/
```

## 文字识别

```
1. 功能:
光学字符识别(OCR,Optical Character Recognition)是指对文本资料进行扫描,然后对
图像文件进行分析处理,获取文字及版面信息的过程
2. 典型应用:
名片扫描
3. android 源码实现:
external/tesseract/*
4. 编译:
$ cd external/tesseract/
$ mm
生成 libocr.so,push 系统/system/lib/中,它也可以放在软件的安装包里
5. 例程下载:
1) 在此下载
http://code.google.com/p/mezzofanti/
2) 直接下载 apk 是能用的, 在源码中编译程序运行就退出,是由于可能 libocr.so 未安
装, 把它 push 到系统中即可
$ adb push libocr.so /data/data/com.itwizard.mezzofanti/lib/
3) 主要借鉴 OCR.java 它是对 libocr.so 库的调用(JNI 方式)
```

## GPS

```
卫星定位
1. gps 说明
1) 原理
每一卫星播发一个伪随机测距码信号,该信号大约每 1 毫秒播发一次。接收仪同
时复制出一个同样结构的信号并与接收到的卫星信号进行比较,由信号的延迟时
间(dT)推算出卫星至 接收仪的距离
2) 述语
TTFF:首次定位时间
PRN:伪随机码,用于辨别是哪颗卫星
SNR:信噪比
2. android 对 gps 的内部支持
1) 位置服务
android 对卫星定位的支持名字叫位置服务,可以通过设置来打开或关闭它
2) android 实现
frameworks/base/location/java/android/location/LocationManager.java 接口
frameworks/base/services/java/com/android/server/LocationManagerService.java 服务
frameworks/base/core/jni/android_location_GpsLocationProvider.cpp 等待 gps 事件,
发给 service
libhardware_legacy/include/hardware_legacy/gps.h 定义了底级 gps 的实现,不同硬
件以不同方式实现它,它可能是对设备的访问,也可能与 modem 通过 rpc 通讯得
到 gps 数据
3) 应用程序调用接口
frameworks/base/location/java/android/location/*.java
LocationManager.java 是最重要的接口,通过它访问 gps 定位资源
LocationListener.java 是定位的回调函数,通过实现它来接收定位数据
Gps*.java 提供了获取当前 gps 信息的接口,包括捕获的卫星数,信噪比等
4) 调试
想要调试 gps,可以把/system/etc/gps.conf 中的 debug 等级调为 5,此时你可以在
logcat 中看到全部的 gps 信息
在室内基本没有信号,窗边效果也不好,建议在室外,至少是站在阳台上测试
3. 例程
1) 功能
显示当前经纬度及搜到的卫星个数
2) 可从此处下载可独立运行的代码
http://download.csdn.net/source/2598910

4. 辅助工具
定位程序要么带地图很大,要么太简单不能得到足够数据。推荐gpslogger,使用它可
以看到当前的经纬度,速度,信号强度,当前搜到了几颗星(搜到小于三颗星时,定
位不到经纬度),帮助进一步定位问题。
http://gpslogger.codeplex.com/可以下载到它的源码
5. 参考
1) gps术语
http://www.mobile01.com/newsdetail.php?id=257
```

## 多媒体

```
1. android 多媒体介绍
android 的多媒体功能基于 PacketVideo 的 OpenCORE。这些库支持播放和录制许多流
行的音频和视频格式,以及静态图像文件,包括 MPEG4、 H.264、 MP3、 AAC、
AMR、JPG、 PNG,底级实现在源码的 external/opencore 中
2. android 框架对多媒体的支持
应用程序调用接口
frameworks/base/media/java/android/media/MediaPlayer.java
3. 例程
1) 功能
播放编辑框中指定的多媒体文件
2) 可从此处下载可独立运行的代码
http://download.csdn.net/source/2602127
3) 核心代码及说明

4. 参考:
1) Android 源码自带的多媒体播放例程
development/samples/ApiDemos/src/ocm/example/android/apis/media/MediaPlayerDe
mo*
2) 流媒体例程
http://kuikui.javaeye.com/blog/325916
```

## 博客客户端的实现

```
1. 原理介绍
1) XML-RPC 介绍
XML-RPC 的全称是 XML Remote Procedure Call,即 XML 远程方法调用。原理是
XML-RCP 工具把传入的参数组合成 XML,然后用通过 http 协议发给服务器,服务
器回复 XML 格式数据,再由工具解析给调用者。
2) Meta Weblog API
一些 Blog 提供 Meta Weblog API,用以支持通过 XML-RPC 的方法在软件中编辑
及浏览 Blog。常用的 API 如下:
发布新文章(metaWeblog.newPost)、获取分类(metaWeblog.getCategories)和最新文
章(metaWeblog.getRecentPosts)、新建文章分类(wp.newCategory)、上传图片音频或
视频(metaWeblog. newMediaObject)等。
2. Android的XML-RPC支持
Android 本 身 并 不 支 持 XML-RPC 协 议 , 需 要 下 载 相 关 应 的 工 具 , 本 例 中 使 用 的
XML-RPC从以下地址下载,完整例程中包含此部分
http://code.google.com/p/android-xmlrpc/downloads/list
3. 例程
package org.xmlrpc;
import java.net.URI;
import java.util.HashMap;
import java.util.Map;
import org.apache.http.conn.HttpHostConnectException;
import org.xmlrpc.android.XMLRPCClient;
import org.xmlrpc.android.XMLRPCException;
import org.xmlrpc.android.XMLRPCFault;
import org.xmlrpc.android.XMLRPCSerializable;
import android.app.Activity;
import android.content.Context;
import android.os.Bundle;
import android.util.Log;
import android.widget.EditText;
import android.widget.Toast;
import android.widget.Button;
import android.content.DialogInterface.OnCancelListener;
import android.view.View.OnClickListener;
import android.view.View;
public class TestBlog extends Activity {
private XMLRPCClient client;
private URI uri;
@Override
public void onCreate(Bundle savedInstanceState) {
992010 年谢彦的 Android 笔记
super.onCreate(savedInstanceState);
setContentView(R.layout.test_blog);
Button btn = (Button) findViewById(R.id.send);
btn.setOnClickListener(new OnClickListener() {
public void onClick(View v) {
post();
}
});
}
void post() {
String blogid = ((EditText) findViewById(R.id.blogid_edit)).getText()
.toString(); // 博客 ID, 有的博客支持一个用户多个 ID
String username = ((EditText) findViewById(R.id.username_edit))
.getText().toString();
// 用户名
String password = ((EditText) findViewById(R.id.password_edit))
.getText().toString();
// 密码
String title = ((EditText) findViewById(R.id.title_edit)).getText()
.toString(); // 标题
String content = ((EditText) findViewById(R.id.content_edit)).getText()
.toString(); // 正文
uri = URI.create("http://blog.csdn.net/" + blogid
+ "/services/metablogapi.aspx");
client = new XMLRPCClient(uri);
Map<String, Object> structx = new HashMap<String, Object>();
structx.put("title", title);
structx.put("description", content);
Object[] params = new Object[] { blogid, username, password, structx,
true };
try {
client.callEx("metaWeblog.newPost", params);
Toast.makeText(this, "OK", 10000).show();
} catch (XMLRPCException e) {
Toast.makeText(this, "ERROR" + e, 10000).show();
}
}
}
4. 多媒体上传的介绍
上传多图片视频音频方法如下
Map<String, Object> structx = new HashMap<String, Object>();
1002010 年谢彦的 Android 笔记
structx.put("name", “xxx.jpg”); // 文件名
structx.put("type”, “image/jpeg”); // 格式
structx.put("bits", filebytes); // 文件内容 , 需要 base64 编码 , 可使用 android.util.Base64 来编
码
structx.put("overwrite", true); // 是否覆盖
Object[] params = new Object[] { blogid, username, password, structx};
client.callEx("metaWeblog.newPost", params);
通过此方式可以实现相片视频的即片即转功能
5. 参考:
1) wordpress使用Meta weblog的接口如下
http://cn.wordpress.org/xmlrpc.php
2) 【PHP】XML-RPCで投稿!
http://blog.studio23c.com/?p=108
3) 完整例程下载
http://download.csdn.net/source/2793892
```

## 调试技巧

```
3.5 调试技术
3.5.1
JDWP调试
1. JDWP 用于在 java 程序层面的调试
2. 在某一终端运行虚拟机
$ adb forward tcp:8000 tcp:8000
$ adb shell
$ dalvikvm -agentlib:jdwp=transport=dt_socket,address=8000,server=y,suspend=y -cp /sdcard/foo.jar
Foo
此时挂起等待调试
3. 在另一终端开启调试
$ jdb -attach localhost:8000
[jdb 提示符 ] run
此时程序继续运行
4. jdb 常用命令
[jdb 提示符] threads 看当前所有线程
[jdb 提示符] trace methods 0x12aac5a00 跟踪线程号为 0x12aac5a00 的线程(线程号从
threads 得到)
[jdb 提示符] next/step 下一步
[jdb 提示符] 40 next 执行 40 次 next
1022010 年谢彦的 Android 笔记
3.5.2
运行dalvik测试程序
1. 运行 dalvik 测试程序及 debug
2. 说明
一般在 android 平台上的程序都运行在应用框架之中,它也可以直接运行,以下介绍
最简单的运行和调试方法。
3. 运行 dalvik 自带的 test 程序
1) 配置 ANDROID 系统环境
$ cd $ANDROID_SRC
$ . build/envsetup.sh
2) 编辑桌面环境脚本 test_env.sh(否则 run-test 程序运行时报错)
内容如下:
#!/bin/sh
base=`pwd`
root=$base/out/debug/host/linux-x86/product/sim/system
export ANDROID_ROOT=$root
bootpath=$root/framework
export
BOOTCLASSPATH=$bootpath/core.jar:$bootpath/ext.jar:$bootpath/framework.jar:$bootpath/androi
d.policy.jar:$bootpath/services.jar
export ANDROID_DATA=/tmp/dalvik_$USER
mkdir -p $ANDROID_DATA/dalvik-cache
并执行该脚本
$ . test_env.sh
3) 运行测试程序 003
$ cd dalvik/test
$ ./run-test 003
```

## 编写测试小程序(jar, dex, bin)

```
1. 各个层面的 android 测试程序
2. 说明
在问题定位时,通常使用一些非常简单的程序来测试,以简化逻辑。下面介绍 android
各个层面的测试的编写:普通的 java 程序,加入 android 类的 java 程序,带 android
界面的 java 程序和运行在 android 平台上的 c/c++程序
3. 配置环境
$ cd $ANDROID_SRC
$ . build/envsetup.sh
$ cd development
4. 普通 java 程序
1) 建立 Foo.java,内容如下
class Foo {
public static void main(String[] args)
{System.out.println(“Hello, world”);}
}
2) 编译
$ javac Foo.java
$ dx --dex --output=foo.jar Foo.class
# 把一个或多个 class 编成一个 jar
3) 运行
$ adb push foo.jar /sdcard # 复制到设备的 sd 卡中
$ adb shell dalvikvm -cp /sdcard/foo.jar Foo
# 指明路径和类名
5. 使用 android 特定功能的 java 程序(需引入 android 库)
1) 建立 Foo.java,内容如下
import android.os.Debug;
class Foo {
public static void main(String[] args)
{
System.out.println(“Hello, world”)
android.os.Debug.dumpHprofData(“/sdcard/test.hprof”);
;}
}
2) 建立 Android.mk,内容如下
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_SRC_FILES:=$(call all-subdir-java-files)
LOCAL_MODULE:=foo
include $(BUILD_JAVA_LIBRARY)
3) 编译
$ mm
4) 运行
$ adb push $ANDROID_SRC/out/target/product/xxxxxxx/system/framework foo.jar /sdcard # 复制到
设备的 sd 卡中
$ adb shell dalvikvm -cp /sdcard/foo.jar Foo
# 指明路径和类名
1042010 年谢彦的 Android 笔记
6. 带界面的 android 程序
1) 使用 eclipse 建立
a) 在 eclipse 中点击菜单 File->New->Project......,选择 Android Project
b) 填写 project 的各项内容如下
Project name: test_xy 目录名, 它位于你设定的 workspace 之下
Package name: com.android.testxy 打包名称
Activity name: TestXy 类名(生成文件 TestXy.java)
Application: name:test_app_name 可执行程序名
然后点 Finish 按钮
c) 填写代码
这时可以看到代码界面了,从左边的树中打开代码
test_xyÆ src Æ com.android.testxyÆ TestXy.javaÆTestXyÆonCreate
修改其中代码(不改也行)
2) 修改编译运行
a) eclipse 中运行
i) 在 eclipse 中点击菜单 Run->Run Configurations......
ii) 双击左边的 Android Application,产生了一个 New Configuration,点开它填
写内容如下:
Name: yan_config // 随便起一个
Project: test_xy // 刚才起的 project, 即目录名
iii) 点击 Apply,然后点 Run,多等一会儿就出来了
b) 从命令行运行
i) 复制工程到 Android 源码目录中
$ cp $WORKSPACE/test_xy $ANDROID_SRC/development/ -R
ii) 加入 Android.mk
$ cd $ANDROID_SRC/development/test_xy/
编写 Android.mk 内容如下
LOCAL_PATH:=$(call my-dir)
include $(CLEAR_VARS)
LOCAL_SRC_FILES := $(call all-subdir-java-files)
LOCAL_PACKAGE_NAME:=XyTest
LOCAL_CERTIFICATE:=platform
include $(BUILD_PACKAGE)
编译
iii)
$ mm
iv) 运行
$ adb install $ANDROID_SRC/out/target/product/xxxxxx/system/app/XyTest.apk
$ adb shell am start -n com.android.testxy/com.android.testxy.TestXy
# am start -n 类名/类名.Activity 名
7. 简单的 c++程序
1) 建立 main.c,内容如下
#include <stdio.h>
int main()
{
1052010 年谢彦的 Android 笔记
printf("Hello World!\n");
return 0;
}
2) 建立 Android.mk,内容如下
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)
LOCAL_SRC_FILES:= \
main.c
LOCAL_MODULE := helloworld
include $(BUILD_EXECUTABLE)
3) 编译
$ cd $(ANDROID_SRC) && make helloworld
或
$ mm
4) 运行
$ adb push out/target/product/generic/system/bin/helloworld /sdcard
$ adb shell /sdcard/helloword
```

## 查看当前堆栈

```
new Exception(“print trace”).printStackTrace();
```

## 调试小技巧

```
MethodTracing
1) 功能:用于热点分析和性能优化,分析每个函数占用的 CPU 时间,调用次数,函
数调用关系等
2) 方法:
a) 在程序代码中加入追踪开关
import android.os.Debug;
......
android.os.Debug.startMethodTracing(“/data/tmp/test”); // 先建 /data/tmp 目录
...... // 被追踪的程序段
android.os.Debug.stopMethodTracing();
b) 编译,运行后,设备端生成/data/tmp/test.trace 文件
c) 把 trace 文件复制到 PC 端
$ adb pull /data/tmp/test.trace ./
d) 使用 android 自带工具分析 trace 文件
$ $ANDROID_SRC/out/host/linux-x86/bin/traceview test.trace
此时可看到各个函数被调用的次数 CPU 占用率等信息
e) 使用 android 自带工具分析生成调用关系类图
$ apt-get install graphviz
# 安装图片相关软件
$ANDROID_SRC/out/host/linux-x86/bin/dmtracedump -g test.png test.trace
此时目录下生成类图 test.png
3) 注意
trace 文件生成与 libdvm 模块 DEBUG 版本相冲突,所以此方法只适用于对非
DEBUG 版本模拟器的调试,否则在分析 trace 文件时会报错
3. HProf (Heap Profile)
1) 功能:
用于 java 层面的内存分析,显示详细的内存占用信息,指出可疑的内存泄漏对象
2) 方法:
a) 在代码中加入 dump 动作
import android.os.Debug;
import java.io.IOException;
......
try {
android.os.Debug.dumpHprofData(“/data/tmp/input.hprof”); // 先建 /data/tmp 目录
} catch (IOException ioe) {
}
b) 把 hprof 文件复制到 PC 端
$ adb pull /data/tmp/input.hprof ./
c) 使用命令 hprof-conv 把 hprof 转成 MAT 识别的标准的 hprof
$ $ANDROID_SRC/out/host/linux-x86/bin/hprof-conv input.hprof output.hprof
1072010 年谢彦的 Android 笔记
d) 使用MAT工具看hprof信息
下载MAT工具:http://www.eclipse.org/mat/downloads.php
用工具打开output.hprof
3) 注意:此工具只能显示 java 层面的,而不能显示C层的内存占用信息
4. SamplingProfile (android 2.0 上版本使用)
1) 功能
每隔N毫秒对当前正在运行的函数取样,并输出到 log 中
2) 在代码中加入取样设定
import dalvik.system.SamplingProfiler
......
SamplingProfile sp = SamplingProfiler.getInstance();
sp.start(n);
// n 为设定每秒采样次数
sp.logSnapshot(sp.snapshot());
......
sp.shutDown();
它会启一个线程监测,在 logcat 中打印信息
5. 用发系统信号的方式取当前堆栈情况和内存信息
1) 原理
dalvik 虚拟机对 SIGQUIT 和 SIGUSR1 信号进行处理(dalvik/vm/SignalCatcher.c),
分别完成取当前堆栈和取当前内存情况的功能
2) 用法
a) $ chmod 777 /data/anr -R # 把 anr 目录权限设为可写
$ rm /data/anr/traces.txt
# 删除之前的 trace 信息
$ ps # 找到进程号
$ kill -3 进程号 # 发送 SIGQUIT 信号给该进程,此时生成 trace 信息
$ cat /data/anr/traces.txt
功能实现:遍历 thread list(dalvik/vm/Thread.c:dvmDumpAllThreadEx()),并打印
当前函数调用关系(dalvik/vm/interp/Stack.c:dumpFrames())
b) $ chmod 777 /data/misc -R
$ ps # 找到进程号
$ kill -10 进程号 # 发送 SIGQUIT 信事信号给该进程,此时生成 hprof 信息
$ ls /data/misc/*.hprof
此时生成 hprf 文件,如何使用此文件,见第二部分(HProf)
注意:hprof 文件都很大,注意用完马上删除,以免占满存储器
6. logcat 及原理
1) android.util.Log 利用 println 的标准 java 输出词句,并加前缀 I/V/D....
2) dalvik 利用管道加线程的方式,先利用 dup2 把 stdout 和 stderr 重定向到管理中
(vm/StdioConverter.c:dvmstdioConverterStartup),然后再启动一个线程从管道另一
端读出内容(dalvik/vm/StdioConverter.c:stdioconverterThreadStart()),使用 LOG 公共
工具(system/core/liblog/logd_write.c: __android_log_print())输出到/dev/log/*中去
3) logcat 通过加不同参数看/dev/log/下的不同输入信息
# logcat -b main
# logcat -b radio
# logcat -b events
显示主缓冲区中的信息
显示无线缓冲区中的信息
显示事件缓冲区中的信息
1082010 年谢彦的 Android 笔记
7. jdwp(java debug wire protocol)及原理
1) 虚拟机(设备端)在启动时加载了 Agent JDWP 从而具备了调试功能。在调试器
端(PC 端)通过 JDWP 协议与设备连接,通过发送命令来获取的状态和控制 Java
程序的执行。JDWP 是通过命令(command)和回复(reply)进行通信的。
2) JDK 中调试工具 jdb 就是一个调试器,DDMS 也提供调试器与设备相连。
3) dalvik 为 JDWP 提供了两种连接方式:tcp 方式和 adb 方式,tcp 方式可以手工指
定端口,adb 方式自动设定为 8700 端口,通常使用 DDMS 调试就是通过 adb 方式
8. monkey
1) monkey 是一个 android 自带的命令行工具。它向系统发送伪随机的用户事件流,
实现对正在开发的应用程序进行压力测试。
2) 方法
在设备端打开 setting 界面
$ adb shell
# monkey -p com.android.settings -v 500
此时可以看到界面不断被切换
9. 其它小工具
具体见 android.os.Debug 中提供的工具
1) 取毫微秒级的时间,用于计算时间
threadCpuTimeNanos()
2) 统计两点间的内存分配情况
startAllocCounting()
stopAllocCounting()
getGlobalAllocCount()
get.....
3) 打印当前已 load 的 class
getLoadedClassCount()
printLoadedClasses() 它需要打开 NDEBUG 功能才能打开 system/core/ 中 Log 功能
10.
打印 debug 信息
$ adb bugreport
```

## c++程序的调试

```
1. 使用 gdbserver 调试
使用 JDWP 只能调试 java 层面的程序,如果想调试 C 层面的代码,需要使用 gdbserver
方式,gdbserver 的服务端和客户端都包含在 android 的源码中。
server 端是 out/target/product/xxxxxx/system/bin/gdbserver。
client 端是 prebuild/linux-x86/toolchain/xxxxxx/bin/arm-eabi-gdb)
,不需另外安装。
(请看完本文再开始调试,尤其是“注意”部分)
本文依据张博的调试文档, 加以扩充说明,感谢原创者。
2. 调试前的准备:编译 DEBUG 版本的程序和库
1) 新建(或修改)ANDROID 源码根目录的 buildspec.mk,加入以下内容
DEBUG_MODULE_lidvm:=true # 虚拟机模块设为 debug
TARGET_CUSTOM_DEBUG_CFLAGS:=-O0 -mlong-calls
(请修改具体模块名,我调试的是虚拟机的 libdvm.so 库)
2) 重编 dalvik 模块
$ make clean-libdvm
$ make dalvik snod
3) 重烧 system.img 或替换手机中的相应模块
3. gdb server 端配置
1) 端口映射
$ adb forward tcp:5039 tcp:5039
把设备的 5039 端口映射到 PC 的 5039
设定之后用 netstat -na 命令可看到 PC 的 5039 端口已处于 listen 状态
注意每次断开手机再连接时,都要重新执行该命令
2) 调试进程号为 2014 进程
$ adb shell
# ps 找进程号
# gdbserver :5039 --attach 2014 # 指明 tcp 端口号和进程号
注意:用此方法只适用于对已运行的程序 debug(不能使用直接在 gdbserver 后跟
程序名的方式运行)
此时 2014 进程被挂起,等待调试
4. gdb client 端配置
1) 用命令行工具调试
$
$ANDROID_DIR/prebuilt/linux-x86/toolchain/xxxxxx/bin/arm-eabi-gdb
$ANDROID_DIR/out/target/product/xxxxxx/system/bin/app_process
注意可执行程序名必须是 app_process,不是你所调试的程序名
(gdb) set solib-absolute-prefix $ANDROID_SRC)/out/target/product/xxxxxx/symbols/system/lib/
(gdb) set solib-search-path $ANDROID_SRC)/out/target/product/xxxxxx/symbols/system/lib/
以上路径为 GDB 默认库的搜索路径,即交叉编译器库路径,若不设定,则找不到
符号表,(带符号表的库在 symbols/system/lib/*,手机里 strip 后无符号表的库在
system/lib/*,它们必须配套使用)
(gdb) target remote :5039 指明 TCP 端口号
此时连接 gdb server,可设断点调试,按 c 继续执行程序
2) 用 eclipse 调试
a) 安装 cdt,使 eclipse 支持 c/c++程序的开发
i) 下载
1102010 年谢彦的 Android 笔记
从http://www.eclipse.org/cdt/downloads.php下载cdt-master-4.0.0.zip
ii) 解压
$ mkdir cdt; cd cdt; unzip ../cdt-master-4.0.0.zip
iii)
将解压缩后的 features、plugins 两个文件夹的内容复制到 Eclipse 安装目
录中
$ cp plugins/* ../../eclipse/plugins/
$ cp features/* ../../eclipse/features/
iv) 重新开启 Eclipse 即可
$ eclipse -clean
在新建 project 中即可看到 c/c++相关选项,说明已安装成功
b) 加入要调试的代码
i) 新建 C++ project (菜单 File->New->Project...)
不使用 default location,把 Location 指定成代码所在目录
ii) 取消自动编译选项(菜单 Project->Build Automatically)
c) 配置 gdb 环境
配置 Debug Configurations(菜单 Run->Debug Configurations...)
i) 新建一个 C/C++ Local Application 的 debug configuration
ii) Main 选项卡中
指定 Project 为新建的 C++工程,
C/C++ Applications 为:
$ANDROID_DIR/out/target/product/xxxxxx/system/bin/app_process
iii)
Debugger 选项卡中
指定 Debugger 为 gdbserver Debugger,
Main 子选项卡的 Gdb debuger 设为:
$ANDROID_DIR/prebuilt/linux-x86/toolchain/xxxxxx/bin/arm-eabi-gdb
GDB command file 设为一个文件名,文件内容如下:
file $ANDROID_DIR/out/target/product/xxxxxx/system/bin/app_process
set solib-absolute-prefix $ANDROID_SRC)/out/target/product/xxxxxx/symbols/system/lib/
set solib-search-path $ANDROID_SRC)/out/target/product/xxxxxx/symbols/system/lib/
Connection 子选项卡:
Type 设为 TCP,Port number 设为 5039
iv) 点击 Debug 按钮进入调试,之前挂起的程序此时继续运行
d) 设置断点及调试
i) 找开某一C程序(菜单->Open file)
ii) 在程序中双击可设置断点,设置后断点出现在右上的 Breakpoints 中
iii) Debug 选项卡提供了工具调试(suspend, resume 等)
5. 加打印语句
如果需要在 C 程序中加打印语句,有两种方法
1) 直接在代码中使用 printf,此方法只能应用于从命令行启动程序的情况,运行时可
以 adb shell 中看到打印信息
2) 使用程序中提供的重定项后的打印语句,并在 logcat 中看到它
例如在 libdvm.so 中使用 dvmFprintf(stderr, “xieyan log\n”);
6. 可能出现的问题及解决方法
1) 在找不到原因时,可以写一个在android可以运行的简单c语言程序用gdbserver调
1112010 年谢彦的 Android 笔记
试,以简化问题,android中c程序做法见:
http://www.top-e.org/jiaoshi/html/?157.html
2) 我的是在 arm-eabi-2.4.1 的编译器编出来的,你的可能不是,编译时用 make
showcommands 确定你的系统使用的编译工具链,否则如果你 debug 时用的和编
译时用的版本不一致,会导致读符号表时出错(注意看提示)
3) 有时编译会引起源码目录的变化,请在左侧 Project explorer 中刷新相关项目
```

## 查看当前堆栈调用关系

```
$ rm /data/anr/traces.txt
清除之前 log 信息,因为 log 信息是追加到此文件中的
$ ps 找应用对应进程号
$ kill -3 进程号 该进程当前的堆栈调用写入 traces.txt
$ cat /data/anr/traces.txt 查看堆栈信息
```

## 查看当前的 dump 信息

```
adb shell dumpstate > xxx.msg
```

## log相关

```
10. 获取当前系统的内核配置, 可用如下方法取得内核配置文件
$ adb pull /proc/config.gz /tmp
$ vi tmp/config.gz
12.
在 Android.mk 中打印提示信息
$(info "xxxxxxxx")
13.
lib 库中打印 log 信息
在文件头部加
#define LOG_TAG “testme”
#undef LOG // 有的版本需要这句,有的版本不需要
#include <utils/Log.h>
在程序中用
LOGE(“log is xxxxx”);
在编 lib 库的 Android.mk 中加
LOCAL_SHARED_LIBRARIES:=libutils
14.
lib 库中 jni 用 c++
在每个函数前头加,以免提示找不到函数名
#ifdef __cplusplus
extern “C”
#endif
15.
看 log 的时间
$ adb logcat –v time > /tmp/log.txt
```

## 9patch 相关

```
9patch 是一种特殊的文件格式,它以”.9.png”为扩展名,它的上下左右各有一象素留
边,用以标识图片以何种方式拉伸,一般做图时留边中以黑色标识其拉伸区域,此为
显式的 9patch 信息,用以方便做图者编辑(android 提供工具 draw9patch 来编辑 9patch
图),程序打包时 aapt 工具把该图留边去掉,并将信息其写入 png 文件内部,使之变
为隐显 9patch 信息
```

## 制作换肤包

```
1. 如何做换肤包
1) 最简单的方法是替换源码中的资源,然后重新编译
a) 举例:修改系统公共资源——系统字体大小
修 改 framework/base/core/res/res/values*/style.xml 其 中 的 TexAppearance 的
Large,Medium,Small 的 textSize,它们分别对应大中小字的字号
修改后,在 res 目录中重新编译(使用 mm 命令),然后将生成的 framework-res.apk
拷到手机的/system/framework 目录中
b) 注意:源码中的资源必须和设备中资源相对应,因在生成 framework-res.apk 的
过程中生成了资源 ID 号,而各应用通过资源 ID 号读取系统资源,所以如果 ID
号不一致,整个系统的资源就乱了
2) 有时候我们只想换包中的某个图片,不想重编整个包,或者从网上下载的应用程
序,得不到源码不能重编,但也想对其换肤。
由于 apk 是 zip 格式的压缩包,最简单的方法是解包,替换图片,然后再打包
$ mkdir tmp; cd tmp
$ unzip ../xxx.apk
$ cp xxx.png res/drawable/ 替换图片
$ zip -r ../xxx_new.apk *
然后安装到系统中,或替换原有包,即可。
3) 有时会遇到图片不能以原有方式被拉伸的问题,这是由于某些 9patch 格式图片丢
失了其格式信息,下面通过了解 apk 打包工具可以解决此问题
(直接修改 apk 包和使用 metaporgh 皮肤的原理是一样的)
```

## apk 如何打包

```
apk 如何打包
了解打包的目的在于了解对 9patch 图及其它资源的处理过程
1) 编译某应用(以计算器为例)
$ cd packages/apps/Calculator
$ mm showcommands
使用参数 showcommands 可以看到编译用到的具体命令,其中最核心的是 aapt
2) 使用aapt命令打包 (aapt源码见framework/base/tools/aapt)
为了解原理,我们建立一个最简单的只含有图片的包,用此方式,可以把图片从
显式的 9patch图变成隐式的 9patch图,建立目录及文件如下
$ mkdir test; cd test
$ vi AndroidManifest.xml 编辑内容如下
<?xml version=”1.0” encoding=”utf8?>
<manifest xmlns:android=“ http://schemas.android.com/apk/res/android “
package=“com.android.test“
</manifest>
$ mkdir res/drawable -p
1202010 年谢彦的 Android 笔记
$ cp xxxx.png res/darwable/
$ aapt package -S res -M AndroidManifest.xml -F test.apk -f
3) 浏览 apk 包中内容
$ mkdir tmp; cd tmp
$ unzip ../test.apk
$ ls
此时看到 xml 文件补转换成不可读的了,产生了 resources.arsc,其中包含资源列
表(ResTable),它说明了每个资源的 resourceid (不同字段标明包名类型和编号) , pac,
type, name, flag,res 中某些资源也会被打入 resources.arsc 中(如 string)
4) res/drawable/中的图片仍存在,如果它是 9patch 图,则图片会把显式的 9patch 位置
打成隐式的 9patch 信息
5) 想看某个 apk 包的内容, 可以编其源码目录中的 printapk.cpp, 用于打印某包的资
源信息, 它的编法是改 Android.mk 为编 printapk 的, 注意库中要加 libzipfile
4. aapt 工具
aapt 工具用于生成查看和编辑 apk 包
1) 打包
a) 打包
$ aapt package -S res -M AndroidManifest.xml -F xxt.apk -f
2) 查看
a) 查看 apk 中包含哪些资源文件
$ aapt list xxx.apk
b) 查看某个 xml 的内容
$ aapt dump xmltree xxx.apk res/layout/main.xml
(xml 不能是 values*中的,因为它已被打进 resources.arsc)
c) 查看 resources.arsc 中的资源内容
$ aapt dump --values resources xxx.apk
3) 编辑
用此方法编辑与 zip 解压修改再压缩的方式不同,它会编译 xml 文件和处理 9patch
图
a) 从包中删除某文件
$ aapt remove xxx.apk res/layout/alert_dialog.xml
b) 将某文件加入包中
$ aapt add xxx.apk res/layout/alert_dialog.xml
5. 总结
换肤时,如果想替换 9patch 图,需要使用 aapt 或其它工具对图进行处理,否则如果
只是简单地用 zip 工具解开 apk 包,替换一个普通图片,再打包成 apk 的话,是达不
到你想要的拉伸效果的,这是由于普通图不包含 9ptach 信息
以上方法可以转换 9patch 图,即做好显式的 9patch 图,然后有以上方法产生隐式的
9patch 图,再将它放入包中替换原有资源
```

## 开机流程

```
1. 系统引导 bootloader
1) 源码:bootable/bootloader/*
2) 说明:加电后,CPU 将先执行 bootloader 程序,此处有三种选择
a) 开机按 Camera+Power 启动到 fastboot,即命令或 SD 卡烧写模式,不加载内核
及文件系统,此处可以进行工厂模式的烧写
b) 开机按 Home+Power 启动到 recovery 模式,加载 recovery.img,recovery.img 包
含内核,基本的文件系统,用于工程模式的烧写
c) 开机按 Power,正常启动系统,加载 boot.img,boot.img 包含内核,基本文件
系统,用于正常启动手机(以下只分析正常启动的情况)
2. 内核 kernel
1) 源码:kernel/*
2) 说明:kernel 由 bootloader 加载
3. 文件系统及应用 init
1) 源码:system/core/init/*
2) 配置文件:system/rootdir/init.rc,
3) 说明:init 是一个由内核启动的用户级进程,它按照 init.rc 中的设置执行:启动服
务(这里的服务指 linux 底层服务,如 adbd 提供 adb 支持,vold 提供 SD 卡挂载
等),执行命令和按其中的配置语句执行相应功能
4. 重要的后台程序 zygote
1) 源码:frameworks/base/cmds/app_main.cpp 等
2) 说 明 :zygote 是 一个在 init.rc 中被 指 定启 动的 服 务, 该服 务 对应 的命 令 是
/system/bin/app_process
a) 建立 Java Runtime,建立虚拟机
b) 建立 Socket 接收 ActivityManangerService 的请求,用于 Fork 应用程序
c) 启动 System Server
5. 系统服务 system server
1) 源码:
frameworks/base/services/java/com/android/server/SystemServer.java
2) 说明:被 zygote 启动,通过 System Manager 管理 android 的服务(这里的服务指
frameworks/base/services 下的服务,如卫星定位服务,剪切板服务等)
6. 桌面 launcher
1) 源码:ActivityManagerService.java 为入口,packages/apps/launcher*实现
2) 说明:系统启动成功后 SystemServer 使用 xxx.systemReady()通知各个服务,系统
已经就绪,桌面程序 Home 就是在 ActivityManagerService.systemReady()通知的过
程中建立的,最终调用 startHomeActivityLocked()启 launcher
7. 解锁
1) 源码:
frameworks/policies/base/phone/com/android/internal/policy/impl/*lock*
2) 说 明 : 系 统 启 动 成 功 后 SystemServer 调 用 wm.systemReady() 通 知
WindowManagerService , 进 而 调 用 PhoneWindowManager , 最 终 通 过
1232010 年谢彦的 Android 笔记
LockPatternKeyguardView 显示解锁界面,跟踪代码可以看到解锁界面并不是一个
Activity,这是只是向特定层上绘图,其代码了存放在特殊的位置
8. 开机自启动的第三方应用程序
1) 源码:
frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
2) 说 明 : 系 统 启 动 成 功 后
SystemServer
调 用
ActivityManagerNative.getDefault().systemReady()通知 ActivityManager 启动成功,
ActivityManager 会通过置变量 mBooting,通知它的另一线程,该线程会发送广播
android.intent.action.BOOT_COMPLETED 以告知已注册的第三方程序在开机时自
动启动。
9. 总结
综上所述,系统层次关于启动最核心的部分是 zygote(即 app_process)和 system server,
zygote 它负责最基本的虚拟机的建立,以支持各个应用程序的启动,而 system server
用于管理 android 后台服务,启动步骤及顺序。
10. 参考
http://blog.csdn.net/basonjiang_sz/category/648399.aspx
```

## 开机动画

```
开机动画
1. 说明
android 开机画面由三部分组成,第一部分在 bootloader 启动时显示,第二部分在启
动 kernel 时显示,第三部分在系统启动时(bootanimation)显示(动画)
2. bootloader 开机图片
1) 一般使用 rle 格式图片,不同的 android 系统不同此图片可能放在不同位置,以下
实例均以 G1 为例,G1 放在 splash 分区中
2) 制作 rle 格式开机图片
a) 将图片转成 320x480,256 色,保存成不带 Alpha 通道的 png 格式
b) 使用 convert 工具将 splash.png 转换成8位色的 splash.raw
convert splash.png -depth 8 rgb:splash.raw
确认 splash.raw 大小为 460800 字节
c) 使用 android 工具 rgb2565 改变图像格式
out/host/linux-x86/bin/rgb2565 < splash.raw > splash.raw565
确认 splash.raw565 大小为 307200 字节
3) 烧写(以 G1 为例)
按 Power+Camera 启动到烧写模式
fastboot flash splash1 splash.raw565
3. kernel 开机图片
1) 相关代码
kernel/drivers/video/msm/msm_fb.c(G1 使用高通芯片组 MSM7201 芯片组)
它会读出根目录下的 xx.rle,并显示为开机画面,rle 做法同上
4. bootanimation 开机动画
1) android 2.0 之前
a) 说明
使用 bootanimation 程序显示开机画面,如需修改开机画面,需要修改源码
b) 代码
frameworks/base/cmds/bootanimation/*
frameworks/base/core/res/assets/images/android-logo*
2) android 2.0 及之后
a) 说明
使用 bootanimation 程序显示开机画面,如需修改开机画面,不用修改代码,只
需按格式要求做 bootanimation.zip 包,放在系统的/system/media 目录中,或
/data/local 目录中即可,两个目录下都存在时,优先使用/data/local 下的
b) 代码
frameworks/base/cmds/bootanimation/*
frameworks/base/core/res/assets/images*
c) 制作动画包
i) 描述文件 desc.txt
480 427 30
p 1 0 part0
p 0 10 part1
总体说明:480 为宽度,427 为高度,30 为帧数,即每秒播放动画 30 帧
部分说明:第一项 p 为标志符,第二项为循环次数 1 为只播放 1 次,0为无
1252010 年谢彦的 Android 笔记
限循环,第三项为两次循环之间间隔的帧数,第四项为对应的目录名
ii) 图片
图片放在 desc.txt 中目录名指定的目录中,目录中按字符顺序播放
iii) 打包
♦ windows
使用 winrar 找包,选择 ZIP 格式,压缩标准要选“储存”
♦ linux
zip -0 -r ../bootanimation.zip ./*
linux 命令使用-0 指定压缩等级为最低等级 stored,即只归档不压缩,否
则可能由于包格式问题引起动画显示为黑屏
♦ 注意
打包不要带上层目录
5. 参考
1) bootanimation相关
http://blog.21ic.com/user1/2537/archives/2009/65606.html
2) rle文件制作
http://hi.baidu.com/kernel_linux/blog/item/9eff140f9d089c206159f3cb.html
3) bootloader启动
http://blog.csdn.net/yili_xie/archive/2010/05/14/5592276.aspx
```

## android应用的启动过程

```
1. 说明
应用的启动过程通常是通过 startActivity 函数,无论是在应用中调其它应用还是在桌
面(桌面是 Launcher 应用)上点击,最终都将通过这个函数启动进程或者界面,下
面以分析代码的方式,介绍它具体的工作过程
2. 过程
1) Launcher/src/com/android/launcher.java
在应用或桌面上启动应用,例如桌面应用的启动由于中调用了 startActivity()函数
2) frameworks/base/core/java/android/app/Activity.java:startActivity()
Activity.java 继承了 Context.java,并实现了它的 startActivity(),它向下调用了
execStartActivity()
3) frameworks/base/core/java/android/app/Instrumentation.java:execStartActivity()
execStartActivity 利用 IntentFilter 得到具体 Activity,并调用了更下层的 startActivity
4) frameworks/base/core/java/android/app/ActivityManagerNative.java
ActivityManagerProxy.startActivity()
IBinder.transact(....);
它通过 Binder 的方式与 ActivityManagerService.java 通讯,并发送启动请求
5) frameworks/base/core/java/android/os/Binder.java:execTransact()
Binder 消息转递的实现,用于用户应用与后台服务的通讯
6) frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
onTransact();
startProcessLocked();
开启新线程
7) frameworks/base/core/java/android/os/Process.java 的函数 start 为入口
通过 socket 发给 zygote 进程
8) frameworks/base/core/java/com/android/internal/os/Zygote*.java
告知虚拟机新建进程,此时会将要建立的进程名,用户名,组名一并传给虚拟机,
以建立进程
9) dalvik/libcore/dalvik/src/main/java/dalvik/system/Zygote.java
虚拟机处理
10)
dalvik/vm/native/dalvik_system_Zygote.c (forkAndSpecializeCommon)
虚拟机处理
```

## 服务的原理与使用

```
1. 说明
android 的后台运行在很多 service,它们在系统启动时被 SystemServer 开启,支持系
统的正常工作,比如 MountService 监听是否有 SD 卡安装及移除,ClipboardService
提供剪切板功能,PackageManagerService 提供软件包的安装移除及查看等等,应用
程序可以通过系统提供的 Manager 接口来访问这些 Service 提供的数据,以下将说明
他们的工具流程
2. 举例说明基本流程
以 android 系统支持 sensor(传感器)实例来说明框架层的 service 和 manager 是如何
配合工作的
1) 什么是 sensor
sensor 是传感器, 比如控制横竖屏切换利用的就是重力传感器(gsensor), 还有
accelerator sensor 可取得 x, y, z 三个轴上的加速度(应用如平衡球, 小猴吃香蕉等)
2) 应用程序调用(以下为关键代码)
sensorManager=(SensorManager)getSystemService(context.SENSOR_SERVICE);
lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT);
sensorManager.registerListener(sensorListener,
lightSensor,
SensorManager.SENSOR_DELAY_NORMAL);
3) Manager 层
a) 提供给应用程序调用的接口,同实与 Service 交互,实现功能
frameworks/base/core/java/android/hardware/SensorManager.java
4) Service 层
a) 开机时就运行的管理 Sensor 的后台服务
frameworks/base/services/java/com/android/server/SensorService.java
b) snesor 后台服务需要的 JNI,通过它与系统级交互
frameworks/base/services/jni/com_android_server_SensorService.cpp
5) 系统层
a) 传感器的头文件,硬件提供商按此文件的定义实现其功能
hardware/libhardware/include/hardware/sensors.h
b) 传感器的系统层实现,与内核交互,此处通常是硬件提供商提供的
hareware/libsensors
6) 内核及硬件层
内核访问硬件,同时以设备文件等方式提供给上层控制接口和传感器数据
3. 系统层实现
1) frameworks/base/core/java/android/*Manager.java 对应用的接口
2) frameworks/base/core/jni/
对应用的接口的 JNI
3) frameworks/base/services/java/com/android/server/ 后台服务
4) frameworks/base/services/jni/
JNI 与系统层接
5) hardware/libhardware/include/
系统层头文件
6) hardware/libxxx
系统库支持
7) 内核支持
4. 应用程序如何使用
1282010 年谢彦的 Android 笔记
1) 查看系统提供哪些服务
find frameworks/base/core/java/android/ -name *Manager.java
此处可以看到调用系统提供服务的入口
2) 一般 register listener,事件发生时都收到回调
5. 如何新建一个 service(以 froyo 为例)
1) 接口:接口供应用调用
frameworks/base/core/java/android/app/ContextImpl.java 加服务名与 Manager 对应
frameworks/base/core/java/android/content/Context.java 加服务名定义
2) Manager:提供服务对应的调用接口
frameworks/base/core/java/android/app/StartXXXXManager.java 实现调用接口
frameworks/base/core/java/android/app/IXXXXManager.aidl 定义调用接口
frameworks/base/Android.mk
加入 aidl 的编译
3) service:提供后台服务支持
frameworks/base/services/java/com/android/server/XXXXService.java 服务实现
frameworks/base/services/java/com/android/server/SystemServer.java
启动服务
```

## 键盘事件处理

```
1. 基本流程
1) 内核处理按键,通过设备文件的方式提供给 framework 层
2) framework 层的 KeyInputQueue.java 启动线程从设备文件中读出键码,然后把读出
的键码按 kl 文件转成相应键值(JNI 调用 EventHub.cpp),最后写入事件队列
3) framework 层的 WindowManagerService.java 启动线程从事件队列中读出键值,然
后根据当前 focus 分发给相应窗口
4) UI 通过 KeyCharacterMap.java 处理 kcm 规则将用户基本按键与功能键(Shift, Alt
等)组合,得出最终按键
2. 两个配置文件
通常更换一种新的硬件,可能其键盘布局及键码与标准版本不同,不用更改代码,只
要修改以下配置文件即可(如果增加新的未定义功能的按键,则需要修改代码)
1) xxx.kl
a) 位置
development/emulator/keymaps/*.kl
(1.6 版本模拟器使用)
sdk/emulator/keymaps/*.kl (2.2 版本模拟器使用)
vendor/xxx/xxx/*.kl (特定硬件专用 kl)
b) 功能
硬件全键盘的键码与键值的对应规则文件(如 0x21 对应 A)
2) xxx.kcm
a) 位置
development/emulator/keymaps/*.kcm (1.6 版本模拟器使用)
sdk/emulator/keymaps/*.kcm (2.2 版本模拟器使用)
vendor/xxx/xxx/*.kcm (特定硬件专用 kcm)
b) 功能
硬件全键盘的键值对应表(如按下 Alt, Shift 时按键对应的键值)
3. 相关代码
1) frameworks/base/core/java/android/view/KeyEvent.java (按键事件定义)
2) frameworks/base/services/java/com/android/server/KeyInputQueue.java (事件读取线
程)
3) frameworks/base/services/java/com/android/server/WindowManagerService.java (事件
分发线程)
4) frameworks/base/core/java/android/view/KeyCharacterMap.java
(功能键转换
kcm)
5) frameworks/base/libs/ui/EventHub.cpp (键码与键值转换)
4. 参考
1) http://www.armfans.net/archiver/tid-2671.html
2) http://www.armfans.net/viewthread.php?tid=2671
```

## 包管理

```
1. 说明
包管理(Package manager)非常重要,它关系着软件包的安装,卸载,查看和使用,
它是运行在后台的一个服务,名叫 PackageManagerService,包括对软件包的解包,
验证,安装等
2. 系统软件包管理信息存储在哪
/data/system/packages.xml
通过它可以看到系统安装的所有软件包,以及软件包的信息
3. 包管理相关源码在哪
frameworks/base/services/java/com/android/server/PackageManagerService.java
4. 系统自带的软件能升级吗(即安装在系统分区 system 中的包,如电话,短信)
可以升级,如果升级/system/app 目录中的包,PackageManagerServer.java 对此情况进
行处理,被升级的包出现 package.xml 的 updated-package 字段中,新的包信息会写在
package 字段中,卸载新包后,原包会恢复到 package 字段中。启动时新的包会优先
地被启动
5. 为什么安装软件时会报错
1) 版本不匹配
比如在 2.2 的 SDK 上编译的软件,不能在 1.6 上安装
AndroidManifest.xml 中可以对版本所安装系统的版本进行指定
2) 签名信息不匹配
软件升级时会做签名信息对比,如果前后两个包签名不一致,则不能安装
3) 包完整性不满足
签名是对包中每个文件进行的,它的压缩格式是 zip,如果手工解包后替换了某文
件再打包,被替换的文件与签名验证不一致,则不能安装
4) 格式不对
有些从网上下载的包可能打了多层压缩,比如又将 apk 打包成了 rar 格式,建议解
压缩看一下格式再安装
6. 包的权限
1) 软件在 AndroidMenifest.xml 中都会指明其需要的权限,安装包时图形界面也通常
显示出它所需要的权限,供用户判断是否安装
2) 特殊情况
有些软件没有说明需要访问 SD 卡和打电话的权限,但安装后却出现此权限。
当 使 用 旧 的 SDK 所 做 的 包 向 新 的 SDK 安 装 时 , 可 能 出 现 这 种 情 况 , 见
framework/base/core/java/android/content/pm/PackageParser.java
中
的
NEW_PERMISSION,此处判断编译使用的 SDK 版本是否在 android1.6 之前
(DONUT),如果在之前就加入这两个权限。
```

## 签名

```
用命令行方式签名
使用标准的 java 工具 keytool 和 jarsigner 来生成证书和给程序签名
a) 生成签名
$ keytool -genkey -keystore keyfile -keyalg RSA -validity 10000 -alias yan
注:validity 为天数,keyfile 为生成 key 存放的文件,yan 为私钥,RSA 为指定
的加密算法(可用 RSA 或 DSA)
b) 为 apk 文件签名
$ jarsigner -verbose -keystore keyfile -signedjar signed.apk base.apk yan
注:keyfile 为生成 key 存放的文件,signed.apk 为签名后的 apk,base.apk 为
未签名的 apk,yan 为私钥
1352010 年谢彦的 Android 笔记
c) 看某个 apk 是否经过了签名
$ jarsigner -verify my_application.apk
d) 查看 apk 有效期等签名信息
$ jarsigner -verify -verbose -certs my_application.apk
e) 优化(签名后需要做对齐优化处理)
$ zipalign -v 4 your_project_name-unaligned.apk your_project_name.apk
3) 在源码中编译的签名
a) 使用源码中的默认签名
在源码中编译一般都使用默认签名的,在某源码目录中用运行
$ mm showcommands 能看到签名命令
Android 提供了签名的程序 signapk.jar,用法如下:
$ signapk publickey.x509[.pem] privatekey.pk8 input.jar output.jar
*.x509.pem 为 x509 格式公钥,pk8 为私钥
build/target/product/security 目录中有四组默认签名可选: testkey, platform, shared,
media ( 具 体 见 README.txt ), 应 用 程 序 中 Android.mk 中 有 一 个
LOCAL_CERTIFICATE 字段,由它指定用哪个 key 签名,未指定的默认用
testkey.
b) 在源码中自签名
Android 提供了一个脚本 mkkey.sh(build/target/product/security/mkkey.sh),用
于生成密钥,
生成后在应用程序中通过 Android.mk 中的 LOCAL_CERTIFICATE
字段指名用哪个签名
c) mkkey.sh 介绍
i) 生成公钥
openssl genrsa -3 -out testkey.pem 2048
其中-3 是算法的参数,2048 是密钥长度,testkey.pem 是输出的文件
ii) 转成x509 格式(含作者有效期等)
openssl req -new -x509 -key testkey.pem -out testkey.x509.pem -days 10000 -subj
‘/C=US/ST=California/L=Mountain
View/O=Android/OU=Android/CN=Android/emailAddress=android@android.com’
iii)
生成私钥
openssl pkcs8 -in testkey.pem -topk8 -outform DER -out testkey.pk8 -nocrypt
把的格式转换成 PKCS #8,这里指定了-nocryp,表示不加密,所以签名时
不用输入密码
4. 签名的相关文件
1) apk 包中签名相关的文件在 META_INF 目录下
CERT.SF:生成每个文件相对的密钥
MANIFEST.MF:数字签名信息
xxx.SF:这是 JAR 文件的签名文件,占位符 xxx 标识了签名者
xxx.DSA:对输出文件的签名和公钥
2) 相关源码
development/tools/jarutils/src/com.anroid.jarutils/SignedJarBuilder.java
frameworks/base/services/java/com/android/server/PackageManagerService.java
frameworks/base/core/java/android/content/pm/PackageManager.java
frameworks/base/cmds/pm/src/com/android/commands/pm/Pm.java
1362010 年谢彦的 Android 笔记
dalvik/libcore/security/src/main/java/java/security/Sign*
build/target/product/security/platform.*
build/tools/signapk/*
5. 签名的相关问题
一般在安装时提示出错:
INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES
1) 两个应用,名字相同,签名不同
2) 升级时前一版本签名,后一版本没签名
3) 升级时前一版本为 DEBUG 签名,后一个为自定义签名
4) 升级时前一版本为 Android 源码中的签名,后一个为 DEBUG 签名或自定义签名
5) 安装未签名的程序
6) 安装升级已过有效期的程序
6. 相关工具
1) 查看某个 x509 证书的的有效日期
在 SignApk.java 中打印出 publicKey.getNotAfter()即可
7. 参考
http://developer.android.com/guide/publishing/app-signing.html
http://www.pgcw.com.cn/Newsdetail.asp?id=257565010
http://www.eoeandroid.com/thread-23010-1-1.html
http://pepa.javaeye.com/blog/250991
```

## 权限

```
应用的权限
1. 权限
每个程序在安装时都有建立一个系统 ID,如 app_15,用以保护数据不被其它应用获
取。Android 根据不同的用户和组,分配不同权限,比如访问 SD 卡,访问网络等等。
底层映射为 Linux 权限。
2. 应用申请权限
1) 应用开发者通过 AndroidManifest.xml 中<uses-permission>指定对应权限,再映射
到底层的用户和组,默认情况下不设定特殊的权限。AndroidManifest 加入权限后
系统安装程序时会在图形界面中提示权限
2) 如果是缺少某个权限(程序中使用的某种权限而在 AndroidManifest.xml 中并未声
名),程序运行时会在 logcat 中打印出错误信息 requires <permission>
3) 与某个进程使用相同的用户 ID
应用程序可与系统中已存在的用户使用同一权限,需要在 AndroidManifest.xml 中
设置 sharedUserId,如 android:sharedUserId="android.uid.shared",作用是获得系统
权限,但是这样的程序属性只能在 build 整个系统时放进去(就是系统软件)才起
作用,共享 ID 的程序必须是同一签名的
3. Android 权限的实现
1) 第一层:由应用设置,修改 AndroidManifest.xml,形如:
<uses-permission android:name=”android.permission.INTERNET”/>
2) 第二层:框架层,权限对应组,frameworks/base/data/etc/platform.xml,形如:
<permission name=”android.permission.INTERNET”>
<group gid=inet” />
</permission>
3) 第三层:系统层,系统的权限,system/core/include/private/android_filesystem_config.h,形如:
#define AID_INET 3003
建立 SOCKET 的权限
......
{ “inet”, AID_INET, },
4. 系统权限
1) 特殊权限的用户
a) system
uid 1000
b) radio uid 1001
2) 查看可用系统的权限
$ adb shell
# pm list permissions
5. framework 层对权限的判断
1) 相关源码实现
frameworks/base/services/java/com/android/server/PackageManagerService.java
frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
2) 在系统层,如何查看某个应用的权限
a) 在应用进程开启时,ActivityManagerService.java 会在 logcat 中输出该应用的权
限,形如:
1382010 年谢彦的 Android 笔记
I/ActivityManager(1730):
Start
proc
com.anbdroid.phone
for
restart
com.android.phone:pid=2605 uid=1000 gids={3002,3001,3003}
即它有 3001,3002,3003 三个权限:访问蓝牙和建立 socket
b) 注意:此打印输出在应用第一次启动时。如果进程已存在,需要先把对应进程
杀掉,以保证该进程重新启动,才能显示
c) 具体实现,见:
framewors/base/services/java/com/android/server/am/ActivityManagerService.java
的函数 startProcessLocked(),其中取其组信息的具本语句是
mContext.getPackageManager().getPackageGids(app.info.packageName);
6. 参考
http://wenku.baidu.com/view/7754a4360b4c2e3f5727634e.html
```

## 适配硬件平台

```
1. 相关硬件
电池,RTC,键值(普通键值,DOCKING 键值),LED 灯,背光,传感器(亮度,
距离,速度,指南针等)
,振动,蓝牙,相机,音视频引擎,网络,显示,电话
2. 硬件相关的主要目录
kernel,vendor,device,hardware,bootable
3. 以 HTC G1 为例分析其主要的平台配置目录 device/htc/dream/* (froyo 源码)
1) 注意:froyo 以前版本在 vendor/htc 中,需要单独下载,现在都已经在 git 里包含
了 g1,g2 的支持。
2) 说明 (参见 g1,g2)
a) AndroidProducts.mk
说明产品都需要编什么东西,定义产品使用哪个 mk 文件
b) vendorsetup.sh
加上某硬件的支持,以便编译前用 lunch 选择
c) full_dream.mk
定义产品所要编译的项目,指定需要编译哪些应用,产品名称,设备,型号(重
要)
d) BoardConfig.mk
含 mtd 设备的分区,硬件相关的模块,及编译工具
e) AndroidBoard.mk
编译 kernel, bootload, nandwrite, 键值定义文件, 开机画面的说明,重要的是
kernel 的默认配置文件 KERNEL_DEFCONFIG
f) device_*.mk
相关具体硬件(美国版的 G1)
g) overlay
格式类似源码根目录,存在定制产生用到的资源
h) *.kl, *.kcm
键值定义
i) *.sh
辅助工具的脚本,如从 update.zip 中提取库
4. 编译某平台相关代码
1) G1/G2
a) 下载并编译 kernel
b) 从手机或 update.zip 中提取 so 库
c) 编译,烧写
2) 其它机型
a) 下载并编译 kernel
b) 按 froyo 新规则添加硬件相关目录结构(vender=>device),修改 mk 文件
c) 从手机或 update.zip 中提取 so 库
d) 编译,烧写
5. 技巧
1) 可以逐步替换 boot.img,system.img 以定位问题
1452010 年谢彦的 Android 笔记
2) 逐个对比新旧 system 目录,以确认问题
3) 先让 adb shell 可用,以便调试
a) 重要的包
i) boot.img:含 kernel 和基本的文件系统
理论上说,只有 boot.img 而没有 system.img 也是可以启动并连接 adb 调试
的,因为 adbd 在 boot.img 所含的基本文件系统中,但是需要重新定义 init.rc
ii) system.img:含主要系统,命令,库,图形界面
iii) userdata.img:放用户数据
b) 启动顺序为 bootloader->kernel->system->launcher
```

## FOTA

```
空中升级Fota
1. 简介
fota(Firmware Over The Air),移动终端空中下载软件升级技术。原理是根据算法把新
旧版本之间的差别做成一个软件包,手机从服务器上下载到手机里,由手机完成软件
版本的升级
2. 用户操作
1) 设置->关于手机->检查更新,检查是否有更新版本。
2) 可以使用默认设置自动更新:设置->关于手机->自动系统检查
3. 升级过程
MT710 的 FOTA 由中国移动服务器发起,服务器发送 FOTA 信息到手机,手机收
到信息并确认后,手机将自动上网下载升级包,下载后,手机将重启完成软件的更新。
用户需要按照手机的提示,确认下载和安装即可,不需要其他操作,也不需要对手机
进行特殊设置。下载中断时手机会自动续接,直到下载完毕。在手机 FOTA 过程中,
需要保持手机在网络良好的连接状态,电池电量充足。
4. Fota 的相关源码
1) 升级界面
package/app/Fota/*
2) 系统层
system/core/fota/*
3) 底层库支持
external/fotalib/*
4) fota 分区
因为像 boot.img 需要在系统之前修改,所以有 fota 启动方式
bootable/bootloader/legacy/fota*
```

## Flash分区

```
1. 查看当前系统的分区情况
$ adb shell
$ cat /proc/mtd
2. 分区对应的 img(源码编译后生成在 out/target/product/xxx/目录下)
1) modem(多个,支持电话和 GPS)
amss.mbn
2) bootloader(启动用)
appsboot.mbn
3) 空中升级
fota*(升级用, 可能多个)
4) 内核和文件系统
boot.img(内核和基本文件系统)
5) 系统分区
system.img(系统分区)
6) 用户数据分区
userdata.img(数据分区)
3. 参考
1) bootloader 启动顺序
http://blog.csdn.net/yili_xie/archive/2010/05/14/5592276.aspx
```

## android p 上使用 hiden 的方法

```
方法1：
private void testJavaPojie() {
    try {
        Class reflectionHelperClz = Class.forName("com.example.support_p.ReflectionHelper");
        Class classClz = Class.class;
        Field classLoaderField = classClz.getDeclaredField("classLoader");
        classLoaderField.setAccessible(true);
        classLoaderFIeld.set(reflectionHelperClz, null);
        // ==> Class.classLoader = com.example.support_p.ReflectionHelper ????
        // com.example.support_p.ReflectionHelper 这个类在哪里？？？
    } catch(Exception e) {
        e.printStackTrace();
    }
}

方法2：
第二种方法，「借助系统的类去反射」也就是说，如果系统有一个方法`systemMethod`，这个`systemMethod` 去调用反射相反的方法，那么`systemMethod`毋庸置疑会反射成功。但是，我们从哪去找到这么一个方法给我们用？事实上，我们不仅能找到这样的方法，而且这个方法能帮助我们调用任意的函数，那就是**反射本身！**
Method metaGetDeclaredMethod = Class.class.getDeclaredMethod("getDeclardMethod"); // 公开API，无问题
Method hiddenMethod = metaGetDeclaredMethod.invoke(hiddenClass, "hiddenMethod", "hiddenMethod参数列表"); // 系统类通过反射使用隐藏 API，检查直接通过。
hiddenMethod.invoke // 正确找到 Method 直接反射调用
```

## YUV

```
https://mp.weixin.qq.com/s?__biz=MzUyOTA2MjA2NQ==&mid=2247483877&idx=1&sn=06b7296d19c3edf96a49b1b0a288b6b1&chksm=fa67803bcd10092d4631be81900e91ff15083e4ef28d121274d2ec3cc692018ceca13995d632&scene=0&xtrack=1&key=7865e1e5a7ba115ec737c955c34dd90271207e03cf02d71abfb3f179ac4458ae35883bc97eccc0a80c0f621e6f3495b61fc0d8d9f3352b646b88959e0090d0df2006e7e1663b51113f6fad1c93f1e004&ascene=1&uin=MTQzOTAxMDg4MA%3D%3D&devicetype=Windows+10&version=62060844&lang=zh_CN&pass_ticket=PxMajixtG4%2F1z9KAWqxn%2B7aMeu95XL6KXXPjRFfctJu2Mn3D0Hff6FIAZiyzR5dZ

YUV
YUV 编码采用了明亮度和色度表示每个像素的颜色。

其中 Y 表示明亮度（Luminance、Luma），也就是灰阶值。

U、V 表示色度（Chrominance 或 Chroma），描述的是色调和饱和度。

YCbCr 其实是 YUV 经过缩放和偏移的翻版。其中 Y 与 YUV 中的 Y 含义一致,Cb,Cr 同样都指色彩，只是在表示方法上不同而已。YCbCr 其中 Y 是指亮度分量，Cb 指蓝色色度分量，而 Cr 指红色色度分量。

YUV 优点
对于 YUV 所表示的图像，Y 和 UV 分量是分离的。如果只有 Y 分量而没有 UV 分离，那么图像表示的就是黑白图像。彩色电视机采用的就是 YUV 图像，解决与和黑白电视机的兼容问题，使黑白电视机也能接受彩色电视信号。

人眼对色度的敏感程度低于对亮度的敏感程度。主要原因是视网膜杆细胞多于视网膜锥细胞，其中视网膜杆细胞的作用就是识别亮度，视网膜锥细胞的作用就是识别色度。所以，眼睛对于亮度的分辨要比对颜色的分辨精细一些。

利用这个原理，可以把色度信息减少一点，人眼也无法查觉这一点。

所以，并不是每个像素点都需要包含了 Y、U、V 三个分量，根据不同的采样格式，可以每个 Y 分量都对应自己的 UV 分量，也可以几个 Y 分量共用 UV 分量。相比 RGB，能够节约不少存储空间。

YUV 采样格式
YUV 图像的主流采样方式有如下三种：

YUV 4:4:4 采样

YUV 4:2:2 采样

YUV 4:2:0 采样

YUV 4:4:4
YUV 4:4:4 表示 Y、U、V 三分量采样率相同，即每个像素的三分量信息完整，都是 8bit，每个像素占用 3 个字节。

如下图所示：





四个像素为： [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
采样的码流为：Y0 U0 V0 Y1 U1 V1 Y2 U2 V2 Y3 U3 V3
映射出的像素点为：[Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
可以看到这种采样方式与 RGB 图像大小是一样的。

YUV 4:2:2
YUV 4:2:2 表示 UV 分量的采样率是 Y 分量的一半。

如下图所示：





四个像素为： [Y0 U0 V0] [Y1 U1 V1] [Y2 U2 V2] [Y3 U3 V3]
采样的码流为：Y0 U0 Y1 V1 Y2 U2 Y3 U3
映射出的像素点为：[Y0 U0 V1]、[Y1 U0 V1]、[Y2 U2 V3]、[Y3 U2 V3]
其中，每采样一个像素点，都会采样其 Y 分量，而 U、V 分量都会间隔采集一个，映射为像素点时，第一个像素点和第二个像素点共用了 U0、V1 分量，以此类推。从而节省了图像空间。

比如一张 1920 * 1280 大小的图片，采用 YUV 4:2:2 采样时的大小为：

(1920 * 1280 * 8 + 1920 * 1280 * 0.5 * 8 * 2 ) / 8 / 1024 / 1024 = 4.68M

可以看出，比 RGB 节省了三分之一的存储空间。

YUV 4:2:0
YUV 4:2:0 并不意味着不采样 V 分量。它指的是对每条扫描线来说，只有一种色度分量以 2:1 的采样率存储，相邻的扫描行存储不同的色度分量。也就是说，如果第一行是 4:2:0，下一行就是 4:0:2，在下一行就是 4:2:0，以此类推。

如下图所示：





图像像素为：
[Y0 U0 V0]、[Y1 U1 V1]、 [Y2 U2 V2]、 [Y3 U3 V3]
[Y5 U5 V5]、[Y6 U6 V6]、 [Y7 U7 V7] 、[Y8 U8 V8]

采样的码流为：
Y0 U0 Y1 Y2 U2 Y3 
Y5 V5 Y6 Y7 V7 Y8

映射出的像素点为：
[Y0 U0 V5]、[Y1 U0 V5]、[Y2 U2 V7]、[Y3 U2 V7]
[Y5 U0 V5]、[Y6 U0 V5]、[Y7 U2 V7]、[Y8 U2 V7]
其中，每采样一个像素点，都会采样 Y 分量，而 U、V 分量都会隔行按照 2:1 进行采样。

一张 1920 * 1280 大小的图片，采用 YUV 4:2:0 采样时的大小为：

(1920 * 1280 * 8 + 1920 * 1280 * 0.25 * 8  * 2 ) / 8 / 1024 / 1024 = 3.51M

相比 RGB，节省了一半的存储空间。

YUV 存储格式
YUV 数据有两种存储格式：平面格式（planar format）和打包格式（packed format）。

planar format：先连续存储所有像素点的 Y，紧接着存储所有像素点的 U，随后是所有像素点的 V。

packed format：每个像素点的 Y、U、V 是连续交错存储的。

因为不同的采样方式和存储格式，就会产生多种 YUV 存储方式，这里只介绍基于 YUV422 和  YUV420 的存储方式。

YUYV
YUYV 格式属于 YUV422，采用打包格式进行存储，Y 和 UV 分量按照 2:1 比例采样，每个像素都采集 Y 分量，每隔一个像素采集它的 UV 分量。

Y0 U0 Y1 V0 Y2 U2 Y3 V2

Y0 和 Y1 共用 U0 V0 分量，Y2 和 Y3 共用 U2 V2 分量。

UYVY
UYVY 也是 YUV422 采样的存储格式中的一种，只不过与 YUYV 排列顺序相反。

U0 Y0 V0 Y1 U2 Y2 V2 Y3

YUV 422P
YUV422P 属于 YUV422 的一种，它是一种 planer 模式，即 Y、U、V 分别存储。

YUV420P 和 YUV420SP
YUV420P 是基于 planar 平面模式进行存储，先存储所有的 Y 分量，然后存储所有的 U 分量或者 V 分量。



同样，YUV420SP 也是基于 planar 平面模式存储，与 YUV420P 的区别在于它的 U、V 分量是按照 UV 或者 VU 交替顺序进行存储。



YU12 和 YU21
YU12 和 YV12 格式都属于 YUV 420P 类型，即先存储 Y 分量，再存储 U、V 分量，区别在于：YU12 是先 Y 再 U 后 V，而 YV12 是先 Y 再 V 后 U 。

NV21 和 NV21
NV12 和 NV21 格式都属于 YUV420SP 类型。它也是先存储了 Y 分量，但接下来并不是再存储所有的 U 或者 V 分量，而是把 UV 分量交替连续存储。

NV12 是 IOS 中有的模式，它的存储顺序是先存 Y 分量，再 UV 进行交替存储。

NV21 是 安卓 中有的模式，它的存储顺序是先存 Y 分量，在 VU 交替存储。

YUV 与 RGB 转换
YUV 与 RGB 之间的转换，就是将 图像所有像素点的 R、G、B 分量和 Y、U、 分量相互转换。
```

## 安卓Webview网页秒开策略探索

```
https://juejin.im/post/5d2605f8f265da1bc23fa07c

痛点是什么？
网页加载缓慢，白屏，使用卡顿。
为何有这种问题？
1.调用loadUrl()方法的时候，才会开始网页加载流程
2.js臃肿问题
3.加载图片太多
4.webview本身问题
webiew是怎么加载网页的呢？
webview初始化->DOM下载→DOM解析→CSS请求+下载→CSS解析→渲染→绘制→合成
优化方向是？
1.webview本身优化

提前内核初始化
代码：

public class App extends Application {

    private WebView mWebView ;
    @Override
    public void onCreate() {
        super.onCreate();
        mWebView = new WebView(new MutableContextWrapper(this));
    }
}

```

## 串口通信 android-serialport-api

```
串口通信(Serial Communication)， 是指外设和计算机间，通过数据信号线 、地线、控制线等，按位进行传输数据的一种通讯方式。这种通信方式使用的数据线少，在远距离通信中可以节约通信成本，但其传输速度比并行传输低。

由于 CPU 与接口之间按并行方式传输，接口与外设之间按串行方式传输，因此，在串行接口中，必须要有 " 接收移位寄存器 " （串→并）和 " 发送移位寄存器 " （并→串）. 在数据输入过程中，数据 1 位 1 位地从外设进入接口的 " 接收移位寄存器 ",当 " 接收移位寄存器 " 中已接收完 1 个字符的各位后，数据就从 " 接收移位寄存器 " 进入 " 数据输入寄存器 " . CPU 从 " 数据输入寄存器 " 中读取接收到的字符.（并行读取，即 D7~D0 同时被读至累加器中）. " 接收移位寄存器 " 的移位速度由 " 接收时钟 " 确定.

UART
通用异步收发传输器（Universal Asynchronous Receiver/Transmitter，通常称为UART）是一种异步收发传输器，是电脑硬件的一部分，将数据通过串行通信和并行通信间作传输转换。UART通常用在与其他通信接口（如EIA RS-232）的连接上。

具体实物表现为独立的模组化芯片，或是微处理器中的内部周边装置(peripheral)。一般和RS-232C规格的，类似Maxim的MAX232之类的标准信号幅度变换芯片进行搭配，作为连接外部设备的接口。在UART上追加同步方式的序列信号变换电路的产品，被称为USART(Universal Synchronous Asynchronous Receiver Transmitter)。

https://juejin.im/post/5d3009375188251b4b32af17

串口工具下载
https://code.google.com/archive/p/android-serialport-api/downloads
```

## 利用GitHub实现简单的个人App版本更新

```
https://juejin.im/post/5d1df865e51d4550a629b2e5
```

## QMUI(简约的ui框架)

```
https://qmuiteam.com/android
```

## html 转 pdf 的库

```
https://wkhtmltopdf.org/

https://github.com/wkhtmltopdf/wkhtmltopdf
```

## 机器学习

```
https://github.com/Avik-Jain/100-Days-of-ML-Code-Chinese-Version
```

## Android V1,V2,V3签名

```
https://jeanboy.blog.csdn.net/article/details/97884257

https://jeanboy.blog.csdn.net/article/details/84849651
```

## 如何导入导出外部数据库

```
把原数据库包括在项目源码的 res/raw

android系统下数据库应该存放在 /data/data/com..（package name）/ 目录下，所以我们需要做的是把已有的数据库传入那个目录下.操作方法是用FileInputStream读取原数据库，再用FileOutputStream把读取到的东西写入到那个目录.
```

## TextView 性能优化

```
我们可以不用从SpannableStringBuilder转化到String。根据你的文本中是否包含链接，底层的TextView可能会复制一份你的字符串，这需要分配一些内存。

我们可以一直使用StaticLayout，这比DynamicLayout要稍微快一些。

我们可以避免使用TexView中其他的逻辑： 监听文本修改的逻辑，展示嵌入drawable的逻辑，绘制编辑器的逻辑以及弹出下拉列表的逻辑。


// 优化后的 StaticLayoutView
public class StaticLayoutView extends View {
    private Layout layout;
    private int width ;
    private int height;

    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
    public StaticLayoutView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
        super(context, attrs, defStyleAttr, defStyleRes);
    }

    public StaticLayoutView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    public StaticLayoutView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public StaticLayoutView(Context context) {
        super(context);
    }

    public void setLayout(Layout layout) {
        this.layout = layout;
        if (this.layout.getWidth() != width || this.layout.getHeight() != height) {
            width = this.layout.getWidth();
            height = this.layout.getHeight();
            requestLayout();
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.save();
        if (layout != null) {
            layout.draw(canvas, null, null, 0);
        }
        canvas.restore();
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        super.onLayout(changed, left, top, right, bottom);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (layout != null) {
            setMeasuredDimension(layout.getWidth(), layout.getHeight());
        } else {
            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        }
    }

}
```

## LocalBroadcastManager 代替普通 BroadcastReceiver，效率和安全性都更高 ？？？？ LocalBroadcastManager 是什么？？？

## 优化

```
2、异步，利用多线程提高TPS
充分利用多核Cpu优势，利用线程解决密集型计算、IO、网络等操作。
关于多线程可参考：Java线程池
在Android应用程序中由于系统ANR的限制，将可能造成主线程超时操作放入另外的工作线程中。在工作线程中可以通过handler和主线程交互。

3、提前或延迟操作，错开时间段提高TPS
(1) 延迟操作
不在Activity、Service、BroadcastReceiver的生命周期等对响应时间敏感函数中执行耗时操作，可适当delay。
Java中延迟操作可使用ScheduledExecutorService，不推荐使用Timer.schedule;
Android中除了支持ScheduledExecutorService之外，还有一些delay操作，如
handler.postDelayed，handler.postAtTime，handler.sendMessageDelayed，View.postDelayed，AlarmManager定时等。

(2) 提前操作
对于第一次调用较耗时操作，可统一放到初始化中，将耗时提前。如得到壁纸wallpaperManager.getDrawable();

4、网络优化
更多见 性能优化第四篇——移动网络优化

以下是网络优化中一些客户端和服务器端需要尽量遵守的准则：
a. 图片必须缓存，最好根据机型做图片做图片适配
b. 所有http请求必须添加httptimeout

c. 开启gzip压缩
d. api接口数据以json格式返回，而不是xml或html
e. 根据http头信息中的Cache-Control及expires域确定是否缓存请求结果。

f. 确定网络请求的connection是否keep-alive
g. 减少网络请求次数，服务器端适当做请求合并。
h. 减少重定向次数
i. api接口服务器端响应时间不超过100ms
google正在做将移动端网页速度降至1秒的项目，关注中https://developers.google.com/speed/docs/insights/mobile
```

## 破解android签名验证

```
services.jar

PackageManagerService.smali

修改方法:
verifySignaturesLP返回1

修改方法:
compareSignatures返回0
```

## android 查看so的依赖关系

```
/data/android-ndk/toolchains/arm-linux-androideabi-4.8/prebuilt/linux-x86_64/arm-linux-androideabi/bin/objdump -x ../bin/system_server | grep NEEDED
```

## 怎样将zip文件保存在图片中

```
linux下执行：

cat aaa.png  bbb.zip >> zzz.png
windows下执行：

COPY /b aaa.png+bbb.zip zzz.png
命令运行完得到的zzz.png打开就是和aaa.png一样的图片，修改扩展名为zip后就是bbb.zip的内容。

其他图片格式也支持哦，自己尝试一下。
```

## Prototype（原型模式）

```
原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。 这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。

这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。 当直接创建对象的代价比较大时，则采用这种模式。

例如，一个对象需要在一个高代价的数据库操作之后被创建。 我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。

使用
实现
创建原型类

public class Prototype implements Cloneable, Serializable { 

    private static final long serialVersionUID = 1L;
    private String string;

    private SerializableObject obj; 

    /* 浅复制 */
    public Object clone() throws CloneNotSupportedException {
        Prototype proto = (Prototype) super.clone();  
        return proto;  
    }

    /* 深复制 */
    public Object deepClone() throws IOException, ClassNotFoundException {

        /* 写入当前对象的二进制流 */  
        ByteArrayOutputStream bos = new ByteArrayOutputStream();  
        ObjectOutputStream oos = new ObjectOutputStream(bos);  
        oos.writeObject(this);  

        /* 读出二进制流产生的新对象 */  
        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());  
        ObjectInputStream ois = new ObjectInputStream(bis);  
        return ois.readObject();  
    }

    public String getString() { 
        return string;
    }

    public void setString(String string) {
        this.string = string;
    }

    public SerializableObject getObj() {
        return obj;
    }

    public void setObj(SerializableObject obj) {
        this.obj = obj;  
    }

}

class SerializableObject implements Serializable {
    private static final long serialVersionUID = 1L;
}
浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。

深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。 简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。

使用场景
资源优化场景。
类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。
性能和安全要求的场景。
通过 new 产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
一个对象多个修改者的场景。
一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。
在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过 clone 的方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与 Java 融为浑然一体，大家可以随手拿来使用。
优点
性能提高。
逃避构造函数的约束。
缺点
配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。
必须实现 Cloneable 接口。
注意事项
与通过对一个类进行实例化来构造新对象不同的是，原型模式是通过复制一个现有对象生成新对象的。 浅复制实现 Cloneable，重写，深复制是通过实现 Serializable 读取二进制流。
```

## 一篇文章看明白 TCP/IP，TCP，UDP，IP，Socket 之间的关系

```
https://jeanboy.blog.csdn.net/article/details/72236734
```

## 搭建Simba 文件共享服务器

```
Ubuntu下使用Simba服务实现局域网内文件共享
Ubuntu下安装Simba服务器将linux电脑上的内容共享，同一局域网内的另外一台Windows PC即可访问其共享内容，
从而实现Windows电脑向访问本地文件一样访问Linux文件系统的内容。

(1)安装Simaba服务器
sudo apt-get install samba

(2)安装samba图形化配置软件
sudo apt-get install system-config-samba

(3)创建一个Simba专用用户
从“系统”—“系统管理”—“用户和组”，来创建。如图，先点击“解锁”，然后“添加新用户”
然后输入新用户名字(如Simba)和密码(如111111)，然后在“高级”里面，选择“主组”为sambashare后点击"确定"即可
一句话来概括，就是创建一个主组为sambashare的用户

(4)配置samba共享
从“系统”—“系统管理—”samba“，运行配置界面
然后”首选项“—”服务器设置“。点击：安全性，在最后的”来宾帐号“里面， 
选择我们新建立的那个用户simba后点击确定

(5)修改samba配置文件
打开/etc/samba/smb.conf，修改valid users = XXXX为valid users = simba

(6)重启samba服务
sudo /etc/init.d/samba restart

(7)添加共享文件
从“系统”—“系统管理—”samba“，运行配置界面
点击"添加"来添加共享文件夹,点击"浏览"来选择需要共享的文件夹，选择"可擦写"和"显示"，点击"访问"可以设置访问权限，最好设置成"允许所有用户访问"

本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/jiajie961/archive/2010/11/04/5987821.aspx
```

## 搭建tftp服务器

```
Ubuntu下tftp服务器的创建
实验平台：Ubuntu9.04

(1)安装tftp服务
sudo apt-get install tftp tftpd openbsd-inetd

(2)在根目录下创建文件夹 tftpboot文件夹并修改权限 
cd / 
sudo mkdir tftpboot 
sudo chmod 777 tftpboot

(3)修改/etc/inetd.conf文件如下：
tftp  dgram    udp    wait    nobody    /usr/sbin/tcpd    /usr/sbin/in.tftpd   /tftpboot

(4)开启tftp服务
sudo /etc/init.d/openbsd-inetd reload 
sudo in.tftpd -l /tftpboot

(5)重启电脑，然后将测试文件放入/tftpboot目录下即可开始测试，出现问题可能一般都是权限问题
/tftpboot目录下的文件访问权限改成0777
```

## ubifs

```
制作ubifs文件系统
1,安装相关的软件包
apt-get install liblzo2-dev

2,获取相关的工具mkfs.ubifs和ubinize
这两个工具是制作ubifs文件系统的时候用到，它们是mtd-utils工具包中的内容，mtd-utils工具包你可以从下面的网站下载和编译出来：
官方网站：http://www.linux-mtd.infradead.org/index.html
资源下载网站：http://git.infradead.org/

3,创建一个create-ubifs.sh脚本，主要是调用mkfs.ubifs和ubinize工具和相关参数来制作ubifs文件系统，内容如下：
#!/bin/bash

##########################################################
#    Script to generate ubifs filesystem image.     #
##########################################################

##### ubinize configuration file
config_file=rootfs_ubinize.cfg

##### Function to check result of the command
check_result() {
if [ $? -ne 0 ]
then
    echo "FAILED"
else
    echo "SUCCESSFUL"
fi
}

######  Function to check whether an application exists
check_program() {
for cmd in "$@"
do
        which ${cmd} > /dev/null 2>&1
        if [ $? -ne 0 ]
        then
                echo
                echo "Cannot find command \"${cmd}\""
                echo
                exit 1
        fi
done
}

if [ $# -ne 5 ]
then
    echo
    echo 'Usage: create-ubifs.sh [page_size_in_bytes] [pages_per_block] [partition_size_in_bytes] [blocks_per_device] [path_to_rootfs]'
    echo
    exit
fi

page_size_in_bytes=$1
echo "Page size                                                 [$page_size_in_bytes]bytes."
pages_per_block=$2
echo "Pages per block                                           [$pages_per_block]"
partition_size_in_bytes=$3
echo "File-system partition size                                [$partition_size_in_bytes]bytes."
blocks_per_device=$4
echo "Blocks per device                                         [$blocks_per_device]"
path_to_rootfs=$5

# wear_level_reserved_blocks is 1% of total blcoks per device
wear_level_reserved_blocks=`expr $blocks_per_device / 100`
echo "Reserved blocks for wear level                            [$wear_level_reserved_blocks]"

#logical_erase_block_size is physical erase block size minus 2 pages for UBI
logical_pages_per_block=`expr $pages_per_block - 2`
logical_erase_block_size=`expr $page_size_in_bytes \* $logical_pages_per_block`
echo "Logical erase block size                                  [$logical_erase_block_size]bytes."

#Block size = page_size * pages_per_block
block_size=`expr $page_size_in_bytes \* $pages_per_block`
echo "Block size                                                [$block_size]bytes."

#physical blocks on a partition = partition size / block size
partition_physical_blocks=`expr $partition_size_in_bytes / $block_size`
echo "Physical blocks in a partition                            [$partition_physical_blocks]"

#Logical blocks on a partition = physical blocks on a partitiion - reserved for wear level
patition_logical_blocks=`expr $partition_physical_blocks - $wear_level_reserved_blocks`
echo "Logical blocks in a partition                             [$patition_logical_blocks]"

#File-system volume = Logical blocks in a partition * Logical erase block size
fs_vol_size=`expr $patition_logical_blocks \* $logical_erase_block_size`
echo "File-system volume                                        [$fs_vol_size]bytes."

echo
echo "Generating configuration file..."
echo "[rootfs-volume]"  > $config_file
echo "mode=ubi" >> $config_file
echo "image=rootfs_ubifs.img" >> $config_file
echo "vol_id=0" >> $config_file
echo "vol_size=$fs_vol_size" >> $config_file
echo "vol_type=dynamic" >> $config_file
echo "vol_name=system" >> $config_file
echo

# Note: Check necessary program for installation
#echo -n "Checking necessary program for installation......"
#check_program mkfs.ubifs ubinize
#echo "Done"

#Generate ubifs image
echo -n "Generating ubifs..."
./mkfs.ubifs -x lzo -m $page_size_in_bytes -e $logical_erase_block_size -c $patition_logical_blocks -o rootfs_ubifs.img -d $path_to_rootfs
check_result
echo -n "Generating ubi image out of the ubifs..."
./ubinize -o ubi.img -m $page_size_in_bytes -p $block_size -s $page_size_in_bytes $config_file -v
check_result

rm -f rootfs_ubifs.img
rm -f $config_file

(4)将mkfs.ubifs和ubinize以及create-ubifs.sh放置在同一目录下，然后调用create-ubifs.sh即可创建ubifs文件系统，create-ubifs.sh用法如下：
create-ubifs.sh  page_size_in_bytes(页大小) pages_per_block(每个扇区的页数量) partition_size_in_bytes(分区大小) blocks_per_device(扇区数量) path_to_rootfs(文件系统路径)
举例如下：
./create-ubifs.sh 2048 64 83886080 4096 ./rootfs
上面命令的意思是调用create-ubifs.sh将当前目录下的rootfs文件夹的内容制作成ubifs文件系统，nand flash的页大小为2k,每个扇区有64页，
总共有4096个扇区，要制作的文件系统的大小为83886080字节。
```

## android makefile 文件的编写

```
android编译系统makefile(Android.mk)写法
android编译系统的makefile文件Android.mk写法如下

(1)Android.mk文件首先需要指定LOCAL_PATH变量，用于查找源文件。由于一般情况下
Android.mk和需要编译的源文件在同一目录下，所以定义成如下形式：
LOCAL_PATH:=$(call my-dir)
上面的语句的意思是将LOCAL_PATH变量定义成本文件所在目录路径。

(2)Android.mk中可以定义多个编译模块，每个编译模块都是以include $(CLEAR_VARS)开始
以include $(BUILD_XXX)结束。
include $(CLEAR_VARS)
CLEAR_VARS由编译系统提供，指定让GNU MAKEFILE为你清除除LOCAL_PATH以外的所有LOCAL_XXX变量，
如LOCAL_MODULE，LOCAL_SRC_FILES，LOCAL_SHARED_LIBRARIES，LOCAL_STATIC_LIBRARIES等。
include $(BUILD_STATIC_LIBRARY)表示编译成静态库
include $(BUILD_SHARED_LIBRARY)表示编译成动态库。
include $(BUILD_EXECUTABLE)表示编译成可执行程序

(3)举例如下(frameworks/base/libs/audioflinger/Android.mk)：
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)  模块一
ifeq ($(AUDIO_POLICY_TEST),true)
  ENABLE_AUDIO_DUMP := true
endif
LOCAL_SRC_FILES:= \
    AudioHardwareGeneric.cpp \
    AudioHardwareStub.cpp \
    AudioHardwareInterface.cpp
ifeq ($(ENABLE_AUDIO_DUMP),true)
  LOCAL_SRC_FILES += AudioDumpInterface.cpp
  LOCAL_CFLAGS += -DENABLE_AUDIO_DUMP
endif
LOCAL_SHARED_LIBRARIES := \
    libcutils \
    libutils \
    libbinder \
    libmedia \
    libhardware_legacy
ifeq ($(strip $(BOARD_USES_GENERIC_AUDIO)),true)
  LOCAL_CFLAGS += -DGENERIC_AUDIO
endif
LOCAL_MODULE:= libaudiointerface
ifeq ($(BOARD_HAVE_BLUETOOTH),true)
  LOCAL_SRC_FILES += A2dpAudioInterface.cpp
  LOCAL_SHARED_LIBRARIES += liba2dp
  LOCAL_CFLAGS += -DWITH_BLUETOOTH -DWITH_A2DP
  LOCAL_C_INCLUDES += $(call include-path-for, bluez)
endif
include $(BUILD_STATIC_LIBRARY)  模块一编译成静态库
include $(CLEAR_VARS)  模块二
LOCAL_SRC_FILES:=               \
    AudioPolicyManagerBase.cpp
LOCAL_SHARED_LIBRARIES := \
    libcutils \
    libutils \
    libmedia
ifeq ($(TARGET_SIMULATOR),true)
 LOCAL_LDLIBS += -ldl
else
 LOCAL_SHARED_LIBRARIES += libdl
endif
LOCAL_MODULE:= libaudiopolicybase
ifeq ($(BOARD_HAVE_BLUETOOTH),true)
  LOCAL_CFLAGS += -DWITH_A2DP
endif
ifeq ($(AUDIO_POLICY_TEST),true)
  LOCAL_CFLAGS += -DAUDIO_POLICY_TEST
endif
include $(BUILD_STATIC_LIBRARY) 模块二编译成静态库
include $(CLEAR_VARS) 模块三
LOCAL_SRC_FILES:=               \
    AudioFlinger.cpp            \
    AudioMixer.cpp.arm          \
    AudioResampler.cpp.arm      \
    AudioResamplerSinc.cpp.arm  \
    AudioResamplerCubic.cpp.arm \
    AudioPolicyService.cpp
LOCAL_SHARED_LIBRARIES := \
    libcutils \
    libutils \
    libbinder \
    libmedia \
    libhardware_legacy
ifeq ($(strip $(BOARD_USES_GENERIC_AUDIO)),true)
  LOCAL_STATIC_LIBRARIES += libaudiointerface libaudiopolicybase
  LOCAL_CFLAGS += -DGENERIC_AUDIO
else
  LOCAL_SHARED_LIBRARIES += libaudio libaudiopolicy
endif
ifeq ($(TARGET_SIMULATOR),true)
 LOCAL_LDLIBS += -ldl
else
 LOCAL_SHARED_LIBRARIES += libdl
endif
LOCAL_MODULE:= libaudioflinger
ifeq ($(BOARD_HAVE_BLUETOOTH),true)
  LOCAL_CFLAGS += -DWITH_BLUETOOTH -DWITH_A2DP
  LOCAL_SHARED_LIBRARIES += liba2dp
endif
ifeq ($(AUDIO_POLICY_TEST),true)
  LOCAL_CFLAGS += -DAUDIO_POLICY_TEST
endif
ifeq ($(TARGET_SIMULATOR),true)
    ifeq ($(HOST_OS),linux)
        LOCAL_LDLIBS += -lrt -lpthread
    endif
endif
ifeq ($(BOARD_USE_LVMX),true)
    LOCAL_CFLAGS += -DLVMX
    LOCAL_C_INCLUDES += vendor/nxp
    LOCAL_STATIC_LIBRARIES += liblifevibes
    LOCAL_SHARED_LIBRARIES += liblvmxservice
#    LOCAL_SHARED_LIBRARIES += liblvmxipc
endif
include $(BUILD_SHARED_LIBRARY) 模块三编译成动态库


(4)编译一个应用程序(APK)
  LOCAL_PATH := $(call my-dir)
  include $(CLEAR_VARS)
   
  # Build all java files in the java subdirectory
  LOCAL_SRC_FILES := $(call all-subdir-java-files)
   
  # Name of the APK to build
  LOCAL_PACKAGE_NAME := LocalPackage
   
  # Tell it to build an APK
  include $(BUILD_PACKAGE)

(5)编译一个依赖于静态Java库(static.jar)的应用程序
  LOCAL_PATH := $(call my-dir)
  include $(CLEAR_VARS)
   
  # List of static libraries to include in the package
  LOCAL_STATIC_JAVA_LIBRARIES := static-library
   
  # Build all java files in the java subdirectory
  LOCAL_SRC_FILES := $(call all-subdir-java-files)
   
  # Name of the APK to build
  LOCAL_PACKAGE_NAME := LocalPackage
   
  # Tell it to build an APK
  include $(BUILD_PACKAGE)

(6)编译一个需要用平台的key签名的应用程序
  LOCAL_PATH := $(call my-dir)
  include $(CLEAR_VARS)
   
  # Build all java files in the java subdirectory
  LOCAL_SRC_FILES := $(call all-subdir-java-files)
   
  # Name of the APK to build
  LOCAL_PACKAGE_NAME := LocalPackage
   
  LOCAL_CERTIFICATE := platform
   
  # Tell it to build an APK
  include $(BUILD_PACKAGE)


(7)编译一个需要用特定key前面的应用程序
  LOCAL_PATH := $(call my-dir)
  include $(CLEAR_VARS)
   
  # Build all java files in the java subdirectory
  LOCAL_SRC_FILES := $(call all-subdir-java-files)
   
  # Name of the APK to build
  LOCAL_PACKAGE_NAME := LocalPackage
   
  LOCAL_CERTIFICATE := vendor/example/certs/app
   
  # Tell it to build an APK
  include $(BUILD_PACKAGE)

(8)添加一个预编译应用程序
  LOCAL_PATH := $(call my-dir)
  include $(CLEAR_VARS)
   
  # Module name should match apk name to be installed.
  LOCAL_MODULE := LocalModuleName
  LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
  LOCAL_MODULE_CLASS := APPS
  LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
   
  include $(BUILD_PREBUILT)

(9)添加一个静态JAVA库
  LOCAL_PATH := $(call my-dir)
  include $(CLEAR_VARS)
   
  # Build all java files in the java subdirectory
  LOCAL_SRC_FILES := $(call all-subdir-java-files)
   
  # Any libraries that this library depends on
  LOCAL_JAVA_LIBRARIES := android.test.runner
   
  # The name of the jar file to create
  LOCAL_MODULE := sample
   
  # Build a static jar file.
  include $(BUILD_STATIC_JAVA_LIBRARY)

(10)Android.mk的编译模块中间可以定义相关的编译内容，也就是指定相关的变量如下：
LOCAL_AAPT_FLAGS

LOCAL_ACP_UNAVAILABLE  

LOCAL_ADDITIONAL_JAVA_DIR 
 
LOCAL_AIDL_INCLUDES  

LOCAL_ALLOW_UNDEFINED_SYMBOLS  

LOCAL_ARM_MODE  

LOCAL_ASFLAGS  

LOCAL_ASSET_DIR  

LOCAL_ASSET_FILES 在Android.mk文件中编译应用程序(BUILD_PACKAGE)时设置此变量，表示资源文件，
                  通常会定义成LOCAL_ASSET_FILES += $(call find-subdir-assets)
 
LOCAL_BUILT_MODULE_STEM  
LOCAL_C_INCLUDES 额外的C/C++编译头文件路径，用LOCAL_PATH表示本文件所在目录
                 举例如下：
                 LOCAL_C_INCLUDES += extlibs/zlib-1.2.3
                 LOCAL_C_INCLUDES += $(LOCAL_PATH)/src 
 
LOCAL_CC 指定C编译器 

LOCAL_CERTIFICATE  签名认证

LOCAL_CFLAGS 为C/C++编译器定义额外的标志(如宏定义)，举例：LOCAL_CFLAGS += -DLIBUTILS_NATIVE=1
 
LOCAL_CLASSPATH  

LOCAL_COMPRESS_MODULE_SYMBOLS  

LOCAL_COPY_HEADERS install应用程序时需要复制的头文件，必须同时定义LOCAL_COPY_HEADERS_TO
 
LOCAL_COPY_HEADERS_TO install应用程序时复制头文件的目的路径

LOCAL_CPP_EXTENSION 如果你的C++文件不是以cpp为文件后缀，你可以通过LOCAL_CPP_EXTENSION指定C++文件后缀名 
                    如：LOCAL_CPP_EXTENSION := .cc
                    注意统一模块中C++文件后缀必须保持一致。

LOCAL_CPPFLAGS 传递额外的标志给C++编译器，如：LOCAL_CPPFLAGS += -ffriend-injection

LOCAL_CXX 指定C++编译器
 
LOCAL_DX_FLAGS

LOCAL_EXPORT_PACKAGE_RESOURCES

LOCAL_FORCE_STATIC_EXECUTABLE 如果编译的可执行程序要进行静态链接(执行时不依赖于任何动态库)，则设置LOCAL_FORCE_STATIC_EXECUTABLE:=true 
                              目前只有libc有静态库形式，这个只有文件系统中/sbin目录下的应用程序会用到，这个目录下的应用程序在运行时通常
                              文件系统的其它部分还没有加载，所以必须进行静态链接。
 
LOCAL_GENERATED_SOURCES
 
LOCAL_INSTRUMENTATION_FOR

LOCAL_INSTRUMENTATION_FOR_PACKAGE_NAME

LOCAL_INTERMEDIATE_SOURCES

LOCAL_INTERMEDIATE_TARGETS

LOCAL_IS_HOST_MODULE

LOCAL_JAR_MANIFEST

LOCAL_JARJAR_RULES

LOCAL_JAVA_LIBRARIES 编译java应用程序和库的时候指定包含的java类库，目前有core和framework两种
                     多数情况下定义成：LOCAL_JAVA_LIBRARIES := core framework
                     注意LOCAL_JAVA_LIBRARIES不是必须的，而且编译APK时不允许定义(系统会自动添加)
 
LOCAL_JAVA_RESOURCE_DIRS  

LOCAL_JAVA_RESOURCE_FILES  

LOCAL_JNI_SHARED_LIBRARIES  

LOCAL_LDFLAGS 传递额外的参数给连接器(务必注意参数的顺序)
 
LOCAL_LDLIBS 为可执行程序或者库的编译指定额外的库，指定库以"-lxxx"格式，举例：
             LOCAL_LDLIBS += -lcurses -lpthread
             LOCAL_LDLIBS += -Wl,-z,origin 
 
LOCAL_MODULE 生成的模块的名称(注意应用程序名称用LOCAL_PACKAGE_NAME而不是LOCAL_MODULE)

LOCAL_MODULE_PATH 生成模块的路径
 
LOCAL_MODULE_STEM 
 
LOCAL_MODULE_TAGS 生成模块的标记 
 
LOCAL_NO_DEFAULT_COMPILER_FLAGS  

LOCAL_NO_EMMA_COMPILE  

LOCAL_NO_EMMA_INSTRUMENT  

LOCAL_NO_STANDARD_LIBRARIES  

LOCAL_OVERRIDES_PACKAGES  

LOCAL_PACKAGE_NAME APK应用程序的名称  

LOCAL_POST_PROCESS_COMMAND
 
LOCAL_PREBUILT_EXECUTABLES 预编译including $(BUILD_PREBUILT)或者$(BUILD_HOST_PREBUILT)时所用,指定需要复制的可执行文件 

LOCAL_PREBUILT_JAVA_LIBRARIES  

LOCAL_PREBUILT_LIBS 预编译including $(BUILD_PREBUILT)或者$(BUILD_HOST_PREBUILT)时所用, 指定需要复制的库. 

LOCAL_PREBUILT_OBJ_FILES  

LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES  
 
LOCAL_PRELINK_MODULE 是否需要预连接处理(默认需要，用来做动态库优化)

LOCAL_REQUIRED_MODULES 指定模块运行所依赖的模块(模块安装时将会同步安装它所依赖的模块)
 
LOCAL_RESOURCE_DIR

LOCAL_SDK_VERSION

LOCAL_SHARED_LIBRARIES 可链接动态库
 
LOCAL_SRC_FILES 编译源文件

LOCAL_STATIC_JAVA_LIBRARIES

LOCAL_STATIC_LIBRARIES 可链接静态库 
 
LOCAL_UNINSTALLABLE_MODULE

LOCAL_UNSTRIPPED_PATH
 
LOCAL_WHOLE_STATIC_LIBRARIES 指定模块所需要载入的完整静态库(这些精通库在链接是不允许链接器删除其中无用的代码)
 
LOCAL_YACCFLAGS
 
OVERRIDE_BUILT_MODULE_PATH 

本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/jiajie961/archive/2010/11/09/5997147.aspx
```

## 按键移植

```
Android系统移植(二)-按键移植

这一部分主要是移植android的键盘和按键
(1)Android使用标准的linux输入事件设备(/dev/input目录下)和驱动，按键定义在内核include/linux/input.h文件中，
按键定义形式如下：
#define KEY_ESC            1
#define KEY_1            2
#define KEY_2            3

(2)内核中(我的平台是arch/arm/mach-mmp/merlin.c文件)中按键的定义如下形式：
static struct gpio_keys_button btn_button_table[] = {
    [0] = {
        .code            =    KEY_F1,
        .gpio            =    MFP_PIN_GPIO2,
        .active_low        =    1,        /* 0 for down 0, up 1; 1 for down 1, up 0 */
        .desc            =    "H_BTN button",
        .type            =    EV_KEY,
        /* .wakeup            = */
        .debounce_interval    =    10,        /* 10 msec jitter elimination */
    },
    [1] = {
        .code            =    KEY_F2,
        .gpio            =    MFP_PIN_GPIO3,
        .active_low        =    1,        /* 0 for down 0, up 1; 1 for down 1, up 0 */
        .desc            =    "O_BTN button",
        .type            =    EV_KEY,
        /* .wakeup            = */
        .debounce_interval    =    10,        /* 10 msec jitter elimination */
    },
    [2] = {
        .code            =    KEY_F4,
        .gpio            =    MFP_PIN_GPIO1,
        .active_low        =    1,        /* 0 for down 0, up 1; 1 for down 1, up 0 */
        .desc            =    "S_BTN button",
        .type            =    EV_KEY,
        /* .wakeup            = */
        .debounce_interval    =    10,        /* 10 msec jitter elimination */
    },
};
static struct gpio_keys_platform_data gpio_keys_data = {
    .buttons  = btn_button_table,
    .nbuttons = ARRAY_SIZE(btn_button_table),
};

static struct platform_device gpio_keys = {
    .name = "gpio-keys",
    .dev  = {
        .platform_data = &gpio_keys_data,
    },
    .id   = -1,
};
上面定义是将MFP_PIN_GPIO2这个GPIO口的按键映射到Linux的KEY_F1按键，MPF_PIN_GPIO3映射到KEY_F2，MFP_PIN_GPIO1映射到KEY_F4

(3)上面(2)步实现了从硬件GPIO口到内核标准按键的映射,但是android并没有直接使用映射后的键值，而且对其再进行了一次映射，从内核标准键值
到android所用键值的映射表定义在android文件系统的/system/usr/keylayout目录下。标准的映射文件为qwerty.kl，定义如下：
key 399   GRAVE
key 2     1
key 3     2
key 4     3
key 5     4
key 6     5
key 7     6
key 8     7
key 9     8
key 10    9
key 11    0
key 158   BACK              WAKE_DROPPED
key 230   SOFT_RIGHT        WAKE
key 60    SOFT_RIGHT        WAKE
key 107   ENDCALL           WAKE_DROPPED
key 62    ENDCALL           WAKE_DROPPED
key 229   MENU              WAKE_DROPPED
key 139   MENU              WAKE_DROPPED
key 59    MENU              WAKE_DROPPED
key 127   SEARCH            WAKE_DROPPED
key 217   SEARCH            WAKE_DROPPED
key 228   POUND
key 227   STAR
key 231   CALL              WAKE_DROPPED
key 61    CALL              WAKE_DROPPED
key 232   DPAD_CENTER       WAKE_DROPPED
key 108   DPAD_DOWN         WAKE_DROPPED
key 103   DPAD_UP           WAKE_DROPPED
key 102   HOME              WAKE
key 105   DPAD_LEFT         WAKE_DROPPED
key 106   DPAD_RIGHT        WAKE_DROPPED
key 115   VOLUME_UP
key 114   VOLUME_DOWN
key 116   POWER             WAKE
key 212   CAMERA

key 16    Q
key 17    W
key 18    E
key 19    R
key 20    T
key 21    Y
key 22    U
key 23    I
key 24    O
key 25    P
key 26    LEFT_BRACKET
key 27    RIGHT_BRACKET
key 43    BACKSLASH

key 30    A
key 31    S
key 32    D
key 33    F
key 34    G
key 35    H
key 36    J
key 37    K
key 38    L
key 39    SEMICOLON
key 40    APOSTROPHE
key 14    DEL
        
key 44    Z
key 45    X
key 46    C
key 47    V
key 48    B
key 49    N
key 50    M
key 51    COMMA
key 52    PERIOD
key 53    SLASH
key 28    ENTER
        
key 56    ALT_LEFT
key 100   ALT_RIGHT
key 42    SHIFT_LEFT
key 54    SHIFT_RIGHT
key 15    TAB
key 57    SPACE
key 150   EXPLORER
key 155   ENVELOPE        

key 12    MINUS
key 13    EQUALS
key 215   AT

(4)android对底层按键的处理方法
android按键的处理是Window Manager负责，主要的映射转换实现在android源代码frameworks/base/libs/ui/EventHub.cpp
此文件处理来自底层的所有输入事件，并根据来源对事件进行分类处理，对于按键事件，处理过程如下：
(a)记录驱动名称为
(b)获取环境变量ANDROID_ROOT为系统路径(默认是/system，定义在android源代码/system/core/rootdir/init.rc文件中)
(c)查找路径为"系统路径/usr/keylayout/驱动名称.kl"的按键映射文件，如果不存在则默认用路径为"系统路径/usr/keylayout/qwerty.kl"
这个默认的按键映射文件，映射完成后再把经映射得到的android按键码值发给上层应用程序。
所以我们可以在内核中定义多个按键设备，然后为每个设备设定不同的按键映射文件，不定义则会默认用qwerty.kl

(5)举例
上面(2)步我们在内核中声明了一个名为"gpio-keys"的按键设备，此设备定义在内核drivers/input/keyboard/gpio_keys.c文件中
然后我们在内核启动过程中注册此设备：  platform_device_register(&gpio_keys);
然后我们可以自己定义一个名为gpio-keys.kl的android按键映射文件，此文件的定义可以参考querty.kl的内容，比如说我们想将MPF_PIN_GPIO3
对应的按键作android中的MENU键用，首先我们在内核中将MPF_PIN_GPIO3映射到KEY_F2，在内核include/linux/input.h中查找KEY_F2发现
#define KEY_F2            60
参照KEY_F2的值我们在gpio-keys.kl中加入如下映射即可
key 60    MENU              WAKE
其它按键也照此添加，完成后将按键表放置到/system/usr/keylayout目录下即可。

补充：
(1)android按键设备的映射关系可以在logcat开机日志中找的到(查找EventHub即可)
(2)android按键设备由Window Manager负责，Window Manager从按键驱动读取内核按键码，然后将内核按键码转换成android按键码，转换完成
后Window Manager会将内核按键码和android按键码一起发给应用程序来使用，这一点一定要注意。
Android系统开发小知识-在android产品开发中添加新的编译模块

Android开发中用户内容定义在vendor目录下，而用户产品的内容都定义在vendor/<company_name>/<board_name>目录下
如果需要添加新的内容，可以在该目录下新建子目录，同时修改AndroidBoard.mk文件即可。比如说要添加一个按键映射文件：
(1)在vendor/<company_name>/<board_name>目录下建立一个keymaps子目录
(2)将我们需要的按键映射文件gpio-keys.kl和power-button.kl复制到keymaps目录下
(3)在keymaps目录下新建一个Mdroid.mk文件，内容如下：
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

file := $(TARGET_OUT_KEYLAYOUT)/gpio-keys.kl
ALL_PREBUILT += $(file)
$(file): $(LOCAL_PATH)/gpio-keys.kl | $(ACP)
    $(transform-prebuilt-to-target)

file := $(TARGET_OUT_KEYLAYOUT)/power-button.kl
ALL_PREBUILT += $(file)
$(file): $(LOCAL_PATH)/power-button.kl | $(ACP)
    $(transform-prebuilt-to-target)
(4)在vendor/<company_name>/<board_name>目录下的AndroidBoard.mk添加如下内容：
include $(LOCAL_PATH)/keymaps/Mdroid.mk
```

## 按键字符表

```
Android系统移植(三)-按键字符表
上节讲android的Window Manager将内核按键码通过按键映射表转换成android按键码，
这节讲的是android按键码向android字符的转换，转换也是通过Window Manager来完成的
(1)原始按键字符表，我们知道一个按键是可以显示多个字符的，决定显示字符的是CAPS(大小写),FN,NUNMBER等按键
举例如下：
[type=QWERTY]                                           
                                                        
# keycode       display number  base    caps    fn      caps_fn
                                                        
A               'A'     '2'     'a'     'A'     '#'     0x00
B               'B'     '2'     'b'     'B'     '<'     0x00
C               'C'     '2'     'c'     'C'     '9'     0x00E7
D               'D'     '3'     'd'     'D'     '5'     0x00
E               'E'     '3'     'e'     'E'     '2'     0x0301
F               'F'     '3'     'f'     'F'     '6'     0x00A5
G               'G'     '4'     'g'     'G'     '-'     '_'
H               'H'     '4'     'h'     'H'     '['     '{'
I               'I'     '4'     'i'     'I'     '$'     0x0302
J               'J'     '5'     'j'     'J'     ']'     '}'
K               'K'     '5'     'k'     'K'     '"'     '~'
L               'L'     '5'     'l'     'L'     '''     '`'
M               'M'     '6'     'm'     'M'     '!'     0x00
N               'N'     '6'     'n'     'N'     '>'     0x0303
O               'O'     '6'     'o'     'O'     '('     0x00
P               'P'     '7'     'p'     'P'     ')'     0x00
Q               'Q'     '7'     'q'     'Q'     '*'     0x0300
R               'R'     '7'     'r'     'R'     '3'     0x20AC
S               'S'     '7'     's'     'S'     '4'     0x00DF
T               'T'     '8'     't'     'T'     '+'     0x00A3
U               'U'     '8'     'u'     'U'     '&'     0x0308
V               'V'     '8'     'v'     'V'     '='     '^'
W               'W'     '9'     'w'     'W'     '1'     0x00
X               'X'     '9'     'x'     'X'     '8'     0xEF00
Y               'Y'     '9'     'y'     'Y'     '%'     0x00A1
Z               'Z'     '9'     'z'     'Z'     '7'     0x00
                                                        
# on pc keyboards
COMMA           ','     ','     ','     ';'     ';'     '|'
PERIOD          '.'     '.'     '.'     ':'     ':'     0x2026
AT              '@'     '0'     '@'     '0'     '0'     0x2022
SLASH           '/'     '/'     '/'     '?'     '?'     '\'
                                                        
SPACE           0x20    0x20    0x20    0x20    0xEF01  0xEF01
ENTER         0xa     0xa     0xa     0xa     0xa     0xa
                                                        
TAB             0x9     0x9     0x9     0x9     0x9     0x9
0               '0'     '0'     '0'     ')'     ')'     ')'
1               '1'     '1'     '1'     '!'     '!'     '!'
2               '2'     '2'     '2'     '@'     '@'     '@'
3               '3'     '3'     '3'     '#'     '#'     '#'
4               '4'     '4'     '4'     '$'     '$'     '$'
5               '5'     '5'     '5'     '%'     '%'     '%'
6               '6'     '6'     '6'     '^'     '^'     '^'
7               '7'     '7'     '7'     '&'     '&'     '&'
8               '8'     '8'     '8'     '*'     '*'     '*'
9               '9'     '9'     '9'     '('     '('     '('
                                                        
GRAVE           '`'     '`'     '`'     '~'     '`'     '~'
MINUS           '-'     '-'     '-'     '_'     '-'     '_'
EQUALS          '='     '='     '='     '+'     '='     '+'
LEFT_BRACKET    '['     '['     '['     '{'     '['     '{'
RIGHT_BRACKET   ']'     ']'     ']'     '}'     ']'     '}'
BACKSLASH       '\'     '\'     '\'     '|'     '\'     '|'
SEMICOLON       ';'     ';'     ';'     ':'     ';'     ':'
APOSTROPHE      '''     '''     '''     '"'     '''     '"'
STAR            '*'     '*'     '*'     '*'     '*'     '*'
POUND           '#'     '#'     '#'     '#'     '#'     '#'
PLUS            '+'     '+'     '+'     '+'     '+'     '+'

(2)android为了减少载入时间，并没有使用原始按键表文件，而是将其转换成二进制文件
转换的工具源代码在android源代码build/tools/kcm目录下，android在编译过程中会
首先编译转换工具，然后利用转换工具将android源代码sdk/emulator/keymaps目录下
的qwerty.kcm和qwerty2.kcm文件分别转换成qwerty.kcm.bin和qwerty2.kcm.bin
转换后的二进制文件复制到out/target/product/<board_name>/system/usr/keychars
目录下，也就是目标平台的/system/usr/keychars目录中。

(3)Window Manager对按键的处理在android源代码frameworks/base/libs/ui/EventHub.cpp文件中
Window Manager从内核接收到一个按键输入事件后会首先调用按键映射表将内核按键码映射成android按键码(这部分上节已讲)，然后会
将android按键码转换成字符，具体过程如下：
(a)设置系统系统属性hw.keyboards.设备号.devname的值为设备名
以上节的gpio-keys设备为例，会设置系统属性hw.keyboards.65539.devname的值为gpio-keys
(b)载入按键字符表，首先载入/system/usr/keychars目录下的设备名.kcm.bin文件(此例即gpio-keys.kcm.bin文件)，如果载入失败
则载入该目录下的querty.kcm.bin.
(c)利用载入的按键字符表将android按键转换成按键字符发给上层应用程序。

(4)一般情况下一个控制按键是不需要作按键字符表的，系统会调用默认的去处理，但是如果要开发一个全功能键盘(包含了字母和数字)，那可能就需要
自己作一个专用的按键字符表了。
android系统开发小问题－启动过程中android字符没有显示出来

android目标平台可以正常启动，但是启动过程中的android字符没有显示出来，这个是linux内核配置的问题
打开内核framebuffer控制台即可。
(1)make menuconifg后选择Device Drivers->Graphics support->Console display driver support->Framebuffer Console support
然后打开相关的几个配置选项即可。
(2)直接修改内核配置文件，如下：
CONFIG_FRAMEBUFFER_CONSOLE=y
CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
CONFIG_FONTS=y
CONFIG_FONT_8x8=y
CONFIG_FONT_8x16=y
CONFIG_FONT_6x11=y
# CONFIG_FONT_7x14 is not set
# CONFIG_FONT_PEARL_8x8 is not set
# CONFIG_FONT_ACORN_8x8 is not set
# CONFIG_FONT_MINI_4x6 is not set
# CONFIG_FONT_SUN8x16 is not set
# CONFIG_FONT_SUN12x22 is not set
# CONFIG_FONT_10x18 is not set
(3)android启动过程中的android字符显示在源代码的system/core/init.c中，如下：
if( load_565rle_image(INIT_IMAGE_FILE) ) {
    fd = open("/dev/tty0", O_WRONLY);
    if (fd >= 0) {
        const char *msg;
            msg = "\n"
        "\n"
        "\n"
        "\n"
        "\n"
        "\n"
        "\n"  // console is 40 cols x 30 lines
        "\n"
        "\n"
        "\n"
        "\n"
        "\n"
        "\n"
        "\n"
        "             A N D R O I D ";
        write(fd, msg, strlen(msg));
        close(fd);
    }
}
```

## android启动过程配置文件的解析与语法

```
(1)android启动文件系统后调用的第一个应用程序是/init，此文件的很重要的内容是解析了init.rc和init.xxx.rc
两个配置文件，然后执行解析出来的任务。相关代码在android源代码/system/core/init/init.c文件中，如下：
    parse_config_file("/init.rc");

    /* pull the kernel commandline and ramdisk properties file in */
    qemu_init();
    import_kernel_cmdline(0);

    get_hardware_name();
    snprintf(tmp, sizeof(tmp), "/init.%s.rc", hardware);
    parse_config_file(tmp);

(2)从上面代码可以看到，第一个配置文件名称固定为init.rc,而第二个配置文件格式为init.xxx.rc，其中xxx部分的内容
是从内核读取的，具体是读取文件/proc/cpuinfo中的Hardware部分，然后截取其部分内容。Hardware部分是定义在内核的
主板定义文件中，我的平台是定义在内核arch/arm/mach-mmp/merlin.c中，我的平台定义如下：
MACHINE_START(ARDENT_MERLIN, "PXA168-based Merlin Platform")
    .phys_io = APB_PHYS_BASE,
    .boot_params = 0x00000100,
    .io_pg_offst = (APB_VIRT_BASE >> 18) & 0xfffc,
    .map_io = pxa_map_io,
    .init_irq = pxa168_init_irq,
    .timer = &pxa168_timer,
    .init_machine = merlin_init,
MACHINE_END
这样截取到的hardware部分的内容就为pxa168-based，也就是说我的平台的第二个配置文件应该命名为init.pxa168-based.rc

(3)从上面看init.xxx.rc中的xxx内容是取决是内核中主板的定义的，如果觉得麻烦，可以将其在代码中写死，例如：
    parse_config_file(“init.merlin.rc”);

(4)配置文件的语法如下：
(a)配置文件的内容包含有4种：
     动作(Action)
     命令(Commands)
     服务(Services)
     选项(Options)
(b)动作和命令一起使用，形式如下：
on <trigger>
  <command>
  <command>
  <command>
其中trigger是触发条件，也就是说在满足触发条件的情况下执行1个或多个相应的命令，举例如下：
on property:persist.service.adb.enable=1
    start adbd

(c)服务和选项一起使用，形式如下：
  service <name> <pathname> [ <argument> ]*
  <option>
  <option>
  ...
上面内容解释为：
  service 服务名称 服务对应的命令的路径 命令的参数
    选项
    选项
  ...
举例如下：
service ril-daemon /system/bin/rild
    socket rild stream 660 root radio
    socket rild-debug stream 660 radio system
    user root
    group radio cache inet misc audio
上面的服务对应到/system/bin/rild命令，没有参数，服务名称为ril-daemon,后面的内容都是服务的选项。

(d)选项是影响服务启动和运行的参数，主要的选项如下：

disabled  禁用服务，此服务开机时不会自动启动，但是可以在应用程序中手动启动它。

socket <type> <name> <perm> [ <user> [ <group> ] ]
套接字    类型        名称           权限           用户           组
创建一个名为/dev/socket/<name>，然后把它的fd传给启动程序
类型type的值为dgram或者stream
perm表示该套接字的访问权限,user和group表示改套接字所属的用户和组，这两个参数默认都是0，因此可以不设置。

user <username>
执行服务前切换到用户<username>，此选项默认是root，因此可以不设置。

group <groupname> [ <groupname> ]*
执行服务前切换到组<groupname>,此选项默认是root,因此可以不设置

capability [ <capability> ]+
执行服务前设置linux capability，没什么用。

oneshot
服务只启动一次，一旦关闭就不能再启动。

class <name>
为服务指定一个类别，默认为"default"，同一类别的服务必须一起启动和停止

(e)动作触发条件<trigger>
boot  首个触发条件，初始化开始(载入配置文件)的时候触发

<name>=<value>
当名为<name>的属性(property)的值为<value>的时候触发

device-added-<path>
路径为<path>的设置添加的时候触发

device-removed-<path>
路径为<path>的设置移除的时候触发

service-exited-<name>
名为<name>的服务关闭的时候触发

(f)命令(Command)的形式
exec <path> [ <argument> ]*
复制(fork)和执行路径为<path>的应用程序，<argument>为该应用程序的参数，在该应用程序执行完前，此命令会屏蔽，

export <name> <value>
声明名为<name>的环境变量的值为<value>，声明的环境变量是系统环境变量，启动后一直有效。

ifup <interface>
启动名为<interface>的网络接口

import <filename>
加入新的位置文件，扩展当前的配置。

hostname <name>
设置主机名

class_start <serviceclass>
启动指定类别的所有服务

class_stop <serviceclass>
停止指定类别的所有服务

domainname <name>
设置域名

insmod <path>
加载路径为<path>的内核模块

mkdir <path>
创建路径为<path>目录

mount <type> <device> <dir> [ <mountoption> ]*
挂载类型为<type>的设备<device>到目录<dir>,<mountoption>为挂载参数，距离如下：
    mount ubifs ubi1_0 /data nosuid nodev

setkey
暂时未定义

setprop <name> <value>
设置名为<name>的系统属性的值为<value>

setrlimit <resource> <cur> <max>
设置资源限制，举例：
# set RLIMIT_NICE to allow priorities from 19 to -20
    setrlimit 13 40 40
没看懂是什么意思。

start <service>
启动服务(如果服务未运行)

stop <service>
停止服务(如果服务正在运行)

symlink <target> <path>
创建一个从<path>指向<target>的符号链接，举例：
    symlink /system/etc /etc

write <path> <string> [ <string> ]*
打开路径为<path>的文件并将一个多这多个字符串写入到该文件中。

(g)系统属性(Property)
android初始化过程中会修改一些属性，通过getprop命令我们可以看到属性值，这些属性指示了某些动作或者服务的状态，主要如下：
init.action      如果当前某个动作正在执行则init.action属性的值等于该动作的名称，否则为""
init.command     如果当前某个命令正在执行则init.command属性的值等于该命令的名称，否则为""
init.svc.<name>  此属性指示个名为<name>的服务的状态("stopped", "running", 或者 "restarting").
```

## 背光灯模块

```
android系统开发(七)-背光模块
1,总论
背光模块属于HAL层开发，HAL层开发，用一句话来概括就是定义一个hardware.h中定义的名称为宏HAL_MODULE_INFO_SYM的hw_module_t结构体，
然后实现结构体的相关内容

2,驱动方面的准备
简单的嵌入式linux驱动，编写LCD背光驱动，并提供接口给上层修改，我所用的是直接修改接口文件，接口如下：
/sys/class/backlight/pwm-backlight/brightness  这个是亮度调节
/sys/class/backlight/pwm-backlight/max_brightness 这个是最大亮度，按照android系统的要求应该设置成255
控制亮度直接写brightness文件即可
背光驱动主要是通过PWM来完成，这里不详细说明。

3,需要包含的头文件
/hardware/libhardware/include/hardware目录下的hardware.h和lights.h
其中hardware.h中定义了通用硬件模块，lights.h中定义了背光设备相关的内容

4,android已有的硬件模块在/hardware/libhardware/modules目录下，为了区分，我们开发的背光模块放置在如下的目录：
vendor/ardent/merlin/lights目录下，编译成lights.default.so放置到/system/lib/hw目录下，模块命名规则可以
参考上一节的内容。

5,修改vendor/ardent/merlin目录下AndroidBoard.mk文件，添加如下内容：
include $(LOCAL_PATH)/lights/Mdroid.mk

6,lights目录新建Mdroid.mk文件，内容如下：
LOCAL_PATH:= $(call my-dir)
include $(CLEAR_VARS)

LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/hw
LOCAL_SRC_FILES:= lights.c

LOCAL_SHARED_LIBRARIES := \
    libutils \
    libcutils \
    libhardware

LOCAL_PRELINK_MODULE := false

LOCAL_MODULE := lights.default

include $(BUILD_SHARED_LIBRARY)

7,lights目录下新建一个lights.c文件，如下：
const struct hw_module_t HAL_MODULE_INFO_SYM = {
    .tag = HARDWARE_MODULE_TAG,
    .version_major = 1,
    .version_minor = 0,
    .id = LIGHTS_HARDWARE_MODULE_ID,
    .name = "lights module",
    .author = "allen",
    .methods = NULL,
};

8，上面的内容可以直接编译通过，但是因为我将其methods部分指向了空指针，因此没有任何功能，下面来实现此部分
hw_module_t机构体的methods成员是一个指向hw_module_methods_t结构体的一个指针，hw_module_methods_t结构体定义如下：
typedef struct hw_module_methods_t {
    int (*open)(const struct hw_module_t* module, const char* id,struct hw_device_t** device);
} hw_module_methods_t;
据此我们定义一个hw_module_methods_t类型的参数lights_module_methods如下：
struct hw_module_methods_t lights_module_methods = {
    .open = lights_device_open
};
然后将上面的methods由NULL改成lights_module_methods

9,接下来就是定义lights_device_open函数了，此函数的参数和返回值由hw_module_methods_t结构体的open成员决定，此函数定义如下：
static int lights_device_open(const struct hw_module_t *module,const char *id, struct hw_device_t **device)
从lights_device_open函数的参数来看，第一个参数和第二个参数是常量，第三个参数是 一个指向hw_device_t结构体的指针，因此可以断定
实现此函数也就是要完成第三个参数的内容，详细的内容我们可以参考直接调用该函数的内容，在frameworks/base/services/jni目录下的
com_android_server_LightsService.cpp文件中，内容如下：
static light_device_t* get_device(hw_module_t* module, char const* name)
{
    int err;
    hw_device_t* device;
    err = module->methods->open(module, name, &device);
    if (err == 0) {
        return (light_device_t*)device;//device由hw_device_t指针强制转换成light_device_t指针
    } else {
        return NULL;
    }
}

static jint init_native(JNIEnv *env, jobject clazz)
{
    int err;
    hw_module_t* module;
    Devices* devices;
    
    devices = (Devices*)malloc(sizeof(Devices));

    err = hw_get_module(LIGHTS_HARDWARE_MODULE_ID, (hw_module_t const**)&module);
    if (err == 0) {
        devices->lights[LIGHT_INDEX_BACKLIGHT]
                = get_device(module, LIGHT_ID_BACKLIGHT);
        devices->lights[LIGHT_INDEX_KEYBOARD]
                = get_device(module, LIGHT_ID_KEYBOARD);
        devices->lights[LIGHT_INDEX_BUTTONS]
                = get_device(module, LIGHT_ID_BUTTONS);
        devices->lights[LIGHT_INDEX_BATTERY]
                = get_device(module, LIGHT_ID_BATTERY);
        devices->lights[LIGHT_INDEX_NOTIFICATIONS]
                = get_device(module, LIGHT_ID_NOTIFICATIONS);
        devices->lights[LIGHT_INDEX_ATTENTION]
                = get_device(module, LIGHT_ID_ATTENTION);
        devices->lights[LIGHT_INDEX_BLUETOOTH]
                = get_device(module, LIGHT_ID_BLUETOOTH);
        devices->lights[LIGHT_INDEX_WIFI]
                = get_device(module, LIGHT_ID_WIFI);
    } else {
        memset(devices, 0, sizeof(Devices));
    }

    return (jint)devices;
}
从上面的内容我们可以看出lights_device_open的第一个参数是JNI层用hw_get_module所获得，第二个参数根据设备的不同有很多种情况
该参数的内容定义在lights.h中，全部情况如下：
#define LIGHT_ID_BACKLIGHT          "backlight"
#define LIGHT_ID_KEYBOARD           "keyboard"
#define LIGHT_ID_BUTTONS            "buttons"
#define LIGHT_ID_BATTERY            "battery"
#define LIGHT_ID_NOTIFICATIONS      "notifications"
#define LIGHT_ID_ATTENTION          "attention"
#define LIGHT_ID_BLUETOOTH          "bluetooth"
#define LIGHT_ID_WIFI               "wifi"
lights调节有背光，键盘，按键，电池，通知，提醒，蓝牙和WIF
第三个参数是一个指向一个hw_device_t的指针，但是com_android_server_LightsService.cpp文件中的背光调节函数定义如下：
static void setLight_native(JNIEnv *env, jobject clazz, int ptr, int light, int colorARGB, int flashMode, int onMS, int offMS, int brightnessMode) {
    Devices* devices = (Devices*)ptr;
    light_state_t state;

    if (light < 0 || light >= LIGHT_COUNT || devices->lights[light] == NULL) {
        return ;
    }

    memset(&state, 0, sizeof(light_state_t));
    state.color = colorARGB;
    state.flashMode = flashMode;
    state.flashOnMS = onMS;
    state.flashOffMS = offMS;
    state.brightnessMode = brightnessMode;

    devices->lights[light]->set_light(devices->lights[light], &state);
}
get_device函数中将hw_device_t指针强制转换成light_device_t指针给调节背光用，而light_device_t定义如下：
struct light_device_t {
    struct hw_device_t common;
    int (*set_light)(struct light_device_t* dev,
            struct light_state_t const* state);
};
因此在实现lights_device_open的第三个参数的时候，我们应该定义一个light_device_t类型结构体，然后
将起common域的指针地址传递过去。这样虽然传递的是一个hw_device_t指针地址，但是JNI层可以将其强制转换
成light_device_t指针地址用，否则devices->lights[light]->set_light就会起不到作用了。实现如下：
static int lights_device_open(const struct hw_module_t *module,const char *id, struct hw_device_t **device)
{
    struct light_device_t *dev = NULL;
    int resvalue = -1;
    dev = calloc(sizeof(struct light_device_t),1);
    dev->common.tag = HARDWARE_DEVICE_TAG;
    dev->common.version = 0;
    dev->common.module = (struct hw_module_t *)module;
    dev->common.close = lights_device_close;
    if(!strcmp(id, LIGHT_ID_BACKLIGHT))
    {
        dev->set_light = lcd_set_light;
        resvalue = 0;
    }
    else
    {
        dev->set_light = other_set_light;
        resvalue = 0;
    }
    *device = &dev->common;
    return resvalue;
}

10，实现lights_device_close，lcd_set_light和other_set_light，这个主要是调用驱动提供的接口直接控制硬件，举例如下：
static int lights_device_close(struct hw_device_t* device)
{
    struct light_device_t *m_device = (struct light_device_t *)device;
    if(m_device)
        free(m_device);
    return 0;
}
static int lcd_set_light(struct light_device_t* dev,struct light_state_t const* state)
{
    int fd = -1;
    int bytes = 0;
    int rlt = -1;
    unsigned char brightness = ((77*((state->color>>16)&0x00ff))
                               + (150*((state->color>>8)&0x00ff)) 
                               + (29*(state->color&0x00ff))) >> 8;
    fd = open("/sys/class/backlight/pwm-backlight/brightness", O_RDWR);
    if(fd>0)
    {
        char buffer[20];
     memset(buffer, 0, 20);
    bytes = sprintf(buffer, "%d", brightness);
    rlt = write(fd, buffer, bytes);
        if(rlt>0)
        {
           close(fd);
           return 0;
        }
    }
    close(fd);
    return -1;
}

static int other_set_light(struct light_device_t* dev,struct light_state_t const* state)
{
    return 0;
}

11，因为上面调节背光是通过写/sys/class/backlight/pwm-backlight/brightness文件来完成，因此一定要设置该文件的权限，
在init.xxx.rc文件中添加如下的内容：
    # for control LCD backlight
    chown system system /sys/class/backlight/pwm-backlight/brightness
    chmod 0666 /sys/class/backlight/pwm-backlight/brightness

12，修改完成后经验证亮度调节可用，上面的例子只是实现了lights部分功能，如果需要完成所有的功能，请参考hardware.h, lights.h和com_android_server_LightsService.cpp文件中的内容。


本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/jiajie961/archive/2010/11/23/6030405.aspx
```

## android系统开发(八)-SDCARD

```
关于android系统开发sdcard移植，主要有如下工作：
1，内核驱动开发，完成后每次插入和拔出sdcard系统都会有相关的信息显示，而且sdcard可以手动挂载。

2，android的sdcard挂载主要是vold来完成，vold的源代码在/system/vold目录下，编译成/system/bin/vold
init.rc文件中有vold系统服务，确保android系统开机后vold有正常运行。

3，添加vold的配置文件，先查看/system/bin/vold/main.cpp文件中的process_config函数，发现配置文件路径如下：
/etc/vold.fstab
android2.2下/etc目录指向了/system/etc目录，因此我们要新建一个vold.fstab文件，目标路径为/system/etc/vold.fstab

4,vold.fstab文件的写法，参考/system/core/rootdir/etc目录下的vold.fstab,里面有详细的说明和例子，写法如下：
dev_mount       <label>     <mount_point>     <part>       <sysfs_path1...>
dev_mount命令        标签                挂载点                            子分区               设备在sysfs文件系统下的路径(可多个)
按照上面的要求和我的平台的实际情况，在vold.fstab中添加如下内容：
dev_mount sdcard /mnt/sdcard auto         /block/mmcblk0
上面的/block/mmcblk0表示sysfs下的路径，由于linux的sysfs文件系统是在sys目录下，所以对应到/sys/block/mmcblk0目录

5，完成后发现android系统中sdcard可用了，总结下载，sdcard部分很简单，主要是找到sdcard设备对应的sysfs文件系统路径


本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/jiajie961/archive/2010/11/25/6035369.aspx
```

## android系统开发小知识-启动脚本文件内部的执行顺序

```
我们知道android在启动的时候通过init进程来解析init.rc和init.xxx.rc文件，
然后执行这两个文件解析出来的内容，init.rc和init.xxx.rc文件中的内容却并不是
按照顺序来执行的，而是有固定的执行顺序，首先，init.rc和init.xxx.rc文件中的内容
全部会放在4个关键字下：
early-init, init, early-boot, boot
所以一个典型的rc文件的写法如下：
on early-init
--------------

on init
--------------

on early-boot
--------------

on boot
--------------
rc文件中这4个部分是可以打乱顺序随便写的，甚至可以有多个部分出现，但是解析完了以后的执行
顺序确实固定的，执行顺序如下：
early-init -> init -> early-boot -> boot

本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/jiajie961/archive/2010/12/01/6047219.aspx
```

## ANR 问题一般解决思路

```
https://mp.weixin.qq.com/s/kT0hZaYRlW9X8fIVEQKJLQ

https://blog.csdn.net/kongbaidepao/article/details/83088650
```

## Android系统增加字体库及修改系统默认字体

```
https://blog.csdn.net/hsaekong/article/details/80305263

一、Android系统增加字体库

1.把字体cordiau.ttf文件copy到frameworks\base\data\fonts目录
2.修改frameworks\base\data\fonts\Android.mk文件,如下图:
3.修改frameworks\base\data\fonts\fonts.mk文件,如下图
4.在frameworks/base/data/fonts目录下单编,执行mm
5.编译成功后,把文件push到system/fonts

二、修改系统默认字体
1、  修改frameworks/base/data/fonts/system_fonts.xml文件，如下图：

然后push到system/etc，重启后，系统默认字体替换为cordiau.ttf了
```

## Android 原生拼音输入法分析

```
当一个可编辑的文本框获得焦点时，系统就会启动当前输入法，首先调用当前输入法的onCreate()函数。

Android系统的输入法通常都派生自基类android.inputmethodservice.InputMethodService，基类InputMethodService定义了Android输入法的公共API集合，其中onCreate就是其中的一个API函数。各个具体的输入法实现根据需要重载实现这些API的全部或者一部分。

Android SDK提供了一个最简单的输入法示例，SoftKeyboard ，这个示例可以在SDK安装目录下samples/plaform-X下找到（其中X为SDK的API level数，如cupcake为3，donut为4，froyo为8）。SoftKeyboard 的onCreate()函数代码如下：
    public void onCreate() {
        super.onCreate();
        mWordSeparators = getResources().getString(R.string.word_separators);
    }
除了简单调用父类的同名函数外，从资源文件中读出单词分隔符的串并保存在成员变量里。每个输入法在被创建时要进行的初始化不尽相同。如Android源代码树在packags/inputmethods子目录下还有其它具体的输入法实例。（参考文档http://android.git.kernel.org/?p=platform/packages/inputmethods/LatinIME.git;a=tree）可以把Android源码取到本地计算机，还可以在线浏览另一个输入法实例LatinIME的onCreate()函数，它要做的工作就复杂得多：创建键盘，读取系统信息，注册系统铃声变化的监听器等等。

回来PinyinIME（也在Android源码的packags/inputmethods下）的onCreate()函数，省略掉与LatinIME类似的代码。
    @Override
    public void onCreate() {
        ...
        startPinyinDecoderService();
        ...
    }
函数startPinyinDecoderService（）检测PinyinDecoderService服务如果未运行，则通过系统函数bindService（）来启动它。bindService的第2个参数对象有2个成员函数会在PinyinDecoderService服务启动过程中被调用：
onServiceConnected()    -- PinyinDecoderService建立，PinyinDecoderService.onBind()返回的binder对象作为函数的第2个参数传入。
onServiceDisconnected() -- PinyinDecoderService结束。

关于bindService()的第2个参数以及其在进程间调用的作用可参见http://developer.android.com/guide/developing/tools/aidl.html，在PinyinIME中，它是ServiceConnection接口的一个实现，onServiceDisconnected（）什么都不用做，onServiceConnected()在PinyinDecoderService建立时被调用，远程service进程的binder对象作为函数的第2个参数传入。输入法作为客户端进程，需要借助以下辅助函数把传入的binder对象转化成可用的接口：
IPinyinDecoderService.Stub.asInterface（）
PinyinIME输入法把转化后的接口对象保存在类DecodingInfo对象mDecInfo的mIPinyinDecoderService成员，以供其后的调用：
    public class PinyinDecoderServiceConnection implements ServiceConnection {
        public void onServiceConnected(ComponentName name, IBinder service) {
            mDecInfo.mIPinyinDecoderService = IPinyinDecoderService.Stub
                    .asInterface(service);
        }
        ....
    }

mDecInfo.mIPinyinDecoderService的声明如下：
    public class DecodingInfo {
        ......
        
        private IPinyinDecoderService mIPinyinDecoderService;
        ......
    }

现在再来看在输入法（客户端进程）调用bindService时，服务端进程启动的详细过程：
因为第1个参数Intent对象的类名在调用前被设成PinyinDecoderService.class，所以系统进程响应bindService时，如果服务未运行时首先调用PinyinDecoderService的onCreate()
    @Override
    public void onCreate() {
        super.onCreate();
        mUsr_dict_file = getFileStreamPath("usr_dict.dat").getPath();
        ......
        initPinyinEngine();
    }
接下来调用PinyinDecoderService的onBind()函数，并把返回的binder对象传给前面说过的ServiceConnection.onServiceConnected():
    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

辅助的初始化函数initPinyinEngine（）首先打算系统静态字典资源文件res/raw/dict_pinyin.dat，然后把用户字典名写到一个byte数组里，最后把静态字典文件信息与用户字典名作为参数，调用本地c/c++函数nativeImOpenDecoderFd（）。

onBind函数返回的binder对象，就是
private final IPinyinDecoderService.Stub mBinder = new IPinyinDecoderService.Stub() {
    ....
};

当PinyinDecoderService创建时，初始化工作包括了收集系统静态字典文件信息以及用户字典路径信息，然后调用C++代码接口nativeImOpenDecoderFd完成底层服务的启动（另一个C++代码接口nativeImOpenDecoder也完成同样的功能，除了传递不同的参数）。

下图是C++函数nativeImOpenDecoderFd的原形如下：
JNIEXPORT jboolean JNICALL nativeImOpenDecoderFd(JNIEnv* env, jclass jclazz,
                                                 jobject fd_sys_dict,
                                                 jlong startoffset,
                                                 jlong length,
```

## MTK 芯片命名规则

```
MT6795M
第一个数字6:表示芯片用途，6为手机，8为平板
第二个数字7:标示指令集类型，5为32位，7为64位
第三个数字9:芯片定位，9为旗舰，5为中端，3为入门
第四个数字5:芯片世代，数字越大发布越晚，性能越强
最后一个字母M:细分版本，T为高端增强版，没有字母为标准版，M为降频低配版

https://blog.csdn.net/zhangbijun1230/article/details/79440291
```

## 代码区分高通和MTK平台

```
public static boolean isHardWareVendorQualcomm() {
    String hardware = android.os.Build.HARDWARE;
    if (hardware.matches("qcom")) {
        Log.d(TAG, "Qualcomm platform");
        return true;
    }
    return false;
}

public static boolean isHardWareVendorMediaTek() {
    String hardware = android.os.Build.HARDWARE;
    if (hardware.matches("mt[0-9]*")) {
        Log.d(TAG, "MediaTek platform");
        return true;
    }
    return false;
}
```

## LK

```
LK全称little Kernel,其主要功能为：
A.          硬件初始化，包括建立vector table,MMU,cache,初始化peripherals,storage,USB,crypto等等;
B.          加载boot.img；
C.          支持烧写和进入recovery
```

## Fastboot

```
fastboot协议是一种通过USB连接与bootloaders通讯的机制。它被设计的非常容易实现，能够用于多种设备和运行Linux、Windows或者OSX的主机;
```

## 安卓bootloader：三分钟让你彻底理解uboot的启动与功能

```
https://blog.csdn.net/kai_zone/article/details/80443820

1.  Bootloader简介
系统上电后，需要一段程序来进行初始化：关闭看门狗，改变系统时钟，初始化存储控制器，将更多的代码复制到内存中等。它就是bootloader。

bootloader的实现非常依赖具体硬件，在嵌入式系统中，硬件配置千差万别，即使是相同的CPU，它的外设（比如flash）也可能不同，所以不可能有一个bootloader支持所有的CPU,所有的电路板。即使是支持CPU架构比较多的UBoot，也不是一拿来就可以使用（除非里面的配置刚好和你的板子相同）。需要进行一些配置。

CPU上电后，会从某个地址开始执行，比如MIPS结构的CPU会从0xBFC00000取第一条指令，而ARM结构的CPU则会从0x00000000开始，嵌入式开发板中，需要把存储器件的ROM或Flash等映射到这个地址，Bootloader就存放在这个地址的开始处，一上电就开始执行。（手机中的RAM和ROM分别对应电脑的内存和硬盘）

2.  启动流程。
u-boot系统启动流程 大多数bootloader都分为stage1和stage2两部分，u-boot也不例外。

依赖于CPU体系结构的代码（如设备初始化代码等）通常都放在stage1且可以用汇编语言来实现，而stage2则通常用C语言来实现，这样可以实现复杂的功能，而且有更好的可读性和移植性。

1.Stage1 start.S代码结构 u-boot的stage1代码通常放在start.S文件中，他用汇编语言写成，其主要代码部分如下

（1） 定义入口。： 该工作通过修改连接器脚本来完成。

（2）设置异常向量（Exception Vector）。 

（3）设置CPU的速度、时钟频率及终端控制寄存器。 

（4）初始化内存控制器。 

（5）将ROM中的程序复制到RAM中。 

（6） 关中断，关看门狗

（7）初始化堆栈，清bss段，为第二阶段准备。

（8）转到RAM中执行，该工作可使用指令ldr pc来完成。
```

## Makefile Android.mk Ninja Soong Blueprint kati Android.bp

```
https://blog.csdn.net/itachi85/article/details/89038370

1.编译系统概述
了解以下一些概念，会对Android编译系统有大概的了解。
Makefile
Android平台的编译系统，其实就是用Makefile写出来的一个独立项目。它定义了编译的规则，实现了“自动化编译”，不仅把分散在数百个Git库中的代码整合起来、统一编译， 而且还把产物分门别类地输出到一个目录，打包成手机ROM，还可以生成应用开发时所使用的SDK、NDK等。
因此，采用Makefile编写的编译系统，也可以称为Makefile编译系统。
Android.mk
Makefile编译系统的一部分，定义了一个模块的必要参数，使模块随着平台编译。通俗来讲就是告诉编译系统，以什么样的规则编译你的源代码，并生成对应的目标文件。

Ninja
Ninja是一个致力于速度的小型编译系统，如果把其他的编译系统看作高级语言，那么Ninja 目标就是汇编。

Soong
Soong是谷歌用来替代此前的Makefile编译系统的替代品，负责解析Android.bp文件，并将之转换为Ninja文件

Blueprint
Blueprint用来解析Android.bp文件翻译成Ninja语法文件。

kati
kati是谷歌专门为了Android而开发的一个小项目，基于Golang和C++。 目的是把Android中的Makefile，转换成Ninja文件。

Android.bp
Android.bp，是用来替换Android.mk的配置文件。

Blueprint负责解析Android.bp文件内容，Blueprint类似一个处理相关语法的库文件，Soong则是定义具体如何处理相应的语法以及命令实现。通俗来讲就是Soong借助于Blueprint定义的Android.bp语法，完成Android.bp的解析，最终转换成Ninja文件。
Makefile文件会通过kati转换为Ninja文件。
随着Android工程越来越大，采用Makefile的编译系统花费的时间也越来越长，因此谷歌在Android 7.0开始引入了Ninja来编译系统，相对于Makefile来说Ninja在大的项目管理中速度和并行方面有突出的优势。
Makefile默认文件名为Makefile或makefile，也常用.make或.mk作为文件后缀。 Ninja的默认文件名是build.ninja，其它文件以.ninja为后缀。Makefile与Ninja的区别在于, Makefile是设计来给开发编写的，而Ninja设计出来是给其它程序生成的。如果Makefile是Java语言，那么Ninja就是汇编语言。

2.编译源码的方式
Androd系统源码编译有很多种方式，主要有以下几种：

在Linux中直接进行系统源码编译（Android官方支持）
在Mac OS中直接进行系统源码编译（Android官方支持）
使用Docker编译，支持Mac OS和Windows
其中需要注意的是，Docker的最低支持版本为Windows7，建议用Windows10环境下使用Docker，因为在Windows7种还需要借助Docker Toolbox和VirtualBox中的容器进行通信，效率相对低些。
考虑到大多数人的设备和上手难易程度，本为讲解在Linux中直接进行系统源码编译，如果你的系统不是Ubuntu，可以查看Android AOSP基础（一）VirtualBox 安装 Ubuntu这篇文章。
```

## Android系统定制视频收藏

```
https://blog.csdn.net/m0_37203554/article/details/81357704

http://toutiao.com/item/6432821122323972610/   android系统定制-Vbox及Ubuntu的安装
http://toutiao.com/item/6432823051523457538/   android系统定制-常见Linux命令介绍-上
http://toutiao.com/item/6432826510821818881/   android系统定制-常见Linux命令介绍-下
http://www.365yg.com/item/6434362415713878530/ android系统定制-OpenJDK和依赖包的安装&amp;配置USB访问权限
http://www.365yg.com/item/6434633590172025346/ android系统定制-其他可选配置介绍
http://toutiao.com/item/6434633933505167873/   android系统定制-AOSP源码的下载
http://toutiao.com/item/6434640927519670785/   android系统定制-Repo的工作原理
http://www.365yg.com/item/6435007280990650881/ android系统定制-源码下载的其他配置
http://toutiao.com/item/6435007754082976258/   android系统定制-Nexus驱动的下载安装&amp;源码编译
http://toutiao.com/item/6436594902649274881/   android系统定制-编译结果展示&amp;刷机介绍&amp;Android系统分区&amp;out目录介绍
http://toutiao.com/item/6436590437795889665/   android系统定制-AOSP下的一些常用命令
http://www.365yg.com/item/6436589910819340801/ android系统定制-AOSP常见工作目录介绍
http://www.toutiao.com/i6436361010902204929/   android系统定制-AndroidBuildSystem介绍
http://www.toutiao.com/i6436848445700440578/   android系统定制-系统开发做什么
http://www.toutiao.com/i6436589000256913921/   android系统定制-Android系统启动流程-从Init到Zygote
http://www.toutiao.com/i6436849268975206913/   android系统定制-Android系统启动流程-从syste_server到Launcher
http://www.toutiao.com/i6436850885292196353/   android系统定制-修改系统APP后进行编译
http://www.toutiao.com/i6436851843262841346/   android系统定制-Dalvik&amp;ART的区别及ODEX文件介绍
http://www.toutiao.com/i6436852898566504962/   android系统定制-编译时odex化的原因
http://www.toutiao.com/i6436853799767245314/   android系统定制-修改Calclator.apk代码并运行
http://www.toutiao.com/i6436853139567018498/   android系统定制-Framework定制及Mac环境介绍
http://www.toutiao.com/i6436857505522909698/   android系统定制-services.jar&amp;framework.jar的修改与运行
http://www.toutiao.com/i6436857259367596545/   android系统定制-libandroid_runtime.so(JNI层)的修改与运行
http://www.toutiao.com/i6436857357145211394/   android系统定制-liblog.so(native层)的修改与编译
http://www.toutiao.com/i6436859125199536641/   android系统定制-系统开发实战回顾
http://www.toutiao.com/i6436351531619975682/   android系统定制-系统级开发的职业发展

https://github.com/open-android/Android
```

## 制作修改开机logo

```
修改开机logo有两种方法，一种直接去改c语言代码，第二种替换图片用python生成splash。第一种方法我没试过，感觉挺麻烦的，还有分辨率限制，超过多少分辨率就不能用第一种方法。

修改的文件路径LINUX/android/bootable/bootloader/lk/splash
准备好logo图片(png、bmp格式)
查看中原图片的分辨率，修改logo图片 保证 分辨率 一致
生成splash.img镜像文件
注：图片分辨率很重要！很重要！很重要！

生成splash.img 步骤

The steps to generate a splash.img:
 
sudo apt-get install python-imaging
python ./logo_gen.py boot_001.png (*.bmp)

为了减少编译时间可以直接将生成好的splash.img将刷机包中的文件替换掉。
```

## Android--隐藏状态栏图标

```
目前状态栏图标有通知图标和系统图标
通知图标主要是指各应用发过来的通知，比如未接电话，截图，后台播放音乐等，系统图标主要有蓝牙，耳机，wifi，数据流量，时间和电池...

1，不显示通知图标，
在/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarIconController.java中
public void updateNotificationIcons {

     for (int i = 0; i < N; i++) {
            NotificationData.Entry ent = activeNotifications.get(i);
  +          final String pkg = ent.notification.getPackageName();
  +           android.util.Log.d("StatusBarIconController","pkg========"+pkg);

            //比如如果包名不是收音机的，就不显示图标
  +        if (!pkg.contains("com.android.fmradio")) {
  +              continue;
            }
            if (notificationData.isAmbient(ent.key)
                    && !NotificationData.showNotificationEvenIfUnprovisioned(ent.notification)) {
                continue;
            }
}

2.不显示系统图标，系统图标的显示是在以下文件，比如蓝牙，wifi，耳机等
/frameworks/base/packages/SystemUI/src/com/android/systemui/statusbar/phone/
PhoneStatusBarPolicy.java

将不要显示图标，将setIconVisibility()改为false即可，比如，如果不要闹钟图标
private void updateAlarm() {
        ....
- - -       mService.setIconVisibility(SLOT_ALARM_CLOCK, mCurrentUserSetup && hasAlarm);

+++ mService.setIconVisibility(SLOT_ALARM_CLOCK, false);
    }
3,系统图标中比较特殊的时间和电池在
/frameworks/base/packages/SystemUI/res/layout/status_bar.xml
<com.android.systemui.statusbar.policy.Clock
                android:id="@+id/clock"
                android:textAppearance="@style/TextAppearance.StatusBar.Clock"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:singleLine="true"
                android:paddingStart="7dp"
                android:gravity="center_vertical|start"
+++            android:visibility="gone"   //时间
                />
/frameworks/base/packages/SystemUI/res/layout/system_icons.xml

<com.android.systemui.BatteryMeterView android:id="@+id/battery"
        android:layout_height="14.5dp"
        android:layout_width="9.5dp"
+++    android:visibility="gone"      电池
        android:layout_marginBottom="@dimen/battery_margin_bottom"/>
```

## android 5.1 usb调试默认关闭设置方法

```
packages/apps/Provision/src/com/android/provision/DefaultActivity.java 
在该文件中加入下面的代码：
if (!android.os.SystemProperties.getBoolean("ro.inet.adb_enabled",true)) {
    Settings.Secure.putInt(getContentResolver(), Settings.Secure.ADB_ENABLED, 0);
}
同时在system.prop中添加：
ro.inet.adb_enabled=false
```

## android:关掉系统的 安全模式(Safe mode)

```
当 Android 设备在安全模式（Safe Mode）下工作时，任何的第三方应用程序或相关文件（主要为apk应用程序文件）都不可以使用，但可以使用 Android 设备的任务管理器选项进行卸载或管理应用程序，即Android 设备的操作系统或软件或相关文件出现问题导致系统进不了正常界面或不能正常启动系统时，则可以将设备进入安全模式（Safe Mode）卸载或管理原系统以外安装的应用程序或驱动文件或其他第三方相关文件，当在安全模式（Safe Mode）下完全卸载或管理了相关第三方安装的应用程序仍然不可以解决问题后，再进行安装或升级或更新操作系统或其他方法来解决问题。进入安全模式时，主界面的左下方显示“安全模式”或“Safe Mode”提示。安全模式进入方法：机器启动后，在开机动画前， 按住 Menu 或 音量减键至开机完成，就可以进入安全模式。安全模式退出方法：若需要退出安全模式，当且Android 设备在没有进行过特别使用或使用不当时（设备未使用非原装充电器充电，设备未拆过机等），将设备关机，然后重新开机，即可以退出安全模式，正常进入系统.系统检测是否进入安全模式的调用实现列出：frameworks/base/services/java/com/android/server/SystemServer.java frameworks/base/services/java/com/android/server/wm/WindowManagerService.javaframeworks/base/policy/src/com/android/internal/policy/impl/PhoneWindowManager.java

+++ frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java
@@ -7532,7 +7532,7 @@ public class WindowManagerService extends IWindowManager.Stub
             Log.i(TAG, "SAFE MODE not enabled");
         }
         mPolicy.setSafeMode(mSafeMode);
-        return mSafeMode;
+        return false;
     }
 
     public void displayReady() {
```

## 屏蔽所有物理按键

```
frameworks\base\services\core\java\com\android\server\wm\WindowManagerService.java

computeScreenConfigurationLocked 方法将hardKeyboardAvailable改为false。

boolean hardKeyboardAvailable = false;
```

## 消除原生Android网络状态上的惊叹号

```
谷歌在Android5.0之后的版本加入了CaptivePotalLogin服务。本服务的功能是检查网络连接互联网情况，主要针对于Wi-Fi，不让Android设备自动连接那些不能联网的无线热点，白白耗电。
该服务的原理就是让接入无线热点后，测一下网站connectivitycheck.gstatic.com的联通情况。
但对于不能访问谷歌服务器的地区，问题就来了：

如果谷歌（谷歌服务）认为WiFi网络无法联网，就不会自动连接到该WiFi热点。而且如果设备有移动网络可用，就会自动切换到2G/3G/LTE。并且让WiFi网络的标志上面显示感叹号标志。

出现感叹号的同时，该服务会一直试探服务器，直到联通为止。该过程会消耗流量和电量，甚至导致部分设备无法休眠。

这个感叹号会使广大强迫症晚期患者无法接受。

对于Android Source开发的同学，最好的解决办法自然是修改源码：
方案1：更换测试地址
frameworks/base/packages/SettingsProvider/res/values/defaults.xml：

diff --git a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
index bede17d..508d384 100644
--- a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
+++ b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
@@ -215,5 +215,5 @@
     <bool name="def_guest_user_enabled">true</bool>
 
     <!-- Default for Settings.Global.CAPTIVE_PORTAL_DETECTION_ENABLED -->
-    <integer name="def_captive_portal_detection_enabled" translatable="false">1</integer>
+    <integer name="def_captive_portal_detection_enabled" translatable="false">0</integer>
 </resources>
```

## Android系统修改所有应用能读写SD卡

```
需要Android源码/frameworks\base\data\etc\platform.xml
找到
<permission name="android.permission.WRITE_EXTERNAL_STORAGE">
<group gid="sdcard_rw" />

修改为

<permission name="android.permission.WRITE_EXTERNAL_STORAGE">
<group gid="sdcard_rw" />

<group gid="media_rw" />

保存，将系统烧录到板中即可。 
```

## 3gpp 协议

```
https://blog.csdn.net/zhangbijun1230/article/details/79951310
```

## TODO : FFmpeg

```
https://blog.csdn.net/gjy_it/article/details/90448722

sudo apt-get install ffmpeg

// 制作 gif 动画
ffmpeg -t 3.6 -ss 00:00:01 -i 01.mp4 01.gif

注释：3.6是秒数，00:00:01是开始时间。 
这一个命令足够走天下了。
```

## Android 7.0 之后的 ota 升级方式 A/B system

```
https://blog.csdn.net/guyongqiangx/article/details/71334889

https://blog.csdn.net/guyongqiangx/article/details/71516768

https://blog.csdn.net/guyongqiangx/article/details/72480154

https://blog.csdn.net/guyongqiangx/article/details/72604355
```

## log抓取

```
1、日志抓取（四类log buffer是main，radio，system，events）
adb wait-for-device logcat  
adb logcat -v time > logcat.txt      //默认是-b main -b system
adb logcat -v time -b main        //main log
adb logcat -v time -b radio        //radio log
adb logcat -v time -b system        //system log
adb shell dmesg                       //kernel log
adb logcat -v time -b events

2、anr log

adb pull /data/anr

3、tombstone log

adb pull /data/tombstones

4、core log

adb pull  /data/log/core

5、开机log

adb shell dmesg > dmesg.txt

6、logcatch

adb pull /data/logcatch

7、qxdm log

adb pull /sdcard/logs

8、 hprof log

在分析app 时，我们通常需要分析app 的java heap 资料，如分析java 的memory leak, 追查heap
中相关变量情况等。
在android 中抓取app 的hprof 操作方式有下面几种:
第一种方式: 使用am 命令
   adb shell am dumpheap {Process} file
   如 adb shell am dumpheap com.android.phone /data/anr/phone.hprof
   adb pull /data/anr/phone.hprof
第二种方式: 使用DDMS 命令
   在DDMS 中选择对应的process, 然后在Devices 按钮栏中选择Dump Hprof file， 保存即可
第三种方式: 通过代码的方式
   在android.os.Debug 这个class 中有定义相关的抓取hprof 的method.
如: public static void dumpHprofData(String fileName) throws IOException;
这样即可在代码中直接将这个process 的hprof 保存到相对应的文件中，注意这个只能抓取当时的
process.
如果想抓其他的process 的hprof, 那么就必须通过AMS 帮忙了。
可以先获取IActivityManager 接口，然后调用它的dumpheap 方法。具体的代码，大家可以参考
frameworks/base/cmds/am/src/com/android/commands/am/am.java 中的调用代码
抓取回hprof 后，就可以用hprof-conv 命令将DVM 格式的hprof 转换成标准的java 命令的hprof
   hprof-conv in.hprof out.hprof
然后使用如MAT 之类的工具进行具体的分析

9、bugreport
adb bugreport > bugreport.txt

10、kernel log(只有从当前时间起的很少的log)
cat proc/kmsg > kmsg.txt

11、其他
adb shell dumpstate //各类信息，比如进程信息，内存信息，进程是否异常，kernnel的log等
adb shell dumpcrash
adb shell dumpsys  //查询所有service的状态
```

## Android 源码 修改系统默认横屏

```
https://blog.csdn.net/gjy_it/article/details/80743448
```

## 修改开机弹出欢迎使用SIM

```
MTK工程/mediatek/packages/apps/Stk1/src/com/android/stk/StkAppService.java
（\frameworks\base\packages\Keyguard\src\com\mediatek\keyguard\Telephony\KeyguardDialogManager.java）
    case DISPLAY_TEXT:
        //显示SIM卡信息
        launchTextDialog(slotId);
        break;
```

## 关闭通知栏通能

```
\frameworks\base\core\java\android\app\NotificationManager.java
public void notify(int id, Notification notification) {
    boolean close=false;
    if(close) {
        notify(null, id, notification);
    }
}
```

## 屏蔽掉下拉通知栏和状态栏

```
..\frameworks\base\packages\SystemUI\src\com\android\systemui\statusbar\phone\PhoneStatusBarView.java
    @Override
    public void addPanel(PanelView pv) {
        super.addPanel(pv);
//        if (pv.getId() == R.id.notification_panel) {
//            mNotificationPanel = pv;
//        } else if (pv.getId() == R.id.settings_panel){
//            mSettingsPanel = pv;
//        }
        pv.setRubberbandingEnabled(!mFullWidthNotifications);
    }
```

## 去掉GPS功能

```
a. 在 mediatek/config/$(pro)/ProjectConfig.mk 更改如下两项为no
MTK_AGPS_APP=no
MTK_GPS_SUPPORT=no
MTK_YGPS_APP=no

b. 在 mediatek/config/$(pro)/autoconfig/kconfig/project 中添加
CONFIG_MTK_GPS=n CONFIG_GPS=n
```

## 平板改为手机

```
build/target/product/$(pro).mk中PRODUCT_CHARACTERISTICS := tablet改为PRODUCT_CHARACTERISTICS := default
```

## MTK 常用默认值修改(KK之前)

```
https://blog.csdn.net/zengrunxiu/article/details/83446881
```

## etckeeper

```
https://blog.csdn.net/guyongqiangx/article/details/71750903
```

## Android脚本envsetup.sh逐行分析

```
https://blog.csdn.net/guyongqiangx/article/details/73188477

gettop 函数从指定的$TOP目录或当前目录开始查找build/core/envsetup.mk文件，并将能找到该文件的目录返回给调用函数作为操作的根目录

croot命令切换到当前编译环境的根目录。

cproj命令用于切换到当前模块的编译目录下（含有Android.mk）

getprebuilt返回ANDROID_PREBUILTS的路径

printconfig输出当前的编译配置

pez函数的参数”$@”是一条可执行命令，通过执行结果来决定打印FAILUE和SUCCESS的颜色，失败打印红色的FAILURE，成功打印绿色的SUCCESS

sgrep，基于(c|h|cc|cpp|S|java|xml|sh|mk|aidl|vts)文件查找
ggrep，基于(.gradle)的文件查找
jgrep，基于(.java)文件查找
cgrep，基于(c|cc|cpp|h|hpp)文件查找
resgrep，基于res目录下(xml)文件查找
mangrep，基于AndroidManifest.xml文件查找
sepgrep，基于sepolicy目录下查找
rcgrep，基于*.rc*文件查找
mgrep，基于(Makefile|Makefile\..*|.*\.make|.*\.mak|.*\.mk)的Makefile文件查找
treegrep，基于代码的文件(c|h|cpp|S|java|xml)进行查找

qpid

pid

smoketest

runtest

provision
```

## external/autotest 怎么用？？？

## Android 编写开启自启动的脚本服务

```
因为公司有一款手机在升级之后用户找不到内部sdcard 中的数据，分析了主要原因是因为升级前后内部sdcard 的链接的路径改变了。之前sdcard的数据在/sdcard/emulated/ 目录下，升级时候放在了/sdcard/emulated/0/ 下面。一个解决方案就是在手机启动的时候开启一个脚本服务检测一下当前的目录是否是正确的，如果不对就进行目录得调整。主要的操作就是mv 操作，效率很高。

目录
1. 编写Shell脚本
2. fs_config.c 提交文件权限
3. 增加selinux te 文件，增加Shell脚本的一些权限
4. 添加新增文件上下文
5. 增加mk 文件实现编译拷贝
6. 在init.rc 中加入开机启动的Service

正文

1. 编写Shell 脚本 
adjust_sdcard.sh

#!/system/bin/sh
i=1
num=0
while :
do
log -t ota-sdcard "try ..."$i
need_adjust=`ls /storage/emulated/ -l |grep "^d"|wc -l`
log -t ota-sdcard "need adjust ="$need_adjust
if [ "$need_adjust" == "2" ]
then
log -t ota-sdcard "adjust inner sdcard success ."
break
else
log -t ota-sdcard "try adjust inner adcard dir..."
for file in /storage/emulated/*
do
    if test -f $file
    then
        echo "move $file -> /storage/emulated/0/${file##*/}"
        log -t ota-sdcard "move $file -> /storage/emulated/0/${file##*/}"
        let num++
        mv $file /storage/emulated/0/${file##*/}
    fi
    if test -d $file && [ ${file##*/} != "0" ] && [ ${file##*/} != "obb" ]
    then
        echo "move $file -> /storage/emulated/0/${file##*/}"
        log -t ota-sdcard "move $file -> /storage/emulated/0/${file##*/}"
        let num++
        mv $file /storage/emulated/0/${file##*/}
    fi
done
log -t ota-sdcard "move num = $num"
fi
sleep 2
i=$(($i+1))
done

具体的功能就是判断一下目录结构对不对，如果不对就会调用mv 进行目录的调整。上面的脚本只是演示了主要的功能，用作调试用的。用兴趣可以看一下。


2. fs_config.c 提交文件权限

这个文件就是设置文件在系统中的权限

fs_path_config android_files 中增加
{ 00750, AID_ROOT, AID_ROOT, 0, "system/bin/adjust_sdcard.sh" },

3. 增加selinux te 文件，增加Shell脚本的一些权限
我们知道Android 4.4 之后引入了selinux的机制，所以我们编写的Shell的脚本的中很多命令代码都需要给予相应的selinux 权限。
#ota_sdcard.te
type ota_sdcard, domain;
type ota_sdcard_exec, exec_type, file_type;

init_daemon_domain(ota_sdcard)
allow ota_sdcard system_file:file execute_no_trans;
allow ota_sdcard shell_exec:file rx_file_perms;
allow ota_sdcard storage_file:dir search;
allow ota_sdcard fuse:dir {open read search getattr write remove_name rename add_name reparent};
allow ota_sdcard fuse:file {open read getattr write rename create};

4. 增加Shell 脚本文件的上下文
/system/bin/adjust_sdcard.sh u:object_r:ota_sdcard_exec:s0

5. 增加mk 文件实现编译拷贝
PRODUCT_COPY_FILES += \
device/qcom/msm8916/adjust_sdcard.sh:/system/bin/adjust_sdcard.sh

6. 在init.rc 中加入开机启动的Service
service ota-sdcard /system/bin/adjust_sdcard.sh
class main
oneshot
开机作为main 自启动。

上面的6个步骤是实现整个机制的核心步骤，细节并没有过多的讲述，后面增加每个步骤具体涉及到的知识点。
```

## Android 优化和调试技巧

```
https://blog.csdn.net/zhangbijun1230/article/details/79514284
```

## 内核日志

```
adb shell dmesg

输出示例：

<6>[14201.684016] PM: noirq resume of devices complete after 0.982 msecs
<6>[14201.685525] PM: early resume of devices complete after 0.838 msecs
<6>[14201.753642] PM: resume of devices complete after 68.106 msecs
<4>[14201.755954] Restarting tasks ... done.
<6>[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC
<6>[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC
<6>[14201.872498] PM: Syncing filesystems ... done.
中括号里的 [14201.684016] 代表内核开始启动后的时间，单位为秒。

通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 Freeing init memory 那一行前面的时间就是。
```

## 设置时间

```
adb shell date 08281319
```

## adb 命令大全

```
https://blog.csdn.net/zhangbijun1230/article/details/79740582
```

## 获取其他包的Context

```
Context c = createPackageContext("chroya.demo", Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY);
//载入这个类
Class clazz = c.getClassLoader().loadClass("chroya.demo.Main");
//新建一个实例
Object owner = clazz.newInstance();
//获取print方法，传入参数并执行
Object obj = clazz.getMethod("print", String.class).invoke(owner, "Hello");
```

## 语言列表

```
https://blog.csdn.net/zhangbijun1230/article/details/80107594
```

## Android 判断你的应用在前台还是在后台 ActivityLifecycleCallbacks

```
https://blog.csdn.net/zhangbijun1230/article/details/80317765

public class MyLifecycleHandler implements Application.ActivityLifecycleCallbacks {
    private static int resumed;
    private static int paused;
    private static int started;
    private static int stopped;
 
    @Override
    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
    }
 
    @Override
    public void onActivityStarted(Activity activity) {
        ++started;
    }
 
    @Override
    public void onActivityResumed(Activity activity) {
        ++resumed;
    }
 
    @Override
    public void onActivityPaused(Activity activity) {
        ++paused;
        android.util.Log.w("test", "application is in foreground: " + (resumed > paused));
    }
 
    @Override
    public void onActivityStopped(Activity activity) {
        ++stopped;
        android.util.Log.w("test", "application is visible: " + (started > stopped));
    }
 
    @Override
    public void onActivityDestroyed(Activity activity) {
    }
 
    @Override
    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
    }
 
    public static boolean isApplicationVisible() {
        return started > stopped;
    }
 
    public static boolean isApplicationInForeground() {
    // 当所有 Activity 的状态中处于 resumed 的大于 paused 状态的，即可认为有Activity处于前台状态中 
        return resumed > paused;
    }
}

然后在自己定义的 Application 中的 onCreate() 方法中注册该 ActivityLifecycleCallbacks：
registerActivityLifecycleCallbacks(new MyLifecycleHandler());
```

## Android 系统（67）---android apk 的root 权限和USB adb 权限的区别

```
USB adb 权限是指，当adb 连接手机时，手机中的守护进程adbd 的权限为root 权限，从而它的子进程也具有root 权限，通常如果adb shell 看到是：
Android 4.0 以后版本:
C:\>adb shell
root@android:/ #
Android 2.3 版本：
C:\>adb shell
#
即表明adb 的连接是root 权限的，相反如果看到是$ 即表明是shell 权限
Android 的APK 本身都是不具备root 权限的，如果想启用root 权限，那么就必须借助具有root 权限的进程或者具有s bit 的文件，目前比较通用的手法是，手机root 后，内置了su到system/bin, 然后普通APP 即可借助su 命令来达到root 权限切换。 
网络上已经有同仁修改su 命令，并通过一个APK 来控制su 命令的权限控制。
 SuperSU: http://forum.xda-developers.com/showthread.php?t=1538053 (更新速度很快，推荐使用)
 
综上所叙，如果adb 已经有root 权限，那么让apk 行使root 权限就很简单了。
```

## Android修改分区格式为F2FS

```
本文介绍如何将Android系统的/data分区改变成F2FS格式。修改的原因是F2FS分区格式拥有更加的I/O性能。

修改文件系统格式成F2FS方法
在改动之前我们先看看当前Android系统的主要分区格式,可以用如下方式查看

$ adb shell df -t ext4
Filesystem                             1K-blocks    Used Available Use% Mounted on
/dev/block/bootdevice/by-name/system     1007736  907964     83388  92% /system
/dev/block/bootdevice/by-name/userdata  12168972 6740960   5411628  56% /data
/dev/block/bootdevice/by-name/cache       259856     332    254160   1% /cache
/dev/block/bootdevice/by-name/persist      28144     200     27292   1% /persist

大多数情况下可以看到我们系统当前的主要分区格式都是EXT4。
现在来将/data分区格式更改成F2FS格式，因为应用的好多私有数据都存放在该分区知悉，比如database，SharedPreferences.更改成F2FS格式能有效提升应用的I/O访问速度，提升性能。 
修改的地方有三点：

１．打开kernel config中对F2FS的支持 
项目的kernel　config 文件中加入

CONFIG_F2FS_FS=y
CONFIG_F2FS_STAT_FS=y
CONFIG_F2FS_FS_XATTR=y
CONFIG_F2FS_FS_POSIX_ACL=y
CONFIG_F2FS_FS_SECURITY=y
CONFIG_F2FS_CHECK_FS=y

２．配置/data分区文件格式为F2FS. 
在文件BoardConfig.mk中做如下修改

TARGET_USERIMAGES_USE_F2FS := true
BOARD_USERDATAIMAGE_FILE_SYSTEM_TYPE := f2fs

３．更改分区文件fstab，使得mount /data分区时的文件类型为F2FS。 
fstab可能有多个类似文件，需要根据具体项目定位。修改形式大致如下:

- /data     ext4        noatime,nosuid,nodev,discard
+ /data     f2fs        noatime,nosuid,nodev,discard

第３点的修改可以参考： 
https://github.com/anpage/android_device_asus_grouper/commit/9d6899d95af972ae7613d02dc30eb36bb74062b8

以上修改完毕，查看当前的/data分区已经变成了F2FS格式。

F2FS vs EXT4
修改了之后为了验证I/O性能确实提升了，可以借助Androbench APK测试。结果如下图。 
这里写图片描述

从跑分结果看f2fs格式的结果要好于ext4,但似乎优势不明显。我们在用dd命令测试： 
这里写图片描述

最后放上一个官方的分区格式不同的性能对比图。 
这里写图片描述

拓展知识点
什么是文件系统： 
文件系统是用来控制如何存取数据的一套规则。如果没有这套规则，那么所有数据都会放在一个大的存储区域上，我们很难找到需要的数据位于该区域的哪一个地方。于是就制定了一套规则，它将整个大的存储区域分割成若干个独立的子区域，每个子区域对应一个名称，如何分割子区域，以及从子区域中读写目标数据的整套规则就是文件系统。
F2FS文件系统优缺点
F2FS (Flash-Friendly File System)文件系统格式是由三星公司开发的，它专为移动设备而生。 
优点：

卓越的读写速度
降低了写的的次数，因此延长了磁盘的寿命。
缺点:

占用的空间更大
没有ext4稳定
没有ext4通用，某些手机可能不支持
EXT4文件系统优缺点
EXT4是Linux的标准文件系统，它基于EXT3而来，EXT3又基于EXT2而来，但从EXT3到EXT4做的改动巨大。 
优点：

良好的稳定性，使用广泛
所有的智能手机都支持。
缺点：

相对与F2FS　I/O速度较慢。
```

## 为什么 Android8.1 使用f2fs文件系统的预置app到data/app不行？

```
https://blog.csdn.net/lb5761311/article/details/83617744

最近使用mtk6739平台开发。有一个需求是想预置系统中，恢复出厂设置后把app删除。
再8.1 的流程是

在 package/apps/3rd-party 下面以需要预置的apk名字新建文件夹，以预置 facebook 为例。
将 facebook.apk 放到 package/apps/3rd-party/facebook 中。
在 package/apps/3rd-party/facebook 下面创建文件 Android.mk，文件内容如下
在 build/make/target/product/core.mk或device/mediatek/common/device.mk中添加PRODUCT_PACKAGES += facebook

LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := facebook
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
LOCAL_CERTIFICATE := PRESIGNED

include $(BUILD_PREBUILT)

然后再下面文件添加facebook的包名
vendor/mediatek/proprietary/frameworks/base/data/etc/pms_sysapp_removable_system_list.txt
就可以完成卸载apk，但是这个做法有一个问题，恢复出厂设置facebook这个app有返回到桌面了。而我们设计需求是不能回到桌面。
这个方法不行。
第二种方法
需要预置apk，卸载以后，恢复出厂设置以后，apk不存在。这种需要预置apk到/data/app目录下。但是android o 版本以后google 加入了patch,不允许预置apk到data/app目录下，只允许使用adb install 的方式来安装apk到data/app目录下，需要将其roll back 回以前的版本，然后用下列方法可以完成预置。

diff --git a/services/core/java/com/android/server/pm/PackageManagerService.javab/services/core/java/com/android/server/pm/PackageManagerService.javaindex bafcad4…71d3d9a 100644
--- a/services/core/java/com/android/server/pm/PackageManagerService.java
+++ b/services/core/java/com/android/server/pm/PackageManagerService.java
@@ -11394,6 +11394,10 @@
                                     + " but expected at " + known.codePathString
                                     + "; ignoring.");
                         }
+                    } else {
+                        throw new PackageManagerException(INSTALL_FAILED_INVALID_INSTALL_LOCATION,
+                                "Application package " + pkg.packageName
+                                + " not found; ignoring.");
                     }
                 }
             }
在PMS中将其中增加的代码删除。
2.在 packages/apps 下面以需要预置的 APK 名字创建文件夹，以预置一个名为Test的APK为例
3.将 Test.apk 放到 packages/apps/Test
4. 在 packages/apps/Test 下面创建文件 Android.mk，文件内容如下：

LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

 

# Module name should match apk name to be installed

LOCAL_MODULE := Test

LOCAL_MODULE_TAGS := optional

 

LOCAL_SRC_FILES := $(LOCAL_MODULE).apk

LOCAL_MODULE_CLASS := APPS

LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)

# LOCAL_PRIVILEGED_MODULE := true

LOCAL_MODULE_PATH := $(TARGET_OUT_DATA_APPS)

 

LOCAL_CERTIFICATE := platform

include $(BUILD_PREBUILT)

5.打开文件 device\mediatek\common\device.mk

将 Test 添加到 PRODUCT_PACKAGES 里面。

PRODUCT_PACKAGES += Test
6.重新 build 整个工程
但是测试后发现 data/app 根本没有打包到userdata.img中。整个userdata.img大小 64K。
只能自己分析原因。
执行 生成userdata.img的命令 make userdataimage-nodeps

.PHONY: userdataimage-nodeps
userdataimage-nodeps: | $(INTERNAL_USERIMAGES_DEPS)
	$(build-userdataimage-target)

INTERNAL_USERIMAGES_DEPS 依赖 ，表示执行 生成userdata.img 需要哪些条件
这个命令 最终执行 build-userdataimage-target
内容如下：

define build-userdataimage-target
  $(call pretty,"Target userdata fs image: $(INSTALLED_USERDATAIMAGE_TARGET)")
  @mkdir -p $(TARGET_OUT_DATA)
  @mkdir -p $(userdataimage_intermediates) && rm -rf $(userdataimage_intermediates)/userdata_image_info.txt
  $(call generate-userimage-prop-dictionary, $(userdataimage_intermediates)/userdata_image_info.txt, skip_fsck=true)
  $(hide) PATH=$(foreach p,$(INTERNAL_USERIMAGES_BINARY_PATHS),$(p):)$$PATH \
      ./build/tools/releasetools/build_image.py \
      $(TARGET_OUT_DATA) $(userdataimage_intermediates)/userdata_image_info.txt $(INSTALLED_USERDATAIMAGE_TARGET) $(TARGET_OUT)
  $(hide) $(call assert-max-image-size,$(INSTALLED_USERDATAIMAGE_TARGET),$(BOARD_USERDATAIMAGE_PARTITION_SIZE))
endef

$(TARGET_OUT_DATA) = out/target/product/k39tv1_bsp_1g/data
$(userdataimage_intermediates) = out/target/product/k39tv1_bsp_1g/obj/PACKAGING/userdata_intermediates
make userdata 的log

PRODUCT_COPY_FILES device/mediatek/common/fstab.enableswap:root/fstab.enableswap ignored.
No private recovery resources for TARGET_DEVICE k39tv1_bsp_1g
[100% 1/1] Target userdata fs image: out/target/product/k39tv1_bsp_1g/userdata.img
Target userdata fs image: out/target/product/k39tv1_bsp_1g/data
Running:  mkf2fsuserimg.sh out/target/product/k39tv1_bsp_1g/userdata.img 3221225472
in mkf2fsuserimg.sh PATH=out/host/linux-x86/bin/:/usr/lib/jvm/java-8-openjdk-amd64/bin:/home/stonecom/mtk6739/out/soong/host/linux-x86/bin:/home/stonecom/mtk6739/out/host/linux-x86/bin:/home/stonecom/mtk6739/prebuilts/gcc/linux-x86/arm/arm-linux-androideabi-4.9/bin::/home/stonecom/mtk6739/development/scripts:/home/stonecom/mtk6739/prebuilts/devtools/tools:/home/stonecom/mtk6739/external/selinux/prebuilts/bin:/home/stonecom/mtk6739/prebuilts/misc/linux-x86/dtc:/home/stonecom/mtk6739/prebuilts/misc/linux-x86/libufdt:/home/stonecom/mtk6739/prebuilts/android-emulator/linux-x86_64:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/home/stonecom/bin
make_f2fs -S 3221225472 out/target/product/k39tv1_bsp_1g/userdata.img

        F2FS-tools: mkfs.f2fs Ver: 1.8.0 (2017-02-03)

Info: Disable heap-based policy
Info: Debug level = 0
Info: Label = 
Info: Trim is disabled
Info: Segments per section = 1
Info: Sections per zone = 1
Info: sector size = 512
Info: total sectors = 6291456 (3072 MB)
Info: zone aligned segment0 blkaddr: 512
Info: format version with
  ""
Info: Overprovision ratio = 3.640%
Info: Overprovision segments = 115 (GC reserved = 62)
Info: format successful
out/target/product/k39tv1_bsp_1g/userdata.img maxsize=3288667008 blocksize=4224 total=57624 reserve=33221760

mkf2fsuserimg.sh 是生成 img脚本，地址在out/host/linux-x86/bin
内容：

#!/bin/bash
#
# To call this script, make sure make_f2fs is somewhere in PATH

function usage() {
cat<<EOT
Usage:
${0##*/} OUTPUT_FILE SIZE
EOT
}

echo "in mkf2fsuserimg.sh PATH=$PATH"

if [ $# -lt 2 ]; then
  usage
  exit 1
fi

OUTPUT_FILE=$1
SIZE=$2
shift; shift


if [ -z $SIZE ]; then
  echo "Need size of filesystem"
  exit 2
fi

MAKE_F2FS_CMD="make_f2fs -S $SIZE $OUTPUT_FILE"
echo $MAKE_F2FS_CMD
$MAKE_F2FS_CMD
if [ $? -ne 0 ]; then
  exit 4
fi

里面最重要的内容就是这句话，
MAKE_F2FS_CMD=“make_f2fs -S $SIZE $OUTPUT_FILE”
$SIZE $OUTPUT_FILE = out/target/product/k39tv1_bsp_1g/userdata.img
make_f2fs 实际使用的命令是mkfs.f2fs ，这是f2fs文件系统的命令
mkfs.f2fs指令使用指南
-s只是指定了段大小。整个命令是生成一个空的userdata.img并指定img段大小。
所以只要使用了 f2fs无法预置data/app到userdata.img,可以修改userdata img 为ext4支持，希望以后f2fs以后能支持
```

## mtk平台上如何开启f2fs

```
1、  MTK Android O1   SW 版本
 
2、  F2FS 在下列平台已经做了验证，其他平台没有验证
     1)6580/6570  
     2)6735/53/37 系列    
     3) 6739
 
3.  开启f2fs :
 
    1)Kernel Config (kernel-xxx/arch/armxx/configs/$project_[debug]_config)
添加如下设定（如已有，请配置为如下设定）
CONFIG_F2FS_FS=y
CONFIG_F2FS_FS_SECURITY=y
CONFIG_F2FS_FS_ENCRYPTION=y
 
  2)add F2FS Property of MTK
device/mediateksample (mediatekprojects) / <Project Name> /device.mk
添加如下设定（如已有，请配置为如下设定）：
# F2FS filesystem
PRODUCT_PROPERTY_OVERRIDES += ro.mtk_f2fs_enable=1
  3)CONFIG data partition as F2FS as below
device/mediateksample (mediatekprojects) / <Project Name> /BoardConfig.mk
 添加如下设定（如已有，请配置为如下设定）：
#Config data partition for F2FS
BOARD_USERDATAIMAGE_FILE_SYSTEM_TYPE := f2fs

# This ensures the needed build tools are available.
# TODO: make non-linux builds happy with external/f2fs-tool; system/extras/f2fs_utils
ifeq ($(HOST_OS),linux)
TARGET_USERIMAGES_USE_F2FS := true
endif
# Filesystem management tools
PRODUCT_PACKAGES += fsck.f2fs mkfs.f2fs
 4.vendor/mediatek/proprietary/bootable/bootloader/lk/project/
 $project.mk (for fastboot)
Add the following line
  MTK_USERIMAGES_USE_F2FS = yes
 
 以上修改后，请make clean后编译，确保修改生效
```

## Alarm的机制

```
https://blog.csdn.net/zhangbijun1230/article/details/80166185

Alarm和Timer以及Handler在定时任务上的区别
相同点：

三者都可以完成定时任务，都支持一次性定时和循环定时（注：Handler可以间接支持循环定时任务）

不同点：

Handler和Timer在定时上是类似的，二者在系统休眠的情况下无法正常工作，定时任务不会按时触发。Alarm在系统休眠的情况下可以正常工作，并且还可以决定是否唤醒系统，同时Alarm在自身不启动的情况下仍能正常收到定时任务提醒，但是当系统重启或者应用被杀死的情况下，Alarm定时任务会被取消。另外，从Android4.4开始，Alarm事件默认采用非精准方式，即定时任务可能会有小范围的提前或延后，当然我们可以强制采用精准方式，而在此之前，Alarm事件都是精准方式。
```

## LOCAL_PRIVILEGED_MODULE

```
https://blog.csdn.net/zhanglianyu00/article/details/75099025
```

## Android关键字persistent

```
https://blog.csdn.net/zhangbijun1230/article/details/80587004
```

## Android应用程序安装过程解析

```
https://blog.csdn.net/zhangbijun1230/article/details/80548728
```

## Android 8.1预置apk为可卸载

```
在MTK Android O1平台预置apk为可卸载时。预置到旧的路径system/vendor/operator/app会编译报错，"You cannot install files to out/target/product/xxx/system/vendor while building a separate vendor.img!"改为预置到vendor/operator/app就可以编译通过，预置可卸载成功,恢复出厂设置可恢复。

旧的

LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)

# Module name should match apk name to be installed
LOCAL_MODULE := Test
LOCAL_MODULE_TAGS := optional
LOCAL_SRC_FILES := $(LOCAL_MODULE).apk
LOCAL_MODULE_CLASS := APPS
LOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)
#LOCAL_PREBUILT_JNI_LIBS := \
#LOCAL_PRIVILEGED_MODULE := true
LOCAL_MODULE_PATH := $(TARGET_OUT)/vendor/operator/app
LOCAL_CERTIFICATE := PRESIGNED

include $(BUILD_PREBUILT)

修改LOCAL_MODULE_PATH为

LOCAL_MODULE_PATH := $(TARGET_OUT_VENDOR)/operator/app
```

## 模拟电源键长按(getevent,sendevent)

```
首先我在手机的shell下输入了getevent命令，这样就可以接收到手机上操作的所有event事件。
这个时候我们按下我们手机电源键，来看看可以接收到哪些事件信息，按下电源键后：
我们得到了以上四条信息。
我们来以第一条为例分析一下获得是什么？
/dev/input/event0:  代表 device
0001                         代表一个type
0074                         代表power键的code(为16进制)
00000001                 代表value 一般 1代表按下，0代表放开。

根据查阅sendevent 需要的参数为就是device、type、code、value。

于是我们就可以通过下面四条命令即可完成按power键的操作，中间sleep的时间长度大于2秒，系统就认为是长按：
sendevent /dev/input/event0 1 116 1（0074转化为十进制后为116）
sendevent /dev/input/event0 0 0 0
sleep 3
sendevent /dev/input/event0 1 116 0
sendevent /dev/input/event0 0 0 0
```

## Android 如何快速写满存储空间

```
方法一：
通过如下 adb 命令在 /mnt/sdcard/ 目录下产生一个名为 bigfile 的文件，让其自动增长到磁盘剩余空间大小。

adb shell dd if=/dev/zero of=/mnt/sdcard/bigfile

方法二：
使用的是android sdk工具创建一个sdcard.img文件，由于Android单个文件传输大小限制，注意不要超过4G。

mksdcard 3G sdcard.img

方法三：
使用微软提供的fsutil.exe命令来创建指定大小的文件。

fsutil file createnew bigfile.txt  100000000
```

## 手机收到8bit编码的短信无法显示

```
android默认不支持8bit编码，8bit只是数据传输的一种方式，8bit编码并没有定义唯一的字符编码表来指明某个编码表示某个字符，所以没办法唯一去解析它
代码可见framework/base/telephony/java/com/android/internal/telephony/gsm/SmsMessage.java
parseUserData方法
switch (encodingType) {
            case ENCODING_UNKNOWN:
            case ENCODING_8BIT:
                messageBody = null;
                break;
 
这也是google default设计，MTK也没有做扩展，因为上面所说的，8bit没有唯一表来定义其编码。
如果发现某个对比机可以显示，那是对比机指定了某种解码方式去解析8bit，但这有风险，只要那些8bit数据不是用指定的那种解码方式去编码的话，会显示乱码。
如果客户一定要用解析8bit编码的短信，可以自行修改代码
以下以UTF-8来解析为例，修改方法：
framework/base/telephony/java/com/android/internal/telephony/gsm/SmsMessage.java
1.parseUserData方法
case ENCODING_8BIT:
                messageBody = null;
  break;
修改为：
case ENCODING_8BIT:
                //messageBody = null;
                messageBody = p.getUserDataUTF8(count);
                break;

2.getUserDataUCS2这个方法后面增加一个方法 getUserDataUTF8，如下：
  String getUserDataUTF8(int byteCount) {
            String ret;
            try {
                ret = new String(pdu, cur, byteCount, "utf-8");
            } catch (UnsupportedEncodingException ex) {
                ret = "";
                Log.e(LOG_TAG, "Utf-8,implausible UnsupportedEncodingException", ex);
            }
            cur += byteCount;
            return ret;
        }

这种修改是有风险的：可能解析出来的短信都是乱码。请客户自行评估风险，谨慎修改。
 
 Android 5及之后的版本，Google提供了一个变量来控制是否支持8bit编码。
默认是false，改成true之后就能支持解码8bit
/frameworks/base/core/res/res/values/config.xml
<bool translatable="false" name="config_sms_decode_gsm_8bit_data">false</bool>
 
注意：开启8bit之后会导致CTS fail. 目前没有能兼顾8bit和CTS测试的解决方案。
```

## 浏览器默认搜索引擎更改

```
vendor/mediatek/proprietary/packages/apps/Browser/src/com/android/browser/preferences/SearchEngineSettings.java）

                 mEntries[i] = searchEngines.get(i).getLabel();  
                 mEntryFavicon[i] = searchEngines.get(i).getFaviconUri();  
                 if (mEntryValues[i].equals(searchEngineName)) {  
-                    selectedItem = i;
+                    selectedItem = 1;
                 }  
             }  
```

## 语音邮件通知无法移除

```
（frameworks/base/telephony/java/android/telephony/CarrierConfigManager.java）

         sDefaults.putBoolean(KEY_SUPPORT_SWAP_AFTER_MERGE_BOOL, true);  
         sDefaults.putBoolean(KEY_USE_HFA_FOR_PROVISIONING_BOOL, false);  
         sDefaults.putBoolean(KEY_USE_OTASP_FOR_PROVISIONING_BOOL, false);  
-        sDefaults.putBoolean(KEY_VOICEMAIL_NOTIFICATION_PERSISTENT_BOOL, false);
+        sDefaults.putBoolean(KEY_VOICEMAIL_NOTIFICATION_PERSISTENT_BOOL, true);
         sDefaults.putBoolean(KEY_VOICE_PRIVACY_DISABLE_UI_BOOL, false);  
         sDefaults.putBoolean(KEY_WORLD_PHONE_BOOL, false);  
         sDefaults.putInt(KEY_VOLTE_REPLACEMENT_RAT_INT, 0);  
```

## 拍照人脸美化会生成两张照片

```
（vendor/mediatek/proprietary/packages/apps/Camera/src/com/mediatek/camera/mode/facebeauty/FaceBeautyMode.java）

if (!mIFeatureConfig.isVfbEnable()) {
                 mIFileSaver.init(FILE_TYPE.JPEG, 0, null, -1);
                 long time = System.currentTimeMillis();
-                mIFileSaver.savePhotoFile(data, null, time, mIModuleCtrl.getLocation(), 0,
-                        mFileSavedListener);
+                // mIFileSaver.savePhotoFile(data, null, time, mIModuleCtrl.getLocation(), 0,
+                //        mFileSavedListener);
             }
         }
     }
```

## ODM 开发用户常见需求文档

```
https://blog.csdn.net/zhangbijun1230/article/details/80821483   八
https://blog.csdn.net/zhangbijun1230/article/details/80821494   九
https://blog.csdn.net/qq_30796789/article/details/72459556      Android7.0 MTK 需求文档（二）
https://blog.csdn.net/qq_30796789/article/details/53782091      Android6.0 MTK 需求文档（六）
```

## 7.0 默认 mtp

```
（frameworks/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java）

diff --git a/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java b/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java  
index 9d3b655..4ac7646 100644  
--- a/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java  
+++ b/base/services/usb/java/com/android/server/usb/UsbDeviceManager.java  
@@ -453,7 +453,7 @@ functions = addFunction(functions, UsbManager.USB_FUNCTION_ACM);  
         private boolean mHostConnected;  
         private boolean mSourcePower;  
         private boolean mConfigured;  
-        private boolean mUsbDataUnlocked;  
+        private boolean mUsbDataUnlocked = true;  
         private String mCurrentFunctions;  
         private String mDefaultFunctions;  
         private boolean mCurrentFunctionsApplied;  
@@ -1361,7 +1361,7 @@ functions = addFunction(functions, UsbManager.USB_FUNCTION_ACM);  
                     mUsbConfigured = mConfigured;  
                     if (!mConnected) {  
                         // When a disconnect occurs, relock access to sensitive user data  
-                        mUsbDataUnlocked = false;  
+                    //  mUsbDataUnlocked = false;  
                     }  
                     updateUsbNotification();  
                     updateAdbNotification();  
@@ -1370,7 +1370,7 @@ functions = addFunction(functions, UsbManager.USB_FUNCTION_ACM);  
                         updateCurrentAccessory();  
                     } else if (!mConnected) {  
                         // restore defaults when USB is disconnected  
-                        setEnabledFunctions(null, false);  
+                  //    setEnabledFunctions(null, false);  
                     }  
                     if (mBootCompleted) {  
                         updateUsbStateBroadcastIfNeeded();  
```

## 理解Android硬件加速原理的小白文

```
https://blog.csdn.net/zhangbijun1230/article/details/80993207
```

## NFC 相关

```
https://blog.csdn.net/zhangbijun1230/article/details/82589171
https://blog.csdn.net/zhangbijun1230/article/details/82589034
https://blog.csdn.net/zhangbijun1230/article/details/82588816
https://blog.csdn.net/zhangbijun1230/article/details/82588770
https://blog.csdn.net/zhangbijun1230/article/details/82586436
https://blog.csdn.net/zhangbijun1230/article/details/82586391
```

## Android 保活技巧

```
https://blog.csdn.net/zhangbijun1230/article/details/82586391
https://blog.csdn.net/zhangbijun1230/article/details/81638694
https://blog.csdn.net/zhangbijun1230/article/details/81638669
https://blog.csdn.net/zhangbijun1230/article/details/81638600
```

## 优化 APK 安装时间长的问题

```
可以优化的方面：
1、改变APK install的模式为speed：android N采用JIT，执行阶段会透过dex2oat compile 所以log 中会看到JIT 相关thread 跑占用CPU较多状态
修改后，使APK安装阶段就进行compile，这样安装的时间会变成，部分APK 采用白名单，强制使用interpret only ，JIT 模式， 
2、调整：Aggressive LMK policy ，在背景process ，service 数量太多的情况下，调整后，可以更积极的去回收一些不重要的进程，缓解系统loading，和memory
3、调整pefservice， 延长app launch CPU，Vcore等boost 时间，
```

## MTK 平台如何PUSH modem 到手机中进行调试

```
1、编译eng或者userdebug版本：
   userdebug: adb shell setprop service.adb.root 1 
              再进入Settings->Developer options，取消 USB debugging，然后再重新勾选上，即可获得root权限
   eng版本可省略这一步。           
2、PUSH modem到手机命令：
adb remount
adb push xxxx.xx  /system/etc/firmware/


modem文件清单：
ltg: catcher_filter_1_ltg_n.bin dsp_1_ltg_n.bin modem_1_ltg_n.img
lwg: catcher_filter_1_lwg_n.bin dsp_1_lwg_n.bin modem_1_lwg_n.img
c2k: boot_3_3g_n.rom fsm_cust_df_3_3g_n.img fsm_rf_df_3_3g_n.img fsm_rw_df_3_3g_n.img modem_3_3g_n.img


3、重启机器
adb reboot
```

## 一张图看懂光圈、快门、感光度的意义

```
光圈越大，参照物越模糊。
快门越高，运动物越清晰。
感光度越大，照片糙点越多。
```

## 三、开机时间优化方法

```
3.1 开机过程中CPU调频调核（kernel，系统），开启多核和调高频率，关注功耗，优化。
3.2 开机过程PMS多线程进行包扫描
3.3 PMS扫描过程中直接根据应用的Native层库目录名称确定应用的ABI，加速扫描.
3.4 添加资源预加载优化
3.5 关闭系统层和Kernel层日志
3.6 分区挂载是否重复
3.7 开机日志分解定位是否有异常耗时点，针对性进行优化
```

## 减小 OTA 大小

```
减小 OTA 大小
本页介绍了为减少多次编译之间不必要的文件变更而对 AOSP 编译系统所做的改动。使用专有编译系统的设备实现人员可根据这项信息采取措施，减小无线下载 (OTA) 更新的大小。

有时，Android OTA 包含的变更文件并非源于代码变更，而是编译系统造成的。在不同时间、不同目录或不同机器上编译相同的代码时可能会发生上述情况，产生大量变更文件。这些多余的文件不仅会增加 OTA 的大小，还会导致难以确定 OTA 中发生变更的代码。

为了使 OTA 的内容更加透明，我们对 AOSP 编译系统做了多项改动，目的是消除多次编译之间不必要的文件变更，以此减小 OTA 的大小。这样做是为了减小 OTA 的大小，使其只包含与 OTA 中所含补丁程序相关的文件。AOSP 还包括编译 diff 工具（可过滤出常见的编译相关文件变更，并提供更清晰的编译文件 diff）以及块映射工具（可协助您确保块分配的一致性）。

编译系统可能会通过多种方式创建不必要的文件 diff。下文讨论了其中一些问题和解决方案，并尽可能提供了 AOSP 中的修复示例。

文件顺序
问题：文件系统在请求目录中的文件列表时，并不保证文件顺序，尽管对于同一个检出，文件顺序通常是相同的。ls 等工具在默认情况下会对结果进行排序，但 find 和 make 等命令使用的通配符函数却不会对结果进行排序。用户在使用这类工具之前，务必要对输出进行排序。

解决方案：用户在使用支持通配符的 find 和 make 等工具之前，务必要对这些命令的输出进行排序。要在 Android.mk文件中使用 $(wildcard) 或 $(shell find)，也应该进行排序。有些工具（如 Java）确实会对输入进行排序，因此有必要先对排序进行验证。

示例：多处问题在核心编译系统中通过内置的 all-*-files-under 宏得到修正，其中包括 all-cpp-files-under（一些定义分散在其他 makefile 中）。有关详情，请参阅以下 CL：

https://android.googlesource.com/platform/build/+/4d66adfd0e6d599d8502007e4ea9aaf82e95569f
https://android.googlesource.com/platform/build/+/379f9f9cec4fe1c66b6d60a6c19fecb81b9eb410
https://android.googlesource.com/platform/build/+/7c3e3f8314eec2c053012dd97d2ae649ebeb5653
https://android.googlesource.com/platform/build/+/5c64b4e81c1331cab56d8a8c201f26bb263b630c
编译目录
问题：变更编译内容所在的目录会导致二进制文件有所不同。Android 编译系统中的大多数路径都是相对路径，因此 C/C++ 中的 __FILE__ 不是问题。不过，默认情况下调试符号会对完整的路径名进行编码，而对预剥离二进制文件进行哈希处理会生成 .note.gnu.build-id，因此调试符号发生变更会致使二进制文件发生变化。

解决方案：AOSP 现在会使调试路径变成相对路径。有关详情，请参阅 CL：https://android.googlesource.com/platform/build/+/6a66a887baadc9eb3d0d60e26f748b8453e27a02。

时间戳
问题：编译输出中的时间戳会导致不必要的文件变更。这可能会发生在以下位置：

C 或 C++ 代码中的 __DATE__/__TIME__/__TIMESTAMP__ 宏。
基于 ZIP 的归档中嵌入的时间戳。
解决方案/示例：要从编译输出中移除时间戳，请遵循下文中的说明操作。

C/C++ 中的 __DATE__/__TIME__/__TIMESTAMP__
这些宏总是为不同的编译生成不同的输出，因此不建议使用。您可以选择通过以下方法来移除这些宏：

直接将其移除（这些宏通常不是必需的）。要查看示例，请参阅：https://android.googlesource.com/platform/system/core/+/30622bbb209db187f6851e4cf0cdaa147c2fca9f。
要对运行中的二进制文件进行唯一标识，请从 ELF 标头中读取 build-id。
要了解操作系统的编译时间，请读取 ro.build.date（应该会对除增量编译之外的所有内容都适用；增量编译可能不会更新此日期）。要查看示例，请参阅：https://android.googlesource.com/platform/external/libchrome/+/8b7977eccc94f6b3a3896cd13b4aeacbfa1e0f84。
注意：Android 7.0 开启了 -Werror=date-time，因此使用时间戳会导致编译错误。

归档文件（zip、jar）中的嵌入时间戳
Android 7.0 通过将 -X 添加到 zip 命令的所有用例中，解决了 zip 归档文件中嵌入时间戳的问题，因此编译工具的 UID/GID 和扩展的 Unix 时间戳不会嵌入到 ZIP 文件中。

新工具 ziptime（位于 /platform/build/+/master/tools/ziptime/ 下）会重置 zip 标头中的正常时间戳。有关详情，请参阅 README 文件。

signapk 工具为 APK 文件设置的时间戳可能会因服务器所在的时区而异。有关详情，请参阅 CL：https://android.googlesource.com/platform/build/+/6c41036bcf35fe39162b50d27533f0f3bfab3028。

版本字符串
问题：APK 版本字符串的硬编码版本通常附加了 BUILD_NUMBER。即使 APK 中并未发生任何其他变更，APK 也仍然会有所不同。

解决方案：从 APK 版本字符串中移除版本号。

示例：

https://android.googlesource.com/platform/packages/apps/Camera2/+/5e0f4cf699a4c7c95e2c38ae3babe6f20c258d27
https://android.googlesource.com/platform/build/+/d75d893da8f97a5c7781142aaa7a16cf1dbb669c
一致的编译工具
问题：生成安装文件的工具必须一致（相同的输入应始终生成相同的输出）。

解决方案/示例：以下编译工具需要进行变更：

NOTICE 文件创建工具。NOTICE 文件创建工具需要变更。请参阅 CL：https://android.googlesource.com/platform/build/+/8ae4984c2c8009e7a08e2a76b1762c2837ad4f64。
Java Android 编译器套件 (Jack)。Jack 工具链需要更新才能处理生成的构造函数排序的偶然性变更。请参阅 CL：https://android.googlesource.com/toolchain/jack/+/056a5425b3ef57935206c19ecb198a89221ca64b。
ART AOT 编译器 (dex2oat)。ART 编译器二进制文件需要更新才能创建确定性映像。请参阅 CL：https://android.googlesource.com/platform/art/+/ace0dc1dd5480ad458e622085e51583653853fb9。
libpac.so 文件 (V8)。每项编译会创建不同的 /system/lib/libpac.so 文件，因为 V8 快照会针对每项编译发生变更。解决方案是移除该快照。请参阅 CL：https://android.googlesource.com/platform/external/v8/+/e537f38c36600fd0f3026adba6b3f4cbcee1fb29。
预先经过 dexopt 处理的 (.odex) 应用文件。预先经过 dexopt 处理的 (.odex) 文件在 64 位系统上包含未初始化填充。请参阅 CL：https://android.googlesource.com/platform/art/+/34ed3afc41820c72a3c0ab9770be66b6668aa029。
使用编译 diff 工具
对于无法消除编译相关文件变更的情况，AOSP 纳入了编译 diff 工具 target_files_diff.py，以用于比较两个文件包。该工具会在两个编译之间执行递归 diff，从而排除常见的编译相关文件变更，例如：

编译输出中的预期变更（例如，由于版本号变更所导致）。
由于当前编译系统中的已知问题所导致的变更。
要使用编译 diff 工具，请运行以下命令：


 
target_files_diff.py dir1 dir2

dir1 和 dir2 是包含每个编译的提取目标文件的基础目录。

使块分配保持一致
在非 A/B OTA 中，影响时间的因素之一是块移动。对于给定的文件，尽管其内容在两个编译之间会保持不变，但实际持有数据的块可能已发生变化。因此，更新程序会在 OTA 期间执行不必要的 I/O 来四处移动块。

为了解决这个问题，我们在 Android 7.0 中扩展了 make_ext4fs 工具，该工具会尝试使块分配在各编译之间保持一致。make_ext4fs 会接受可选的 -d base_fs 标记，该标记会在生成 ext4 映像时尝试将文件分配给相同的块。您可以从上一个编译的目标文件 zip 文件（IMAGES/system.map 和 IMAGES/vendor.map）中提取块映射文件（即 base_fs 映射文件）。接下来，base_fs 文件便可以通过 PRODUCT_SYSTEM_BASE_FS_PATH 和 PRODUCT_VENDOR_BASE_FS_PATH 进行记录并指定。例如，


 
PRODUCT_SYSTEM_BASE_FS_PATH := path/to/base_fs_files/base_system.map PRODUCT_VENDOR_BASE_FS_PATH := path/to/base_fs_files/base_vendor.map

虽然这对减小整体的 OTA 更新包大小来说并无帮助，但它确实可以通过减少 I/O 量来改善 OTA 性能。
```

## 使用Android Studio调试Android Framework代码

```
3.生成android.ipr和android.iml文件
进入Android 源码根目录 
执行 
mmm development/tools/idegen/ 
这行命令的意思是编译idegen这个项目,生成idegen.jar文件.生成成功后,会显示这个jar包的位置,并显示 #### make completed successfully 
然后执行 
sh ./development/tools/idegen/idegen.sh 
这行命令的意思是生成对应的文件:android.iws, android.ipr, android.iml .

4.android studio导入源码
生成上述对应的文件后,打开Android Studio,选择打开一个现有的Android Studio项目,选择Android源码的根目录,导入即可(起作用的是android.irp文件).在配置sdk版本之后就可以查看Android 源码了. 
导入过程比较慢，可以打开android.iml参考网上文章过滤掉一些模块。

5.调试代码
Run->Attach debugger to Android process选择要调试的程序

选择要调试的程序。

这里选择了自己的一个程序，来调试ListView，虚拟机中国年滑动下ListView，编辑器中进入了断点，这样就可以开开心心的，一步一步研究android的一些源码的原理

注意： 
调试的时候，国产手机有的断点进不去，可能是厂商修改了framework的原因（具体有待考证）所以我这里使用的是虚拟机。
```

## 防止按钮连续点击

```
public class Utils {
    private static long lastClickTime;
    public static boolean isFastDoubleClick() {
        long time = System.currentTimeMillis();    
        if ( time - lastClickTime < 500) {
            return true;
        }
        lastClickTime = time;
        return false;
    }
}

public void onClick(View v) {
    if (Utils.isFastDoubleClick()) {
        return;
    }
}
```

## dump解码所得图片方法

```
https://blog.csdn.net/zhangbijun1230/article/details/81414385
```

## 无需刷机，查看rom包内的文件

```
静态调试
有时候为了确认系统内某些文件是否存在、是否编译了odex、反编译apk、反编译oat等，查看一些静态信息的时候，一般我们都会找一个机器通过flash_all，再等开机后adb 进去查看。这样一来很浪费时间，其实我们完全可以将system.img mount到本地pc上查看。

1）下载对应的rom包。

2）本地解压后找到对应的system.img。

3）通过本地编译时提供的host小工具命令simg2img（一般位于out/host/linux-x86/bin下）将system.img转化为raw img文件。simg2img system.img s.raw

4）本地创建挂载点目录，如mkdir system-host，接着直接通过mount s.raw system-host即可（注意mount需要root权限）。

5）挂载成功后，system-host就跟手机上system分区一模一样。
```

## 精简官方ROM并且内置ROOT权限，开启Romer之路

```
https://blog.csdn.net/qq_26787115/article/details/50736823
```

## 密码强度监测工具类

```
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class CheckPWD {
 
	public static Safelevel checkPasswordStrength(String c) {
		Safelevel d = Safelevel.WEAK;
		if (isEmptyPassword(c)) {
			return d;
		}
		if (isTooShort(c)) {
			d = Safelevel.WEAK;
		} else {
			if (hasNum(c) && hasLetter(c) && hasSymbol(c)) {
				d = Safelevel.SECURE;
			} else {
				if (hasNum(c) && hasLetter(c)) {
					d = Safelevel.STRONG;
				} else {
					if (hasNum(c) && hasSymbol(c)) {
						d = Safelevel.STRONG;
					} else {
						if (hasSymbol(c) && hasLetter(c)) {
							d = Safelevel.STRONG;
						} else {
							if (isAllNum(c) || isAllLetter(c) || isAllSymbol(c)) {
								d = Safelevel.WEAK;
							}
						}
					}
				}
			}
		}
		return d;
	}
 
	public enum Safelevel {
 
		WEAK, /* 弱 */
 
		STRONG, /* 强 */
 
		SECURE, /* 安全 */
 
	}
 
	public static boolean hasNum(String content) {
		boolean flag = false;
		Pattern p = Pattern.compile(".*\\d+.*");
		Matcher m = p.matcher(content);
		if (m.matches())
			flag = true;
		return flag;
 
	}
 
	public static boolean hasSymbol(String content) {
		boolean flag = false;
		Pattern p = Pattern.compile(".*[a-zA-Z0-9\\s<>;'\\\\]+.*");
		Matcher m = p.matcher(content);
		if (m.matches())
			flag = true;
		return flag;
 
	}
 
	public static boolean isAllSymbol(String content) {
		boolean flag = false;
		Pattern p = Pattern.compile("^[a-zA-Z0-9\\s<>;'\\\\]+$");
		Matcher m = p.matcher(content);
		if (m.matches())
			flag = true;
		return flag;
 
	}
 
	public static boolean hasSpace(String content) {
		boolean flag = false;
		Pattern p = Pattern.compile(".*\\s+.*");
		Matcher m = p.matcher(content);
		if (m.matches())
			flag = true;
		return flag;
 
	}
 
	public static boolean hasIllegalSymbol(String content) {
		boolean flag = false;
		Pattern p = Pattern.compile(".*[\\s<>;'\\\\].*");
		Matcher m = p.matcher(content);
		if (m.matches())
			flag = true;
		return flag;
 
	}
 
	public static boolean hasLetter(String content) {
		boolean flag = false;
		Pattern p = Pattern.compile(".*[a-zA-Z]+.*");
		Matcher m = p.matcher(content);
		if (m.matches())
			flag = true;
		return flag;
 
	}
 
	public static boolean isAllLetter(String content) {
		boolean flag = false;
		Pattern p = Pattern.compile("^[a-zA-Z]+$");
		Matcher m = p.matcher(content);
		if (m.matches())
			flag = true;
		return flag;
 
	}
 
	private static boolean isEmptyPassword(String b) {
		return (b == null || b.length() == 0);
	}
 
	private static boolean isTooShort(String b) {
		return b.length() < 6;
	}
 
	public static boolean isAllNum(String content) {
		boolean flag = false;
		Pattern p = Pattern.compile("^\\d+$");
		Matcher m = p.matcher(content);
		if (m.matches())
			flag = true;
		return flag;
 
	}
 
	public static boolean hasRepeat6Chars(String content) {
 
		boolean flag = false;
		Pattern p = Pattern.compile(".*([0-9a-zA-Z])\\1{5}.*");
		Matcher m = p.matcher(content);
		if (m.matches())
			flag = true;
		return flag;
 
	}
 
	public static boolean hasIncrease6Chars(String g) {
 
		if (g == null || g.length() < 6) {
			return false;
		}
		char h = g.charAt(0);
		char i = 1;
		char j = 1;
		for (j = 1; j < g.length(); j++) {
			char f = g.charAt(j);
			if (f == h + 1) {
				i++;
				if (i >= 6) {
					return true;
				}
			} else {
				i = 1;
			}
			h = f;
		}
		return false;
 
	}
 
	public static boolean hasDecrease6Chars(String g) {
 
		if (g == null || g.length() < 6) {
			return false;
		}
		char h = g.charAt(0);
		char i = 1;
		char j = 1;
		for (j = 1; j < g.length(); j++) {
			char f = g.charAt(j);
			if (f == h - 1) {
				i++;
				if (i >= 6) {
					return true;
				}
			} else {
				i = 1;
			}
			h = f;
		}
		return false;
 
	}
 
	public static boolean hasAllIncreaseChars(String g) {
 
		if (g == null) {
			return false;
		}
		int i = g.length();
		char h = g.charAt(0);
		char j = 1;
		char k = 1;
		for (k = 1; k < g.length(); k++) {
			char l = g.charAt(k);
			if (l == h + 1) {
				j++;
				if (j >= i) {
					return true;
				}
			} else {
				j = 1;
			}
			h = l;
		}
		return false;
 
	}
 
	public static boolean hasAllDecreaseChars(String g) {
		if (g == null) {
			return false;
		}
		int i = g.length();
		char h = g.charAt(0);
		char j = 1;
		char k = 1;
		for (k = 1; k < i; k++) {
			char l = g.charAt(k);
			if (l == h - 1) {
				j++;
				if (j >= i) {
					return true;
				}
			} else {
				j = 1;
			}
			h = l;
		}
		return false;
 
	}
 
	public static boolean isAllSameChars(String content) {
 
		if (content == null || content.length() < 2) {
			return false;
		}
		char h = content.charAt(0);
		char e = 1;
		for (e = 1; e < content.length(); e++) {
			char f = content.charAt(e);
			if (f != h) {
				return false;
			}
		}
		return true;
 
	}
 
}
```

## 深入Android源码系列（二） HOOK技术大作战

```
https://mp.weixin.qq.com/s?__biz=MzI1MjMyOTU2Ng==&mid=2247484652&idx=1&sn=7795db9405e1ed1594d751410ddb7c7a&chksm=e9e42fddde93a6cbc29e56518b38dbd4ebf86aafe299d1f0dcd80a1397d9bdfbd814c18d0111&scene=21#wechat_redirect
```

## Qualcomm平台android开发总结 （精）

```
https://blog.csdn.net/gjsisi/article/details/7716364
```

## pgrep 查看 ubuntu 下进程id

```
pgrep eclipse
```

## Log.wtf()的意思是What a Terrible Failure,而不是What The Fuck!

```
Log.wtf()的意思是What a Terrible Failure,而不是What The Fuck!
```

## 把 View 保存为 Bitmap

```
public static Bitmap createBitmap(View v) {
    v.setDrawingCacheEnabled(true);
    v.buildDrawingCache();
    Bitmap bitmap = Bitmap.createBitmap(v.getDrawingCache());
    v.setDrawingCacheEnabled(false);
    return bitmap;
}

public static Bitmap createBitmap(ScrollView v) {
    int width = 0, height = 0;
    for (int i = 0 ; i < v.getChildCount(); i++) {
        width += v.getChildAt(i).getWidth();
        height += v.getChildAt(i).getHeight();
    }
    Bitmap bitmap = Bitmap.createBitmap(width, height, ConfigARGB_8888);
    Canvas canvas = new Canvas(bitmap);
    v.draw(canvas);
    return bitmap;
}
```

## 反调试

```
方案策略总结
下面简单几句话总结这几种方案：

第一、自己附加进程，先占坑，ptrace(PTRACE_TRACEME, 0, 0, 0)！

第二、签名校验不可或缺的一个选择，本地校验和服务端校验双管齐下！

第三、借助系统api判断应用调试状态和调试属性，最基础的防护！

第四、轮训检查android_server调试端口信息和进程信息，防护IDA的一种有效方式！

第五、轮训检查自身status中的TracerPid字段值，防止被其他进程附加调试的一种有效方式！
```

## android处理资源文件复制到database区域java

```
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
 
import android.content.Context;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteException;
 
final public class CopyRawtodata {
 
	public static boolean CopyRawtodata(String path,String DbName,Context context,int id,boolean IsRawData)
	{
		boolean dbExist=checkDataBase(path,DbName);
		if(!dbExist)
		{
        	try{
        		copyDataBase(path,DbName,context,id,IsRawData);
        	}catch(IOException e){
        		throw new Error("Error copying database");
        	}
		}
		return true;
	}
	private static boolean checkDataBase(String path,String DbName)
	{
    	SQLiteDatabase checkDB = null;
    	try{
    		String databaseFilename = path+"/"+DbName;
    		checkDB =SQLiteDatabase.openDatabase(databaseFilename, null,
    				SQLiteDatabase.OPEN_READONLY);
    	}catch(SQLiteException e){
    		
    	}
    	if(checkDB!=null){
    		checkDB.close();
    	}
    	return checkDB !=null?true:false;
	}
	private static  void copyDataBase(String path,String DbName,Context context,int ResId,boolean IsRawData) throws IOException{
	    	String databaseFilenames =path+"/"+DbName;
	    	InputStream is;
	    	File dir = new File(path+"/");
	    	if(!dir.exists())//判断文件夹是否存在，不存在就新建一个
	    		dir.mkdir();
	    	FileOutputStream os = null;
	    	try{
	    		os = new FileOutputStream(databaseFilenames);//得到数据库文件的写入流
	    	}catch(FileNotFoundException e){
	    		e.printStackTrace();
	    	}
	    	if(IsRawData)
	    	{
	    		 is = context.getResources().openRawResource(ResId);//得到数据库文件的数据流
	    	}
	    	else
	    	{
	    		is = context.getResources().getAssets().open(DbName);//得到数据库文件的数据流
	    	}	
	        byte[] buffer = new byte[8192];
	        int count = 0;
	        try{
	        	
	        	while((count=is.read(buffer))>0){
	        		os.write(buffer, 0, count);
	        		os.flush();
	        	}
	        }catch(IOException e){
	        	
	        }
	        try{
	        	is.close();
	        	os.close();
	        }catch(IOException e){
	        	e.printStackTrace();
	        }
	    }
}
```

## adb reboot 的几个命令

```
adb reboot
adb reboot -p   //关机
adb reboot recovery
adb reboot fastboot
```

## OEM, ODM, OEM 的区别

```
OEM(Original Equipment Manufactuce，原始设备生产商)。
ODM(Original Design Manufactuce，原始设计制造商)
OBM(Orignal Brand Manufactuce，原始品牌制造商)
```

## MTK PA 相关 (power amplifier)

## Firda hook

```
https://blog.csdn.net/weixin_39190897/article/details/91979456
```

## Android获取设备CPU最大频率两种方案

```
//方案1
long result = 0L;
try {
    String line;
    BufferedReader br = new BufferedReader(new FileReader("/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq"));
    if ((line = br.readLine()) != null) {
        result = Long.parseLong(line);
    }
    br.close();
} catch (Exception e) {
    e.printStackTrace();
}
return result;


//方案2
long result = 0L;
try {
    String line;
    BufferedReader br = new BufferedReader(new FileReader("/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq"));
    if ((line = br.readLine()) != null) {
        result = Long.parseLong(line);
    }
    br.close();
} catch (Exception e) {
    e.printStackTrace();
}
return result;
```

## python爬虫

```
https://blog.csdn.net/mouday/article/details/83026074

将工具按照以上分类说明，按照学习路线顺序给出参考文章

一、页面下载器
requests(必学)

python爬虫入门requests模块
Python爬虫：requests库基本使用
Python爬虫：使用requests库下载大文件
Python爬虫：requests多进程爬取猫眼电影榜单
requests InsecureRequestWarning: Unverified HTTPS request is being made.
scrapy

Python网络爬虫之scrapy框架
scrapy学习
Python爬虫：关于scrapy模块的请求头
Python爬虫：scrapy框架请求参数meta、headers、cookies一探究竟
Python爬虫：scrapy辅助功能实用函数
selenium+chrome + PhantomJS(抓取动态网页，不推荐)

mac下安装selenium+phantomjs+chromedriver
Python爬虫：selenium模块基本使用
Python爬虫selenium模块
Python爬虫：selenium和Chrome无头浏览器抓取烯牛数据动态网页
Python爬虫：利用selenium爬取淘宝商品信息
Python爬虫：selenium使用chrome和PhantomJS实用参数
Splash(抓取动态网页，推荐)

Python爬虫：splash的安装与简单示例
Python爬虫：splash+requests简单示例
Python爬虫：scrapy利用splash爬取动态网页
总结：
对于下载器而言，python自带的urllib就不要花时间去学了，学了就忘，直接requests能满足大部分测试+抓取需求，进阶工程化scrapy，动态网页优先找API接口，如果有简单加密就破解，实在困难就使用splash渲染

二、页面解析器
BeautifulSoup(入门级)

Python爬虫入门BeautifulSoup模块
pyquery （类似jQuery）

Python爬虫：pyquery模块解析网页
lxml

Python爬虫：使用lxml解析网页内容
parsel

Extract text using CSS or XPath selectors
scrapy的Selector (强烈推荐, 比较高级的封装，基于parsel)

选择器(Selectors)
python爬虫：scrapy框架xpath和css选择器语法
总结：
其实解析器学习一个就够了，其他都不用学，很多培训会教你从上到下的学习，我不是很推荐，直接学习scrapy的Selector 就行，简单、直接、高效

三、数据存储
txt文本
Python全栈之路：文件file常用操作
csv文件
python读取写入csv文件
sqlite3 （python自带）
Python编程：使用数据库sqlite3
MySQL
SQL：pymysql模块读写mysql数据
MongoDB
Python编程：mongodb的基本增删改查操作
总结：
数据存储没有什么可深究的，按照业务需求来就行，一般快速测试使用MongoDB，业务使用MySQL

四、其他工具
execjs ：执行js
Python爬虫：execjs在python中运行javascript代码

pyv8: 执行js
mac安装pyv8模块-JavaScript翻译成python

html5lib
1. Python爬虫：scrapy利用html5lib解析不规范的html文本

五、关于xpath练习
本人的一个开源项目：PageParser
https://github.com/mouday/PageParser
用于解析网页，最终实现6行代码写爬虫，可以贡献代码，顺便练习网页解析的能力



requests包：是一个实用的python的http客户端库，编写爬虫从web上爬取数据时经常用到 ，简单实用，接口简单 ，requests.get(URL)。

lxml包：主要用来解析通过requests抓取的html内容，从中提取出我们需要的数据，在对html文本内容进行提取、筛选时用到的是xpath语法 ，lxml使用的是xpath语法对html内容进行的定位筛选提取。

lxml包的使用： 
通过lxml工具可以从html代码中提取我们需要的数据
一个网页就是一个html的文件  
需要通过lxml对一个html格式的文件内容进行组织（组织成一个树形结构） 
html文件是一个树形结构 - 类型linux系统的目录结构  
通过lxml组织成树形结构后，然后再使用xpath语法对内容进行定位、筛选、过滤


xpath的语法使用： 
路径表示（使用xpath语法来表示xml文本中标签的路径）
//div  定位到根节点下的所有的div标签，并返回一个可迭代对象
//div[class="j-r-list-c-desc"]/hl/text()   提取某个标签下的文本数据
/@href   提取的是某个标签下的属性名称为href的属性值

筛选条件 
//div[@class="link"] 定位到根目录下的包含class属性并且属性值为link的div标签
//div[li]  筛选出根目录下所有的包含li子标签的div标签
//div[@class] 筛选出包含class属性的div标签
```

## 抓包工具charles神器

```
1.下载

官方：https://www.charlesproxy.com

其他网站：https://www.52pojie.cn/thread-619994-1-1.html

需要破解，破解文件以及破解方法：Windows平台,将下载的charles.jar文件覆盖到安装目录下的lib文件夹下即可完成破解。Mac 平台,将下载的charles.jar文件右键 Charles.app 显示包内容,覆盖到Content->Java下即可完成破解。

最新版v4.2.0破解文件下载:链接: https://pan.baidu.com/s/1sl4YMK1 密码: b8cy

2.安装

省略

3.配置
a、 启用proxy代理，proxy菜单下勾选启用proxy
b、 安装charles root 证书或模拟器证书。菜单help>SSL Proxying
c、 设置http proxy代理
f、 本机为wifi热点，手机端设置代理，于模拟器方式设置代理相同。

4.使用
```

## Android中APK安装流程解析

```
复制APK安装包到/data/app目录下，解压缩并扫描安装包，向资源管理器注入APK资源，解析AndroidManifest文件，并在/data/data目录下创建对应的应用数据目录，然后针对Dalvik/ART环境优化dex文件，保存到dalvik-cache目录，将AndroidManifest文件解析出的组件、权限注册到PackageManagerService并发送广播。
```

## Android开发丶基于mupdf在Android设备上横竖屏查阅pdf文件

```
https://blog.csdn.net/u014078990/article/details/83011534
```

## 串口通信

```
https://blog.csdn.net/gd6321374/article/details/74779770
```

## FDex2脱壳(腾讯乐固、360加固一键脱壳)

```
https://zhuanlan.zhihu.com/p/45591754
```

## 基于Airtest的微信朋友圈自动点赞脚本设计与实现 

```
Airtest
Airtest官方文档

本脚本可以通过AirtestIDE和python执行，推荐使用AirtestIDE的环境执行，更稳定一些
AirtestIDE官方文档

使用python执行该脚本
安装库 airtest、pocoui
pip install airtest
pip install pocoui
代码如下

# -*- encoding=utf8 -*-
__author__ = "admin"
from airtest.core.api import *
from poco.drivers.android.uiautomation import AndroidUiautomationPoco

poco = AndroidUiautomationPoco(use_airtest_input=True, screenshot_each_action=False)
connect_device("Android://127.0.0.1:5037/f350e2f7")
print("start...")
PKG = "com.tencent.mm"  # 微信包名
stop_app(PKG)  # 关闭此app
wake()  # 唤醒并解锁设备
home()  # 返回HOME界面
start_app(PKG)  # 启动此app

poco(text='发现').wait(2).click()
pyq = poco(text='朋友圈')
pyq.click()

while True:
    try:
        # 评论按钮
        comments = poco("com.tencent.mm:id/eho")
        for comment in comments:
            childX, childY = comment.get_position()
            print(childX)
            print(childY)
            if (childY >= 0.1 and childY < 1.0):
                comment.click()
                zan = poco(text='赞')
                if zan.exists():
                    zan.click()
    except Exception as e:
        print('error'+str(e))
        keyevent("BACK")  # 有可能进入其它页面，调用系统级返回按钮
        if pyq.exists(): # 如果返回到发现页，重新进入朋友圈
            pyq.click()
    swipe((500, 1700), (500, 900))  # 向上滑动
```

## 逆向实战(破解恶意勒索软件)

```
https://blog.csdn.net/ALDYS4/article/details/92376145
```

## MBR分区简介

```
主引导记录（MBR，Main Boot Record）是位于磁盘最前边的一段引导（Loader）代码。它负责磁盘操作系统(DOS)对磁盘进行读写时分区合法性的判别、分区引导信息的定位，它由磁盘操作系统(DOS)在对硬盘进行初始化时产生的。

MBR 位于硬盘的 0 磁头、0 柱面、1 扇区，大小为 512 字节。它里面包含着操作系统里的分区信息。现在，我就简单介绍怎么从MBR作为入口点，获取系统的主分区、拓展分区以及逻辑分区。

编程实现对MBR数据读写
https://www.write-bug.com/article/1887.html
```

## 利用Accessibility分享朋友圈

```
public class AutoCopyService extends AccessibilityService {
 
    private String TARGET_UI = "";
    private String EDIT_TEXT_ID = "";
 
 
    @Override
    public void onAccessibilityEvent(final AccessibilityEvent event) {
        int eventType = event.getEventType();
        if (eventType == AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED || eventType == AccessibilityEvent.TYPE_WINDOW_CONTENT_CHANGED) {
            //
            getWeChatSupport();
            if (TARGET_UI.equals(event.getClassName())) {
                //如果当前页面是目标页面
                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
                    final AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();
                    if (nodeInfo == null) {
                        System.out.println(" onAccessibilityEvent error  null");
                        return;
                    }
                    if (TextUtils.isEmpty(EDIT_TEXT_ID)) {
                        Toast.makeText(this, "自动复制失败，并重试！", Toast.LENGTH_SHORT).show();
                        return;
                    }
                    List<AccessibilityNodeInfo> openId = nodeInfo.findAccessibilityNodeInfosByViewId(EDIT_TEXT_ID);
                    if (openId != null && openId.size() > 0) {
                        String timeLineContent = Preference.create(this).getPrefString("TIME_LINE_CONTENT", "");
                        if (!TextUtils.isEmpty(timeLineContent)) {
                            Bundle arguments = new Bundle();
                            arguments.putCharSequence(AccessibilityNodeInfo
                                    .ACTION_ARGUMENT_SET_TEXT_CHARSEQUENCE, timeLineContent);
                            openId.get(0).performAction(AccessibilityNodeInfo.ACTION_SET_TEXT, arguments);
                        }
                        Preference.create(this).setPrefString("TIME_LINE_CONTENT", "");
                    }
 
 
                    //-------------------------673版本處理方案----------------------------------------------
                    /**
                     * 添加按钮的GridView的Item的LinearLayout
                     * 667 com.tencent.mm:id/jz
                     * 673 com.tencent.mm:id/lr
                     */
                    int image_num = Preference.create(getApplicationContext()).getPrefInt("image_num", 0);
                    if (image_num <= 0)
                        return;
                    List<AccessibilityNodeInfo> imageAdd = nodeInfo.findAccessibilityNodeInfosByText("添加照片按钮");
                    if (null == imageAdd || imageAdd.isEmpty())
                        return;
 
                    List<AccessibilityNodeInfo> alreadyAdd = nodeInfo.findAccessibilityNodeInfosByText("图片");//已经添加的图片
                    //如果已经添加的图片数量 等于  模板图片的数量，则不用点击
                    if (null != alreadyAdd && alreadyAdd.size() == (image_num + 1)) {
                        return;
                    }
                    AccessibilityNodeInfo lin_image_add = imageAdd.get(0).getParent();
                    if (null == lin_image_add) {
                        return;
                    }
                    //点击相机小图片
                    lin_image_add.performAction(AccessibilityNodeInfo.ACTION_CLICK);
 
                    sleep(600);
 
                    //点击从相册选择
                    clickToChooseImage();
 
                }
            }
            //自动选择图片
            if ("com.tencent.mm.plugin.gallery.ui.AlbumPreviewUI".equals(event.getClassName())) {
                int image_num = Preference.create(getApplicationContext()).getPrefInt("image_num", 0);
                if (image_num <= 0) {
                    return;
                }
                sleep(500);
                AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();
 
                checkImage(nodeInfo);
 
            }
        }
    }
 
 
    //选择图片
    private void checkImage(AccessibilityNodeInfo nodeInfo) {
        //com.tencent.mm:id/bt3
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
            /**
             * 图片列表的CheckBoc上层的ImageVIew 代替点击的
             * 667 com.tencent.mm:id/bt4
             * 673 com.tencent.mm:id/bhl
             */
            int image_num = Preference.create(getApplicationContext()).getPrefInt("image_num", 0);
            int compat_num = Preference.create(getApplicationContext()).getPrefInt("compat_num", 0);
            if (null == nodeInfo) {
                if (compat_num > 0) {
                    sleep(1000);
                    performGlobalAction(AccessibilityService.GLOBAL_ACTION_RECENTS);
                    sleep(600);
                    performGlobalAction(AccessibilityService.GLOBAL_ACTION_BACK);
                    Preference.create(getApplicationContext()).setPrefInt("compat_num", 0);
                } else {
                    Preference.create(getApplicationContext()).setPrefInt("image_num", 0);
                    Toast.makeText(this, "当前手机不支持自动选择，请从第" + image_num + "个倒序手动选择图片", Toast.LENGTH_SHORT).show();
                }
                return;
            }
 
            List<AccessibilityNodeInfo> checkList = nodeInfo.findAccessibilityNodeInfosByViewId("com.tencent.mm:id/bhl");
            if (null == checkList || checkList.isEmpty()) {
                Preference.create(getApplicationContext()).setPrefInt("image_num", 0);
                Toast.makeText(this, "本次操作不支持自动选择，请从第" + image_num + "个倒序手动选择图片", Toast.LENGTH_SHORT).show();
                return;
            }
            if (image_num < checkList.size()) {
                for (int i = image_num - 1; i >= 0; i--) {
                    logger("addimage_click", String.format("点击第%d张", i));
                    checkList.get(i).performAction(AccessibilityNodeInfo.ACTION_CLICK);
                }
 
                clickSubmitImage(nodeInfo);
            }
        }
    }
 
 
    private void clickSubmitImage(AccessibilityNodeInfo nodeInfo) {
//        com.tencent.mm:id/hg
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
            /**
             * 完成 的 TextView
             * 667 com.tencent.mm:id/hg
             * 673 com.tencent.mm:id/j0
             */
            Preference.create(getApplicationContext()).setPrefInt("image_num", 0);
            List<AccessibilityNodeInfo> submit = nodeInfo.findAccessibilityNodeInfosByText("完成");
//            List<AccessibilityNodeInfo> submit = nodeInfo.findAccessibilityNodeInfosByViewId("com.tencent.mm:id/j0");
            if (null == submit || submit.isEmpty()) return;
            submit.get(0).performAction(AccessibilityNodeInfo.ACTION_CLICK);
 
        }
    }
 
    private void clickToChooseImage() {
        //
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.JELLY_BEAN_MR2) {
            final AccessibilityNodeInfo nodeInfo = getRootInActiveWindow();
            if (null != nodeInfo) {
                /**
                 * 点击添加图片的弹出框的ListView
                 * 667 com.tencent.mm:id/i7
                 * 673 com.tencent.mm:id/jq
                 */
                List<AccessibilityNodeInfo> textView = nodeInfo.findAccessibilityNodeInfosByText("从相册选择");
                if (textView.isEmpty()) return;
                try {
                    AccessibilityNodeInfo lin_item = textView.get(0).getParent().getParent();
                    if (TextUtils.equals(lin_item.getClassName(), "android.widget.LinearLayout"))
                        lin_item.performAction(AccessibilityNodeInfo.ACTION_CLICK);
                    logger("addimage_click", "跳转到选择图片列表");
                } catch (Exception e) {
                    logger("addimage_click", e.getMessage());
                }
 
 
            }
        }
    }
 
    private void sleep(long millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
 
    @Override
    public void onInterrupt() {
        logger("addimage_click", "onInterrupt 服务中断了");
 
    }
 
    @Override
    protected void onServiceConnected() {
        logger("addimage_click", "onServiceConnected success");
        getWeChatSupport();
        super.onServiceConnected();
    }
 
 
    /**
     * 加载微信的相关信息
     */
    private void getWeChatSupport() {
        String install_wechat_version_name = Preference.create(this).getPrefString("install_wechat_version_name", "");
        if (TextUtils.isEmpty(install_wechat_version_name))
            return;
        try {
            WechatSuppertEntity support = App.getDB().findById(WechatSuppertEntity.class, install_wechat_version_name);
            TARGET_UI = support.getTarget_ui();
            EDIT_TEXT_ID = support.getWechat_weiget_id();
        } catch (Exception e) {
            e.printStackTrace();
            TARGET_UI = "";
            EDIT_TEXT_ID = "";
        }
    }
 
    private void logger(String tag, String message) {
        boolean isDebug = x.isDebug();
        if (isDebug) {
            LoggerPrinter.saveLogger("自动辅助服务：tag:" + tag + "--->message:" + message);
        }
    }
}
```

## Android通过辅助功能 AccessibilityService 实现抢微信红包原理简单介绍

```
https://segmentfault.com/a/1190000019931725?utm_source=tag-newest
```

## 棋牌搭建，APP新手搭建教程

```
https://blog.csdn.net/weixin_43813691/article/details/86525701
```

## Android recovery图片资源制作

```
一、文字图片转换
png 图片生成源码：development/tools/recovery_l10n/
recovery_l10n 在 o上已经没有源码了，需要从kk上移植过来
原生的源代码有个bug，导致读取出来的Locale[]数组值全部为空，无法完成图片的制作。

diff --git a/tools/recovery_l10n/src/com/android/recovery_l10n/Main.java b/tools/recovery_l10n/src/com/android/recovery_l10n/Main.java
index 3f2bebe..5da5592 100755
--- a/tools/recovery_l10n/src/com/android/recovery_l10n/Main.java
+++ b/tools/recovery_l10n/src/com/android/recovery_l10n/Main.java
@@ -150,7 +150,7 @@ public class Main extends Activity {
         Arrays.sort(localeNames);
         ArrayList<Locale> locales = new ArrayList<Locale>();
         for (String ln : localeNames) {
-            int u = ln.indexOf('_');
+            int u = ln.indexOf('-');
             if (u >= 0) {
                 Log.i(TAG, "locale = " + ln);
                 locales.add(new Locale(ln.substring(0, u), ln.substring(u+1)));
1、res\values-zh-rCN\strings.xml用于显示中文文字，可以修改里面的中文文字为您所需要的。
2、res\layout\main.xml用于改变文字格式，如大小、字体等。
3、然后使用mm编译出out\target\product…\system\app\RecoveryLocalizer.apk。
4、安装打开后选择需要的文字图片后点击go按钮。
5、取出图片：adb pull data/data/com.android.recovery_l10n/files/text-out.png
6、生成的图片还不能直接替换系统图片，需要在Ubuntu环境下作进一步处理
（如未安装 pngcrush，请先安装 ：sudo apt-get install pngcrush）
pngcrush -c 0 text-out.png output.png

二、android5.1 logo动画
android5.1的logo动画是单张多帧PNG图片
1、安装python、pip、PIL 图形库
2、python interlace-frames.py .\src1.png .\src2.png .\src3.png .\src4.png .\src5.png .\src6.png .\src7.png .\src8.png .\dst.png

三、android8.1 logo动画
android8.1的logo动画是多张8位深度png的图片
用 imagemagick 工具的 convert 命令转换     sudo apt-get install imagemagick
//convert src.png -colorspace gray dst.png
convert image.png -define png:color-type=2 result.png

bit_depth（8）channels（3）color_type（2）



// 转换图片的脚本
#!/bin/bash
# get all filename in specified path

path=$1
files=$(ls $path)
for filename in `find . -name "*.png"`;
do
    echo "convert"$filename
    convert $filename -define png:color-type=2 $filename
done



查看png图片信息
sudo apt-get install pngtools
pnginfo bootable/recovery/res-mdpi/images/error_text.png

显示结果如下:
error_text.png...
  Image Width: 163 Image Length: 2582
  Bitdepth (Bits/Sample): 8
  Channels (Samples/Pixel): 1
  Pixel depth (Pixel Depth): 8
  Colour Type (Photometric Interpretation): GRAYSCALE 
  Image filter: Single row per byte filter 
  Interlacing: No interlacing 
  Compression Scheme: Deflate method 8, 32k window
  Resolution: 0, 0 (unit unknown)
  FillOrder: msb-to-lsb
  Byte Order: Network (Big Endian)
  Number of text strings: 0

使用 convert 命令转换之后查看图片信息显示结果如下：
error_text.png...
  Image Width: 163 Image Length: 2582
  Bitdepth (Bits/Sample): 8
  Channels (Samples/Pixel): 3
  Pixel depth (Pixel Depth): 24
  Colour Type (Photometric Interpretation): RGB 
  Image filter: Single row per byte filter 
  Interlacing: No interlacing 
  Compression Scheme: Deflate method 8, 32k window
  Resolution: 0, 0 (unit unknown)
  FillOrder: msb-to-lsb
  Byte Order: Network (Big Endian)
  Number of text strings: 0


转换之后的 channels 和 pixel depth 和 Colour Type 都已经发生了变化
```

## PNG图片文件的种类

```
https://blog.csdn.net/csdn66_2016/article/details/72303400

6.2 PNG支持的种类

    并非所有的PNG图片，在recovery下面都可以显示，这也是很多人会遇到的问题，明明是png图片，怎么还是不能显示呢，recovery原生对png图片的支持如下：

      bit_depth         channels        color_type

         8                 3                2

        <=8                1                0

        <=8                1                3

    其中bit_depth是位深度, channels是指支持的颜色的种类，color_type是值颜色类型。我们需要记住的是：

    bit_depth不能大于8。

    color_type值有 PNG_COLOR_TYPE_GRAY（0）

                   PNG_COLOR_TYPE_RGB（2）

                   PNG_COLOR_TYPE_PALETTE（3）

channels值，与color_type有关，PNG_COLOR_TYPE_GRAY 与 PNG_COLOR_TYPE_PALETTE 时，只有一种颜色，PNG_COLOR_TYPE_RGB 时有三种颜色

6.3 判断PNG属性方法

我们上节描述了，通过三个属性，来看一个png图片是否能在recovery中显示，当我们拿到一个png图片的时候，怎么分析呢，我们可以写个小的获取png info的程序。

第一步：编译 libpng.a 库文件

我们从官网下载png的源码，http://www.libpng.org/pub/png/libpng.html，注意 linux/ubuntu 系统下需要下载 libpng-1.6.37.tar.gz 的压缩包(否则编译的时候会出现 /bin/sh^M:bad interpreter: No such file or directory 的错误)，然后解压，然后编译：./configure CC=gcc --prefix=$PWD/_install, make, make install; 然后就可以生成 libpng.a 以及 png.h 相关文件了。

第二步：写 sample

pnginfo.c

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include "png.h"
 
int main(int argc ,char **argv) {
    unsigned char header[8];
    size_t bytesRead;
    int result = 0;
    FILE* fp = NULL;
    png_structp png_ptr = NULL;
    png_infop info_ptr = NULL;
    int color_type, bit_depth;
    png_uint_32 width;
    png_uint_32 height;
    png_byte channels;
 
    if (argc !=2 ) {
        printf("eg:./pnginfo png_name\n");
        return -1;
    }
 
    fp = fopen(argv[1], "rb");
    if (fp == NULL) {
        result = -1;
        goto exit;
    }
 
    bytesRead = fread(header, 1, sizeof(header), fp);
    if (bytesRead != sizeof(header)) {
        result = -2;
        goto exit;
    }
 
    if (png_sig_cmp(header, 0, sizeof(header))) {
        result = -3;
        goto exit;
    }
 
    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
    if (!png_ptr) {
        result = -4;
        goto exit;
    }
 
    info_ptr = png_create_info_struct(png_ptr);
    if (!info_ptr) {
        result = -5;
        goto exit;
    }
 
    if (setjmp(png_jmpbuf(png_ptr))) {
        result = -6;
        goto exit;
    }
 
    png_init_io(png_ptr, fp);
    png_set_sig_bytes(png_ptr, sizeof(header));
    png_read_info(png_ptr, info_ptr);
 
    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth,
            &color_type, NULL, NULL, NULL);
 
    channels = png_get_channels(png_ptr, info_ptr);
 
    printf("pnginfo bit_depth:%d, channels:%d, color_type:%d\n", bit_depth, channels, color_type);
 
exit:
    if (fp != NULL) {
        fclose(fp);
        fp = NULL;
    }
 
    printf("pnginfo result:%d\n", result);
    return result;
}




makefile:
CC=gcc
TARGET=pnginfo
 
%.o:%.c
	$(CC) -c $(CFLAGS) $(CPPFLAGS) -o $@ $<
 
all:pnginfo.o
	$(CC) -o $(TARGET) $< -L. -lpng -lz -lm
 
clean:
	rm -rf *.o $(TARGET)

执行make即可生成pnginfo
TODO : 这一步 make 的时候失败了，不知道如何解决？？？？

第三步：获取png属性
./pnginfo icon_error.png

6.4 png转换
使用如下命令转换 convert image.png -define png:color-type=2 result.png
如果我拿到的png图片，不支持怎么办呢，我们可以使用PS工具，把png图片转换为recovery可支持的格式即可，如果又不太会使用PS工具呢，还有个更简单的方法，采用QQ的截图功能，然后另存为png图片即可，QQ截图保存的png是标准的RGB格式，即 bit_depth（8）channels（3）color_type（2）
    

6.5 总结
通过上述了解，现在知道了recovery的图片资源文件png的信息了，怎么去判断png是否能够在recovery中显示，以及如果制作recovery支持的png背景图片了。
```

## dos 系统文件转换成 unix 系统文件

```
如何确认是 dos 系统文件
用 vi 打开文件可以看到文件每一行的末尾都有 ^M 的字符
方法1：用 dos2unix 命令可以转换

方法2：在 windows 上用 EditPlus 打开文件，双击右下角状态栏文件格式相关的那一栏，会弹出一个对话框让你选择转换成什么系统的文件格式 PC / UNIX/Mac / MacOS9
```

## TODO : 如何获取和修改文件的头信息？？

## TODO : 长连接抓包 anyproxy

## Android 系统签名实现的三种方式

```
在项目开发时，如果需要使应用具有系统权限，例如可以支持静默安装和卸载APK，此时就需要使用系统签名。
常用的系统签名方式包括在ubuntu环境下、手动签名和在AndroidStudio环境配置，三种方式中，实现最简单的是通过AndroidStudo方式，该方式的签名实现与正常的APK签名相同，唯一不同的就是签名文件是通过系统生成的。
注意，无论采用何种签名方式，如果想实现具有系统权限的应用，在APK生成时，都需要在AndroidManifest.xml中配置android:sharedUserId=“android.uid.system”，如下所示

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.xxxx.xxxx"
    android:sharedUserId="android.uid.system">
</manifest>

1. ubuntu环境编译
该方式需要在安卓源码编译的环境下，在将APK打包至安卓系统升级包时，需要配置Android.mk文件，通过在配置LOCAL_CERTIFICATE 参数时，将其设置为PRESIGNED，如果需要改APK具有系统权限，使用系统签名，则需要设置为platform

LOCAL_CERTIFICATE := platform 或 shared 或 media

在设置好 Android.mk 文件后，在ubuntu环境下执行系统的编译流程。
如果之前在ubuntu环境下已经执行好了系统的编译流程，则可以直接cd到系统的package/apps目录下，进入到需要编译的APK文件目录下执行mm指令，或在其他目录执行mmm /package/apps/APK所在的文件夹名称。

2.手动签名
手动系统签名与Android的APK重签名不同，重签名是之前APK已经签名完成，在实际使用时，需要更改签名文件，例如一些特殊的算法处理对于系统的包名和签名都有绑定操作，如更换则无法使用。
手动系统签名是对于通过AndroidStudio的build生成的无签名的APK文件，进行手动系统签名操作。具体执行过程如下。

2.1 下载SignApk.jar
首先下载SignApk.jar包，如下图所示
如果本地有安卓系统的源码，可以直接在本地的build\tools\signapk目录下查找到该jar包。

2.2 查找security文件
拿到系统定制厂商提供的security文件，不同编译下生成的security文件内容不同，需针对该安卓系统下的编译生成的security文件，因此这也限定了该系统签名后的应用只能在该系统下运行，在其他系统下运行就不具有系统权限。
在security文件中找到media.pk8和platform.x509.pem两个文件。

2.3 执行系统签名操作
将2.1中的SignApk.jar和2.2中的media.pk8和platform.x509.pem文件一起复制到包含需要签名的APK文件夹中，然后执行如下语句

java -jar signapk.jar  platform.x509.pem platform.pk8　old.apk new.apk

生成的new.apk文件就是系统签名后APK文件。
该方式的操作，可参考安卓签名工具SignApk.jar使用教程，其已将签名的流程制作成Window下的.exe工具，只需一次配置，每次点击更换需要签名的文件即可。

3 AndroidStudio方式
通常对于APK的签名文件是通过AndroidStudio的New Key Store方式自定义实现，但是如果需要使用系统签名文件需要结合security文件中的media.pk8和platform.x509.pem两个文件，通过keytool-importkeypair实现，下载成功后，将media.pk8和platform.x509.pem两个文件放置在包含 keytool-importkeypair目前下，执行以下语句。

./keytool-importkeypair -k ./platform.keystore -p android -pk8 platform.pk8 -cert platform.x509.pem -alias platform

需要注意的是：

该语句的执行是在 ubuntu 环境下执行的
platform.keystore 为系统签名文件
android 为签名密码
platform 为签名的别名(alias)
生成系统签名后，在 AndroidStudio 中配置 Signing 签名信息，配置成功后在 module 的 buid.gradle 中可以查看如下配置信息。

signingConfigs {
    releaseConfig {
        keyAlias 'platform'
        keyPassword 'android'
        storeFile file('.........platform.keystore')//签名文件路径
        storePassword 'android'
    }
}
4.总结
从以上的分析中可以看出，无论三种那种方式的实现，都离不开系统源码中的security目录下的media.pk8和platform.x509.pem两个文件，该两个文件是保证应用具有系统签名的前提，如果使用其他系统的文件，则在该系统中，无法具有系统权限。
对比以上方法，分为具有ubuntu和没有两种环境下。

具有ubuntu的编译环境：则使用第一种比较简单，第三种生成的系统签名文件，可用于其他APK的签名使用，在AndroidStudio中配置后，方便调试使用，不必每次都执行命令行来生成签名后的APK文件。
不具有ubuntu的编译环境：该方式只能通过第二种方式实现，且每次调试使用时都需要替换APK生成新的系统签名后的APK，操作比较繁琐。当然在2.3中也提到，可借助其他同学制作的小工具方便签名文件的使用。
```

## 设置网络代理

```
设置代理：
adb shell settings put global http_proxy ip:port
adb shell settings put global http_proxy 127.0.0.1:8888
移除代理：
adb shell settings delete global http_proxy
adb shell settings delete global global_http_proxy_host
adb shell settings delete global global_http_proxy_port

其实还可以安装第三方应用实现代理功能，不过没什么意义，上述两种方法基本可以解决大部分场景
```

## 在 PhoneWindowManager 中用 WindowState 获取栈顶Activity

```
public boolean isTopActivityFactoryTool(WindowState win) {
    if(win != null){
        String topPackageName = win.getOwningPackage();
        if (("com.cp.packagename1".equals(topPackageName) || "com.cp.packagename2".equals(topPackageName))) {
            Log.d(TAG,"top activity is " + topPackageName);
            return true;
        }
    }
    return false;
}
```

## Android 屏蔽Power键 Home键 在InputDispatcher.cpp中处理

```
frameworks/base/native/services/inputflinger/InputDispatcher.cpp

void InputDispatcher::notifyKey(const NotifyKeyArgs* args) {
#if DEBUG_INBOUND_EVENT_DETAILS
    ALOGD("notifyKey - eventTime=%lld, deviceId=%d, source=0x%x, policyFlags=0x%x, 
    action=0x%x, flags=0x%x, keyCode=0x%x, scanCode=0x%x,
    metaState=0x%x, downTime=%lld",
            args->eventTime, args->deviceId, args->source, args->policyFlags,
            args->action, args->flags, args->keyCode, args->scanCode,
            args->metaState, args->downTime);
#endif
    if (!validateKeyEvent(args->action)) {
        return;
    }

    uint32_t policyFlags = args->policyFlags;
    int32_t flags = args->flags;
    int32_t metaState = args->metaState;
    if ((policyFlags & POLICY_FLAG_VIRTUAL) || (flags &
            AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY)) {
        policyFlags |= POLICY_FLAG_VIRTUAL;
        flags |= AKEY_EVENT_FLAG_VIRTUAL_HARD_KEY;
    }
    if (policyFlags & POLICY_FLAG_FUNCTION) {
        metaState |= AMETA_FUNCTION_ON;
    }

    policyFlags |= POLICY_FLAG_TRUSTED;

    int32_t keyCode = args->keyCode;
    if (metaState & AMETA_META_ON && args->action == AKEY_EVENT_ACTION_DOWN) {
        int32_t newKeyCode = AKEYCODE_UNKNOWN;
        if (keyCode == AKEYCODE_DEL) {
            newKeyCode = AKEYCODE_BACK;
        } else if (keyCode == AKEYCODE_ENTER) {
            newKeyCode = AKEYCODE_HOME;
        }
        if (newKeyCode != AKEYCODE_UNKNOWN) {
            AutoMutex _l(mLock);
            struct KeyReplacement replacement = {keyCode, args->deviceId};
            mReplacedKeys.add(replacement, newKeyCode);
            keyCode = newKeyCode;
            metaState &= ~AMETA_META_ON;
        }
    } else if (args->action == AKEY_EVENT_ACTION_UP) {
        // In order to maintain a consistent stream of up and down events, check to see if the key
        // going up is one we've replaced in a down event and haven't yet replaced in an up event,
        // even if the modifier was released between the down and the up events.
        AutoMutex _l(mLock);
        struct KeyReplacement replacement = {keyCode, args->deviceId};
        ssize_t index = mReplacedKeys.indexOfKey(replacement);
        if (index >= 0) {
            keyCode = mReplacedKeys.valueAt(index);
            mReplacedKeys.removeItemsAt(index);
            metaState &= ~AMETA_META_ON;
        }
    }

    KeyEvent event;
    event.initialize(args->deviceId, args->source, args->action,
            flags, keyCode, args->scanCode, metaState, 0,
            args->downTime, args->eventTime);

    mPolicy->interceptKeyBeforeQueueing(&event, /*byref*/ policyFlags);

    bool needWake;
    { // acquire lock
        mLock.lock();

        if (shouldSendKeyToInputFilterLocked(args)) {
            mLock.unlock();

            policyFlags |= POLICY_FLAG_FILTERED;
            if (!mPolicy->filterInputEvent(&event, policyFlags)) {
                return; // event was consumed by the filter
            }

            mLock.lock();
        }

        int32_t repeatCount = 0;
        //add your control code here
        if(false){
            //origin source code
        }else{
            //your self source code
        }
        #ifdef CONTROL_KEY_CODE
            //your self source code
        #else
            //origin source doce
        #endif
        KeyEntry* newEntry = new KeyEntry(args->eventTime,
                args->deviceId, args->source, policyFlags,
                args->action, flags, keyCode, args->scanCode,
                metaState, repeatCount, args->downTime);

        needWake = enqueueInboundEventLocked(newEntry);
        mLock.unlock();
    } // release lock

    if (needWake) {
        mLooper->wake();
    }
}
```

## Android捕获监听Home键、最近任务列表键

```
package zhangphil.home;
 
import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.Bundle;
import android.widget.Toast;
 
public class MainActivity extends Activity {
	private MyReceiver receiver;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		// setContentView(R.layout.activity_main);
		receiver = new MyReceiver();
		IntentFilter homeFilter = new IntentFilter(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
		registerReceiver(receiver, homeFilter);
	}

	@Override
	public void onDestroy() {
		unregisterReceiver(receiver);
		super.onDestroy();
	}

	private class MyReceiver extends BroadcastReceiver {
		private final String SYSTEM_DIALOG_REASON_KEY = "reason";
		private final String SYSTEM_DIALOG_REASON_HOME_KEY = "homekey";
		private final String SYSTEM_DIALOG_REASON_RECENT_APPS = "recentapps";
 
		@Override
		public void onReceive(Context context, Intent intent) {
			String action = intent.getAction();
			if (action.equals(Intent.ACTION_CLOSE_SYSTEM_DIALOGS)) {
				String reason = intent.getStringExtra(SYSTEM_DIALOG_REASON_KEY);
 
				if (reason == null) {
					return;
				}
 
				// Home键
				if (reason.equals(SYSTEM_DIALOG_REASON_HOME_KEY)) {
					Toast.makeText(getApplicationContext(), "按了Home键", Toast.LENGTH_SHORT).show();
				}
 
				// 最近任务列表键
				if (reason.equals(SYSTEM_DIALOG_REASON_RECENT_APPS)) {
					Toast.makeText(getApplicationContext(), "按了最近任务列表", Toast.LENGTH_SHORT).show();
				}
			}
		}
	}
}
```

## activity 标签中 android:logo 和 android:icon 的区别

```
其中android:icon就是你的安卓应用图标，比如在桌面上显示的应用图标。
而logo是什么时候被使用呢？ActionBar上有一个图标，那个图标就是使用的android:logo对应的那个资源，一般是一个drawble的资源。
```

## android 获取 versionName 和 versionCode 以及作用

```
android:versionCode: 
主要是用于版本升级所用，是INT类型的，第一个版本定义为1，以后递增，这样只要判断该值就能确定是否需要升级，该值不显示给用户。 
android:versionName: 
这个是我们常说明的版本号，由三部分组成..,该值是个字符串，可以显示给用户。 
关于版本号有两个值，如下面的例子

android:versionCode="2"
android:versionName="1.1"

versionCode是给设备程序识别版本(升级)用的，必须是一个interger值，整数，代表app更新过多少次

versionName是给用户看的，可以写1.1.1 , 1.1.2的形式

延伸出另外一个问题：当app需要校对版本的时候怎样读取这个值？

//eclipse获取versionCode和versionName 这两个参数是写在manifest.xml文件中
public void getEclipseVersionInfo(){
    int versioncode;
    String versionname;
    PackageManager pm = getPackageManager();
    try {
        PackageInfo packageInfo = pm.getPackageInfo(getPackageName(), 0);
        versioncode = packageInfo.versionCode;
        versionname = packageInfo.versionName;
    } catch (PackageManager.NameNotFoundException e) {
        e.printStackTrace();
    }
}
//在Android Studio中获取到versionname和versionCode 这两个参数是写在${modle_name}.gradle文件中

public void getASVersionName() {
    int versionCode = BuildConfig.VERSION_CODE;
    String versionName = BuildConfig.VERSION_NAME;
}
这样我们就可以拿到versioncode和versionname了，这里我们看到使用到了BuildConfig类（是从项目包下的配置文件，即 我们的包名.BuildConfig;），可以导入这个类后Ctrl+单击查看这个类,里面还有其他的参数

手机型号: android.os.Build.MODEL 
SDK版本: android.os.Build.VERSION.SDK
系统版本: android.os.Build.VERSION.RELEASE
```

## Android 实现连点两次返回后退出整个App

```
主要是监听onBackPressed来实现在两秒之内连点两次实现退出App，一般使用在首页。。
以下是源代码和实现的效果：
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
    if (keyCode == KeyEvent.KEYCODE_BACK) {
        if ((System.currentTimeMillis() - mExitTime) > 2000) {
            Toast.makeText(this, "再按一次退出程序", Toast.LENGTH_SHORT).show();
            mExitTime = System.currentTimeMillis();
        } else {
            finish();
        }
        return true;
    }
    return super.onKeyDown(keyCode, event);
}
```

## 反射调用 SystemProperties

```
public static public String getProperty(String key, String defaultValue) {
    String value = defaultValue;
    try {
        Class<?> c = Class.forName("android.os.SystemProperties");
        Method get = c.getMethod("get", String.class, String.class);
        value = (String)(get.invoke(c, key, "unknown" ));
    } catch (Exception e) {
        e.printStackTrace();
    }finally {
        return value;
    }
}
```

## TODO : 在O,P系统上使用反射调用hide的方法和变量？？

## 截屏的几种方法

```
// 第一种 ： 5.0 之后开放了截屏的方法
if (Build.VERSION.SDK_INT >= 21) {
    startActivityForResult(((MediaProjectionManager) getSystemService("media_projection")).createScreenCaptureIntent(),1);
} else {
    Log.e("TAG", "版本过低,无法截屏");
}

@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    switch (requestCode) {
        case REQUEST_MEDIA_PROJECTION: {
            if (resultCode == -1 && data != null) {
                parseData(data);
            }
        }
    }
}

private void parseData(Intent data){
	MediaProjection mMediaProjection = (MediaProjectionManager).getSystemService(
            Context.MEDIA_PROJECTION_SERVICE).getMediaProjection(Activity.RESULT_OK,data);
        ImageReader mImageReader = ImageReader.newInstance(
                getScreenWidth(),
                getScreenHeight(),
                PixelFormat.RGBA_8888,1);

	VirtualDisplay mVirtualDisplay = mMediaProjection.createVirtualDisplay("screen-mirror",
            getScreenWidth(),
            getScreenHeight(),
            Resources.getSystem().getDisplayMetrics().densityDpi,
            DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR,
            mImageReader.getSurface(), null, null);

	Handler handler = new Handler();
    handler.postDelayed(new Runnable() {
       @Override
       public void run() {
           Image image = mImageReader.acquireLatestImage();
           // TODO 将image保存到本地即可
       }
    }, 300);

	mVirtualDisplay.release();
	mVirtualDisplay = null;
}

// 第二种 ： 使用 decorView
public static Bitmap capture(Activity activity) {
    activity.getWindow().getDecorView().setDrawingCacheEnabled(true);
    Bitmap bmp = activity.getWindow().getDecorView().getDrawingCache();
    return bmp;
}

public static Bitmap shotActivity(Activity ctx) {
    View view = ctx.getWindow().getDecorView();
    view.setDrawingCacheEnabled(true);
    view.buildDrawingCache();
    Bitmap bp = Bitmap.createBitmap(view.getDrawingCache(), 0, 0, view.getMeasuredWidth(),
    view.getMeasuredHeight());
    view.setDrawingCacheEnabled(false);
    view.destroyDrawingCache();
    return bp;
}

// 第三种 ： 使用 screencap 命令
adb shell screencap -p /sdcard/sreenshot1.png

// 长截屏
// scrollView 截屏
public static Bitmap shotScrollView(ScrollView scrollView) {
    int h = 0;
    Bitmap bitmap = null;
    for (int i = 0; i < scrollView.getChildCount(); i++) {
        h += scrollView.getChildAt(i).getHeight();
        scrollView.getChildAt(i).setBackgroundColor(Color.parseColor("#ffffff"));
    }
    bitmap = Bitmap.createBitmap(scrollView.getWidth(), h, Bitmap.Config.RGB_565);
    final Canvas canvas = new Canvas(bitmap);
    scrollView.draw(canvas);
    return bitmap;
}

// listView 截屏
public static Bitmap shotListView(ListView listview) {
    ListAdapter adapter = listview.getAdapter();
    int itemscount = adapter.getCount();
    int allitemsheight = 0;
    List<Bitmap> bmps = new ArrayList<Bitmap>();
    for (int i = 0; i < itemscount; i++) {
        View childView = adapter.getView(i, null, listview);
        childView.measure(
        View.MeasureSpec.makeMeasureSpec(listview.getWidth(), View.MeasureSpec.EXACTLY),
        View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));
        childView.layout(0, 0, childView.getMeasuredWidth(), childView.getMeasuredHeight());
        childView.setDrawingCacheEnabled(true);
        childView.buildDrawingCache();
        bmps.add(childView.getDrawingCache());
        allitemsheight += childView.getMeasuredHeight();
    }

    Bitmap bigbitmap = Bitmap.createBitmap(listview.getMeasuredWidth(), allitemsheight, Bitmap.Config.ARGB_8888);
    Canvas bigcanvas = new Canvas(bigbitmap);
    Paint paint = new Paint();
    int iHeight = 0;

    for (int i = 0; i < bmps.size(); i++) {
        Bitmap bmp = bmps.get(i);
        bigcanvas.drawBitmap(bmp, 0, iHeight, paint);
        iHeight += bmp.getHeight();
        bmp.recycle();
        bmp = null;
    }
    return bigbitmap;
}

// recyclerView 截屏
public static Bitmap shotRecyclerView(RecyclerView view) {
    RecyclerView.Adapter adapter = view.getAdapter();
    Bitmap bigBitmap = null;
    if (adapter != null) {
      int size = adapter.getItemCount();
      int height = 0;
      Paint paint = new Paint();
      int iHeight = 0;
      final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024);

      // Use 1/8th of the available memory for this memory cache.
      final int cacheSize = maxMemory / 8;
      LruCache<String, Bitmap> bitmaCache = new LruCache<>(cacheSize);
      for (int i = 0; i < size; i++) {
        RecyclerView.ViewHolder holder = adapter.createViewHolder(view, adapter.getItemViewType(i));
        adapter.onBindViewHolder(holder, i);
        holder.itemView.measure(
            View.MeasureSpec.makeMeasureSpec(view.getWidth(), View.MeasureSpec.EXACTLY),
            View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));
        holder.itemView.layout(0, 0, holder.itemView.getMeasuredWidth(),
            holder.itemView.getMeasuredHeight());
        holder.itemView.setDrawingCacheEnabled(true);
        holder.itemView.buildDrawingCache();
        Bitmap drawingCache = holder.itemView.getDrawingCache();
        if (drawingCache != null) {

          bitmaCache.put(String.valueOf(i), drawingCache);
        }
        height += holder.itemView.getMeasuredHeight();
      }

      bigBitmap = Bitmap.createBitmap(view.getMeasuredWidth(), height, Bitmap.Config.ARGB_8888);
      Canvas bigCanvas = new Canvas(bigBitmap);
      Drawable lBackground = view.getBackground();
      if (lBackground instanceof ColorDrawable) {
        ColorDrawable lColorDrawable = (ColorDrawable) lBackground;
        int lColor = lColorDrawable.getColor();
        bigCanvas.drawColor(lColor);
      }

      for (int i = 0; i < size; i++) {
        Bitmap bitmap = bitmaCache.get(String.valueOf(i));
        bigCanvas.drawBitmap(bitmap, 0f, iHeight, paint);
        iHeight += bitmap.getHeight();
        bitmap.recycle();
      }
    }
    return bigBitmap;
}

// 第四种：完美截屏(优雅的方案实现屏幕截图，利用android 5.0之后的录屏API实现截屏)
https://github.com/BruceWind/AndroidScreenShot_SysApi


https://android-notes.github.io/2016/12/03/android%E9%95%BF%E6%88%AA%E5%B1%8F%E5%8E%9F%E7%90%86/
https://juejin.im/post/5a33403b6fb9a045132abdb6
https://mp.weixin.qq.com/s/JPVZtErFTzJ5PDuTAPk0DA
```

## 仿 wechat 和 支付宝 防止截屏？？？

```
getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE)

设置安全窗口，禁用系统截屏。防止 App 中的一些界面被截屏，并显示在其他设备中造成信息泄漏。（常见手机设备系统截屏操作方式为：同时按下电源键和音量键。）
比如支付宝 App 的“向商家付款”的包含付款二维码的界面。（补充说明一点，微信付款界面不是这么做的，采用的是在 onResume() 生命周期方法中实时刷新付款二维码，与支付宝在安全方法采取的手段不同。）
```

## Android性能指标

```
https://blog.csdn.net/xiaoru5127/article/details/84862668
```

## system.transfer.list深度解析

```
system.transfer.list  system.new.dat
很明显，通过名字我们就知道这两个文件的作用，system.new.dat为数据部分，system.transfer.list为转换的描述列表，我们可以通过这两个文件完成升级。

我们打开一个升级包的升级脚本META-INF\com\google\android\updater-script
block_image_update("/dev/block/system", package_extract_file("system.transfer.list"), "system.new.dat", "system.patch.dat");
调用的是block_image_updater接口，传入system.transfer.list及system.new.dat文件来实现升级。

block_image_updater的代码实现在
bootable/recovery/updater/blockimg.cpp中：
void RegisterBlockImageFunctions() {
  RegisterFunction("block_image_verify", BlockImageVerifyFn);
  RegisterFunction("block_image_update", BlockImageUpdateFn);
  RegisterFunction("block_image_recover", BlockImageRecoverFn);
  RegisterFunction("check_first_block", CheckFirstBlockFn);
  RegisterFunction("range_sha1", RangeSha1Fn);
}
想了解具体实现的过程，可以另行深入研究，本文不再探讨。

我们来看看system.transfer.list：
3
133943
0
0
new 48,0,32770,32897,32899,33411,65535,65536,65538,98304,98306,98433,98435,98947,131071,131072,131074,163840,163842,163969,163971,164483,195737,196608,196610,229376,229378,229505,229507,230019,235652,262144,262146,294912,294914,295041,295043,327680,327682,360448,360450,393216,393218,425984,425986,458752,458754,491520,491522
zero 70,32770,32897,32899,33411,65535,65536,65538,66050,97792,98304,98306,98433,98435,98947,131071,131072,131074,131586,163328,163840,163842,163969,163971,164483,195737,196608,196610,197122,228864,229376,229378,229505,229507,230019,235652,236164,261632,262144,262146,262658,294400,294912,294914,295041,295043,295555,327168,327680,327682,328194,359936,360448,360450,360962,392704,393216,393218,393730,425472,425984,425986,426498,458240,458752,458754,459266,491008,491520,491522,492034
erase 24,66050,97792,131586,163328,197122,228864,236164,261632,262658,294400,295555,327168,328194,359936,360962,392704,393730,425472,426498,458240,459266,491008,492034,524288


其中：
3 ： 为transfer的版本，目前已经支持从1-4版本
133943：为总共new的block数量。
0： stash slots没有使用，所以这里两个都是0
0：
new：需要写入的block块范围总数：总共48个范围，【0-32770】 【32897-32899】【33411-65535】......
zero：需要填充0的block块范围总数：总共70个范围，【32770-32897】 【32899-33411】.......
erase：需要擦除的block块范围总数：总共24个范围，【66050-97792】 【131586-163328】.......


system.transfer.list是由build/tools/releasetools/blockimgdiff.py生成的，我们来验证下前面几个参数：
    out.insert(0, "%d\n" % (self.version,))   # format version number
    out.insert(1, "%d\n" % (total,))
    # v3+: the number of stash slots is unused.
    out.insert(2, "0\n")
    out.insert(3, str(max_stashed_blocks) + "\n")

    with open(prefix + ".transfer.list", "wb") as f:
      for i in out:
        f.write(i)
第一行是版本，第二行是total的block数量，由于没有使用stash，第三行四行为0。


我们再次验证下总共写入的total是否正确。
1.我们先确认block的大小，blockimg.cpp中定义为4K
static constexpr size_t BLOCKSIZE = 4096;

2.确认升级包中system.new.dat的大小，其值为548630528
$ ls -l system.new.dat
-rwxr--r-- 1 xxxxxx.xx szsoftware 548630528 Mar 19 16:37 system.new.dat

3.我们再来计算下总共需要写入的total
total=system.new.dat/block=548630528/4096=133943，刚好即为写入的总的total。


我们再来看看这些所有的new zero erase的描述区间
【0-32770】【32770-32897】【32897-32899】...【66050-97792】...【492034-524288】
   new                      zero                     new                      erase                      erase

总共524288个block需要处理
524288*4096=2147483648byte=2048Mb=2G
正好为我们ext4 system 分区的大小，也就是我们把整个2G的system分区按照4096的大小分割，然后给每个block赋予了new/zero/erase的属性，然后保存到transfer.list文件，把所有需要new的数据，生成了new.dat文件。

在最新的version=4的版本中，我们发现system.new.dat文件不见了，增加了vendor.new.dat.br文件，并且计算的时候，发现了vendor.new.dat.br文件打大小变小了，原来是最新的版本，加入了压缩功能，vendor.new.dat.br为采用压缩后的block数据部分。
```

## 恢复出厂设置的脚本

```
#/bin/sh

rm -rf /cache/recovery/command
echo "--wipe_data" > /cache/recovery/command
echo "--wipe_cache" >> /cache/recovery/command
sync
sync
sleep 1
sync
sync
reboot recovery

把以上脚本写到一个 reset.sh 文件中
push reset.sh 到 /data/local/tmp/
adb shell sh /data/local/tmp/reset.sh


恢复出厂设置的流程
(1)用户在系统设置中选择了“恢复出厂设置”。
(2)Android 系统在/cache/recovery/command 中写入“--wipe_data”。
(3)设备重启后发现了 command 命令,于是进入 recovery。
(4)recovery 将在 BCB(bootloader control block)中写入“boot-recovery”和“--wipe_data”具体是在 get_args()函数中——这样即便设备此时重启,也会再进入 erase 流程。
(5)通过 erase_volume 来重新格式化/data。
(6)通过 erase_volume 来重新格式化/cache。
(7)finish_recovery 将擦除 BCB,这样设备重启后就能进入正常的开机流程了。
(8)main 函数调用 reboot 来


OTA升级的流程
(1)OTA 包的下载过程参见前一小节的介绍。假设包名是 update.zip,存储在 SDCard 中。
(2)系统在/cache/recovery/command 中写入"--update_package=[路径名]"。
(3)系统重启后检测到 command 命令,因而进入 recovery。
(4)get_args 将在 BCB 中写入"boot-recovery" 和 "--update_package=..." —— 这样即便此时设备重启,也会尝试重新安装 OTA 升级包。
(5)install_package 开始安装 OTA 升级包。
(6)finish_recovery 擦除 BCB,这样设备重启后就可以进入正常的开机流程了。
(7)如果 install 失败的话:prompt_and_wait 显示错误,并等待用户响应;用户重启(比如拔掉电池等方式)。
(8)main 调用 maybe_install_firmware_update,OTA 包中还可能包含 radio/hboot firmware 的更新,具体过程略。
(9)main 调用 reboot 重启系统。


ps:
command 支持的几个命令
--send_intent=anystring             将 text 输出到 recovery.intent 中
--update_package=path               安装 OTA 包
--wipe_data                         擦除 user data,然后重启
--wipe_cache                        擦除 cache(不包括 user data),然后重启
--set_encrypted_filesystem=on|off   enable/disable 加密文件系统
--just_exit                         直接退出,然后重启


//恢复出厂设置流程分析
https://blog.csdn.net/kehyuanyu/article/details/47054325
```

## android build 编译打印详细过程

```
我们在make otapackage编译android代码的时候，有时候需要跟踪详细的过程，包括所有的过程，可以修改build/core/Makefile，赋值hide ：= 为空即可

# Put some miscellaneous rules here

# HACK: clear LOCAL_PATH from including last build target before calling
# intermedites-dir-for
LOCAL_PATH := $(BUILD_SYSTEM)

# Pick a reasonable string to use to identify files.
ifneq (,$(filter eng.%,$(BUILD_NUMBER)))
  # BUILD_NUMBER has a timestamp in it, which means that
  # it will change every time.  Pick a stable value.
  FILE_NAME_TAG := eng.$(USER)
else
  FILE_NAME_TAG := $(BUILD_NUMBER)
endif

# modified begin
hide :=
# modified end
```

## Fuzz 是什么玩意 ？？？

```
模糊测试定义为“通过向应用提供非预期的输入并监控输出中的异常来发现软件中的故障(faults)的方法”。典型而言,模糊测试利用自动化或是半自动化的方法重复地向应用提供输入。显然,上述定义相当宽泛,但这个定义阐明了模糊测试的基本概念。 
用于模糊测试的模糊测试器(fuzzer)分为两类:一类是基于变异(mutation-based)的模糊测试器,这一类测试器通过对已有的数据样本进行变异来创建测试用例;而另一类是基于生成(generation-based)的模糊测试器,该类测试器为被测系统使用的协议或是文件格式建模,基于模型生成输入并据此创建测试用例。这两种模糊测试器各有其优缺点
```

## Android 关机实现

```
private void shutDown(){
    Intent intent = new Intent("android.intent.action.ACTION_REQUEST_SHUTDOWN");
    intent.putExtra("android.intent.extra.KEY_CONFIRM", false);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
    startActivity(intent);
}

需要在AndroidManifest.xml里添加 
Android:sharedUserId=”android.uid.system”和”权限。 
android:sharedUserId=”android.uid.system”是将自己的程序加入到了系统的进程中，同时也将获得系统的权限。需要添加系统签名。 

当然，这些代码在eclipse里会报错（我当时用的是eclipse），把这些错误报告删掉，强行编译就可以了。具体做法是把problems里的把与它相关的错误报告删除掉。Windows-show view-other-搜索problems可以找到错误报告。上机用时需要添加系统签名，不然安装不上。

签名用目标系统的platform密钥来重新给apk文件签名。在我的Android源码目录中的位置是”build\target\product\security”，下面的platform.pk8和platform.x509.pem两个文件。然后用Android提供的Signapk工具来签名，signapk的源代码是在”build\tools\signapk”下，用法为”signapk 
platform.x509.pem platform.pk8 input.apk 
output.apk”，文件名最好使用绝对路径防止找不到，也可以修改源代码直接使用。

root过的手机也可以用 Runtime 执行 su reboot -p 命令来关机
```

## TODO : 学习使用 Jekins 持续化集成方案？？？？

## misc分区即"miscellaneous"(杂项)

## 解析 ramdisk.img

```
首先对 ramdisk.img 执行 file 命令,得到如下结果:
$file ramdisk.img
ramdisk.img: gzip compressed data, from Unix
$gzip –d ramdisk.img.gz
这说明它是一个 gZip 的压缩文件。我们将其改名为 ramdisk.img.gz,再进行解压。具体命令
如下:
这时会得到另一个名为 ramdisk.img 的文件,不过文件类型变了:
$file ramdisk.img
ramdisk.img: ASCII cpio archive (SVR4 with no CRC)
由此可知,这时的 ramdisk.img 是 CPIO 文件了。
再来执行以下操作:
$cpio -i -F ramdisk.img
3544 blocks
```

## dm-verity

```
从 4.4 版本开始,Android 结合 Kernel 的 dm-verity 驱动能力实现了一个名为“Verified Boot”的
安全特性,以期更好地保护系统本身免受恶意程序的侵害。我们在本小节将向大家讲解这一特性的基
本原理,以便读者们在无法成功利用 fastboot 写入 image 时可以清楚地知道隐藏在背后的真正原因。
dm-verity           Linux kernel 的一个驱动,用于在运行时态验证文件系统分区的完整性(判断依据是Hash Tree 和Signed metadata)
Boot State          保护等级,分为 GREEN、YELLOW、ORANGE 和 RED 四种
Device State        表明设备接受软件刷写的程度,通常有 LOCKED 和 UNLOCKED 两种状态
Keystore            公钥合集
OEM key Bootloader  用于验证 boot image 的 key
```

## odex文件

```
ODEX 是 Optimized Dalvik Executable 的缩写,从字面意思上理解,就是经过优化的 Dalvik 可执行文件。
```

## ABI (Application Binary Interface)

## CM

```
CyanogenMod
http://www.cyanogenmod.org/
```

## jack编译方式和传统编译方式的区别

```
当然,如果开启了 Jack 编译,那么依赖关系会有所不同。Jack 与传统编译方式一个重要的区别就是,它会直接生成最终的 dex 文件—不过在 Static Java Library 的情况下它还需要生成.jack 文件。

Jack 并不输出中间状态的 jar 文件,而是直接得到最终的 dex 产物—这也是它会导致一些分析工具失效的原因,例如著名的 Jacoco 代码覆盖率工具。

android 整体编译失败之后如果log不容易看出问题的话，可以把 -j 设置为 1 之后再编译就比较容易看出问题
```

## envsetup.sh 相关

```
envsetup.sh 除了提供很多实用的函数外, envsetup.sh 在文件的最后还会扫描和加载 device 和 vendor 目录下的 vendorsetup.sh 文件
vendorsetup.sh 会通过 add_lunch_combo 命令来为 lunch 添加一条加载项
```

## TODO : 尝试在 envsetup.sh 脚本中添加自己的脚本并且定制自己的命令 ???

## 快速定位android的启动耗时

```
cat /proc/bootprof

https://mp.weixin.qq.com/s?__biz=MzI1MjMyOTU2Ng==&mid=2247485130&idx=1&sn=8fa8b69d5257f65692b60cbdfbddfbb8&chksm=e9e42dfbde93a4ed1f3d9ed4229893f9ab563035c3a49f690be1c35389d94e3e23c392d046b8#rd
```

## 一次性关闭所有的Activity

```
ActivityManager am = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);   
am.restartPackage(getPackageName()); 
系统会将，该包下的 ，所有进程，服务，全部杀掉，就可以杀干净了，要注意加上
<uses-permission android:name="android.permission.RESTART_PACKAGES" />
```

## 自动滚动ListView

```
<ListView android:id="@android:id/list" 
    android:layout_width="fill_parent" 
    android:layout_height="fill_parent" 
    android:stackFromBottom="true" 
    android:transcriptMode="alwaysScroll" />
```

## TODO : Android 上如何使用 FTP ？？？

## [Snippet]获得手机UA

```
public String getUserAgent(){
    String user_agent = ProductProperties.get(ProductProperties.USER_AGENT_KEY, null);
    return user_agent;
}
```

## javac 编译带中文的java文件报错unmappable character for encoding GBK。

```
问题：进行以上Java编译的时候，出现unmappable character for encoding GBK。

我的解决方法：当我将编译改写为javac -encoding UTF-8 Exerc02.java就可以正常输出。
我的分析：我的电脑字符集默认的是GBK,有什么办法能改为unicode么？
 
你用javac -encoding UTF-8 Exerc02.java能正常输出, 说明你的java文件的编码是utf8
你用javac Exerc02.java编译出错, 说明你的系统默认编码不是utf8
推测你应该是window系统吧
记事本打开Exerc02.java文件, 文件另存为-->选择编码ANSI保存（采用强大的编辑器UltraEdit）
然后javac Exerc02.java就可以编译了
```

## 编译打包java文件生成jar包的流程

```
方法1：通过eclipse中的export导出来，但这样生成的 jar 包会包含一些其他jar包，导致生成的jar包比较大

方法2：通过命令行打包
javac -encoding UTF-8 Main.java                 //生成 .class 字节码文件
jar cvf Main.jar Main.class     //生成 Main.jar 文件
然后用 rar 等压缩工具打开 Main.jar , 在 META-INF/MANIFEST.MF 文件的最下面添加 Main-Class: Main
或
jar cvfe libparser.jar  ParseApk  ParseApk.class    //直接把第二个参数 ParseApk 设置为 Main-Class，写入到 MANIFEST.MF 文件中
```

## TODO : [爬虫]学习使用 htmlunit 抓取网页？？？？

```
如何模拟登录？？
获取 MTK FAQ 的解析地址？？？
```

## 拦截 Back 键，使 App 进入后台而不是关闭

```
@Override
public void onBackPressed() {
    Intent launcherIntent = new Intent(Intent.ACTION_MAIN);
    launcherIntent.addCategory(Intent.CATEGORY_HOME);
    startActivity(launcherIntent);
}
```

## bitmap.extractAlpha()

```
从源 bitmap 中根据 alpha 获取一个新的 bitmap 对象。比较绕口，通常 App 中的 Icon 多数是纯色透明像素背景组成，利用这个方法可以对该图的非透明区域着色，有多种使用场景，常见如 Button 的 pressed 状态，View 的阴影状态等。举个例子：
private static Bitmap getDropShadow(ImageView iv, Bitmap src, float radius, int color) {

    final Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
    paint.setColor(color);

    final int width = src.getWidth(), height = src.getHeight();
    final Bitmap dest = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    final Canvas canvas = new Canvas(dest);
    final Bitmap alpha = src.extractAlpha();
    canvas.drawBitmap(alpha, 0, 0, paint);

    final BlurMaskFilter filter = new BlurMaskFilter(radius, BlurMaskFilter.Blur.OUTER);
    paint.setMaskFilter(filter);
    canvas.drawBitmap(alpha, 0, 0, paint);
    iv.setImageBitmap(dest);

    return dest;
}
```

## 通过反射获取资源

```
public class ResourceMan {
    public static int getResId(String variableName, Class<?> c) {
        try {
            Field idField = c.getDeclaredField(variableName);
            return idField.getInt(idField);
        } catch (Exception e) {
            e.printStackTrace();
            return -1;
        }
    }
}

int id = ResourceMan.getResId("icon", R.drawable.class);

据说这种方法比用 getIdentifier() 方法快5倍，而且不需要context对象
```

## TODO : FileProvider

```
https://www.jianshu.com/p/3c554d3983d8
```

## 从ota卡刷包recovery-from-boot.p生成recovery.img

```
如果手机官方没有提供线刷包，和无法通过手机里面提取recovery情况下可以尝试提供卡刷包来生成官方recovery.img，当然你的OTA卡刷包里面必须要有boot.img、recovery-from-boot.p、install-recovery.sh三个文件缺一不可，然后利用android applypatch来生成，system/bin/目录下即可。
1、applypatch指令帮助： shell@ha3g:/data/local/tmp $ applypatch
usage: applypatch [-b ] <src-file> <tgt-file> <tgt-sha1> <tgt-size>
[: …]
or applypatch -c <file> [ …]
or applypatch -s <bytes>
or applypatch -l
2、将applypatch、boot.img、recovery-from-boot.p推送（adb push ）到/data/local/tmp/目录；给予applypatch 755quan 3、打开nstall-recovery.sh文件： #!/system/bin/sh
update_recovery –check-sha1 908410f138130a19caf8fbbc2f2d89496f6caa41 \
–src-sha1 a56291c5b942895ecf64da89e55c5ac444b5a939 \
–tgt-sha1 f44fd8fdc4bc4382fab01f5eb966ee9956b42120 \
–tgt-size 11330560 \
–patch /system/recovery-from-boot.p
其中：src-sha1表示recovery-from-boot.p的sha1值；tgt-size表示recovery的大小；tgt-sha1表示recovery的sha1值；
4、生成命令如下： applypatch <boot文件> <recovery.img tgt-sha1值> <tgt-sized大小> <src-sha1值>:recovery-from-boot.p 如：applypatch boot.img recovery.img f44fd8fdc4bc4382fab01f5eb966ee9956b42120 11330560 a56291c5b942895ecf64da89e55c5ac444b5a939:recovery-from-boot.p
5、生成成功入下图所示：

```

## TODO : app增量升级方案

```
https://www.jianshu.com/p/f70e31755bcd
```

## 文件上传

```
https://www.runoob.com/w3cnote/android-tutorial-upload-file.html

https://topmanopensource.iteye.com/blog/1605238
```

## strace

```
分析发烫的应用进程在干嘛
需要用到linux下的strace命令，但是android是没有集成这个命令的，android版本的下载地址：
http://benno.id.au/android/strace
下载完成后，上传到手机中：
我们adb push strace /system/bin，在模拟器上是上传到/system/bin会报out of memory错误，我们也可以上传到/data目录下，如果没有执行权限，还需要chmod 777 strace.
strace命令有很多参数，直接执行strace会显示使用说明:

其中-p参数输入的就是进程号，第一步中我们找到com.tianxia.test的进程ID是644，我们看看这个应用占用这么高的cpu在干嘛？

strace -p 644
输出如下：

它的系统调用一直是gettimeofday,一直输出这个，显然哪里一定进入死循环了，而且是获取时间的死循环，然后结合logcat和代码，定位这段代码(就是前面我们给出的那段代码了)解决这个bug。
```

## 采集某个应用的内存数据

```
# !/system/bin/sh
#这个脚步比较粗糙，是这么个意思
file=/sdcard/cpu/mem_info.log
rm $file
until [ 1 -gt 10000 ]
do
echo -e "\n\n\n\n\n---------------">>$file
date >> $file
dumpsys meminfo com.tianxia.test >> $file
sleep 3
done
```

## @ ? 的用法和解释

```
Syntax
Now let's see what is the actual syntax for referencing different resources.

Referencing resources (@)
@[package_name:]resource_type/resource_name

package_name - optional name of the package this resource belongs to (by default - your app package). Reserved package - android. Used for resources shipping with platform
resource_type - the R subclass for the resource type (attr, color, string, dimen, etc)
resource_name - an actual name of the resource we are trying to reference.
Let's actually take my first 2 examples and try to break them down:

android:background="@color/colorPrimary"
android:background="@com.myapp:color/colorPrimary"
As you can see - both of them are equivalent since by default, package name is set to our app's package name, so it is not necessary to mention it:

package(optional) = com.myapp
resource_type = color
resource_name = colorPrimary
As you might think, Android ships with some predefined resources for entire OS. F.i. I could reference some built-in color this way:

android:background="@android:color/holo_orange_dark"
Here is what we got in this case:

package = android - referencing built-in resources
resource_type = color
resource_name = holo_orange_dark
PLEASE NOTE

Nowadays, lots of people use AppCompat (and if you don't - you probably should), and AppCompat often defines its own resources. Even though AppCompat is a first-party lib shipped by Google, it is not really a part of operating system. Instead, those resources get merged into your app, so you don't need to use android keyword to reference those.

Example:

android:background="?selectableItemBackground"
Here, even though we don't have custom style attribute name selectableItemBackground in our app (notice that we didn't use android: prefix), we can still reference it because it was "added" to our app by AppCompat.

Referencing style attributes (?)
Guess what. The syntax is pretty similar to resources: 
?[package_name:][resource_type/]resource_name

There one small difference though.

The only allowed resource_type when referencing style attributes is attr. So given that, Android packaging tool actually allows us to omit resource_type, so it is effectively optional.

So following expressions mean exactly the same thing from Android perspective:

android:background="?com.myapp:attr/colorPrimary" //verbose format
android:background="?com.myapp:colorPrimary" //attr is skipped since its optional
android:background="?attr/colorPrimary" //package is skipped since its optional 
android:background="?colorPrimary"  // package & attr is skipped
```

## [术语]GSI

```
What is Generic System Image (GSI)?
Android GSI is a full OS image that matches with AOSP source code. To application developers, GSI is a tool, similar to emulator, to enable developers to perform early application development and validation on future OS versions: if an application works on GSI then it should execute smoothly on future certified OEM platforms that have the same Android API level.
```

## ClassLoader和DexClassLoader

```
上面说到JAVA的动态加载的机制就是通过ClassLoader来实现的，ClassLoader也是实现反射的基石。ClassLoader是JAVA提供的一个类，顾名思义，它就是用来加载Class文件到JVM，以供程序使用的。

但是问题来了，ClassLoader加载文件到JVM，但是Android是基于DVM的，用ClassLoader加载文件进DVM肯定是不行的。于是Android提供了另外一套加载机制，分别为 dalvik.system.DexClassLoader 和 dalvik.system.PathClassLoader，区别在于 PathClassLoader 不能直接从 zip 包中得到 dex，因此只支持直接操作 dex 文件或者已经安装过的 apk（因为安装过的 apk 在 cache 中存在缓存的 dex 文件）。而 DexClassLoader 可以加载外部的 apk、jar 或 dex文件，并且会在指定的 outpath 路径存放其 dex 文件。

ClassLoader在JAVA中的应用
下面利用反射来调用另一个类中的方法

//定义一个测试类，用来被反射调用
package com.izzy;
public class Test {
    private String s;
    //构造方法
    public Test(String s) {
        this.s = s;
    }
    //定义一个方法，用来输出，构造方法中传递进来的参数
    public void display() {
        System.out.println(s);
    }

}

package com.izzy;
import java.lang.reflect.Constructor;
public class Client {
    public static void main(String[] s) {
        try {
            //首先拿到系统ClassLoader，并加载Class，返回的是一个Class对象clazz 
            Class clazz = ClassLoader.getSystemClassLoader().loadClass("com.izzy.Test");
            //通过clazz 拿到构造方法并转换成对象
            Constructor constructor = clazz.getConstructor(String.class);
            Object obj = constructor.newInstance("I AM IZZY");
            //通过clazz 拿到成员方法
            Method method = clazz.getMethod("display", null);
            method.invoke(obj, null);
        } catch (Exception e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}

DexClassLoader在Android中的应用
以一个例子来说明DexClassLoader用法（本例采用两个已安装的Apk），现在有两个Apk：Share和Test，利用Test来调用Share 里面的方法。

首先在Share　apk中定义Share类，其中有一个display()方法提供给远程调用

public class Share {
    public void display(String s) {
        Log.e("IZZY", s);
    }
}



public void getFromRemote() {
    Intent intent = new Intent("com.IZZY");
    PackageManager pm = getPackageManager();
    List<ResolveInfo> resolveInfos = pm.queryIntentActivities(intent, 0);

    ResolveInfo resolveInfo = resolveInfos.get(0);
    ActivityInfo activityInfo = resolveInfo.activityInfo;
    //拿到目标类的包名
    String packageName = activityInfo.packageName;

    //拿到目标类所在的apk或者jar存放的路径
    String dexPath = activityInfo.applicationInfo.sourceDir;
    //该路径为拿到目标类dex文件存放在调用者里的路径
    String dexOutputDir = getApplicationInfo().dataDir;
    //拿到目标类所使用的C/C++库存放路径
    String nativeLibraryDir = activityInfo.applicationInfo.nativeLibraryDir;
    //拿到类装载器
    ClassLoader classLoader = getClassLoader();

    //DexClassLoader参数分别对应以上四个参数
    DexClassLoader dcl = new DexClassLoader(dexPath,dexOutputDir,nativeLibraryDir,classLoader);
    try {
        //装载目标类
        Class<?> clazz = dcl.loadClass(packageName + ".Share");
        //拿到构造器并实例化对象
        Constructor<?> constructor = clazz.getConstructor();
        Object o = constructor.newInstance();
        //拿到成员方法
        Method display = clazz.getMethod("display", String.class);
        display.invoke(o, "I AM IZZY");
    } catch (Exception e) {
        e.printStackTrace();
    }
}

DexClassLoader 在 Android 中的使用场景
上面是是使用的已经安装过的Apk，如果采用未安装过的jar包或者Apk，则实例化DexClassLoader的时候把相应路径改为需要加载的jar包或者Apk路径亦可拿到结果。这就使得DexClassLoaderde可以应用在HotFix（热修复），动态加载框架等等 一些基于插件化的架构中。
```

## java反射工具库 jOOR(https://github.com/jOOQ/jOOR)

```
Reflect.on(UserManager.class).call("get", getApplicationContext());
```

## 静默安装

```
https://blog.csdn.net/u013270171/article/details/89320824
```

## TextView 自动换行,每行排满的自定义TextView

```
https://juejin.im/post/5d4a3359f265da03eb13b28c?utm_source=gold_browser_extension
```

## Android实现多渠道打包，动态替换包名、Icon、图片等资源，解决因applicationId和BuildConfig路径不匹配的问题

```
https://blog.csdn.net/woshizisezise/article/details/96303750
```

## TODO : ARouter ????

## TODO : gradle 加速编译？？？

## TODO : Android Jetpack?????

## TODO : Toast的显示时长为什么是固定的？？？有什么方法可以修改？？

```
在 Toast.java 中有 @interface Duration 的注解，规定只能用 LENGTH_SHORT = 4000 和 LENGTH_LONG = 7000
/** @hide */
@IntDef({LENGTH_SHORT, LENGTH_LONG})
@Retention(RetentionPolicy.SOURCE)
public @interface Duration {}

用反射的方式是否可以修改？？
```

## FLAG_ACTIVITY_NEW_TASK

```
7、在一个程序中通过广播启动另一个程序的Activity时，需要在被启动的BroadcastReceiver里添加：intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
```

## 缩短字体与Button控件间的边缘距离，只要padding=0dp就可以了。

## HandlerThread

```
AsyncTask是获得后台线程的最简单方式，但它基本上不适用于重复且长时间运行的任务，比如后台下载的图片如果过大，推荐用HandlerThread代替，原因是自Android3.2版本开始，AsyncTask不再为每一个AsyncTask实例单独创建一个线程。而是使用一个Executor在单一的后台线程上运行所有AsyncTask的后台任务。这意味着每个AsyncTask都需要排除逐个运行，显然，长时间运行的AsyncTask会阻塞其他AsyncTask。
```

## 获取Android运行时最大内存限制：

```
ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);
int maxMenory = manager.getMemoryClass();
```

## TODO : APK Inspector??

## 实现动态启动未注册的Activity

```
https://github.com/BolexLiu/AndroidHookStartActivity

1.application标签里配置一个壳Activity

<activity android:name=".HostActivity" />
2.注册一下其中this为context

AMSHookUtil.hookStartActivity(this);
3.以后就可以按照标准的Intent启动为那些未被注册的Activity。

Intent intent = new Intent(MainActivity.this, OtherActivity.class);
startActivity(intent);

原理详解：http://www.jianshu.com/p/2ad105f54d07

使用黑科技启动未注册的Activity
https://mp.weixin.qq.com/s/gzg0a_afY0459w07WvuXkQ
```

## 应用卸载反馈

```
https://github.com/CharonChui/UninstallFeedback

// Android.mk
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE    := uninstall_feedback
LOCAL_SRC_FILES := uninstall_feedback.c
LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
LOCAL_LDLIBS += -L$(SYSROOT)/usr/lib -llog
include $(BUILD_SHARED_LIBRARY)


Java_com_charon_uninstallfeedback_MainActivity_initUninstallFeedback(
        JNIEnv* env, jobject thiz, jstring packageDir, jint sdkVersion) {
    char * pd = Jstring2CStr(env, packageDir);
    //fork子进程，以执行轮询任务
    pid_t pid = fork();
    if (pid < 0) {  // fork失败了
    } else if (pid == 0) {
        // 可以一直采用一直判断文件是否存在的方式去判断，但是这样效率稍低，下面使用监听的方式，死循环，每个一秒判断一次，这样太浪费资源了。
        int check = 1;
        while (check) {
            FILE* file = fopen(pd, "rt");
            if (file == NULL) {
                if (sdkVersion >= 17) { // Android4.2系统之后支持多用户操作，所以得指定用户
                    execlp("am", "am", "start", "--user", "0", "-a",
                            "android.intent.action.VIEW", "-d",
                "http://shouji.360.cn/web/uninstall/uninstall.html",
                            (char*) NULL);
                } else {
                    // Android4.2以前的版本无需指定用户
                    execlp("am", "am", "start", "-a",
                        "android.intent.action.VIEW", "-d",
                "http://shouji.360.cn/web/uninstall/uninstall.html",
                            (char*) NULL);}
                check = 0;
            } else {
            }
            sleep(1);
        }
    } 
}


public class MainActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        String packageDir = "/data/data/" + getPackageName();
        initUninstallFeedback(packageDir, Build.VERSION.SDK_INT);
    }
    private native void initUninstallFeedback(String packagePath, int sdkVersion);
    static {
        System.loadLibrary("uninstall_feedback");
    }
}
```

## 无网络权限访问网络

```
Timer timer = new Timer();
final KeyguardManager  km = (KeyguardManager) getSystemService(KEYGUARD_SERVICE);
TimerTask   task = new TimerTask() {
    @Override
    public void run() {
        // TODO: 2017/6/26  如果用户锁屏状态下，就打开网页通过get方式偷偷传输数据
        if (km.inKeyguardRestrictedInputMode()) {
            Intent intent = new Intent();
            intent.setAction(Intent.ACTION_VIEW);
            intent.addCategory(Intent.CATEGORY_BROWSABLE);
            intent.setData(Uri
                    .parse("http://192.168.0.2/send?user=1&pwd=2"));
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startActivity(intent);
        }else{
            // TODO: 2017/6/26  判断如果在桌面就什么也不做 ,如果不在桌面就返回
            Intent intent = new Intent();
            intent.setAction("android.intent.action.MAIN");
            intent.addCategory("android.intent.category.HOME");
            intent.addCategory(Intent.CATEGORY_DEFAULT);
            intent.addCategory("android.intent.category.MONKEY");
            intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            startActivity(intent);
        }
    }
};
timer.schedule(task, 1000, 2000);
```

## Root情况下静默安装

```
String command = "LD_LIBRARY_PATH=/vendor/lib:/system/lib pm install " +"apk路径";
ShellUtils.execCmd(command, ture);
```

## tools命名空间

```
toos:layout / tools:listitem / tools:listheader / tools:listfooter 开发Fragment或listview的时候，无法预览界面，用上面的工具，就可以在布局中看到界面了噢！界面如下：

tools:node="merge"
如果合并中没有冲突，合并所有属性及嵌套元素
tools:node="merge-only-attributes"
仅合并属性
tools:node="replace"
完全替换低优先级元素。
tools:xxx
tools:text="xxx"可以让我们在开发时候预览，而不用担心打包后，显示出来

shrinkResources 开启这个之后会把一些不用的资源给移除掉，用下面的方法可以保护图片不被移除
tools:keep="@drawable/ic_*,@drawable/t_all"     这样达到保护我们的ic_前缀图片不要被清理。
```

## TextUtils.join()

```
String[] strs = {"aaa","bbb"};
String join = TextUtils.join(",", strs);
assert join.equals("aaa,bbb");
List<String> lists = new ArrayList<>();
lists.add("ddd");
lists.add("eee");
String joinList = TextUtils.join(",", lists);
assert joinList.equals("ddd,eee");
```

## Activity相关方法

```
moveTaskToBack(boolean nonRoot)   让APP进入后台运行

startActivities(aIntent,bIntent)  会先进入B，返回的话到A。（跳转详情的时候，返回主页面。是不是有点用？）
```

## SharedPreference相关

```
commit是同步操作。apply是异步操作。
我们可以用v4包的方法来处理提交请求。(SharedPreferencesCompat.EditorCompat.getInstance().apply()
```

## 判断是否连接到远程服务器

```
Runtime runtime = Runtime.getRuntime();
//-c 是ping几次 ，-w是等待时间，秒为单位
Process exec = runtime.exec("ping  -c 2 -w 3 www.baidu.com");
if (exec.waitFor() == 0) {
    Log.d("liu", "连接成功");
} else {
    Log.d("liu", "连接失败");
}
```

## ArgbEvaluator

```
ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue)
```

## TextView设置内容右对齐

```
android:layoutDirection="rtl"
android:textDirection="ltr"
```

## 去除TextView默认的padding

```
android:includeFontPadding="false"
```

## URLUtil

```
isNetworkUrl()
isAboutUrl()
isContentUrl()
isDataUrl()
isJavaScriptUrl()
```

## ScheduledThreadPoolExecutor

```
ScheduledThreadPoolExecutor scheduled = new ScheduledThreadPoolExecutor(2);
scheduled.scheduleAtFixedRate(new Runnable() {
    @Override
    public void run() {
        handler.sendEmptyMessage(11);
    }
}, 0, 40, TimeUnit.MILLISECONDS);
//第一个参数0。第一次，延迟时间
//第二个参数40。表示间隔时间
//第三个参数。表示单位
```

## DEX文件格式分析

```
http://gnaixx.cc/2016/11/26/20161126dex-file/
```

## 解析编译之后的Dex文件格式

```
https://blog.csdn.net/jiangwei0910410003/article/details/50668549
```

## aapt编译时替换资源 resourceOverlay

```
https://www.jianshu.com/p/8c373d5b0464
```

## 4种Android获取View宽高的方式

```
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if (hasFocus) {
        System.out.println("onWindowFocusChanged width=" + tvTest.getWidth() + " height=" + tvTest.getHeight());
    }
}


private void getSize1() {
    ViewTreeObserver vto = tvTest.getViewTreeObserver();
    vto.addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {
        @Override
        public boolean onPreDraw() {
            int height = tvTest.getMeasuredHeight();
            int width = tvTest.getMeasuredWidth();
            System.out.println("height" + height);
            System.out.println("width" + width);
            return true;
        }
    });
}


private void getSize2() {
    ViewTreeObserver viewTreeObserver = tvTest.getViewTreeObserver();
    viewTreeObserver.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
        @Override
        public void onGlobalLayout() {
            tvTest.getViewTreeObserver().removeGlobalOnLayoutListener(this);
            System.out.println("onGlobalLayout width=" + tvTest.getWidth() + " height=" + tvTest.getHeight());
        }
    });
}


private void getSize3() {
    tvTest.post(new Runnable() {
        @Override
        public void run() {
            System.out.println("postDelayed width=" + tvTest.getWidth() + " height=" + tvTest.getHeight());
        }
    });
}
```

## 异步加载布局 AsyncLayoutInflater

```
https://www.itcodemonkey.com/article/14874.html

public void onCreate() {
    new AsyncLayoutInflater(MainActivity.this).inflate(R.layout.activity_main, null, new AsyncLayoutInflater.OnInflateFinishedListe() {
        @Override
        public void onInflateFinished(@NonNull View view, int i, @Nullable ViewGroup viewGroup) {
            //view：加载得到 view
            setContentView(view);
            //一系列的 findViewById(...)
        }
    });
}
```

## WebView无法调用js的方法

```
webView.getSettings().setJavaScriptEnabled(true);
webView.setWebChromeClient(new WebChromeClient());

//调用 js 的方法, func 为 js 中写的方法
webView.loadUrl("javascript:"+func+"()");
```

## webView加载 url 的时候有可能还是老的网页的缓存，需要清一下apk的缓存 adb shell pm clear com.mo.h5test

## 判断Activity是否存在？？

```
一、根据包名判断应用是否存在
public boolean checkApplication(String packageName) {
    if (packageName == null || "".equals(packageName)){
        return false;
    }
    try {
        ApplicationInfo info = getPackageManager().getApplicationInfo(packageName, PackageManager.GET_UNINSTALLED_PACKAGES);
        return true;
    } catch (NameNotFoundException e) {
        return false;
    }
}

二、判断Activity是否存在
Intent intent = new Intent();
intent.setClassName("包名", "类名");

方法一：
if (getPackageManager().resolveActivity(intent, 0) == null) {
    // 说明系统中不存在这个activity
}

方法二：
if(intent.resolveActivity(getPackageManager()) == null) {
    // 说明系统中不存在这个activity
}
方法三：
List<ResolveInfo> list = getPackageManager().queryIntentActivities(intent, 0);
if (list.size() == 0) {
    // 说明系统中不存在这个activity
}
```

## 判断文件是否完整的几种方法？？

```
1，使用MD5，本地文件下载完后去文件的md5值与服务器的该文件md5进行比对，一致证明下载完全。
2，比较文件的size，文件长度，下载完成取下 File.length()，与服务器的文件长度比对，一致则下载完全。
3，文件命名法，开始下载时，把文件命名为宜别名如xxx.tmp，下载完成后再把文件名称修改过来。只要正式的文件名存在，则是下载完全的。
```

## 获取文件大小？？

```
File apkFile = new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/xxx.apk");
int apkSize = apkFile.length();
```

## TODO : 学习 mtklog 的设计方法？？

## [反编译]反编译工具

```
Smali + Baksmali
Androguard
jeb
Radare2
IDA Pro
Hex-Rays

dexopt

jadx
```

## [反编译]apktool 下载编译

```
https://www.androiddevtools.cn/             里面有反编译工具大全

https://ibotpeaches.github.io/Apktool/

git clone git://github.com/iBotPeaches/Apktool.git
cd Apktool
For steps 3-5 use ./gradlew for unix based systems or gradlew.bat for windows.
需要先把终端设置为如下字符集，否则会编译报错
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
./gradlew build shadowJar - Builds Apktool, including final binary.
./gradlew build shadowJar proguard       Optional (You may build a Proguard jar) 

编译之后生成的 apktool 的路径
./brut.apktool/apktool-cli/build/libs/apktool-xxxxx.jar

添加到 ~/.bashrc 和 ~/.zshrc
alias apktool='java -jar ~/github/Apktool/brut.apktool/apktool-cli/build/libs/apktool-cli-all.jar'
```

## [反编译]google官方一键反编译 apk 工具 ClassyShark 使用

```
https://github.com/google/android-classyshark/releases

下载最新的 ClassyShark.jar
export LC_ALL=en_US.UTF-8
export LANG=en_US.UTF-8
java -jar ClassyShark.jar       //选择一个apk打开即可
```

## [反编译]andoguard

```
https://github.com/androguard/androguard

pip install -U androguard
```

## [反编译]手机上的反编译工具 APKParser

```
https://github.com/jaredrummler/APKParser
```

## [反编译]MAC 上的反编译工具 Android-Crack-Tool

```
https://github.com/Jermic/Android-Crack-Tool
```

## [反编译]Smali Viewer 用户指南(查看 Smali 文件用)

```
http://blog.avlyun.com/show/%E3%80%8Asv%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97%E3%80%8B/

https://blog.csdn.net/jiangwei0910410003/article/details/51456735       Android逆向之旅---动态方式破解apk前奏篇(Eclipse动态调试smail源码)
```

## [反编译]手把手教你逆向分析 Android 程序

```
https://segmentfault.com/a/1190000005133219
```

## [反编译]26款优秀的Android逆向工程工具

```
https://www.freebuf.com/sectool/111532.html
```

## [反编译]反编译.vdex文件

```
O版本，vdex文件直接通过vdexExtractor 直接生成dex文件
./vdexExtractor  -i xxxx.vdex  -o . --deps -f

P版本，会生成中间.cdex文件，需要使用compact_dex_converters临时转换成dex文
件, 生成的boot-framework_classes.cdex.new其实就是.dex文件，重命名成.dex后
缀，直接jadx解开即可看到java文件

工具同步更新到如下目录：smb://192.168.3.127/02_sw/127文件目录/02_工具dTOOL/02%20智能机/10_Tools/Extra-vdex/
```

## TODO : 学习 xposed 和 dexposed 的框架开发插件

## PackageManager 卸载包的方法

```
PackageManager pkgManager = mContext.getPackageManager();
// 需要system权限
PackageDeleteObserver observer = new PackageDeleteObserver(currVirus, 1);
pkgManager.deletePackage(pakName, observer, 0);


private class PackageDeleteObserver extends IPackageDeleteObserver.Stub {
    private int position;
    private int mFlag;
    public PackageDeleteObserver(int index, int flag) {
        position = index;
        mFlag = flag;// 0卸载1个包，1卸载N个包 N>1
    }
  
    @Override
    public void packageDeleted(String arg0, int arg1) throws RemoteException {
        // TODO Auto-generated method stub
        //arg0是pakname，arg1是具体没了解，卸载成功后这里是1
        LLog.e("###packageDeleted +++" + arg0 + "---" + arg1);
        Message msg;
        msg = mHandle.obtainMessage();
        msg.what = FLAG_DELETE_VIRUS;
        msg.arg1 = position;
        msg.arg2 = mFlag;
        msg.sendToTarget();
    }
}

<uses-permission android:name="android.permission.DELETE_PACKAGES" />
```

## [混淆]混淆

```
https://juejin.im/post/5d1717996fb9a07eeb13bc95

https://blog.csdn.net/aqi00/article/details/50773578     Android开发笔记（七十三）代码混淆与反破解
```

## [混淆]资源文件混淆

```
美团：修改aapt在处理资源文件相关的源码达到资源文件名的替换

微信：通过直接修改resources.arsc文件达到资源文件名的混淆    AndResGuard
```

## TODO : 代码反混淆simplify

```
https://github.com/CalebFenton/simplify
```

## TODO : gist 是个什么玩意儿？？？

## TODO : Java字节码框架asm 是什么？？怎么用？？？有什么用？？？

## [shell]查看内存占用前10的进程

```
ps -aux | sort -k4nr | head -n 10

adb shell ps -A | sort -k4nr | head -n 10
```

## [adb]如何测量一个应用的启动时间

```
adb shell am start -W com.android.settings/.Settings
```

## USER软件查看布局 HierarchyView

## [adb]adb shell 直接执行 sqlite3 查询数据库的命令

```
adb shell sqlite3 /data/user_de/0/com.android.providers.telephony/databases/telephony.db "'select * from carriers;'" > db1.log
adb pull /data/user_de/0/com.android.providers.telephony/databases/telephony.db
```

## [adb]adb uiautomator dump布局

```
adb shell uiautomator dump
adb exec-out uiautomator dump /dev/tty

dump 出来的文件怎么看？？
```

## 单工、半双工、全双工的区别？？？

```
在网络的领域内，单工、半双工、全双工是经常会遇见的名称，下面简单的讲述一下他们的区别。
单工：简单的说就是一方只能发信息，另一方则只能收信息，通信是单向的。
半双工：比单工先进一点，就是双方都能发信息，但同一时间则只能一方发信息。
全双工：比半双工再先进一点，就是双方不仅都能发信息，而且能够同时发送。
```

## Android中的run-as命令引出升降权限的安全问题

```
https://blog.csdn.net/qq_35559358/article/details/79052640
```

## 第一次开机会走的文件（恢复出厂设置也会走）

```
packages/apps/Provision/src/com/android/provision/DefaultActivity.java 在这个里面的oncreate方法里面添加需要处理第一次开机配置
```

## TODO : GPIO

```
General-purpose input/output，通用型之输入输出的简称，功能类似8051的P0—P3，其接脚可以供使用者由程控自由使用，PIN脚依现实考量可作为通用输入（GPI）或通用输出（GPO）或通用输入与输出（GPIO），如当clk generator, chip select等。
```

## Android系统修改汇总（MTK）

```
https://blog.csdn.net/jay8824589/article/details/54912404

以下都是基于Android 8.1 的代码去修改的！！！

一、server 运行时，app退出后台，一段时间后，server被杀kill 掉了
diff --git a/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java b/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
index f348453..8e1d2ec 100644
--- a/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -8596,6 +8596,10 @@ public class ActivityManagerService extends IActivityManager.Stub
     // some other background operations are not.  If we're doing a check
     // of service-launch policy, allow those callers to proceed unrestricted.
     int appServicesRestrictedInBackgroundLocked(int uid, String packageName, int packageTargetSdk) {
+        if ("com.aura.aura_go7".equals(packageName)) {
+            Slog.i(TAG, "App " + uid + "/" + packageName + " is phone app; not restricted in background");
+            return ActivityManager.APP_START_MODE_NORMAL;
+        }
         // Persistent app?
         if (mPackageManagerInt.isPackagePersistent(packageName)) {
             if (DEBUG_BACKGROUND_CHECK) {


以下都是基于Android 6.0 的代码去修改的！！！
usb storage


二十三、屏幕亮度跟踪（按power 键唤醒屏幕  较亮会闪一下bug 跟踪）
\frameworks\base\services\core\java\com\android\server\display\DisplayPowerController.java
        // Animate the screen brightness when the screen is on or dozing.
        // Skip the animation when the screen is off or suspended.
        if (!mPendingScreenOff) {
            if (state == Display.STATE_ON || state == Display.STATE_DOZE) {
                animateScreenBrightness(brightness,
                        slowChange ? BRIGHTNESS_RAMP_RATE_SLOW : mBrightnessRampRateFast);
            } else {
                animateScreenBrightness(brightness, 0);
            }
        }

   private void animateScreenBrightness(int target, int rate) {
        if (DEBUG) {
            Slog.d(TAG, "Animating brightness: target=" + target +", rate=" + rate);
        }
        if (mScreenBrightnessRampAnimator.animateTo(target, rate)) {
            try {
                mBatteryStats.noteScreenBrightness(target);
            } catch (RemoteException ex) {
                // same process
            }
        }
    }

二十二、屏幕横屏反方向
robin@ubuntu:~/workspace/SP8/SP8-2017-07-27/SP8_mtk8735$ git diff frameworks/base/core/res/res/values/config.xml
diff --git a/frameworks/base/core/res/res/values/config.xml b/frameworks/base/core/res/res/values/config.xml
index 5451540..7aa09d2 100755
--- a/frameworks/base/core/res/res/values/config.xml
+++ b/frameworks/base/core/res/res/values/config.xml
@@ -637,7 +637,7 @@
          landscape will cause a clockwise rotation, and on a landscape device an
          app requesting portrait will cause a counter-clockwise rotation.  Setting
          true here reverses that logic. -->
-    <bool name="config_reverseDefaultRotation">false</bool>
+    <bool name="config_reverseDefaultRotation">true</bool>
 

二十一、修改浏览器默认地址（Browser）
diff --git a/res/values/strings.xml b/res/values/strings.xml
old mode 100644
new mode 100755
index bba4dbe..28a3628
--- a/res/values/strings.xml
+++ b/res/values/strings.xml
@@ -793,9 +793,9 @@
     <!-- Do not translate.  Testing only -->
     <string name="dump_nav" translatable="false">Dump navigation cache</string>
 
-    <!-- The default homepage. -->
-    <string name="homepage_base" translatable="false">
-        https://www.google.com/webhp?client={CID}&amp;source=android-home</string>
+
+    <!-- The default homepage./////   之前保存的网址 Google：    https://www.google.com/webhp?client={CID}&amp;source=android-home   -->
+    <string name="homepage_base" translatable="false">http://pldthome.com/</string>
 
     <!-- Bookmarks -->
     <string-array name="bookmarks" translatable="false">

二十、去掉SystemUI sim 卡显示ICON （Android version：7.1.1）

diff --git a/packages/SystemUI/res/values/config.xml b/packages/SystemUI/res/values/config.xml
old mode 100644
new mode 100755
index 03456c9..3873cb9
--- a/packages/SystemUI/res/values/config.xml
+++ b/packages/SystemUI/res/values/config.xml

-    <!-- The default tiles to display in QuickSettings -->
+       
+    <!-- The default tiles to display in QuickSettings  
     <string name="quick_settings_tiles_default" translatable="false">
         wifi,cell,battery,dnd,flashlight,rotation,bt,airplane
     </string>
-
-    <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default" -->
+-->
+    <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default"  
     <string name="quick_settings_tiles_stock" translatable="false">
         wifi,cell,battery,dnd,flashlight,rotation,bt,airplane,location,hotspot,inversion,saver,work,cast,night
     </string>
+-->
+       <!-- The default tiles to display in QuickSettings     R add 2017-7-1 15:35:52-->
+       <string name="quick_settings_tiles_default" translatable="false">
+        wifi,battery,dnd,flashlight,rotation,bt,airplane
+    </string>
 
+    <!-- Tiles native to System UI. Order should match "quick_settings_tiles_default"  -->
+    <string name="quick_settings_tiles_stock" translatable="false">
+        wifi,battery,dnd,flashlight,rotation,bt,airplane,location,hotspot,inversion,saver,work,cast,night
+    </string>

十九、修改Settings 默认打开显示开发者选项

diff --git a/src/com/android/settings/SettingsActivity.java b/src/com/android/settings/SettingsActivity.java
index 62c7b85..faf50d0 100755
--- a/src/com/android/settings/SettingsActivity.java
+++ b/src/com/android/settings/SettingsActivity.java

@@ -1276,10 +1280,13 @@ public class SettingsActivity extends Activity
     }
 
     private void updateTilesList(List<DashboardCategory> target) {
-        final boolean showDev = mDevelopmentPreferences.getBoolean(
+        // final boolean showDev = mDevelopmentPreferences.getBoolean(
+                // DevelopmentSettings.PREF_SHOW,
+                // android.os.Build.TYPE.equals("eng"));
+               /// R add 2017-3-14 09:22:33
+               final boolean showDev = mDevelopmentPreferences.getBoolean(
                 DevelopmentSettings.PREF_SHOW,
-                android.os.Build.TYPE.equals("eng"));
-
+                true);
         final UserManager um = (UserManager) getSystemService(Context.USER_SERVICE);
 
         final int size = target.size();


十八、修改 Launcher3 ICON  字体颜色
packages/apps/Launcher3$ vim res/values/styles.xml +63

    <style name="Icon.AllApps">
        <item name="android:background">@null</item>
        <item name="android:textColor">@color/quantum_panel_bg_color</item>
        <item name="android:drawablePadding">@dimen/dynamic_grid_icon_drawable_padding</item>
        <item name="android:shadowRadius">0</item>
        <item name="android:paddingLeft">4dp</item>
        <item name="android:paddingRight">4dp</item>
        <item name="customShadows">false</item>
    </style>

十七、修改系统屏方向（MTK 8735   代码6.0）

Modify screen direction for horizontal screen and power logo
diff --git a/device/hiteq/hiteq8735m_6h/ProjectConfig.mk b/device/hiteq/hiteq8735m_6h/ProjectConfig.mk
index 6f9bc55..2d7e53f 100755
--- a/device/hiteq/hiteq8735m_6h/ProjectConfig.mk
+++ b/device/hiteq/hiteq8735m_6h/ProjectConfig.mk
@@ -1,7 +1,7 @@
-BOOT_LOGO = wxga
+BOOT_LOGO = wxganl
 BUILD_KERNEL = yes
 BUILD_LK = yes
 BUILD_MD32 = no
@@ -411,7 +411,7 @@ MTK_KERNEL_POWER_OFF_CHARGING = yes
 MTK_LAUNCHER_UNREAD_SUPPORT = yes
 MTK_LCEEFT_SUPPORT = yes
 MTK_LCM_DEVICE_TREE_SUPPORT = no
-MTK_LCM_PHYSICAL_ROTATION = 0
+MTK_LCM_PHYSICAL_ROTATION = 90
 MTK_LIVEWALLPAPER_APP = yes
 MTK_LOCKSCREEN_TYPE = 0
 MTK_LOG2SERVER_APP = no
diff --git a/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_debug_defconfig b/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_debug_defconfig
old mode 100644
new mode 100755
index 8b71f3a..0373649
--- a/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_debug_defconfig
+++ b/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_debug_defconfig
@@ -214,7 +214,7 @@ CONFIG_MTK_LCM=y
 CONFIG_CUSTOM_KERNEL_LCM="ek79023_dsi_wsvga_vdo"
 CONFIG_MTK_FB=y
 CONFIG_MTK_VIDEOX=y
-CONFIG_MTK_LCM_PHYSICAL_ROTATION="0"
+CONFIG_MTK_LCM_PHYSICAL_ROTATION="90"
 CONFIG_LCM_HEIGHT="1280"
 CONFIG_LCM_WIDTH="800"
 CONFIG_MTK_DRAMC=y
diff --git a/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_defconfig b/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_defconfig
old mode 100644
new mode 100755
index 7ca6079..fbbd792
--- a/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_defconfig
+++ b/kernel-3.18/arch/arm64/configs/hiteq8735m_6h_defconfig
@@ -205,7 +205,7 @@ CONFIG_MTK_LCM=y
 CONFIG_CUSTOM_KERNEL_LCM="ek79023_dsi_wsvga_vdo"
 CONFIG_MTK_FB=y
 CONFIG_MTK_VIDEOX=y
-CONFIG_MTK_LCM_PHYSICAL_ROTATION="0"
+CONFIG_MTK_LCM_PHYSICAL_ROTATION="90"
 CONFIG_LCM_HEIGHT="1280"
 CONFIG_LCM_WIDTH="800"
 CONFIG_MTK_DRAMC=y
diff --git a/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/gt9xx_driver.c b/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/gt9xx_driver.c
old mode 100644
new mode 100755
index 32fceca..42804b3
--- a/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/gt9xx_driver.c
+++ b/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/gt9xx_driver.c
@@ -19,7 +19,7 @@
 #endif
 #include <linux/proc_fs.h>     /*proc */
 
-#define GTP_CHANGE_X2Y         0
+#define GTP_CHANGE_X2Y         1
 
 int touch_irq;
 static int tpd_flag;
diff --git a/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/include/tpd_gt9xx_common.h b/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/include/tpd_gt9xx_common.h
old mode 100644
new mode 100755
index 9a48867..a895259
--- a/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/include/tpd_gt9xx_common.h
+++ b/kernel-3.18/drivers/input/touchscreen/mediatek/GT9XXTB_hotknot/include/tpd_gt9xx_common.h
@@ -266,7 +266,7 @@ enum CHIP_TYPE_T {
 #define TPD_NO_GPIO
 #define TPD_RESET_ISSUE_WORKAROUND
 
-#define TPD_WARP_X  
+///#define TPD_WARP_X
 #define TPD_WARP_Y
 
 #ifdef TPD_WARP_X
diff --git a/kernel-3.18/drivers/misc/mediatek/accelerometer/stk8baxx/stk8baxx.c b/kernel-3.18/drivers/misc/mediatek/accelerometer/stk8baxx/stk8baxx.c
old mode 100644
new mode 100755
index 1990df9..30a7273
--- a/kernel-3.18/drivers/misc/mediatek/accelerometer/stk8baxx/stk8baxx.c
+++ b/kernel-3.18/drivers/misc/mediatek/accelerometer/stk8baxx/stk8baxx.c
@@ -1995,9 +1995,14 @@ static int STK8BAXX_ReadSensorData(struct i2c_client *client, char *buf, int buf
                acc[STK8BAXX_AXIS_X] = acc[STK8BAXX_AXIS_X] * GRAVITY_EARTH_1000 / obj->reso->sensitivity;
                acc[STK8BAXX_AXIS_Y] = acc[STK8BAXX_AXIS_Y] * GRAVITY_EARTH_1000 / obj->reso->sensitivity;
                acc[STK8BAXX_AXIS_Z] = acc[STK8BAXX_AXIS_Z] * GRAVITY_EARTH_1000 / obj->reso->sensitivity;              
-               
+               ///sprintf(buf, "%04x %04x %04x",  -acc[STK8BAXX_AXIS_X], acc[STK8BAXX_AXIS_Y], acc[STK8BAXX_AXIS_Z]);
 
-               sprintf(buf, "%04x %04x %04x",  -acc[STK8BAXX_AXIS_Y], -acc[STK8BAXX_AXIS_X], -acc[STK8BAXX_AXIS_Z]);
+               ///sprintf(buf, "%04x %04x %04x",  -acc[STK8BAXX_AXIS_Y], -acc[STK8BAXX_AXIS_X], -acc[STK8BAXX_AXIS_Z]);
+               ///sprintf(buf, "%04x %04x %04x", -acc[STK8BAXX_AXIS_X] , -acc[STK8BAXX_AXIS_Y], -acc[STK8BAXX_AXIS_Z]);
+               ///sprintf(buf, "%04x %04x %04x", -acc[STK8BAXX_AXIS_X] , acc[STK8BAXX_AXIS_Y], acc[STK8BAXX_AXIS_Z]);
+               
+               sprintf(buf, "%04x %04x %04x", acc[STK8BAXX_AXIS_X] , -acc[STK8BAXX_AXIS_Y], -acc[STK8BAXX_AXIS_Z]);
+               
                if(atomic_read(&obj->trace) & ADX_TRC_IOCTL)
                {
                        GSE_LOG("gsensor data: %s!\n", buf);
diff --git a/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_kernel.bmp b/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_kernel.bmp
old mode 100644
new mode 100755
index fbef98a..764997e
Binary files a/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_kernel.bmp and b/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_kernel.bmp differ
diff --git a/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_uboot.bmp b/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_uboot.bmp
old mode 100644
new mode 100755
index f2470c5..764997e
Binary files a/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_uboot.bmp and b/vendor/mediatek/proprietary/bootable/bootloader/lk/dev/logo/wxganl/wxganl_uboot.bmp differ
diff --git a/vendor/mediatek/proprietary/bootable/bootloader/lk/platform/mt6735/boot_mode_menu.c b/vendor/mediatek/proprietary/bootable/bootloader/lk/platform/mt6735/boot_mode_menu.c
old mode 100644
new mode 100755
index 47f666b..608c928
--- a/vendor/mediatek/proprietary/bootable/bootloader/lk/platform/mt6735/boot_mode_menu.c
+++ b/vendor/mediatek/proprietary/bootable/bootloader/lk/platform/mt6735/boot_mode_menu.c
@@ -139,6 +139,8 @@ void boot_mode_menu_select()
                        mdelay(300);
                } else if (mtk_detect_key(MT65XX_MENU_OK_KEY)) { //VOL_DOWN,
                        //use for OK
+                       video_clean_screen();  /// R add 2017-3-15 13:47:29
+
                        break;
                } else {
                        //pass
diff --git a/vendor/mediatek/proprietary/bootable/bootloader/lk/project/hiteq8735m_6h.mk b/vendor/mediatek/proprietary/bootable/bootloader/lk/project/hiteq8735m_6h.mk
index 605a41d..01deff5 100755
--- a/vendor/mediatek/proprietary/bootable/bootloader/lk/project/hiteq8735m_6h.mk
+++ b/vendor/mediatek/proprietary/bootable/bootloader/lk/project/hiteq8735m_6h.mk
@@ -12,7 +12,7 @@ MTK_KERNEL_POWER_OFF_CHARGING = yes
 DEFINES += SWCHR_POWER_PATH
 DEFINES += MTK_BQ24296_SUPPORT
 DEFINES += MTK_BATLOWV_NO_PANEL_ON_EARLY
-MTK_LCM_PHYSICAL_ROTATION = 0
+MTK_LCM_PHYSICAL_ROTATION = 90
 CUSTOM_LK_LCM="ek79023_dsi_wsvga_vdo"
 #nt35590_hd720_dsi_cmd_auo = yes
 
@@ -22,7 +22,7 @@ MTK_VERIFIED_BOOT_SUPPORT = yes
 MTK_SEC_FASTBOOT_UNLOCK_SUPPORT = yes
 
 DEBUG := 2
-BOOT_LOGO := wxga
+BOOT_LOGO := wxganl
 
 #DEFINES += WITH_DEBUG_DCC=1
 DEFINES += WITH_DEBUG_UART=1
(END)

十六、连接USB线，隐藏 USB Storage
diff --git a/packages/apps/Settings/src/com/android/settings/deviceinfo/UsbModeChooserActivity.java b/packages/apps/Settings/src/com/android/settings/deviceinfo/UsbModeChooserActivity.java
old mode 100644
new mode 100755
index 7fad036..3310d1a
--- a/packages/apps/Settings/src/com/android/settings/deviceinfo/UsbModeChooserActivity.java
+++ b/packages/apps/Settings/src/com/android/settings/deviceinfo/UsbModeChooserActivity.java
@@ -44,7 +44,7 @@ public class UsbModeChooserActivity extends Activity {
         UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_PTP,
         UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_MIDI,
         /// M: Add for Built-in CD-ROM and USB Mass Storage @{
-        UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_MASS_STORAGE,
+        /// R: hide ----> UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_MASS_STORAGE,
         UsbBackend.MODE_POWER_SINK | UsbBackend.MODE_DATA_BICR
         /// M: @}
     };

十五、launcher 切换语言 退回到 all app 界面 ，桌面与all app 界面重叠
diff --git a/packages/apps/Launcher3/src/com/android/launcher3/LauncherStateTransitionAnimation.java b/packages/apps/Launcher3/src/com/android/launcher3/LauncherStateTransitionAnimation.java
index cdde8c1..be4b9f7 100755
--- a/packages/apps/Launcher3/src/com/android/launcher3/LauncherStateTransitionAnimation.java
+++ b/packages/apps/Launcher3/src/com/android/launcher3/LauncherStateTransitionAnimation.java
@@ -386,6 +386,8 @@ public class LauncherStateTransitionAnimation {
             toView.setVisibility(View.VISIBLE);
             toView.bringToFront();
 
+            fromView.setVisibility(View.INVISIBLE);
+            
             // Show the content view
             contentView.setVisibility(View.VISIBLE);

十四、将桌面workspace、hotseat 大小调整 放大一半 ，这个要根据自己的需求来制定
workspace.setPadding(padding.left/2, padding.top/2, padding.right/2, padding.bottom);
hotseat.setPadding(edgeMarginPx + padding.left/2, 0, edgeMarginPx + padding.right/2, 2 * edgeMarginPx);


十三、隐藏Launcher3 桌面界面 上面的 搜索栏 
packages\apps\Launcher3\src\com\android\launcher3\Launcher.Java
//mSearchDropTargetBar.addView(mQsb); 注释掉这一行 就行


十二、修改Launcher3 appall app菜单列表背景透明度
\packages\apps\Launcher3\src\com\android\launcher3\allapps\AllAppsContainerView.java
mContainerView.setBackground(background);
//mRevealView.setBackground(background.getConstantState().newDrawable());
mAppsRecyclerView.updateBackgroundPadding(bgPadding);
mAdapter.updateBackgroundPadding(bgPadding);
mContainerView.getBackground().setAlpha(20);
packages\apps\Launcher3\src\com\android\launcher3\op09\AllAppsContainerView.java
mContainerView.setBackground(null);
//mRevealView.setBackground(background.getConstantState().newDrawable());

十一、长按电源键 只显示 关机 一项
我们知道长按Power键会弹出选项，如 关机、 重启、飞行模式。现在想只保留一项  关机 ；
frameworks/base/core/res/res/values/config.xml
搜索 config_globalActionsList 
    <string-array translatable="false" name="config_globalActionsList">
        <item>power</item>
    </string-array>
以下是参考 ，需要添加的放在上面这个数组里面就是了  ：
<item>power</item>关机选项
<item>bugreport</item>错误报告选项
<item>airplane</item>飞行模式选项
<item>silent</item>静音振动铃声选项
<item>restart</item>重启选项
<item>reboot</item>//新增重启功能  
<item>settings</item>设置选项
<item>lockdown</item>锁屏选项
<item>screencapture</item>截图、录制选项
<item>users</item>用户选项

十、无法写入sn号，需要把这个 宏 打开,这个去掉注释,让写的barcode生效,barcode就是SN,不然都是默认的123456789ABCDEF
vendor/mediatek/proprietary/bootable/bootloader/lk/app/mt_boot/mt_boot.c
/* #define SERIAL_NUM_FROM_BARCODE */

九、launcher  focus_indicator 桌面 页面 显示表示 （就是桌面上那小白点），在设置系统字体大小后和在app_app界面屏幕旋转 回到all_app 界面会显示出来 ，bug，让它不显示：

+++ b/packages/apps/Launcher3/src/com/android/launcher3/Launcher.java
@@ -138,6 +138,10 @@ import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
+import android.hardware.SensorManager;
+
+import android.content.pm.ResolveInfo;
+import android.os.IBinder;
 
 /**
  * Default launcher application.   onCreate()里面添加
@@ -656,7 +660,47 @@ public class Launcher extends Activity
             showFirstRunActivity();
             showFirstRunClings();
         }
+
+               IntentFilter mInrentFilter = new IntentFilter() ;
+        mInrentFilter.addAction("android.intent.action.CONFIGURATION_CHANGED");
+        registerReceiver(screenOrientationChangedReceiver,mInrentFilter) ;
+               
+               mOrientationListener = new OrientationEventListener(this,
+                SensorManager.SENSOR_DELAY_NORMAL) {
+                               @Override
+                               public void onOrientationChanged(int orientation) {
+                               }
+                       };
+
+                       if (mOrientationListener.canDetectOrientation()) {
+                               setPageIndicatorVisble();
+                               mOrientationListener.enable();
+                       } else {
+                               setPageIndicatorVisble();
+                               mOrientationListener.disable();
+                       }
     }
+       
+       /// R add hide Visble ndicator ///#Switching language#Screen rotation/// 2017-3-2 09:34:26
+       private void setPageIndicatorVisble(){
+               if(isAppsViewVisible()){
+                       if (mPageIndicators != null){
+                               mPageIndicators.setAlpha(0f);
+                       }
+               } else {
+                       if (mPageIndicators != null) {
+                               mPageIndicators.setAlpha(1f);
+                       }
+               }
+       }
+       
+       /// R add Monitor#Screen rotation/// 2017-3-2 09:34:32
+       private BroadcastReceiver screenOrientationChangedReceiver=new BroadcastReceiver() {
+                       @Override 
+                       public void onReceive(Context context, Intent intent) {
+                               setPageIndicatorVisble();
+                       }
+    };
 
     @Override
     public void onSettingsChanged(String settings, boolean value) {
@@ -2344,6 +2388,7 @@ public class Launcher extends Activity
         if (mLauncherCallbacks != null) {
             mLauncherCallbacks.onDestroy();
         }
+               unregisterReceiver(screenOrientationChangedReceiver);
     }
 
     public DragController getDragController() {
@@ -5468,6 +5513,7 @@ public class Launcher extends Activity
         }
         return false;
     }
 }
diff --Git a/packages/apps/Launcher3/AndroidManifest.xml b/packages/apps/Launcher3/AndroidManifest.xml
index a3d5ec0..20e7d4d 100755
--- a/packages/apps/Launcher3/AndroidManifest.xml
+++ b/packages/apps/Launcher3/AndroidManifest.xml
@@ -68,6 +68,7 @@
     <uses-permission android:name="com.android.launcher3.permission.WRITE_SETTINGS" />
     <uses-permission android:name="com.android.launcher3.permission.RECEIVE_LAUNCH_BROADCASTS" />
     <uses-permission android:name="com.android.launcher3.permission.RECEIVE_FIRST_LOAD_BROADCAST" />
+       <uses-permission android:name="android.permission.CHANGE_CONFIGURATION" />
     <!-- M: hide apps activity requires this permission to get package size. -->
     <uses-permission android:name="android.permission.GET_PACKAGE_SIZE"/>
     <!-- M: ALSP02141215, android security patch. -->

八、Workspace 界面大小修改；hotseat 界面大小修改
diff --git a/packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java b/packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java
index ebb19cc..0ed0ad0 100755
--- a/packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java
+++ b/packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java
@@ -414,7 +414,7 @@ public class DeviceProfile {
         lp.gravity = Gravity.CENTER;
         Rect padding = getWorkspacePadding(isLayoutRtl);
         workspace.setLayoutParams(lp);
-        workspace.setPadding(padding.left, padding.top, padding.right, padding.bottom);
+        workspace.setPadding(padding.left/2, padding.top/2, padding.right/2, padding.bottom);
         workspace.setPageSpacing(getWorkspacePageSpacing(isLayoutRtl));
 
         // Layout the hotseat
@@ -432,8 +432,8 @@ public class DeviceProfile {
             lp.gravity = Gravity.BOTTOM;
             lp.width = LayoutParams.MATCH_PARENT;
             lp.height = hotseatBarHeightPx;
-            hotseat.setPadding(edgeMarginPx + padding.left, 0,
-                    edgeMarginPx + padding.right,
+            hotseat.setPadding(edgeMarginPx + padding.left/2, 0,
+                    edgeMarginPx + padding.right/2,
                     2 * edgeMarginPx);
         } else {

七、修改盘符名称信息、型号信息
index b20ecaa..f92828b 100755
--- a/device/hiteq/hiteq8783_tb_m/full_hiteq8783_tb_m.mk
+++ b/device/hiteq/hiteq8783_tb_m/full_hiteq8783_tb_m.mk
@@ -55,7 +55,7 @@ TRUSTY_PROJECT ?= hiteq8783_tb_m
 #CHIVIN
 
 PRODUCT_BRAND := GP8PRO
-CHIVIN_PRODUCT := GP8_PRO
+CHIVIN_PRODUCT := Aura_TELPAD_GP8_PRO_tablet
 CHIVIN_VERSION := GP8_PRO_V01.00.01    #micheal modify version
 
 #CHIVIN
diff --git a/packages/apps/Settings/src/com/android/settings/DeviceInfoSettings.Javab/packages/apps/Settings/src/com/android/settings/DeviceInfoSettings.java
index a964aed..bf11928 100755
--- a/packages/apps/Settings/src/com/android/settings/DeviceInfoSettings.java
+++ b/packages/apps/Settings/src/com/android/settings/DeviceInfoSettings.java
@@ -134,7 +134,7 @@ public class DeviceInfoSettings extends SettingsPreferenceFragment implements In
         findPreference(KEY_BUILD_NUMBER).setEnabled(true);
         findPreference(KEY_KERNEL_VERSION).setSummary(getFormattedKernelVersion());
                
-               findPreference(KEY_DEVICE_MODEL).setSummary("Aura_TELPAD-GP8-PRO-tablet");
+               findPreference(KEY_DEVICE_MODEL).setSummary(SystemProperties.get("ro.product.model"));
                
         if (!SELinux.isSELinuxEnabled()) {
             String status = getResources().getString(R.string.selinux_status_disabled);
@@ -155,7 +155,7 @@ public class DeviceInfoSettings extends SettingsPreferenceFragment implements In
         // Remove Equipment id preference if FCC ID is not set by RIL
         removePreferenceIfPropertyMissing(getPreferenceScreen(), KEY_EQUIPMENT_ID,
                 PROPERTY_EQUIPMENT_ID);
diff --git a/frameworks/av/media/mtp/MtpServer.cpp b/frameworks/av/media/mtp/MtpServer.cpp
index 470d6ca..91eb0c9 100755
--- a/frameworks/av/media/mtp/MtpServer.cpp
+++ b/frameworks/av/media/mtp/MtpServer.cpp
@@ -500,7 +500,7 @@ MtpResponseCode MtpServer::doGetDeviceInfo() {
 
     property_get("ro.product.model", prop_value, "MTP Device");
     //string.set(prop_value);
-       string.set("Aura_GP8_PRO_tablet"); ///R add 2017-2-27 21:38:22
+       string.set("Aura_SP8_PRO_tablet"); ///R add 2017-2-27 21:38:22   盘符名称
     mData.putString(string);   // Model
     string.set("1.0");
     mData.putString(string);   // Device Version

六、修改距离感应的阈值Update-hiteq8783_tb_m.dts-threshold
diff --git a/kernel-3.18/arch/arm64/boot/dts/hiteq8783_tb_m.dts b/kernel-3.18/arch/arm64/boot/dts/hiteq8783_tb_m.dts
index 7ac604a..ea78285 100644
--- a/kernel-3.18/arch/arm64/boot/dts/hiteq8783_tb_m.dts
+++ b/kernel-3.18/arch/arm64/boot/dts/hiteq8783_tb_m.dts
@@ -1,4 +1,3 @@
-
 /dts-v1/;
 
 #include "mt6753.dtsi"
@@ -92,8 +91,8 @@ memory@00000000 {
                power_vol = <0>;
                als_level = <1 2 5 10 20 30 40 80 200 300 400 600 1000 1600 2000>;
                als_value = <80 400 800 1200 1800 2000 2300 2300 12000 12000 12000 48000 48000 72000 81920 81920>;
-               ps_threshold_high =  <90>;
-               ps_threshold_low =  <70>;
+               ps_threshold_high =  <300>;
+               ps_threshold_low =  <140>;
                is_batch_supported_ps   = <0>;
                is_batch_supported_als  = <0>;
        };
注：值比ps_threshold_high 高，黑屏，值比ps_threshold_low  低，亮屏
  通话界面 为避免 脸部贴近屏幕 而 设计 黑屏 ，是最好的列子。

五、闹钟中的倒计时；设置1秒后；当到达设定的时间后；要超过4秒作用才会提示响铃提醒；设2秒倒计时就会3秒提示；设3秒就2秒提示；5秒后；即时提示；
index c7bf61c..170b536 100755
--- a/packages/apps/DeskClock/src/com/android/deskclock/timer/TimerFragment.java
+++ b/packages/apps/DeskClock/src/com/android/deskclock/timer/TimerFragment.java
@@ -123,6 +123,13 @@ public class TimerFragment extends DeskClockFragment implements OnSharedPreferen
             final boolean visible = Utils.getTimeNow() % TIME_PERIOD_MS < SPLIT;
             final boolean toggle = mVisible != visible ;
             mVisible = visible;
+                       
+                       final TimerObj mTimer_up = getCurrentTimer();
+                       /// R: add Prompt
+                       if (mTimer_up.mTimeLeft <= 0 ) {
+                               updateTimerState(mTimer_up, Timers.TIMES_UP);
+            }  
+                       
             for (int i = 0; i < mAdapter.getCount(); i++) {
                 final TimerObj t = mAdapter.getTimerAt(i);


四、铃声音量调节时；调节到最小后；再调大；还是没有声音

diff --git a/packages/apps/Settings/src/com/mediatek/audioprofile/SeekBarVolumizer.java b/packages/apps/Settings/src/com/mediatek/audioprofile/SeekBarVolumizer.java
old mode 100644
new mode 100755
index 3b52c18..fa24e40
--- a/packages/apps/Settings/src/com/mediatek/audioprofile/SeekBarVolumizer.java
+++ b/packages/apps/Settings/src/com/mediatek/audioprofile/SeekBarVolumizer.java
@@ -58,6 +58,7 @@ public class SeekBarVolumizer implements OnSeekBarChangeListener, Handler.Callba
     private final Receiver mReceiver = new Receiver();
     private final Observer mVolumeObserver;
     private String mKey;
+    private String mCurrentKey;//add by steven on 20170215
     private boolean mProfileIsActive = false;
 
     private int mOriginalStreamVolume;
@@ -81,6 +82,8 @@ public class SeekBarVolumizer implements OnSeekBarChangeListener, Handler.Callba
 
         mStreamType = streamType;
         mKey = profileKey;
+        // add by steven on 20170215
+        mCurrentKey = mProfileManager.getActiveProfileKey();
         //mMaxStreamVolume = mAudioManager.getStreamMaxVolume(mStreamType);
         mMaxStreamVolume = mProfileManager.getStreamMaxVolume(mStreamType);
         mSystemVolume = mAudioManager.getStreamVolume(mStreamType);
@@ -412,6 +415,9 @@ public class SeekBarVolumizer implements OnSeekBarChangeListener, Handler.Callba
         }
     }
 
+    // add by steven on 20170215
+    private static final String GENERAL_PREF_KEY = "mtk_audioprofile_general";
+    
     /**
      * When click the "Ok" button, set the volume to system.
      */
@@ -429,6 +435,11 @@ public class SeekBarVolumizer implements OnSeekBarChangeListener, Handler.Callba
                     + mLastProgress);
             setVolume(mStreamType, mLastProgress, false);
         } else {
+               // add by steven on 20170215
+               if (GENERAL_PREF_KEY.equals(mCurrentKey)&&!mProfileManager.isActiveProfile(mCurrentKey)) {
+                       mProfileManager.setActiveProfile(mCurrentKey);
+               }
+               
             if (!isSilentProfileActive()) {
                 Log.d("@M_" + TAG, "saveVolume: " + mStreamType
                         + " not Active, Revert system Volume "

三、修改蓝牙默认名称：
蓝牙名称未按要求设定；现在为Android BT；  Setting---->Bluetooth---->这里的字：“ANDROID BT ” 修改为：HaHa
diff --git a/system/bt/btif/src/btif_dm.c b/system/bt/btif/src/btif_dm.c
old mode 100644
new mode 100755
index f7b9ed4..2da5800
--- a/system/bt/btif/src/btif_dm.c
+++ b/system/bt/btif/src/btif_dm.c
@@ -195,7 +195,7 @@ static BOOLEAN btif_dm_inquiry_in_progress = FALSE;
 /************************************************************************************
 **  Static variables
 ************************************************************************************/
-static char btif_default_local_name[DEFAULT_LOCAL_NAME_MAX+1] = {'\0'};
+static char btif_default_local_name[DEFAULT_LOCAL_NAME_MAX+1] = "HaHa";
 
 /******************************************************************************

二、修改默认打开wifi、bluetooth
diff --git a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
old mode 100644
new mode 100755
index daa22c4..0a7584b
--- a/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
+++ b/frameworks/base/packages/SettingsProvider/res/values/defaults.xml
@@ -36,7 +36,7 @@
     <bool name="def_haptic_feedback">true</bool>
 
     <bool name="def_bluetooth_on">false</bool>    // 默认打开蓝牙 true  false
-    <bool name="def_wifi_display_on">false</bool>
+    <bool name="def_wifi_display_on">true</bool>
     <bool name="def_install_non_market_apps">false</bool>
     <bool name="def_package_verifier_enable">true</bool>

     <bool name="assisted_gps_enabled">true</bool>
     <bool name="def_netstats_enabled">true</bool>
     <bool name="def_usb_mass_storage_enabled">true</bool>
-    <bool name="def_wifi_on">false</bool>
+    <bool name="def_wifi_on">true</bool>
     <!-- 0 == never, 1 == only when plugged in, 2 == always -->
     <integer name="def_wifi_sleep_policy">2</integer>
     <bool name="def_networks_available_notification_on">true</bool>
```

## MTK android平台常用的编译调试命令

```
https://utxz.com/2018/01/10/mtk_android002/

1 配置编译环境
1) 自用环境配置脚本myenv.sh

# {board} {project} 变量根据不同项目定义
export USE_CCACHE=1
export CCACHE_DIR=/opt/.ccache_{board}_{project}
#export _JAVA_OPTIONS=-Xmx3072m

export JACK_SERVER_VM_ARGUMENTS="-Dfile.encoding=UTF-8 -XX:+TieredCompilation -Xmx4g"
#./prebuilts/sdk/tools/jack-admin kill-server
#./prebuilts/sdk/tools/jack-admin start-server

#export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-amd64
#export JRE_HOME=/usr/lib/jvm/java-1.8.0-openjdk-amd64/jre
#export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH
#export PATH=$JAVA_HOME/bin:$PATH

prebuilts/misc/linux-x86/ccache/ccache -M 50G
source build/envsetup.sh
lunch 22
2) 导出环境变量

# . myenv.sh
2 内核配置修改(具体平台可能有差异)
kernel-3.18/arch/arm64/configs/{board}_debug_defconfig   // eng模式
kernel-3.18/arch/arm64/configs/{board}_defconfig         // user模式
cd git/kernel-3.18
cp arch/arm64/configs/{board}_debug_defconfig .config
make ARCH=arm64 menuconfig
make ARCH=arm64 savedefconfig
cp defconfig arch/arm64/configs/{board}_debug_defconfig
# 执行后会有一些中间文件产生，可手动删除。

# 另外一种推荐方法:
menuconfig命令：
source build/envsetup.sh && lunch (一个shell执行一次即可)
mmm kernel-3.18:kernel-menuconfig (生成的.cconfig在out\target\product\[project]\obj\KERNEL_OBJ)
mmm kernel-3.18: kernel-savedefconfig (用out\target\product\[project]\obj\KERNEL_OBJ\.config 替换 kernel-3.18/arch/$(TARGET_ARCH)/configs/[project]_defconfig)
3 编译指定模块
make pl -j8             // 编译preloader
make lk -j8             // 编译bootloader
make bootimage -j8      // 编译kernel
make systemimage -j8    // 编译system
make recoveryimage -j8  // 编译recovery

#其他编译moudles，有nodeps表示不依赖检查，编译较快

make ramdisk-nodeps     // 打包ramdisk
make bootimage-nodeps   //

平台之间命令有差异，可以自己查看android/build/core/main.mk或其他makefile里的规则
dont_bother_goals := clean clobber dataclean installclean \
	help out \
	snod systemimage-nodeps \
	stnod systemtarball-nodeps \
	userdataimage-nodeps userdatatarball-nodeps \
	cacheimage-nodeps \
	vendorimage-nodeps \
	ramdisk-nodeps \
	bootimage-nodeps \
	recoveryimage-nodeps \
	product-graph dump-products

# mmm的编译方式
# 编译命令：(-B、-j是可选项，-B表示强制编译，-j表示开的线程数，进行快速编译)
mmm ../kernel-3.18:bootimage          // mmm方式编译内核bootimage
mmm -B kernel-3.18:kernel -j8         // mmm方式编译内核
mmm -B vendor/mediatek/proprietary/bootable/bootloader/preloader:pl -j8
mmm -B vendor/mediatek/proprietary/bootable/bootloader/lk:lk -j8

# clean命令：
mmm vendor/mediatek/proprietary/bootable/bootloader/preloader:clean-preloder
mmm vendor/mediatek/proprietary/bootable/bootloader/lk:clean-lk
mmm kernel-3.18:clean-kernel
4 git仓库kernel单独编译方式：
1. 修改android/device/mediatek/common/device.mk文件，注释掉
#PRODUCT_COPY_FILES += $(LOCAL_KERNEL):kernel
5 内核烧录
注意adb的环境变量，有时候使用android env下的adb不能成功，用ubuntu自带的adb又是可以的
可能是ubutnu环境有问题
adb path/to/boot.img /dev/block/platform/mtk-msdc.0/11230000.MSDC0/by-name/boot
或者拷贝到/data分区使用dd

ls /dev/block/platform/mtk-msdc.0/11230000.MSDC0/by-name/boot -l
/dev/block/platform/mtk-msdc.0/11230000.MSDC0/by-name/boot -> /dev/block/mmcblk0p10
adb path/to/boot.img /dev/block/mmcblk0p10
```

## MTK Android常用的命令记录（CPU/GPU频率调整等）

```
1 查看CPU频率
cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq
1050000
1050000
1050000
1050000
2 使用GPU Procfs接口查看设置频率等
1）查看当前频率
/ # cat /sys/kernel/debug/ged/hal/current_freqency
/ # cat /proc/gpufreq/gpufreq_var_dump
GPU current frequency = 299000KHz
Current Vcore = 1150mV
g_cur_gpu_OPPidx = 2
g_last_gpu_dvs_result = 127 (0:success, 127:not enabled, else:error)
g_limited_max_id = 0
mt_gpufreq_power_limited_index_array[0] = 0
mt_gpufreq_power_limited_index_array[1] = 0
mt_gpufreq_power_limited_index_array[2] = 0
mt_gpufreq_power_limited_index_array[3] = 0
mt_gpufreq_volt_enable_state = 0
mt_gpufreq_fixed_freq_state = 0
mt_gpufreq_dvfs_table_type = 2
mt_gpufreq_dvfs_mmpll_spd_bond = 5
# GPU可以开启GPU柱状图显示，使用命如下令进入原生设置界面
# am start -n com.android.settings/.Settings
# -->开发者选项-->GPU呈现模式分析-->在屏幕上显示为条形图
2）GPU固定频率等接口

/proc/mali # cat /proc/mali/help
======================================================================
A.For Query GPU/CPU related Command:
  cat /proc/mali/utilization
  cat /proc/mali/frequency
  cat /proc/mali/memory_usage
======================================================================
B.For Fix GPU Frequency:
  echo > (450000, 280000) /proc/gpufreq/gpufreq_opp_freq
  echo 0 > /proc/gpufreq/gpufreq_opp_freq(re-enable GPU DVFS)
C.For Turn On/Off CPU core number:
  echo (1, 0) > /sys/devices/system/cpu/cpu1/online
  echo (1, 0) > /sys/devices/system/cpu/cpu2/online
  echo (1, 0) > /sys/devices/system/cpu/cpuN/online
D.For CPU Performance mode(Force CPU to run at highest speed:
 echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
 echo interactive > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor(re-enable CPU DVFS)
==============================================================================================
E.For GPU advanced debugging command:
 echo [dvfs_freq(ms)] > /proc/mali/dvfs_freq
 echo [dvfs_thr_max] [dvfs_thr_min] > /proc/mali/dvfs_threshold
 echo [dvfs_deferred_count] > /proc/mali/dvfs_deferred_count
==============================================================================================
#方法1：
echo 520000 >gpufreq_fixed_freq
#方法2：
echo 1 >/proc/gpufreq/gpufreq_state
cat /proc/gpufreq/gpufreq_state
GPU DVFS disabled
echo 520000 >/proc/gpufreq/gpufreq_opp_freq
3) 查看GPU电压频率控制列表

/ # cat /proc/gpufreq/gpufreq_power_dump                                           <
mt_gpufreqs_power[0].gpufreq_khz = 520000
mt_gpufreqs_power[0].gpufreq_volt = 115000
mt_gpufreqs_power[0].gpufreq_power = 828
mt_gpufreqs_power[1].gpufreq_khz = 416000
mt_gpufreqs_power[1].gpufreq_volt = 115000
mt_gpufreqs_power[1].gpufreq_power = 662
mt_gpufreqs_power[2].gpufreq_khz = 416000
mt_gpufreqs_power[2].gpufreq_volt = 115000
mt_gpufreqs_power[2].gpufreq_power = 662
mt_gpufreqs_power[3].gpufreq_khz = 299000
mt_gpufreqs_power[3].gpufreq_volt = 115000
mt_gpufreqs_power[3].gpufreq_power = 475
mt_gpufreqs_power[4].gpufreq_khz = 299000
mt_gpufreqs_power[4].gpufreq_volt = 115000
mt_gpufreqs_power[4].gpufreq_power = 475
mt_gpufreqs_power[5].gpufreq_khz = 299000
mt_gpufreqs_power[5].gpufreq_volt = 115000
mt_gpufreqs_power[5].gpufreq_power = 475
4）其他sys目录下的gpu接口

/ # find /sys -name gpu*
/sys/devices/soc/13040000.gpu/gpuinfo
/sys/firmware/devicetree/base/soc/gpu@13040000
/sys/kernel/debug/mali0/gpu_memory
/sys/kernel/debug/ged/hal/gpu_utilization
/sys/kernel/debug/ged/logbufs/gpuinfo
/sys/kernel/debug/tracing/events/mtk_events/gpu_freq
/sys/module/ged/parameters/gpu_idle
/sys/module/ged/parameters/gpu_dvfs_enable
/sys/module/ged/parameters/gpu_block
/sys/module/ged/parameters/gpu_loading
/sys/module/ged/parameters/gpu_cust_boost_freq
/sys/module/ged/parameters/gpu_cust_upbound_freq
/sys/module/ged/parameters/gpu_debug_enable
/sys/module/ged/parameters/gpu_bottom_freq
3 温度监测
1）查看所有温度传感器的温度
/ # cat /sys/devices/virtual/thermal/thermal_zone*/temp
37000
48300
47100
48300
47700
47700
-127000
54985
38000

2）对应温度传感器的名称
/ # cat /sys/devices/virtual/thermal/thermal_zone*/type
mtktswmt              //wifi温度
mtktscpu              // CPU
mtkts1
mtkts5
mtkts3
mtkts4
mtktsbattery        //电池
mtktspmic           //电源管理芯片
mtktsAP

4）其他温度接口
/ # cat /proc/driver/thermal/tzpmic
[mtktspmic_read] trip_0_temp=145000,trip_1_temp=110000,trip_2_temp=100000,trip_3_temp=90000,trip_4_temp=80000,
trip_5_temp=70000,trip_6_temp=65000,trip_7_temp=60000,trip_8_temp=55000,trip_9_temp=50000,
g_THERMAL_TRIP_0=0,g_THERMAL_TRIP_1=0,g_THERMAL_TRIP_2=0,g_THERMAL_TRIP_3=0,g_THERMAL_TRIP_4=0,
g_THERMAL_TRIP_5=0,g_THERMAL_TRIP_6=0,g_THERMAL_TRIP_7=0,g_THERMAL_TRIP_8=0,g_THERMAL_TRIP_9=0,
cooldev0=mtktspmic-sysrst,cooldev1=no-cooler,cooldev2=no-cooler,cooldev3=no-cooler,cooldev4=no-cooler,
cooldev5=no-cooler,cooldev6=no-cooler,cooldev7=no-cooler,cooldev8=no-cooler,cooldev9=no-cooler,time_ms=1000

/ # cat /proc/driver/thermal/tzcpu
[tscpu_read]6
trip_0=117000 0 mtktscpu-sysrst                      //117度CPU会复位
trip_1=100000 0 mtk-cl-shutdown00               //100度关机
trip_2=95000 0 cpu02
trip_3=90000 0 cpu_adaptive_0
trip_4=76000 0 cpu_adaptive_1
trip_5=68000 0 cpu_adaptive_2
trip_6=45000 0 no-cooler
trip_7=35000 0 no-cooler
trip_8=25000 0 no-cooler
trip_9=15000 0 no-cooler
4 CPU调整性能模式
echo performance > /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor
echo performance > /sys/devices/system/cpu/cpu1/cpufreq/scaling_governor
echo performance > /sys/devices/system/cpu/cpu2/cpufreq/scaling_governor
echo performance > /sys/devices/system/cpu/cpu3/cpufreq/scaling_governor
```

## TODO : thermal 是什么意思？？

```
Linux Thermal 是 Linux 系统下温度控制相关的模块，主要用来控制系统运行过程中芯片产生的热量，使芯片温度和设备外壳温度维持在一个安全、舒适的范围。
```

## Android 系统属性SystemProperty分析

```
https://blog.csdn.net/yangwen123/article/details/8936555
```

## Android中@Override错误的解决方法

‵‵`
在使用eclipse开发Android应用时可能会遇到@Override错误，对于@Override的annotation报错。这是由于JRE/JDK的版本问题所致。解决方法很简单，在eclipse的Windows菜单-Preference-Java-Complier中调整Complier compliance level即可。虽然Android是基于1.5设计的，不过由于eclipse的兼容问题，需要在这里修改为1.6才行。

对于已经导入至workspace的项目，可能还需要点击右上角的Configure Project Specifiec Settings对其进行修改才行。

完成了修改之后，之前编译器提示的@Override错误就会消失了。
```

## Android中获取设备当前时间日期

```
Calendar c = Calendar.getInstance();
String month = Integer.toString(c.get(Calendar.MONTH));
String day = Integer.toString(c.get(Calendar.DAY_OF_MONTH));
String hour = Integer.toString(c.get(Calendar.HOUR_OF_DAY));
String min = Integer.toString(c.get(Calendar.MINUTE));
```

## Android中将字符串文字内容复制到系统剪贴板

```
ClipboardManager cmb = (ClipboardManager) getSystemService(CLIPBOARD_SERVICE);
cbm.setText(et.getText().toString());
```

## TODO : DSL 式编程???

## 帮我生成java类的库GeneratorX

```
https://blog.csdn.net/weizongwei5/article/details/54312281
```

## TODO : JavaPoet

## 使用Facebook redex工具优化app

```
https://blog.csdn.net/weizongwei5/article/details/52146166

在Facebook工程博客的一篇文章中指出，`dex`并不是按照应用启动时候加载的顺序加载的，而是按照编译工具指定的顺序加载的。

ReDex使程序运行时产生的运行数据判定哪些类应该在.DEX文件中被优先载入。“想要最小化从内存中读取数据的次数，最好从启动的时候就载入字节码。”Facebook称，他们使用ReDex对应用优化之后，对存储的读取减少了25%，运行速度提高了30%。
关于这个速度，Facebook称，在存储较慢的老旧机器上效果非常明显，但是对于新的收集，性能也有明显的提高。

Facebook在一台搭载了安卓4.4的全新的Nexus4上（有35%的安卓设备运行这个版本）测试，启动时间从2秒降至1.6秒。

Runtime分析可以用来删除无关的元数据和接口，但是开发者也可以自定义优化的行为。比如，有些方法即使没有直接被调用，也可以让它们保留下来。

这个优化是在应用编译完成之后进行的。也就是说，理论上你也可以结合其他优化，比如对Java进行虚拟机层的优化和语言的优化，像即将到来的Java 9的语言模块特性等等。
优化Java的字节码文件并不是一种新技术。还有其他的开源项目，例如ProGuard就可以通过删除运行时没有使用的代码进行优化。但是它并不能像ReDex那样按照执行顺序来重新组织类。
```

## 4.某个类使用private修饰了带参构造函数,如果你特么的还非要访问这个带参构造函数的话

```
用Gson里面这个UnsafeAllocator 可以完美实现不开放默认构造函数的类的实例化。这个方案同时可以解决4的问题。
```

## 将ubuntu安装到u盘上，实现即插即用

## 5.0之前的android系统是webkit内核，5.0之后便是chromium内核，虽然webiew内核改了，或许性能提升了很多，但是终究他还是单线程在操作，你懂得。

## adb shell am kill 包名

## ubuntu下缩小图片的方法

```
sudo apt-get install imagemagick

第一种方法，这种方法缩小之后会生成一堆的 “small-*”的文件名的文件：
convert -resize 20%x20% ./*.JPG   small

第二种方法：这个方法是缩小图片并保留原始文件名的命令：
for img in `ls *.JPG`; do convert -resize 20%x20% $img small-$img; done
```

## 保持宽高比的自定义View

```
<declare-styleable name="FixHeiImageView">
    <attr name="whratio" format="float" />
</declare-styleable> 

public class FixHeiImageView extends ImageView {
    private double wh_ratio=0.0;
    public FixHeiImageView(Context context) {
        super(context);
        wh_ratio = 2.0;
    }

    public FixHeiImageView(Context context, double mWh_ratio) {
        super(context);
        this.wh_ratio = mWh_ratio;
    }

    public FixHeiImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.FixHeiImageView);
        wh_ratio = typedArray.getFloat(R.styleable.FixHeiImageView_whratio, (float) 1.0);
        typedArray.recycle();
    }

    public FixHeiImageView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.FixHeiImageView);
        wh_ratio = typedArray.getFloat(R.styleable.FixHeiImageView_whratio, (float) 1.0);
        typedArray.recycle();
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        // 父容器传过来的宽度方向上的模式
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        // 父容器传过来的高度方向上的模式
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        // 父容器传过来的宽度的值
        int width = MeasureSpec.getSize(widthMeasureSpec) - getPaddingLeft() - getPaddingRight();
        // 父容器传过来的高度的值
        int height = MeasureSpec.getSize(heightMeasureSpec) - getPaddingBottom() - getPaddingTop();
        height = (int) (width / wh_ratio + 0.5f);
        heightMeasureSpec = MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY);
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}
```

## android 已省内存方式把图片加载到内存

```
package com.commons.utils.image;
 
import android.annotation.TargetApi;
import android.content.Context;
import android.graphics.*;
import android.os.Build;
import android.util.Log;
import com.commons.config.GlobalConfig;
import com.commons.utils.memory.MemoryUtils;
 
import java.io.*;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
 
/**
 * 从DrawableUtil类中分离出来这个类,为了使代码看起来更加简洁明了
 * 用于Bitmap处理的一些方法
 */
public class BitmapUtils {
    public static final int ARGB8888_MODEL=4;//ARGB8888模式下消耗内存,为像素数乘以4个字节.
    public static final int RGB565_MODEL=2;//RGB565模式下消耗内存,为像素数乘以4个字节.
    /**
     * 获取APP剩余可申请内存,判断是否够大,以手机分辨率为基础,进行计算图片处理所需要消耗的内存.
     * @return
     *
     * !!!这里获取的不是手机的剩余内存而是APP的
     */
    public static boolean isBigSurpluseMemory(Context context)
    {
        boolean isbig=true;//默认
        long appsurplusMe= MemoryUtils.getAppSurplusMe();//这里单位是Byte
        long phonesurplusMe= MemoryUtils.getPhoneSurplusMe(context);//这里单位是Byte
        long bitmapoptNeedmemory=GlobalConfig.scrwid*GlobalConfig.scrhei*ARGB8888_MODEL;//单位依旧是Byte
        //在进行图片处理的时候会把图片分辨率缩小到屏幕分辨率大小,所以这里消耗内存的计算是以屏幕分辨率所谓基础的.
        if(bitmapoptNeedmemory*2 > appsurplusMe)//为了其他考虑,剩余内存应该大于所需要内存的两倍
        {
            return false;
        }
 
 
        if(bitmapoptNeedmemory*2>phonesurplusMe)
        {
            return  false;
        }//这里一定要判断手机剩余内存,上面的判断只是app的理论上的内存限制,而如果手机本身就已经没有内存了,
        // 会有两种情况 1.自动清理一些内存  来给当前app用,2.本身就是内存太小,现在占内存的应用都是系统级别的清理不掉,那就坑了
        // 举个例子：125M内存的手机上就会发生当手机时，我发现内存不够的时候，android的自动杀进程的机制就没法用了
        //请看如下的我在410M的手机上运行的结果
 
        return isbig;
    }
    /**
     12-11 16:52:35.260      441-441/com.jsdx.zqysypt D/MemoryUtils.printMemoryInfo()﹕ 常规应用最大内存限制:64M 流氓应用最大内存限制:128M
     12-11 16:52:35.270      441-441/com.jsdx.zqysypt D/MemoryUtils.printMemoryInfo()﹕ APP当前内存状态: 最大可申请内存:128MB 已申请内存:21MB 空闲内存:4MB
     12-11 16:52:35.270      441-441/com.jsdx.zqysypt D/MemoryUtils.printMemoryInfo()﹕ 手机剩余内存:70.12109MB 手机总内存:410.54297MB
     这里可以明显看出app剩余可申请的内存要大于手机的剩余内存的.当申请更多内存的时候android就会自动清理
     */
 
 
 
 
 
    /**
     * 创建倒影图片
     * @throws IOException
     */
    public static Bitmap createReflectedBitmap(Bitmap srcBitmap) {
        if (null == srcBitmap) {
            return null;
        }
 
        // The gap between the reflection bitmap and original bitmap.
        final int REFLECTION_GAP = 4;
 
        int srcWidth = srcBitmap.getWidth();
        int srcHeight = srcBitmap.getHeight();
        int reflectionWidth = srcBitmap.getWidth();
        int reflectionHeight = srcBitmap.getHeight() / 2;
 
        if (0 == srcWidth || srcHeight == 0) {
            return null;
        }
 
        // The matrix
        Matrix matrix = new Matrix();
        matrix.preScale(1, -1);
 
        try {
            // The reflection bitmap, width is same with original's, height is half of original's.
            Bitmap reflectionBitmap = Bitmap.createBitmap(
                    srcBitmap,
                    0,
                    srcHeight / 2,
                    srcWidth,
                    srcHeight / 2,
                    matrix,
                    false);
 
            if (null == reflectionBitmap) {
                return null;
            }
 
            // Create the bitmap which contains original and reflection bitmap.
            Bitmap bitmapWithReflection = Bitmap.createBitmap(
                    reflectionWidth,
                    srcHeight + reflectionHeight + REFLECTION_GAP,
                    Bitmap.Config.ARGB_8888);
 
            if (null == bitmapWithReflection) {
                return null;
            }
 
            // Prepare the canvas to draw stuff.
            Canvas canvas = new Canvas(bitmapWithReflection);
 
            // Draw the original bitmap.
            canvas.drawBitmap(srcBitmap, 0, 0, null);
 
            // Draw the reflection bitmap.
            canvas.drawBitmap(reflectionBitmap, 0, srcHeight + REFLECTION_GAP, null);
 
            Paint paint = new Paint();
            paint.setAntiAlias(true);
            LinearGradient shader = new LinearGradient(
                    0,
                    srcHeight,
                    0,
                    bitmapWithReflection.getHeight() + REFLECTION_GAP,
                    0x70FFFFFF,
                    0x00FFFFFF,
                    Shader.TileMode.MIRROR);
            paint.setShader(shader);
            paint.setXfermode(new PorterDuffXfermode(android.graphics.PorterDuff.Mode.DST_IN));
 
            // Draw the linear shader.
            canvas.drawRect(
                    0,
                    srcHeight,
                    srcWidth,
                    bitmapWithReflection.getHeight() + REFLECTION_GAP,
                    paint);
 
            return bitmapWithReflection;
        } catch (Exception e) {
            e.printStackTrace();
        }
 
        return null;
    }
 
 
    public static Bitmap revitionImageSize(String path, int max_w, int max_h) throws IOException {
        BufferedInputStream in = new BufferedInputStream(new FileInputStream(
                new File(path)));
        BitmapFactory.Options options = new BitmapFactory.Options();
        options.inJustDecodeBounds = true;
        BitmapFactory.decodeStream(in, null, options);
        in.close();
        int i = 0;
        Bitmap bitmap = null;
        while (true) {
            if ((options.outWidth >> i <= max_w)
                    && (options.outHeight >> i <= max_h)) {
                in = new BufferedInputStream(
                        new FileInputStream(new File(path)));
                options.inSampleSize = (int) Math.pow(2.0D, i);
                options.inJustDecodeBounds = false;
                bitmap = BitmapFactory.decodeStream(in, null, options);
                break;
            }
            i += 1;
        }
        return bitmap;
    }
 
 
    /**
     *将Bitmap保存到本地
     * @param bitmap
     * @param imgurl imgurl   不带file了开头的路径,如:  /strange/sdcard/asdasd.jpg
     */
    public static void savePictureToLocal(Bitmap bitmap, String imgurl) {
        FileOutputStream b = null;
        File file = new File(imgurl);
        file.getParentFile().mkdirs();// 创建文件夹
 
 
        //对图片质量进行压缩,这样保存的图片就变小了
        int yasuolv = 60;
        try {
            b = new FileOutputStream(imgurl);
            bitmap.compress(Bitmap.CompressFormat.JPEG, yasuolv, b);// 把数据写入文件
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } finally {
            try {
                b.flush();
                b.close();
                //bitmap.recycle();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 得到本地或者网络上的bitmap url - 网络或者本地图片的绝对路径,比如:
     * <p/>
     * A.网络路径: url="http://blog.foreverlove.us/girl2.png" ;
     * <p/>
     * B.本地路径:url="mnt/sdcard/photo/image.png";  不带 file: 头
     * <p/>
     * C.支持的图片格式 ,png, jpg,bmp,gif等等
     *
     * @param path
     * @return
     */
    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
    public static Bitmap GetLocalOrNetBitmap(String path) {
        final String TAG = "GetLocalOrNetBitmap";
        Bitmap bitmap = null;
        try {
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;
            bitmap = BitmapFactory.decodeFile(path, options); //此时返回 bm 为空
            options.inJustDecodeBounds = false; //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可
            int hi = (int) (options.outHeight / (float) GlobalConfig.scrhei);//以屏幕高度作为显示依据
            int wi = (int) (options.outWidth / (float) GlobalConfig.scrwid);//以屏幕高度作为显示依据
            int be = 0;
            if (wi > hi) {
                be = hi;
            } else {
                be = wi;
            }
            Log.d(TAG, "缩放比:"+be); //缩放之后
            Log.d(TAG, "原图宽高:"+options.outWidth+" "+options.outHeight); //缩放之后
 
            if (be <= 0) {
                be = 1;
            }
            options.inSampleSize = be; //重新读入图片，注意此时已经把 options.inJustDecodeBounds 设回 false 了
            options.inPreferredConfig = Bitmap.Config.RGB_565;//使用RGB_565后会是内存降低一半但是,不适合decode带有透明区域的PNG
            bitmap = BitmapFactory.decodeFile(path, options);
            int w = bitmap.getWidth();
            int h = bitmap.getHeight();
            Log.d(TAG, "缩放后:宽"+w + " 高" + h); //缩放之后
            Log.d(TAG, "RGB_565格式内存:"+bitmap.getByteCount() / 1024 + "KB");
        } catch (Exception ex) {
            if (bitmap!=null && !bitmap.isRecycled()) {
                bitmap.recycle();
            }
            System.gc();  //提醒系统及时回收
        }
        return bitmap;
    }

    //同上,最后一个参数可选,配置是否返回高色彩的Bitmap
    //本地路径  不带 file: 头
    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
    public static Bitmap GetLocalOrNetBitmap(String path, boolean isRGb_565) {
        final String  TAG="GetLocalOrNetBitmap";
        Bitmap bitmap = null;
        try {
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;
            bitmap = BitmapFactory.decodeFile(path, options); //此时返回 bm 为空
            options.inJustDecodeBounds = false; //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可
            int hi = (int) (options.outHeight / (float) GlobalConfig.scrhei);//以屏幕高度作为显示依据
            int wi = (int) (options.outWidth / (float) GlobalConfig.scrwid);//以屏幕高度作为显示依据
 
            int be = 0;
            if (wi > hi) {
                be = hi;
            } else {
                be = wi;
            }
            Log.d(TAG, "缩放比:"+be); //缩放之后
            Log.d(TAG, "原图宽高:"+options.outWidth+" "+options.outHeight); //缩放之后
 
            if (be <= 0) {
                be = 1;
            }
            options.inSampleSize = be; //重新读入图片，注意此时已经把 options.inJustDecodeBounds 设回 false 了
            if (isRGb_565) {
                options.inPreferredConfig = Bitmap.Config.RGB_565;//使用RGB_565后会是内存降低一半但是,不适合decode带有透明区域的PNG
            }
            bitmap = BitmapFactory.decodeFile(path, options);
            int w = bitmap.getWidth();
            int h = bitmap.getHeight();
            Log.d(TAG, "缩放后:宽" + w + " 高" + h); //缩放之后
            Log.d(TAG, "RGB_565格式内存:"+bitmap.getByteCount() / 1024 + "KB");
        } catch (Exception ex) {
            if(bitmap!=null&&!bitmap.isRecycled()) {
                bitmap.recycle();
            }
            System.gc();  //提醒系统及时回收
        }
        return bitmap;
    }

    //同上,最后一个参数可选,配置是否返回高色彩的Bitmap
    //本地路径  不带 file: 头
    @TargetApi(Build.VERSION_CODES.HONEYCOMB_MR1)
    public static Bitmap GetLocalOrNetBitmap(String path, boolean isRGb_565,int maxwidth,int maxheight) {
        final String  TAG="GetLocalOrNetBitmap";
        Bitmap bitmap = null;
        try {
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;
            Log.d("GetLocalOrNetBitmap",path);
 
            bitmap = BitmapFactory.decodeFile(path, options); //此时返回 bm 为空
            options.inJustDecodeBounds = false; //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可
            int hi = (int) (options.outHeight / (float) maxwidth);//以指定宽度作为显示依据
            int wi = (int) (options.outWidth / (float) maxheight);//以指定高度作为显示依据
 
            int be = 0;
            if (wi < hi) {
                be = hi;
            } else {
                be = wi;
            }
 
            Log.d(TAG, "缩放比:"+be); //缩放之后
            Log.d(TAG, "原图宽高:"+options.outWidth+" "+options.outHeight); //缩放之后
 
            if (be <= 0) {
                be = 1;
            }
            options.inSampleSize = be; //重新读入图片，注意此时已经把 options.inJustDecodeBounds 设回 false 了
            if(isRGb_565) {
                options.inPreferredConfig = Bitmap.Config.RGB_565;//使用RGB_565后会是内存降低一半但是,不适合decode带有透明区域的PNG
            }
            bitmap = BitmapFactory.decodeFile(path, options);
            int w = bitmap.getWidth();
            int h = bitmap.getHeight();
            Log.d(TAG, "缩放后:宽" + w + " 高" + h); //缩放之后
            Log.d(TAG, "RGB_565格式内存:"+bitmap.getByteCount() / 1024 + "KB");
        } catch (Exception ex) {
            if(bitmap!=null&&!bitmap.isRecycled()) {
                bitmap.recycle();
            }
            System.gc();  //提醒系统及时回收
        }
        return bitmap;
    }
 
    public static void createPath(String path) {
        File file = new File(path);
        if (!file.exists()) {
            file.mkdir();
        }
    }
 
    //传递两个参数即可 第一个是bitmap  第二个是目录名称,第二个参数为空时  保存在SD卡上
    public static void saveMyBitmap(Bitmap bmp, String directory, String filename) {
        String direc = "";
        if (directory.length() < 1) {
            direc = GlobalConfig.sdPath + "/";
        } else {
            direc = GlobalConfig.sdPath + "/" + directory + "/";
            createPath(direc);
        }
        File f = null;
        if (filename.length() < 1) {
            try {
                Date date = new Date();
                DateFormat format = new SimpleDateFormat("yyyy-MM-dd HH_mm_ss_");
                filename = "www.njoki.com__" + format.format(date);
            } catch (Exception e) {
                filename = "未知";
            }
            f = new File(direc + filename + ".png");
        } else {
            f = new File(direc + filename + ".png");
        }
 
        FileOutputStream fOut = null;
        try {
            f.createNewFile();
            fOut = new FileOutputStream(f);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        //Bitmap bitmap = ((BitmapDrawable)mImageView.getDrawable()).getBitmap();
        //bitmap.compress(Bitmap.CompressFormat.PNG, 100, fOut);
        bmp.compress(Bitmap.CompressFormat.PNG, 100, fOut);
        try {
            fOut.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            fOut.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 给自己公司的项目写了两个功能 1.将对象 写入本地 缓存 2.去本地的缓存放到对象中

```
//讲一个对象存储到本地缓存里面
public static void setObjectToSharedpreferences(Object oc,String name) {
    if (oc == null)
        return;
    if (oc instanceof Integer || oc instanceof String || oc instanceof Double || oc instanceof Float || oc instanceof Boolean)
        return;

    Field[] fields = oc.getClass().getDeclaredFields();
    SharedPreferences settings = LYApplication.getInstance().getSharedPreferences(name, 0);
    SharedPreferences.Editor editor = settings.edit();

    for (Field f : fields) {
        f.setAccessible(true);
    }
    if (fields.length == 0)
        return;
    //输出所有属性
    for (int i = 0; i < fields.length; i++) {

        String field = fields[i].toString().substring(fields[i].toString().lastIndexOf(".") + 1);         //取出属性名称
        try {

            if (fields[i].get(oc) instanceof String)
                editor.putString(field, ((String) fields[i].get(oc)));
            else if (fields[i].get(oc) instanceof Integer)
                editor.putInt(field, ((Integer) fields[i].get(oc)));
            else if (fields[i].get(oc) instanceof Double)
                editor.putFloat(field, ((Float) fields[i].get(oc)));
            else if (fields[i].get(oc) instanceof Float)
                editor.putFloat(field, ((Float) fields[i].get(oc)));
            else if (fields[i].get(oc) instanceof Boolean)
                editor.putBoolean(field, ((Boolean) fields[i].get(oc)));
            else if (fields[i].get(oc) instanceof Long)
                editor.putLong(field, ((Long) fields[i].get(oc)));

        } catch (IllegalArgumentException e) {

        } catch (IllegalAccessException e) {

        }
    }
    editor.commit();
}


//取本地缓存  写入到一个对象中
public static void getObjectToSharedpreferences(Object oc,String name) {
    if (oc == null)
        return ;
    if (oc instanceof Integer || oc instanceof String || oc instanceof Double || oc instanceof Float || oc instanceof Boolean)
        return ;

    Field[] fields = oc.getClass().getDeclaredFields();
    SharedPreferences settings = LYApplication.getInstance().getSharedPreferences(name, 0);


    for (Field f : fields) {
        f.setAccessible(true);
    }
    if (fields.length == 0)
        return ;
    //输出所有属性
    for (int i = 0; i < fields.length; i++) {

        String field = fields[i].toString().substring(fields[i].toString().lastIndexOf(".") + 1);         //取出属性名称
        try {

            if (fields[i].get(oc) instanceof String) {
                String s = settings.getString(field, ((String) fields[i].get(oc)));
                fields[i].set(oc, s);
            } else if (fields[i].get(oc) instanceof Integer) {
                int s = settings.getInt(field, ((Integer) fields[i].get(oc)));
                fields[i].set(oc, s);
            } else if (fields[i].get(oc) instanceof Double) {
                float s = settings.getFloat(field, ((Float) fields[i].get(oc)));
                fields[i].set(oc, s);
            } else if (fields[i].get(oc) instanceof Float) {
                float s = settings.getFloat(field, ((Float) fields[i].get(oc)));
                fields[i].set(oc, s);
            } else if (fields[i].get(oc) instanceof Boolean) {
                boolean s = settings.getBoolean(field, ((Boolean) fields[i].get(oc)));
                fields[i].set(oc, s);
            } else if (fields[i].get(oc) instanceof Long) {
                long s = settings.getLong(field, ((Long) fields[i].get(oc)));
                fields[i].set(oc, s);
            }

        } catch (IllegalArgumentException e) {
            return ;
        } catch (IllegalAccessException e) {
            return ;
        }
    }

}
```

## TODO : gRPC 调用 ?? https://doc.oschina.net/grpc?t=58008

## 使用.properties文件读写属性值

```
https://blog.csdn.net/aqi00/article/details/50846832

Java中的配置文件常为.properties文件，而Properties类便是读写此类文件的工具。属性文件有两种格式，一种是文本格式，其内容是“键=值”的形式，文本注释信息可以用"#"来注释。另一种是XML格式，键值对遵循XML规范，Android的SharedPreferences也是以xml存储的。


下面是Properties的常用方法：
load : 从属性文件中加载属性对象
store : 把属性对象保存到属性文件
getProperty : 获取属性值
setProperty : 设置属性值
loadFromXML : 从XML格式的属性文件中加载属性对象
storeToXML : 把属性对象保存到XML格式的属性文件

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Properties;
 
import android.content.Context;
import android.os.Environment;
import android.util.Log;
 
public class PropertiesUtil {
	private final static String TAG = "PropertiesUtil";
 
	private Context mContext;
	private String mPath;
	private String mFile;
	private Properties mProp;
	private static PropertiesUtil mPropUtil = null;
	
	public static PropertiesUtil getInstance(Context context) {
		if (mPropUtil == null) {
			mPropUtil = new PropertiesUtil();
			mPropUtil.mContext = context;
			mPropUtil.mPath = Environment.getExternalStorageDirectory() + "/ExmKeyValue";
			mPropUtil.mFile = "properties.ini";
		}
		return mPropUtil;
	}
	
	public PropertiesUtil setPath(String path) {
		mPath = path;
		return this;
	}
 
	public PropertiesUtil setFile(String file) {
		mFile = file;
		return this;
	}
	
	public PropertiesUtil init() {
		Log.d(TAG, "path="+mPath+"/"+mFile);
		try {
			File dir = new File(mPath);
			if (!dir.exists()) {
				dir.mkdirs();
			}
			File file = new File(dir, mFile);
			if (!file.exists()) {
				file.createNewFile();
			}
			InputStream is = new FileInputStream(file);
			mProp = new Properties();
			mProp.load(is);
			is.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		return this;
	}
	
	public void commit() {
		try {
			File file = new File(mPath + "/" + mFile);
			OutputStream os = new FileOutputStream(file);
			mProp.store(os, "");
			os.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
		mProp.clear();
	}
 
	public void clear() {
		mProp.clear();
	}
	
	public void open() {
		mProp.clear();
		try {
			File file = new File(mPath + "/" + mFile);
			InputStream is = new FileInputStream(file);
			mProp = new Properties();
			mProp.load(is);
			is.close();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
    public void writeString(String name, String value) {
    	mProp.setProperty(name, value);
    }
 
    public String readString(String name, String defaultValue) {
        return mProp.getProperty(name, defaultValue);
    }
 
    public void writeInt(String name, int value) {
    	mProp.setProperty(name, ""+value);
    }
 
    public int readInt(String name, int defaultValue) {
        return Integer.parseInt(mProp.getProperty(name, ""+defaultValue));
    }
 
    public void writeBoolean(String name, boolean value) {
    	mProp.setProperty(name, ""+value);
    }
 
    public boolean readBoolean(String name, boolean defaultValue) {
        return Boolean.parseBoolean(mProp.getProperty(name, ""+defaultValue));
    }
 
    public void writeDouble(String name, double value) {
    	mProp.setProperty(name, ""+value);
    }
 
    public double readDouble(String name, double defaultValue) {
        return Double.parseDouble(mProp.getProperty(name, ""+defaultValue));
    }
}

// 写 .properties 文件
PropertiesUtil mProp = PropertiesUtil.getInstance(this).init();
mProp.writeString("name", "Mr Lee");
mProp.writeInt("age", (int)(Math.random()*100%100));
mProp.writeBoolean("married", true);
mProp.writeDouble("weight", 100f);
mProp.writeString("time", Utils.getNowDateTime());
mProp.commit();

// 读 .properties 文件
PropertiesUtil mProp = PropertiesUtil.getInstance(this).init();
mProp.open();
String name = mProp.readString("name", "");
int age = mProp.readInt("age", 0);
boolean married = mProp.readBoolean("married", false);
double weight = mProp.readDouble("weight", 0f);
String time = mProp.readString("time", "");
```

## 树莓派

```
科学上网，你需要的是 openwrt 路由
如果需要架设网站，你需要的是vps；
一个私有git服务器，相信我数据丢失的风险相当大，出门左拐有bitbucket；
BT下载和NAS，你需要的是一个真正的NAS；
airplay，小米电视都有，安卓机顶盒都有，方式多到简直不要不要的；
私有云NAS也会有；上传到百度盘的功能nas也有；
网站资源下载是什么，如果是爬站那普通人用不到，如果只是想看新闻，大多数都有rss，你需要的是feedly；dnsmasq在openwrt，这都不是事儿；
远程开机关机——openwrt装个pptpd，你就在家里；
定时的语音任务——找个旧手机设定闹铃就好了，好多闹铃app支持自己录音的。
```

## 配置 node.js 的脚本

```
curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.26.1/install.sh | bash
source ~/.nvm/nvm.sh
export NVM_IOJS_ORG_MIRROR="http://npm.taobao.org/mirrors/iojs"
nvm i 4
nvm alias default v4.0.0
npm install -g cnpm --registry=https://registry.npm.taobao.org
cnpm install pm2 -g
```

## TODO : APKAnalyser ???

## TODO : AspectJ ????

## 简洁好看实用的logger库

```
https://github.com/orhanobut/logger

implementation 'com.orhanobut:logger:2.2.0'
```

## Android Fragment 的妙用 - 优雅地申请权限和处理 onActivityResult

```
https://juejin.im/post/5cdcbb0ee51d453ce606dbd7
```

## 媲美微信的二维码识别库

```
https://mp.weixin.qq.com/s/f8rmlWR1ZHtAv-TvTGFy7Q

1，YUV
2，图像缩小
3，裁剪
4，使用OpenCV加快识别
```

## [算法] 寻找一个数组中是否有重复的数字

```
public int duplicate(int arr[], int length) {
    int i = 0;
    while(i < length){
        if(arr[arr[i]] == arr[i]){
            if(arr[i] == i){
                i++;
            }else{
                return arr[i];
            }
        }else{
            int tmp = arr[arr[i]];
            arr[arr[i]] = arr[i];
            arr[i] =  tmp;
        }
    }
    return false;
}
```

## Android签名机制详细介绍

```
https://blog.csdn.net/jiangwei0910410003/article/details/50402000
```

## [签名]EmmcTest_v1.2_mu.apk 在 drv_only 上无法安装，报错 INSTALL_FAILED_SHARED_USER_INCOMPATIBLE

```
用 apktool d EmmcTest_v1.2_mu.apk 发现这个 apk 用了 android:sharedUserId="android.uid.system"，需要 platform 的签名

找到 drv_only 分支上的 build/target/product/security/platform.x509.pem 和 platform.pk8 并下载下来

随便找一个编译过的工程找到 out/host/linux-x86/framework/signapk.jar

然后用 java -jar signapk.jar platform.x509.pem platform.pk8 EmmcTest_v1.2_mu.apk EmmcTest_v1.2_mu_signed.apk 去签名

发现报错信息如下

Exception in thread "main" java.lang.UnsatisfiedLinkError: org.conscrypt.NativeCrypto.get_cipher_names(Ljava/lang/String;)[Ljava/lang/String;
	at org.conscrypt.NativeCrypto.get_cipher_names(Native Method)
	at org.conscrypt.NativeCrypto.<clinit>(NativeCrypto.java:764)
	at org.conscrypt.OpenSSLProvider.<init>(OpenSSLProvider.java:56)
	at org.conscrypt.OpenSSLProvider.<init>(OpenSSLProvider.java:49)
	at com.android.signapk.SignApk.main(SignApk.java:942)

百度之后发现要用如下的签名命令才可以签名成功
java -Djava.library.path=out/host/linux-x86/lib64 -jar signapk.jar platform.x509.pem platform.pk8 EmmcTest_v1.2_mu.apk EmmcTest_v1.2_mu_signed.apk

问题来了：为什么 dev 分支上的软件不需要给 apk 签名也可以成功安装呢？

因为通过 keytool 查看了 EmmcTest_v1.2_mu.apk 的签名发现这个 apk 已经经过签名了，apk 的签名和系统签名不一致，所以无法安装
```

## [签名]如何查看 apk 签名？？？

```
1.解压 apk
2.keytool -printcert -file META-INF/CERT.RSA

Owner: EMAILADDRESS=android@android.com, CN=Android, OU=Android, O=Android, L=Mountain View, ST=California, C=US
Issuer: EMAILADDRESS=android@android.com, CN=Android, OU=Android, O=Android, L=Mountain View, ST=California, C=US
Serial number: b3998086d056cffa
Valid from: Wed Apr 16 06:40:50 CST 2008 until: Sun Sep 02 06:40:50 CST 2035
Certificate fingerprints:
	 SHA1: 27:19:6E:38:6B:87:5E:76:AD:F7:00:E7:EA:84:E4:C6:EE:E3:3D:FA
	 SHA256: C8:A2:E9:BC:CF:59:7C:2F:B6:DC:66:BE:E2:93:FC:13:F2:FC:47:EC:77:BC:6B:2B:0D:52:C1:1F:51:19:2A:B8
Signature algorithm name: MD5withRSA (weak)
Subject Public Key Algorithm: 2048-bit RSA key
Version: 3

Extensions: 

#1: ObjectId: 2.5.29.35 Criticality=false
AuthorityKeyIdentifier [
KeyIdentifier [
0000: 4F E4 A0 B3 DD 9C BA 29   F7 1D 72 87 C4 E7 C3 8F  O......)..r.....
0010: 20 86 C2 99                                         ...
]
[EMAILADDRESS=android@android.com, CN=Android, OU=Android, O=Android, L=Mountain View, ST=California, C=US]
SerialNumber: [    b3998086 d056cffa]
]

#2: ObjectId: 2.5.29.19 Criticality=false
BasicConstraints:[
  CA:true
  PathLen:2147483647
]

#3: ObjectId: 2.5.29.14 Criticality=false
SubjectKeyIdentifier [
KeyIdentifier [
0000: 4F E4 A0 B3 DD 9C BA 29   F7 1D 72 87 C4 E7 C3 8F  O......)..r.....
0010: 20 86 C2 99                                         ...
]
]


Warning:
The certificate uses the MD5withRSA signature algorithm which is considered a security risk.
```

## [签名]查看 keystore

```
keytool -list -keystore debug.keystore
```

## [签名]给空白包签名

```
jarsigner -verbose -keystore [keystorePath] -signedjar [apkOut] [apkIn] [alias]

jarsigner命令格式：-verbose输出详细信息 -keystore密钥库位置 -signedjar要生成的文件 要签名的文件 密钥库文件

keystorePath--参数代表keyStore的绝对路径，如D:\keystore
apkOut--参数代表签名后的apk路径，如D:\signed.apk
apkOut--参数代表签名后的apk路径，如D:\signed.apk
apkin--参数代表在腾讯应用中心下载的未签名apk，默认名称为tap_unsign.apk
alias--参数代表签名用的alias名称（创建keyStore时所填写），如timdong

jarsigner -verbose -keystore debug.keystore -signedjar test2.apk tap_unsign1.apk timdong
```

## apk打包时的系统签名

```
https://github.com/getfatday/keytool-importkeypair

./keytool-importkeypair -k ./tg.jks -p myPassword -pk8 platform.pk8 -cert platform.x509.pem -alias myAlias
```

## jks 类型的签名和普通类型的签名的有什么区别

## 什么是.pem和.pk8文件

```
.pem
通过上面的分析，很明显，在android对apk签名的时候，.pem这种文件就是一个X.509的数字证书，里面有用户的公钥等信息，是用来解密的。但是由上文可知，这种文件格式里面不仅可以存储数字证书，还能存各种key。
在 ubuntu 系统上直接双击就能打开查看里面的信息，这个是明文保存的

.pk8 
上文没有提过以.pk8为扩展名的文件，应该和PKCS #8是对应的，用来保存private key。
```

## jarsign 和 signapk 工具

```
jarsign是Java本生自带的一个工具，他可以对jar进行签名的。

而signapk是后面专门为了Android应用程序apk进行签名的工具，他们两的签名算法没什么区别，主要是签名时使用的文件不一样，这个就要引出第三个问题了。
```

## keystore文件和pk8，x509.pem文件的区别

```
jarsigner签名时用的是keystore文件，signapk签名时用的是pk8和x509.pem文件，而且都是给apk进行签名的，那么keystore文件和pk8,x509.pem他们之间是不是有什么联系呢？答案是肯定的，网上搜了一下，果然他们之间是可以转化的，这里就不在分析如何进行转化的，网上的例子貌似很多，有专门的的工具可以进行转化：

到这里我们就知道CERT.SF文件做了什么：

1》计算这个MANIFEST.MF文件的整体SHA1值，再经过BASE64编码后，记录在CERT.SF主属性块（在文件头上）的“SHA1-Digest-Manifest”属性值值下

2》逐条计算MANIFEST.MF文件中每一个块的SHA1，并经过BASE64编码后，记录在CERT.SF中的同名块中，属性的名字是“SHA1-Digest



最后我们在来看一下CERT.RSA文件

这里我们看到的都是二进制文件，因为RSA文件加密了，所以我们需要用openssl命令才能查看其内容

openssl pkcs7 -inform DER -in CERT.RSA -noout -print_certs –text

1、数据指纹，签名文件，证书文件的含义
1》数据指纹就是对一个数据源做SHA/MD5算法，这个值是唯一的
2》签名文件技术就是：数据指纹+RSA算法
3》证书文件中包含了公钥信息和其他信息
4》在Android签名之后，其中SF就是签名文件，RSA就是证书文件我们可以使用openssl来查看RSA文件中的证书信息和公钥信息

2、我们了解了Android中的签名有两种方式：jarsigner和signapk 这两种方式的区别是：
1》jarsigner签名时，需要的是keystore文件，而signapk签名的时候是pk8,x509.pem文件
2》jarsigner签名之后的SF和RSA文件名默认是keystore的别名，而signapk签名之后文件名是固定的:CERT
3》Eclipse中我们在跑Debug程序的时候，默认用的是jarsigner方式签名的，用的也是系统默认的debug.keystore签名文件
4》keystore文件和pk8,x509.pem文件之间可以互相转化
```

## 使用腾讯X5SDK优化webView加载

## JSON解析的三种方式

```
第一. 传统的JSON解析  可以把json字符串解析为一个javabean，一个List数组，一个嵌套Map的List数组
第二. GSON解析  Gson.fromJson(jsonString , cls);
第三. FastJson解析 JSON.parseObject(jsonString, cls);
```

## 设置窗体背景模糊

```
getWindow().setFlags(WindowManager.LayoutParams.FLAG_BLUR_BEHIND, WindowManager.LayoutParams.FLAG_BLUR_BEHIND);
```

## Android中WebViewClient与WebChromClient两个类的区别

```
https://blog.csdn.net/lanxingfeifei/article/details/52045082
```

## bmp格式图片详细介绍

```
https://www.jb51.net/article/78186.htm
https://www.jb51.net/article/78187.htm
```

## 读取 FAQ00042 上的bmp格式的图片的时候，总是读了一会就关闭了 socket 链接，导致图片不完整，是否是图片格式有问题？？

## 用 ffmpeg 下载 m3u8 视频

```
ffmpeg -i [m3u8地址] output.mp4
```

## TODO : javassist 和 asm 框架学习？？

## 用 exe4j 将 java 程序作成可以运行的 exe 程序

```
https://blog.csdn.net/jiangwei0910410003/article/details/80148786
```

## 带你把Apk混淆成中文语言代码

```
http://www.520monkey.com/archives/992
```

## TODO : 学习使用 Packet Capture 和 Debug Proxy 工具抓包

## TODO : Fiddler 和 Charles 等 pc 端工具抓包

## MT管理器

## 23Code UI动画特效的集中地

## TODO : 学习 Frida, xposed, SubstrateCydia 等 hook 工具

```
https://blog.csdn.net/jiangwei0910410003/article/details/80372118
```

## 我们在开发Android应用的时候如果程序崩溃了最快的查看异常信息的方法就是用日志过滤方式：adb logcat -s AndroidRuntime

## [动态壁纸]用摄像头拍摄制作动态壁纸

```
https://blog.csdn.net/jiangwei0910410003/article/details/80461169
```

## 通过抓包分析数据爬取 英语流利说 视频

```
https://blog.csdn.net/jiangwei0910410003/article/details/79367213
```

## VPNService

## TODO : 如何读取图片中的 exif 信息？？

## TODO : 如何读取头文件信息？？？

## 利用 AXMLEditor 修改 AndroidManifest.xml 和 arsc 文件

```
AXMLEditor 的开源项目地址
https://github.com/fourbrother/AXMLEditor

第一、用途
针对于特定apk反编译破解之后无法回编译操作，直接进行arsc文件的二进制文件修改，然后只需要二次签名即可。无需在进行反编译和回编译。

第二、用法
1》插入属性
java -jar AXMLEditor.jar -attr -i [标签名] [标签唯一标识] [属性名] [属性值] [输入xml] [输出xml]
案例：java -jar AXMLEditor.jar -attr -i application package debuggable true input_arsc.xml out_arsc.xml
application的标签中插入android:debuggable="true"属性，让程序处于可调式状态

2》删除属性
java -jar AXMLEditor.jar -attr -r [标签名] [标签唯一标识] [属性名] [输入xml] [输出xml]
案例：java -jar AXMLEditor.jar -attr -r application allowBackup input_arsc.xml out_arsc.xml
application标签中删除allowBackup属性，这样此app就可以进行沙盒数据备份

3》更改属性
java -jar AXMLEditor.jar -attr -m [标签名] [标签唯一标识] [属性名] [属性值] [输入xml] [输出xml]
案例：java -jar AXMLEditor.jar -attr -m application package debuggable true input_arsc.xml out_arsc.xml
application的标签中修改android:debuggable="true"属性，让程序处于可调式状态

4》插入标签
java -jar AXMLEditor.jar -tag -i [需要插入标签内容的xml文件] [输入xml] [输出xml]
案例：java -jar AXMLEditor.jar -tag -i [insert.xml] input_arsc.xml out_arsc.xml
因为插入标签时一个标签内容比较多，所以命令方式不方便，而是输入一个需要插入标签内容的xml文件即可。

5》删除标签
java -jar AXMLEditor.jar -tag -r [标签名] [标签唯一标识] [输入xml] [输出xml]
案例：java -jar AXMLEditor.jar -tag -r activity cn.wjdiankong.demo.MainActivity input_arsc.xml out_arsc.xml
删除android:name="cn.wjdiankong.demo.MainActivity"的标签内容
```

## apktool 反编译失败

```
我们在使用apktools工具进行反编译失败的时候，我们可以这么做来避免：

第一步：利用baksmali和smali工具直接修改器对应的dex文件
第二步：利用AXMLEditor.jar工具直接修改对应的xml文件
```

## Xpatch

```
Xpatch用来重新签名打包Apk文件，使重打包后的Apk能加载安装在系统里的Xposed插件，从而实现免Root Hook任意App。

java -jar ../../xpatch.jar ../../wechat.apk

java -jar ../../xpatch.jar ../../source.apk -xm ../../module1.apk
```

## Xposed 模块编写

```
非常详细的教程
https://www.52pojie.cn/thread-688466-1-1.html

xposed 官方api
https://api.xposed.info/reference/packages.html

xposed 插件
https://xposed.appkg.com/
```

## 太极·Magisk

```
https://magiskmanager.com/
```

## [adb] 可以查看指定包名应用的数据库存储信息(包括存储的sql语句)

```
adb shell dumpsys dbinfo [packagename]
```

## 编写简单的驱动程序并且将其编译到内核源码中

```
http://www.520monkey.com/archives/881
```

## 编写系统服务并且将其编译到系统源码中

```
http://www.520monkey.com/archives/893
```

## [重点研究]免root实现Hook系统服务拦截方法

```
http://www.520monkey.com/archives/861
```

## [重点研究]运行时修改内存中的Dalvik指令来改变代码逻辑

```
http://www.520monkey.com/archives/815
```

## [重点研究]Hook系统的AMS服务实现应用启动的拦截功能

```
http://www.520monkey.com/archives/870
```

## Android中利用ZipEntry漏洞实现免root写恶意文件到应用的沙盒中

```
http://www.520monkey.com/archives/833
```

## 硬上MTK平板-修改定制安卓系统

```
https://bbs.pediy.com/thread-249739.htm

怎么才能知道 rom 分区的开始结束地址？？
```

## 解压 Android 系统中的 system.img

```
https://www.jianshu.com/p/db70835d41c8
```

## 输入法

```
//中州输入法
https://rime.im/code/

//印度输入法
https://gitlab.com/indicproject/indic-keyboard/tree/master
git clone --recursive git@gitlab.com:smc/Indic-Keyboard.git

如何在一周内做一款拼音输入法
https://www.jianshu.com/p/ea70b424030e
```

## 读取ini文件

```
package com.zryf.sotp;
 
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
 
public class IniFile {
 
	private Map<String, String> mIni = new HashMap<String, String>();
 
	public IniFile(File file) throws IOException {
		String line;
		Pattern pattern = Pattern.compile("\\s*([^=]*)=(.*)");
		FileReader fr = new FileReader(file);
		BufferedReader br = new BufferedReader(fr);
		while ((line = br.readLine()) != null)
			if (!line.startsWith("#")) {
				Matcher matcher = pattern.matcher(line);
				if (matcher.matches()) {
					String key = matcher.group(1).trim();
					String value = matcher.group(2).trim();
					mIni.put(key, value);
				}
			}
		br.close();
		fr.close();
	}
 
	public String get(String key, String defaultvalue) {
		return mIni.get(key);
	}
	public static void main(String[] args) throws IOException {
		IniFile iniFile=new IniFile(new File("c://test.ini"));
		String data=iniFile.get("ID", "1234");
		System.out.println(data);
	}
}
```

## Android通用脱壳机FUPK3

```
https://blog.csdn.net/earbao/article/details/82761525


https://github.com/F8LEFT/FUPK3
```

## AspectJ 埋点技术

```
http://ju.outofmemory.cn/entry/338292
```

## 安全的日志打印方法

```
//控制日志输出的开关必须是 final static 的常量
private static final boolean DEBUG = false;

// 然后用 if 语句把 LogUtil 给控制起来，就不会被编译到系统中了
if (DEBUG) {
    LogUtil.d(TAG, "msg");
}

用 Live Template 把上面的代码包装成一个模板 ifd
```

## [Log]Android之打印长日志（两种方法）

```
经过查询才得知，Android系统的单条日志打印长度是有限的，在底层Logger驱动程序的一个类Logger.h头文件中有如下两行代码
#define LOGGER_ENTRY_MAX_LEN        (4*1024)  
#define LOGGER_ENTRY_MAX_PAYLOAD    \\  
    (LOGGER_ENTRY_MAX_LEN - sizeof(struct logger_entry))
可以看出，系统显示单条Log信息的长度是固定的，为4*1024个字符长度！

//第一种方式
//打印长的日志
public  static void  LongLoge(String str){
    int max_str_length=2001-NOTGREENDAO.length();
    //大于4000时
    while (str.length()>max_str_length){
        Log.d(NOTGREENDAO, str.substring(0,max_str_length) );
        str=str.substring(max_str_length);
    }
    //剩余部分
    Log.d(NOTGREENDAO, str );
}

//第二种方式
//日志打印不全
public static void d(String tag, String msg) {  //信息太长,分段打印
    //因为String的length是字符数量不是字节数量所以为了防止中文字符过多，
    //  把4*1024的MAX字节打印长度改为2001字符数
    int max_str_length = 2001 - tag.length();
    //大于4000时
    while (msg.length() > max_str_length) {
        Log.i(tag, msg.substring(0, max_str_length));
        msg = msg.substring(max_str_length);
    }
    //剩余部分
    Log.d(tag, msg);
}
```

## 通过 dexloader 代码动态加载apk

```
public class TestAActivity extends Activity {
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		setContentView(R.layout.main);
		String path=Environment.getExternalStorageDirectory()+"/";
		String fileName="TestB.apk";
		DexClassLoader classLoader=new DexClassLoader(path+fileName, path, null, getClassLoader());
		try {
			Class mLoadClass=classLoader.loadClass("cn.jiepu.testb.TestBActivity");
			Constructor constructor=mLoadClass.getConstructor(new Class[]{});
			Object TestBActivity=constructor.newInstance(new Object[]{});
			Method getMoney=mLoadClass.getMethod("getMoney", null);
			getMoney.setAccessible(true);
			Object money=getMoney.invoke(TestBActivity, null);
			Toast.makeText(this, money.toString(), Toast.LENGTH_LONG).show();
			Log.i("wjh", "success");
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

## [adb]aapt

```
aapt dump xmltree applock.apk AndroidManifest.xml > D:\demo.txt
```

## 打开android debug设备系统调试

```
1. 修改boot.img
不歪同学在 http://bbs.pediy.com/showthread.php?t=197334 这篇帖子中提到修改boot.img，从而打开系统调试，这样就可以省去给app添加android:debuggable="true"，再重打包的步骤了。（这个方法不歪同学讲的很详细了，我就不展开了）
一、下载“Google Nexus 5 谷歌最新官方原厂安卓4.4.4固件”，从这个ROM中提取出boot.img文件。

二、boot.img解包
运行下面的命令将会对boot.img解包，得到boot.img-kernel和boot.img-ramdisk.gz两个文件：
split-bootimg.pl boot.img

三、处理boot.img-ramdisk.gz
运行下面的命令，对boot.img-ramdisk.gz进行解压：
mkdir ramdisk
cd ramdisk
gzip -dc ../boot.img-ramdisk.gz | cpio -i

四、修改default.prop，打开系统调试标志
找到解压出来的default.prop文件，将其中的ro.debuggable=0修改为ro.debuggable=1

五、ramdisk目录打包
返回ramdisk的上层目录，输入命令：
mkbootfs ./ramdisk | gzip > ramdisk.img

六、打包出新的boot.img
命令：
mkbootimg --base 0x00000000 --ramdisk_offset 0x02900000 --second_offset 0x00F00000 --tags_offset 0x02700000 --cmdline 'console=ttyHSL0 androidboot.hardware=hammerhead user_debug=31 maxcpus=2 msm_watchdog_v2.enable=1 earlyprintk' --kernel boot.img-kernel --ramdisk ramdisk.img -o newboot.img

七、将新的boot.img刷入手机
这时，在windows下还是linux下就无所谓了。将手机连上电脑输入下面的命令，重启手机进入fastboot：
adb reboot bootloader
当重启手机后，将新的boot.img刷入手机：
fastboot flash boot newboot.img
如果出现类似下图的输出，就说明刷入成功了：


刷入成功并不代表你的手机可以正常使用~~不过只要严格按照上面的方法，在Nexus5这个手机下还是没有问题的。现在输入下面的命令重启手机吧：
fastboot reboot

八、系统中的APP都可以调试了！
APP调试命令：adb shell am start -D -n <包名>/<Activity名>

2. 直接修改系统属性
使用setpropex工具在已经root的设备上修改只读的系统属性。使用此工具来修改ro.secure和ro.debuggable的值。
工具地址：https://github.com/poliva/rootadb

如果需要调试长期存在系统中的服务和进程等，那么我们可以强制重启android的Dalvik层，可以简单的结束system_server进程。
```

## android完美退出自身进程的方法

```
public static void exit(Context context){
	Log.i(TAG, "Tool exit pid="+android.os.Process.myPid()+",tid="+Thread.currentThread().getId()+ ",mytid="+android.os.Process.myUid()+",tname="+Thread.currentThread().getName());
	//需要申请权限<uses-permission android:name="android.permission.KILL_BACKGROUND_PROCESSES"/>	
	//ActivityManager manager = (ActivityManager) getApplicationContext().getSystemService(Context.ACTIVITY_SERVICE); 
    //manager.killBackgroundProcesses(getApplicationContext().getPackageName());
	//android.os.Process.sendSignal(android.os.Process.myPid(),android.os.Process.SIGNAL_KILL);//发送杀死信号
	//android.os.Process.sendSignal(android.os.Process.myPid(),android.os.Process.SIGNAL_QUIT);//发送退出信号
	
	//android进程完美退出方法。
	Intent intent = new Intent(Intent.ACTION_MAIN);
    intent.addCategory(Intent.CATEGORY_HOME);
    //intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
           
    //让Activity的生命周期进入后台，否则在某些手机上即使sendSignal 3和9了，还是由于Activity的生命周期导致进程退出不了。除非调用了Activity.finish()
    context.startActivity(intent);
	android.os.Process.killProcess(android.os.Process.myPid());
	//System.runFinalizersOnExit(true);
    System.exit(0);
}
```

## 获取apk的签名信息

```
public void getAPKSign(View view) {
	Signature[]  signatures;
	if(Build.VERSION.SDK_INT>=21)
	{
		signatures=showUninstallAPKSignaturesAfter21("/mnt/sdcard/qqemail.apk");			
	}else{
		signatures=showUninstallAPKSignatures("/mnt/sdcard/qqemail.apk");
	}
	parseSignature(signatures[0].toByteArray());
	getSingInfo("com.android.phone");
	
}

//反射调用android.content.pm.PackageParser的时候注意：android 4.4以下是有参构造 android5.0以上是无参构造函数了。
//下面是android5.0以上的解决方法
public Signature[]  showUninstallAPKSignaturesAfter21(String apkPath) {
	String PATH_PackageParser = "android.content.pm.PackageParser";
	try {
		// PackageParser packageParser = new PackageParser();
		
		Class pkgParserCls = Class.forName(PATH_PackageParser);
		Constructor pkgParserCt = pkgParserCls.getConstructor( new Class[]{});			
		Object pkgParser = pkgParserCt.newInstance(new Object[]{});
		Log.i(TAG, "pkgParser:" + pkgParser.toString());
		// 这个是与显示有关的, 里面涉及到一些像素显示等等, 我们使用默认的情况
		DisplayMetrics metrics = new DisplayMetrics();
		metrics.setToDefaults();
		//方法原型： public Package parsePackage(File packageFile, int flags) throws PackageParserException 
		
		Method pkgParser_parsePackageMtd = pkgParserCls.getDeclaredMethod(
				"parsePackage",  new Class[]{File.class,int.class});
		
		Object pkgParserPkg = pkgParser_parsePackageMtd.invoke(pkgParser,
				new Object[]{new File(apkPath),PackageManager.GET_SIGNATURES});

		Method pkgParser_collectCertificatesMtd = pkgParserCls
				.getDeclaredMethod("collectCertificates", new Class[]{ pkgParserPkg.getClass(),Integer.TYPE});
				
		pkgParser_collectCertificatesMtd.invoke(pkgParser, new Object[]{pkgParserPkg,PackageManager.GET_SIGNATURES});
		// 应用程序信息包, 这个公开的, 不过有些函数, 变量没公开
		Field packageInfoFld = pkgParserPkg.getClass().getDeclaredField("mSignatures");
		Signature[] info = (Signature[]) packageInfoFld.get(pkgParserPkg);

		Log.i(TAG, info[0].toCharsString());
		return info;
	} catch (Exception e) {
		e.printStackTrace();
	}
	return null;
}
//反射调用android.content.pm.PackageParser的时候注意：android 4.4以下是有参构造 android5.0以上是无参构造函数了。
//下面是android5.0以下的解决方法
public Signature[]  showUninstallAPKSignatures(String apkPath) {
	String PATH_PackageParser = "android.content.pm.PackageParser";
	try {
		// apk包的文件路径
		// 这是一个Package 解释器, 是隐藏的
		// 构造函数的参数只有一个, apk文件的路径
		// PackageParser packageParser = new PackageParser(apkPath);
		Class pkgParserCls = Class.forName(PATH_PackageParser);
		Constructor pkgParserCt = pkgParserCls.getConstructor( new Class[]{String.class});
		
		Object pkgParser = pkgParserCt.newInstance(new Object[]{apkPath});
		Log.i(TAG, "pkgParser:" + pkgParser.toString());
		// 这个是与显示有关的, 里面涉及到一些像素显示等等, 我们使用默认的情况
		DisplayMetrics metrics = new DisplayMetrics();
		metrics.setToDefaults();
		
		//PackageParser.Package mPkgInfo = public Package parsePackage(File sourceFile, String destCodePath,DisplayMetrics metrics, int flags) 

		Method pkgParser_parsePackageMtd = pkgParserCls.getDeclaredMethod(
				"parsePackage",  new Class[]{File.class, String.class,DisplayMetrics.class,Integer.TYPE});
		
		Object pkgParserPkg = pkgParser_parsePackageMtd.invoke(pkgParser,
				new Object[]{new File(apkPath), apkPath,metrics,PackageManager.GET_SIGNATURES});

		Method pkgParser_collectCertificatesMtd = pkgParserCls
				.getDeclaredMethod("collectCertificates", new Class[]{ pkgParserPkg.getClass(),Integer.TYPE});
				
		pkgParser_collectCertificatesMtd.invoke(pkgParser, new Object[]{pkgParserPkg,PackageManager.GET_SIGNATURES});
		// 应用程序信息包, 这个公开的, 不过有些函数, 变量没公开
		Field packageInfoFld = pkgParserPkg.getClass().getDeclaredField("mSignatures");
		Signature[] info = (Signature[]) packageInfoFld.get(pkgParserPkg);

		Log.i(TAG, info[0].toCharsString());
		return info;
	} catch (Exception e) {
		e.printStackTrace();
	}
	return null;
}

private String getSign(Context context) {
	PackageManager pm = context.getPackageManager();
	List<PackageInfo> apps = pm
			.getInstalledPackages(PackageManager.GET_SIGNATURES);
	Iterator<PackageInfo> iter = apps.iterator();
	while (iter.hasNext()) {
		PackageInfo packageinfo = iter.next();
		String packageName = packageinfo.packageName;
		if (packageName.equals(context.getPackageName())) {
			Log.i(TAG, packageinfo.signatures[0].toCharsString());
			return packageinfo.signatures[0].toCharsString();
		}
	}
	return null;
}

public void getSingInfo(String pkgName) {
	try {
		PackageInfo packageInfo = getPackageManager().getPackageInfo(pkgName, PackageManager.GET_SIGNATURES);
		Signature[] signs = packageInfo.signatures;
		Signature sign = signs[0];
		parseSignature(sign.toByteArray());
	} catch (Exception e) {
		e.printStackTrace();
	}
}
public void parseSignature(byte[] signature) {
	try {
		CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
		X509Certificate cert = (X509Certificate) certFactory.generateCertificate(new ByteArrayInputStream(signature));
		String pubKey = cert.getPublicKey().toString();
		String signNumber = cert.getSerialNumber().toString();
		System.out.println("signName:" + cert.getSigAlgName());
		System.out.println("pubKey:" + pubKey);
		System.out.println("signNumber:" + signNumber);
		System.out.println("subjectDN:"+cert.getSubjectDN().toString());
	} catch (CertificateException e) {
		e.printStackTrace();
	}
}
```

## Android小分队教你怎么利用Bluebox Security 曝的漏洞 

```
1.      漏洞原理
漏洞的关键点在于，Android假设一个APK包中的文件是不会重名的。可实际上Zip格式是允许一个Zip文件包含具有相同文件命的文件。（注意，这里的文件名，包括这个文件在Zip包里的相对路径）。
Android在安装应用时，会抽取APK包中每个文件，进行签名验证。但如果碰到了相同文件名的文件，则只会校验第二个文件，而忽略第一个文件。
另外在应用运行前会释放classes.dex到/data/dalvik-cache/目录生成优化过的odex文件，然后再运行。这个阶段如果APK里有两个classes.dex，就只会抽取第一个classes.dex进行优化，而忽略第二。
好了，说到这，相信读者应该明白怎么利用这个漏洞了吧。

2.      攻击分析
如果我们将一个APK包中放入两个classes.dex文件。第一个classes.dex是被我们篡改过的恶意dex文件；第二个classes.dex是原来这个APK中的classes.dex文件。那么在签名验证时，就会验证原来的classes.dex，因此通过验证；而执行时，却执行了被篡改过的第一个classes.dex。

3.      攻击步骤
a)      找个你想攻击的APK，抽取出其classes.dex保存
b)      反编译 classes.dex，修改之，重新生成新的classes.dex，更名为classes.dey
c)      用7z打开原APK包，删除其中的classes.dex，保存退出7z。
d)      依次将classes.dey和保存的classes.dex，通过7z塞入APK，然后保存退出7z
e)      用UltraEdit编辑修改过的APK，查找“classes.dey”，修改为“classes.dex”（共有两处），然后保存。
f)       大功告成。

4.      总结
a)      这个漏洞可以攻击几乎所有的APK应用。利用该漏洞修改过的APK，能依然保留原签名，可以通过Android的签名验证，并能执行恶意代码。
b)      如果手机里的一些应用是APK + odex形式存在的。很不幸，这个漏洞无法攻击这部手机上的这些应用。因为这个APK里没有classes.dex，无法借尸还魂。
c)      如果手机里有Settings.apk（非APK + odex形式），取出来修改下，再安装覆盖，就能拿到System权限。因为Settings是system uid。
```

## 利用文件头的漏洞

```
1.      在讲这个漏洞之前，首先需要搞明白java里short类型转int类型的问题。要理解这个漏洞，必须明白这个技术点。

public class JavaTest {

    public static void main(String[] args) {

       short a = (short)0xFFFF;

       int b;

       b = a;

       System.out.println(b);

       b = a & 0xFFFF;

       System.out.println(b);

   }

}

如果你能很清楚的了解上述代码中两次打印变量b的值有何不同，以及为何不同的话，这部分就可以先跳过了。否则还是要先弄清楚再往下看。

 

2.      Zip文件格式

在每个Zip文件中都有一个Central directory，Central directory中的每一项是一个File header。这个File header的结构对应到Android代码的类就是ZipEntry。File header结构中有一个偏移量指向local file header，local file header后面就紧跟着file data。接下来我们详细看一下local file header的结构。

       local file header signature    4 bytes  (0x04034b50)

       version needed to extract      2 bytes

       general purpose bit flag       2 bytes

       compression method             2 bytes

       last mod file time             2 bytes

       last mod file date             2 bytes

       crc-32                         4 bytes

       compressed size                4 bytes

       uncompressed size              4 bytes

       file name length               2 bytes

       extra field length              2 bytes

       file name (variable size)

       extra field (variable size)

可以看到，除最后2个域以外，local file header的其他域都是定长的。而这两个变长域的长度是由file name length和extra field length所确定。再次说明，紧跟在extra field后面的就是文件的数据file data了。

 

3.      Android如何进行apk校验

Android在进行apk文件校验时，会调到ZipFile的public InputStream getInputStream(ZipEntry entry)函数。这函数中，有这么一段：

           RAFStream rafstrm = new RAFStream(raf, entry.mLocalHeaderRelOffset + 28);

           DataInputStream is = new DataInputStream(rafstrm);

           int localExtraLenOrWhatever = Short.reverseBytes(is.readShort());

           is.close();

 

           // Skip the name and this "extra" data or whatever it is:

           rafstrm.skip(entry.nameLength + localExtraLenOrWhatever);

           rafstrm.mLength = rafstrm.mOffset + entry.compressedSize;

           if (entry.compressionMethod == ZipEntry.DEFLATED) {

               int bufSize = Math.max(1024, (int)Math.min(entry.getSize(), 65535L));

               return new ZipInflaterInputStream(rafstrm, new Inflater(true), bufSize, entry);

           } else {

               return rafstrm;

           }

注意：上述代码中红色部分。localExtraLenOrWhatever就是local file header结构中的extra field length。回想一下我们第一部分将的技术点，如果这里的extra filed length的大小是大于2^15，会怎么样？

没错，localExtraLenOrWhatever将会是负值。因此接下来，rafstrm.skip(entry.nameLength + localExtraLenOrWhatever); 这句将无法真正跳过变长域file name (variable size) 和extra field (variable size)。反而有可能呢会跳到file name (variable size)中，甚至file name (variable size)之前。当然为了攻击方便，我们还是期望它跳到file name (variable size)中。

 

4.      如何实施攻击

要改变一个apk的行为，显然攻击的目标就是apk里的classes.dex文件。对于classes.dex文件在apk文件中的local file header结构，其file name (variable size)域的内容肯定就是“classes.dex”了。注意，这里的后缀名dex，正好和dex文件开头的三个字节完全相同（不理解的，参见dex文件格式）。

a)      利用这一点，从file name (variable size)域“classex.dex”的“.”之后开始我们可以写入一个完整的dex文件。这个dex文件必须是原apk里的classes.dex文件。只有这样才能绕过签名验证

b)      修改extra field length，使之为0xFFFD。因为这个值刚好为-3。根据漏洞，rafstrm.skip(entry.nameLength + localExtraLenOrWhatever); 这句就会跳到file name (variable size)域中的“.”之后。也就是一个dex文件的开始，这里必须是原dex文件内容。

c)      修改local file header之后的file data数据。在这里写入带有攻击代码的classes.dex内容。

d)      以上的修改会带来apk文件一些结构上的调整，比如扩充extra field域，调整file data大小等。

具体攻击模型，如下图。

安卓安全小分队发现Android新漏洞


 

5.      总结

总的来说该攻击手段，首先利用了Android在签名验证过程中，对Zip文件相应16位域的读取时，没有考虑到大于2^15的情况。（因为java的int , short, long都是有符号数，而不像C/C++里有无符号数）。

其次利用了Zip文件中的local file header结构的extra field域来存放原classes.dex。但这个域的大小最多只能是2^16-1，因此被攻击的Apk里的classes.dex大小必须在64K以内。否则，就无法对其进行攻击。这算是这种攻击方式的一个限制。

最后还有一个问题补充说明：之所以这种攻击方式能成功，还在于在运行时，系统抽取的是hacked classes.dex，而在签名校验时，验证的是extra域里的classes.dex。前者是在libdex.so中实现，后者在Java层实现。是由Java层跟Native层不一致导致。
```

## sdcard是采用fat32格式的，无法保存权限相关的数据

## 使用系统隐藏api的另外一种方法，使用系统编译的 android.jar 包，并使其的优先级最高

```
将out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/classes.jar复制到eclipse开发环境中，用user library的方式挂载，使其的优先级比android.jar要高即可
```

## 修改了系统的/etc/hosts文件。让广告域名都指向本机IP地址

## Android网络防火墙的几种实现方式

```
a)        Android应用层：敏感函数hook
i.             绝大多数Android应用都是调用Android Framework来实现网络通讯。例如：WebView.loadUrl()，HttpClient.execute()，DefaultHttpClient.execute()等。只需穷举这些类的函数，并将它们都Hook住，就可实现拦截上网的功能了。

ii.             当然想要Hook这些函数入口，有两种方式：1. 首先获得root权限，然后通过进程注入，将Client代码注入到应用进程，在进程上网时，应用进程将会发起IPC请求到Server进程，由Server进程来决定是否允许其访问网络。2. 通过修改应用本身来加入Hook代码，从而避免了root手机，相对比较安全。洗大师就是使用了这种方法。

iii.             这种方案的优点是：简单、快速、可实现网络热开关（无需杀死进程）。缺点是：不能拦截所有的网络访问入口。例如：某应用没有调用Android的库，而是自己实现了一个访问网络的库，或者甚至用native代码来实现，那么这时候这个方案将拦截不到任何的上网请求。

b)        Android框架层：android.permission.INTERNET权限

i.             在Android系统中，任何想访问网络的应用必须申请android.permission.INTERNET权限。当Zygote在fork()一个AndroidManifest.xml中带有这个权限的应用时，会将当前应用加到inet组中。凡是一个进程的gid组中有inet，那么这个应用就有权限上网。

ii.             因此禁止应用上网有两种方式：1. 修改应用的AndroidManifest.xml，使其没有android.permission.INTERNET权限。2. 获得root权限，然后注入zygote进程，使其在fork()之后，不要将inet设到应用的gid组中。

iii.             这个方案相对于第一个方案来说，它可以彻底的屏蔽一个应用上网。实现起来也不复杂，但是gid组一旦设定后，应用进程将再无权限修改。因此被禁止掉上网权限的进程，想要再次获得上网权限，则必须杀死，然后重新由zygote进程fork()生成。

c)        Linux内核层：iptables

i.             在Linux内核中，NetworkFilter在TCP/IP的协议栈中加了相应的Hook。通过这些Hook我们可以对网络数据包可以进行过滤，丢弃，修改等。但直接使用起来相对麻烦。幸好Linux给我们提供了一个强大的工具：iptables来简化这一过程。Iptables是一个Linux命令，通过这个命令，可以对整个系统发出去的包，接收到的包，以及转发的包进行拦截，修改，拒绝等操作。具体起使用方法，这里不再展开，有兴趣的朋友可以自行到网上搜索相应的资料即可。

ii.             Iptable不仅可以按照uid来禁用应用上网，还可以分别禁用某个uid的3G上网和Wifi上网。这给用户带来的极大的方便。

iii.             这个方案的优点是，不需要进程注入，所以实现起来相对简单。同时能够将3G网络和Wifi网络分别禁用，用户体验将更加好。此外由于iptables的功能远不止这些，基于iptables可以实现功能更加强大的防火墙。Iptable虽然好，但是也是有缺点的，运行iptables需要root权限。基于iptables的Android防火墙目前有许多，这里有一个开源的项目http://code.google.com/p/droidwall/

有兴趣的朋友，可以研究一下。目前主流安全软件的联网拦截功能，如360手机卫士，手机毒霸等都是使用这一方案。

总结：
以上主要介绍了通过三个层面来控制一个应用的上网。具体使用哪一种，需要看用户的需求，以及手机的系统环境而定。
a)      如果不能获得root权限，基本思路就是定制修改apk，可以考虑加入hook代码，或者是压根在AndroidManifest.xml里将android.permission.INTERNET权限去除。
b)      如果能获得root权限，可以考虑注入zygote，使之fork()之后不加入inet组，还可以注入应用进程加上敏感函数的hook。此外还可以使用iptables命令。
c)      如果用户希望不杀死进程就实现上网权限的开关，并且要求可以分别禁用3G网络和Wifi网络的话，那么非iptables不可了。

其实比较下来，还是基于iptables的方案相对较好。它似乎只有一个缺点就是需要root权限。但大家又知道一旦手机被root以后，安全性反而将大大降低。我们可否找到一种手机既不被root，又能使用iptables的方案呢？

其实是有的。只是这无法通过第三方的应用实现。必须有手机厂商对Android系统进行定制化修改，添加一个具有root权限的service来负责iptables命令的操作。其他进程只有向这个service提出请求，才能间接调用iptables。当然app应用要和这个service沟通，必须遵循一定的协议和获得相应的授权才行，否则又会变的不安全了。

我们 @安卓安全小分队 已经实现了上述方案，并且效果还不错。我们在init.rc里添加了一个service，并且授予这个service root权限。这个service起来之后，会等待client端请求。对于这个client端，我们对外提供了一套SDK，应用程序只需调用这套SDK API就可以和这个root service进行通信了，然后就可以间接执行iptables命令。

以下是我们的SDK API接口。Uid指应用的uid。type是针对的网络类型，可以是3G网络或者是Wifi网络。Blocked表示禁用还是启用网络。

public static final int MOBILE_NETWORK = 1;
public static final int WIFI_NETWORK = 2;
public void setApplicationPolicy(int uid, int type, boolean blocked); //设置拦截状态
public boolean getApplicationPolicy(int uid, int type); //获得当前的拦截状态
```

## 获取wifi信息

```
public void GetWifi() {
	if (!mWifi.isWifiEnabled()) {
		mWifi.setWifiEnabled(true);
	}
	WifiInfo wifiInfo = mWifi.getConnectionInfo();

	if (bAdapt != null) {
		if (!bAdapt.isEnabled()) {
			Intent enBT = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
			startActivityForResult(enBT, REQUEST_ENABLE_BT);
		}

		btMac = bAdapt.getAddress();
	} else {
		btMac = "No Bluetooth Device!";
	}

	if ((WifiMac = wifiInfo.getMacAddress()) == null) {
		WifiMac = "No Wifi Device";
	}

	mac.setTextSize(16);
	String ipString = "";// 本机在WIFI状态下路由分配给的IP地址
	
	/**获得IP地址的方法一：
	int ipAddress = wifiInfo.getIpAddress();
	if (ipAddress != 0) {
	       ipString = ((ipAddress & 0xff) + "." + (ipAddress >> 8 & 0xff) + "."
	        + (ipAddress >> 16 & 0xff) + "." + (ipAddress >> 24 & 0xff));
	}*/
	//Log.i(this.getClass().getSimpleName(), TypeUtil.typeToString("wifiInfo", wifiInfo));

	// 获得IP地址的方法二（反射的方法）：
	try {
		Field field = wifiInfo.getClass().getDeclaredField("mIpAddress");  
	    field.setAccessible(true); 
	    InetAddress address =  (InetAddress) field.get(wifiInfo);
	    ipString=address.getHostAddress();
	    System.out.println("ipString:" + ipString);
	} catch (Exception e) {
	    e.printStackTrace();
	}
	// 查看已经连接上的WIFI信息，在Android的SDK中为我们提供了一个叫做WifiInfo的对象，这个对象可以通过WifiManager.getConnectionInfo()来获取。WifiInfo中包含了当前连接中的相关信息。
	// getBSSID() 获取BSSID属性
	// getDetailedStateOf() 获取客户端的连通性
	// getHiddenSSID() 获取SSID 是否被隐藏
	// getIpAddress() 获取IP 地址
	// getLinkSpeed() 获取连接的速度
	// getMacAddress() 获取Mac 地址
	// getRssi() 获取802.11n 网络的信号
	// getSSID() 获取SSID
	// getSupplicanState() 获取具体客户端状态的信息
	StringBuffer sb = new StringBuffer();
	sb.append("\n获取BSSID属性（所连接的WIFI设备的MAC地址）：" + wifiInfo.getBSSID());
	// sb.append("getDetailedStateOf()  获取客户端的连通性：");
	sb.append("\n\n获取SSID 是否被隐藏：" + wifiInfo.getHiddenSSID());
	
	sb.append("\n\n获取wifi IP 地址：" +ipString);
	sb.append("\n\n获取连接的速度：" + wifiInfo.getLinkSpeed());
	sb.append("\n\n获取Mac 地址（手机本身网卡的MAC地址）：" + WifiMac);
	sb.append("\n\n获取802.11n 网络的信号：" + wifiInfo.getRssi());
	sb.append("\n\n获取SSID（所连接的WIFI的网络名称）：" + wifiInfo.getSSID());
	sb.append("\n\n获取具体客户端状态的信息：" + wifiInfo.getSupplicantState());
	mac.setText("WIFI网络信息:  " + sb.toString() + "\n\n蓝牙MAC:  " + btMac);
}
```

## Java 重启应用

```
public static void restartApplication() throws URISyntaxException, IOException {
    final String javaBin = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java";
    final File currentJar = new File(Start.class.getProtectionDomain().getCodeSource().getLocation().toURI());
    if(!currentJar.getName().endsWith(".jar")){
        return;
    }
    final ArrayList<String> command = new ArrayList<String>();
    command.add(javaBin);
    command.add("-jar");
    command.add(currentJar.getPath());
    final ProcessBuilder builder = new ProcessBuilder(command);
    builder.start();
    System.exit(0);
}
```

## java管道通讯

```
public InputStream getInputStream(final FileHeader hd) throws RarException, IOException {
	final PipedInputStream in = new PipedInputStream(32 * 1024);
	final PipedOutputStream out = new PipedOutputStream(in);

	// creates a new thread that will write data to the pipe. Data will be
	// available in another InputStream, connected to the OutputStream.
	new Thread(new Runnable() {
		public void run() {
			try {
				extractFile(hd, out);
			} catch (RarException e) {
			} finally {
				try {
					out.close();
				} catch (IOException e) {
				}
			}
		}
	}).start();
	return in;
}
```

## TODO : busybox 如何使用？？

```
1、 BusyBox 的诞生 
BusyBox 最初是由 Bruce Perens 在 1996 年为 Debian GNU/Linux 安装盘编写的。其目标是在一张软盘上创建一个可引导的 GNU/Linux 系统，这可以用作安装盘和急救盘。 

2、busybox的用法 
可以这样用busybox 
#busybox ls 
他的功能就相当运行ls命令 
最常用的用法是建立指向busybox的链接,不同的链接名完成不同的功能. 
#ln -s busybox ls 
#ln -s busybox rm 
#ln -s busybox mkdir 
然后分别运行这三个链接: 
#./ls 
#./rm 
#./mkdir 
就可以分别完成了ls rm 和mkdir命令的功能.虽然他们都指向同一个可执行程序busybox，但是只要链接名不同,完成的功能就不同，很多linux网站都提供busybox的源代码下载。

3、配置busybox 
busybox的配置程序和linux内核菜单配置方式简直一模一样.熟悉用make menuconfig方式配置linux内核的朋友很容易上手. 
#cp busybox-1.00.tar.gz /babylinux 
#cd /babylinux 
#tar xvfz busybox-1.00.tar.gz 
#cd busybox-1.00 
#make menuconfig 
下面是需要编译进busybox的功能选项。 
General Configuration应该选的选项 
Show verbose applet usage messages 
Runtime SUID/SGID configuration via /etc/busybox.conf 
Build Options 
Build BusyBox as a static binary (no shared libs) 
这个选项是一定要选择的,这样才能把busybox编译成静态链接的可执行文件,运行时才独立于其他函数库.否则必需要其他库文件才能运行,在单一个linux内核不能使它正常工作. 
Installation Options 
Don't use /usr 
这个选项也一定要选,否则make install 后busybox将安装在原系统的/usr下,这将覆盖掉系统原有的命令.选择这个选项后,make install后会在busybox目录下生成一个叫_install的目录,里面有busybox和指向它的链接. 
其它选项都是一些linux基本命令选项,自己需要哪些命令就编译进去,一般用默认的就可以了，配置好后退出并保存。

4、编译并安装busybox 
#make 
#make install 
编译好后在busybox目录下生成子目录_install,里面的内容: 
drwxr-xr-x 2 root root 4096 11月 24 15:28 bin 
rwxrwxrwx 1 root root 11 11月 24 15:28 linuxrc -> bin/busybox 
drwxr-xr-x 2 root root 4096 11月 24 15:28 sbin 
其中可执行文件busybox在bin目录下,其他的都是指向他的符号链接. 
```

## MyClass 反射模板类

```
public class MyClass {
	private Class<?> class1;
	private Method method1;
 
	private MyClass(Class<?> class1,String name, Class<?>... parameterTypes) throws NoSuchMethodException {
		super();
		this.class1 = class1;
		this.method1=class1.getMethod(name, parameterTypes);
	}
	public static MyClass build(String className,String name, Class<?>... parameterTypes) throws ClassNotFoundException, NoSuchMethodException {
		return new MyClass(className, name, parameterTypes);
		
	}
	public static MyClass build(Class<?> class1,String name, Class<?>... parameterTypes) throws ClassNotFoundException, NoSuchMethodException {
		return new MyClass(class1, name, parameterTypes);
		
	}
	private MyClass(String className,String name, Class<?>... parameterTypes) throws ClassNotFoundException, NoSuchMethodException {
		super();
		this.class1 = forName(className);
		this.method1=class1.getMethod(name, parameterTypes);
	}
 
	public Class<?> getClass1() {
		return class1;
	}
 
	public void setClass1(Class<?> class1) {
		this.class1 = class1;
	}
 
	public Method getMethod1() {
		return method1;
	}
 
	public void setMethod1(Method method1) {
		this.method1 = method1;
	}
 
	public static Class<?> forName(String className) throws ClassNotFoundException {
		return Class.forName(className);
	}
	
    public Object invoke(Object receiver, Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
        return method1.invoke(receiver, args);
    }
}

//使用方法
MyClass class1 = MyClass.build("android.util.Log", "i", new Class[] { String.class, String.class });
class1.invoke(class1.getClass1(), "tag", "ok");

TelephonyManager telephonyManager = (TelephonyManager) getSystemService(Activity.TELEPHONY_SERVICE);
// telephonyManager.getDeviceId();
MyClass class1 = MyClass.build("android.telephony.TelephonyManager", "getDeviceId", new Class[] {});
String result = (String) class1.invoke(telephonyManager);
Log.i("xx", result);
Log.i("fuck",(String) MyClass.build("android.telephony.TelephonyManager", "getDeviceId", new Class[] {}).invoke(telephonyManager));
```

## Java 反射例子之android Application 查看和设置：meta-data

```
http://my.oschina.net/xesam/blog/135333
public class BaseApplication extends Application {
	@Override
	public void onCreate() {
		super.onCreate();
		// android Application 查看和设置：meta-data 
		// 在application应用<meta-data>元素。
		ApplicationInfo appInfo;
		try {
			appInfo = this.getPackageManager().getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
			Bundle bundle = appInfo.metaData;
			if (bundle == null) {
				System.out.println("bundle==null");
			}
			bundle.putString("ddd", "xxx");
			Class class1 = Class.forName("android.os.Bundle");			
			Field[] fields = class1.getFields();//和getDeclaredFields不同
			for (Field field : fields) {
				System.out.println(field.getName());
			}
			System.out.println("========");
			fields = class1.getDeclaredFields();
			for (Field field : fields) {
				System.out.println(field.getName());
			}

			Field field = class1.getDeclaredField("mMap");
			if (field != null) {
				field.setAccessible(true);
				Map<String, Object> mMap = (Map<String, Object>) field.get(bundle);
				if (mMap==null) {
					System.out.println("mMap==null");
					return ;
				}
				for(Map.Entry<String, Object> entry:mMap.entrySet()) {
					String key=entry.getKey();
					Object value=entry.getValue();
					System.out.println(key+"="+value);
				}
			} else {
				System.out.println("field==null");
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
```

## Android Json RPC

```
JSONRPCClient client = JSONRPCClient.create("http://service/uri");
client.setConnectionTimeout(2000);
client.setSoTimeout(2000);
try {
    String string = client.callString("mymethod");
    double d = client.callDouble("pow", x, y);
    int i = client.callInt("add", 56, 25); ...
} catch (JSONRPCException e) {
    e.printStackTrace();
}
```

## Android lib与libs的区别和解决apk动态加载时异常

```
Android lib与libs的区别和解决apk动态加载时java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation

异常：

按照文章中的理解：

http://www.bubuko.com/infodetail-842175.html，出现java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation 动态加载apk/jar时出现异常的原因是jar中的类冲突。解决办法是：把接口的jar放到lib目录去打包编译，然后config buildpath。不要放在libs,放在libs目录的jar会一起打包进入apk，动态加载相同的类时就会出现java.lang.IllegalAccessError: Class ref in pre-verified class resolved to unexpected implementation异常。

总之解决该异常的方法是：整个程序运行中，包括主程序和插件程序，jar包中的类只包含唯一实例。重复的类不要打包进入apk。即不放在libs目录。
```

## 在 Android 上使用 LocalSocket 进行进程间通信

```
https://blog.csdn.net/earbao/article/details/50722080
```

## 自己用 c 编写一个可以在android 上运行的命令

```
https://blog.csdn.net/earbao/article/details/51275463

https://blog.csdn.net/earbao/article/details/51275705

https://blog.csdn.net/earbao/article/details/51277087

https://blog.csdn.net/earbao/article/details/51277160
```



























